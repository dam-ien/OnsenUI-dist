/* onsenui v2.9.2 - 2018-05-01 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.ons = factory());
}(this, (function () { 'use strict';

var onsElements = {};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Add vendor prefix.
 *
 * @param {String} name
 * @return {String}
 */
var prefix = function () {
  var styles = window.getComputedStyle(document.documentElement, '');
  var prefix = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];

  return function (name) {
    return '-' + prefix + '-' + util$1.hyphenate(name);
  };
}();

/**
 * Minimal utility library for manipulating element's style.
 * Set element's style.
 *
 * @param {Element} element
 * @param {Object} styles
 * @return {Element}
 */
var styler = function styler(element, style) {
  Object.keys(style).forEach(function (key) {
    if (key in element.style) {
      element.style[key] = style[key];
    } else if (prefix(key) in element.style) {
      element.style[prefix(key)] = style[key];
    } else {
      util$1.warn('No such style property: ' + key);
    }
  });
  return element;
};

/**
 * @param {Element} element
 * @param {String} styles Space-separated CSS properties to remove
 */
styler.clear = function (element) {
  var styles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var clearlist = styles.split(/\s+/).reduce(function (r, s) {
    return r.concat([util$1.hyphenate(s), prefix(s)]);
  }, []),
      keys = [];

  var _loop = function _loop(i) {
    var key = element.style[i];
    if (clearlist.length === 0 || clearlist.some(function (s) {
      return key.indexOf(s) === 0;
    })) {
      keys.push(key); // Store the key to fix Safari style indexes
    }
  };

  for (var i = element.style.length - 1; i >= 0; i--) {
    _loop(i);
  }

  keys.forEach(function (key) {
    return element.style[key] = '';
  });
  element.getAttribute('style') === '' && element.removeAttribute('style');
};

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};









var objectWithoutProperties = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};

var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

// Save HTMLElement object before Custom Elements polyfill patch global HTMLElement.
var NativeHTMLElement = window.HTMLElement;

/**
 * @object ons.platform
 * @category util
 * @description
 *   [en]Utility methods to detect current platform.[/en]
 *   [ja]現在実行されているプラットフォームを検知するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
 */

var Platform = function () {

  /**
   * All elements will be rendered as if the app was running on this platform.
   * @type {String}
   */
  function Platform() {
    classCallCheck(this, Platform);

    this._selectedPlatform = null;
    this._ignorePlatformSelect = false;
  }

  /**
   * @method select
   * @signature select(platform)
   * @param  {string} platform Name of the platform.
   *   [en]Possible values are: "opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios" or "wp".[/en]
   *   [ja]"opera", "firefox", "safari", "chrome", "ie", "android", "blackberry", "ios", "wp"のいずれかを指定します。[/ja]
   * @description
   *   [en]Sets the platform used to render the elements. Useful for testing.[/en]
   *   [ja]要素を描画するために利用するプラットフォーム名を設定します。テストに便利です。[/ja]
   */


  createClass(Platform, [{
    key: 'select',
    value: function select(platform) {
      if (typeof platform === 'string') {
        this._selectedPlatform = platform.trim().toLowerCase();
      }
    }
  }, {
    key: '_getSelectedPlatform',
    value: function _getSelectedPlatform() {
      return this._ignorePlatformSelect ? null : this._selectedPlatform;
    }
  }, {
    key: '_runOnActualPlatform',
    value: function _runOnActualPlatform(fn) {
      this._ignorePlatformSelect = true;
      var result = fn();
      this._ignorePlatformSelect = false;

      return result;
    }

    //----------------
    // General
    //----------------
    /**
     * @method isWebView
     * @signature isWebView()
     * @description
     *   [en]Returns whether app is running in Cordova.[/en]
     *   [ja]Cordova内で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isWebView',
    value: function isWebView() {
      if (document.readyState === 'loading' || document.readyState == 'uninitialized') {
        throw new Error('isWebView() method is available after dom contents loaded.');
      }

      return !!(window.cordova || window.phonegap || window.PhoneGap);
    }

    //----------------
    // iOS devices
    //----------------
    /**
     * @method isIPhone
     * @signature isIPhone()
     * @description
     *   [en]Returns whether the device is iPhone.[/en]
     *   [ja]iPhone上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPhone',
    value: function isIPhone() {
      return (/iPhone/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isIPhoneX
     * @signature isIPhoneX()
     * @description
     *   [en]Returns whether the device is iPhone X.[/en]
     *   [ja]iPhone X上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPhoneX',
    value: function isIPhoneX() {
      // iPhone 8 and iPhone X have a same user agent. We cannot avoid using window.screen.
      // This works well both in iOS Safari and (UI|WK)WebView of iPhone X.
      return this.isIPhone() && (window.screen.width === 375 && window.screen.height === 812 || window.screen.width === 812 && window.screen.height === 375);
    }

    /**
     * @method isIPad
     * @signature isIPad()
     * @description
     *   [en]Returns whether the device is iPad.[/en]
     *   [ja]iPad上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIPad',
    value: function isIPad() {
      return (/iPad/i.test(navigator.userAgent)
      );
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isIPod',
    value: function isIPod() {
      return (/iPod/i.test(navigator.userAgent)
      );
    }

    //----------------
    // iOS versions
    //----------------
    /**
     * @method isIOS
     * @signature isIOS()
     * @description
     *   [en]Returns whether the OS is iOS.[/en]
     *   [ja]iOS上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS',
    value: function isIOS() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'ios';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform)
        );
      } else {
        return (/iPhone|iPad|iPod/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isIOS7above
     * @signature isIOS7above()
     * @description
     *   [en]Returns whether the iOS version is 7 or above.[/en]
     *   [ja]iOS7以上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOS7above',
    value: function isIOS7above() {
      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/iOS/i.test(device.platform) && parseInt(device.version.split('.')[0]) >= 7
        );
      } else if (/iPhone|iPad|iPod/i.test(navigator.userAgent)) {
        var ver = (navigator.userAgent.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [''])[0].replace(/_/g, '.');
        return parseInt(ver.split('.')[0]) >= 7;
      }
      return false;
    }

    //----------------
    // iOS browsers
    //----------------
    /**
     * @method isIOSSafari
     * @signature isIOSSafari()
     * @description
     *   [en]Returns whether app is running in iOS Safari.[/en]
     *   [ja]iOS Safariで実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIOSSafari',
    value: function isIOSSafari() {
      var navigator = window.navigator;
      var ua = navigator.userAgent;

      return !!(this.isIOS() && ua.indexOf('Safari') !== -1 && ua.indexOf('Version') !== -1 && !navigator.standalone);
    }

    /**
     * @method isWKWebView
     * @signature isWKWebView()
     * @description
     *   [en]Returns whether app is running in WKWebView.[/en]
     *   [ja]WKWebViewで実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isWKWebView',
    value: function isWKWebView() {
      var lte9 = /constructor/i.test(NativeHTMLElement);
      return !!(this.isIOS() && window.webkit && window.webkit.messageHandlers && window.indexedDB && !lte9);
    }

    /**
     * @method isUIWebView
     * @signature isUIWebView()
     * @description
     *   [en]Returns whether app is running in UIWebView.[/en]
     *   [ja]UIWebViewで実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isUIWebView',
    value: function isUIWebView() {
      return !!(this.isIOS() && !this.isIOSSafari() && !this.isWKWebView());
    }

    //----------------
    // Android devices
    //----------------
    /**
     * @method isAndroidPhone
     * @signature isAndroidPhone()
     * @description
     *   [en]Returns whether the device is Android phone.[/en]
     *   [ja]Android携帯上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidPhone',
    value: function isAndroidPhone() {
      return (/Android/i.test(navigator.userAgent) && /Mobile/i.test(navigator.userAgent)
      );
    }

    /**
     * @method isAndroidTablet
     * @signature isAndroidTablet()
     * @description
     *   [en]Returns whether the device is Android tablet.[/en]
     *   [ja]Androidタブレット上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroidTablet',
    value: function isAndroidTablet() {
      return (/Android/i.test(navigator.userAgent) && !/Mobile/i.test(navigator.userAgent)
      );
    }

    //----------------
    // Android versions
    //----------------
    /**
     * @method isAndroid
     * @signature isAndroid()
     * @description
     *   [en]Returns whether the OS is Android.[/en]
     *   [ja]Android上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isAndroid',
    value: function isAndroid() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'android';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Android/i.test(device.platform)
        );
      } else {
        return (/Android/i.test(navigator.userAgent)
        );
      }
    }

    //----------------
    // Other devices
    //----------------
    /**
     * @return {Boolean}
     */

  }, {
    key: 'isWP',
    value: function isWP() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'wp';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/Win32NT|WinCE/i.test(device.platform)
        );
      } else {
        return (/Windows Phone|IEMobile|WPDesktop/i.test(navigator.userAgent)
        );
      }
    }

    /**
     * @method isBlackBerry
     * @signature isBlackBerry()
     * @description
     *   [en]Returns whether the device is BlackBerry.[/en]
     *   [ja]BlackBerry上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isBlackBerry',
    value: function isBlackBerry() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'blackberry';
      }

      if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object' && !/browser/i.test(device.platform)) {
        return (/BlackBerry/i.test(device.platform)
        );
      } else {
        return (/BlackBerry|RIM Tablet OS|BB10/i.test(navigator.userAgent)
        );
      }
    }

    //----------------
    // Other browsers
    //----------------
    /**
     * @method isOpera
     * @signature isOpera()
     * @description
     *   [en]Returns whether the browser is Opera.[/en]
     *   [ja]Opera上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isOpera',
    value: function isOpera() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'opera';
      }

      return !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
    }

    /**
     * @method isFirefox
     * @signature isFirefox()
     * @description
     *   [en]Returns whether the browser is Firefox.[/en]
     *   [ja]Firefox上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isFirefox',
    value: function isFirefox() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'firefox';
      }

      return typeof InstallTrigger !== 'undefined';
    }

    /**
     * @method isSafari
     * @signature isSafari()
     * @description
     *   [en]Returns whether the browser is Safari.[/en]
     *   [ja]Safari上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isSafari',
    value: function isSafari() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'safari';
      }

      return Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0 || function (p) {
        return p.toString() === '[object SafariRemoteNotification]';
      }(!window['safari'] || safari.pushNotification);
    }

    /**
     * @method isChrome
     * @signature isChrome()
     * @description
     *   [en]Returns whether the browser is Chrome.[/en]
     *   [ja]Chrome上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isChrome',
    value: function isChrome() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'chrome';
      }

      return !!window.chrome && !(!!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0) && !(navigator.userAgent.indexOf(' Edge/') >= 0);
    }

    /**
     * @method isIE
     * @signature isIE()
     * @description
     *   [en]Returns whether the browser is Internet Explorer.[/en]
     *   [ja]Internet Explorer上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isIE',
    value: function isIE() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'ie';
      }

      return false || !!document.documentMode;
    }

    /**
     * @method isEdge
     * @signature isEdge()
     * @description
     *   [en]Returns whether the browser is Edge.[/en]
     *   [ja]Edge上で実行されているかどうかを返します。[/ja]
     * @return {Boolean}
     */

  }, {
    key: 'isEdge',
    value: function isEdge() {
      if (this._getSelectedPlatform()) {
        return this._getSelectedPlatform() === 'edge';
      }

      return navigator.userAgent.indexOf(' Edge/') >= 0;
    }

    //----------------
    // Utility functions
    //----------------
    /**
     * @return {String}
     */

  }, {
    key: 'getMobileOS',
    value: function getMobileOS() {
      if (this.isAndroid()) {
        return 'android';
      } else if (this.isIOS()) {
        return 'ios';
      } else if (this.isWP()) {
        return 'wp';
      } else {
        return 'other';
      }
    }

    /**
     * @return {String}
     */

  }, {
    key: 'getIOSDevice',
    value: function getIOSDevice() {
      if (this.isIPhone()) {
        return 'iphone';
      } else if (this.isIPad()) {
        return 'ipad';
      } else if (this.isIPod()) {
        return 'ipod';
      } else {
        return 'na';
      }
    }
  }]);
  return Platform;
}();

var platform = new Platform();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var error = function error(message) {
  return util$1.throw('In PageAttributeExpression: ' + message);
};

var pageAttributeExpression = {
  _variables: {},

  /**
   * Define a variable.
   *
   * @param {String} name Name of the variable
   * @param {String|Function} value Value of the variable. Can be a string or a function. The function must return a string.
   * @param {Boolean} overwrite If this value is false, an error will be thrown when trying to define a variable that has already been defined.
   */
  defineVariable: function defineVariable(name, value) {
    var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (typeof name !== 'string') {
      error('Variable name must be a string');
    } else if (typeof value !== 'string' && typeof value !== 'function') {
      error('Variable value must be a string or a function');
    } else if (this._variables.hasOwnProperty(name) && !overwrite) {
      error('"' + name + '" is already defined');
    }
    this._variables[name] = value;
  },

  /**
   * Get a variable.
   *
   * @param {String} name Name of the variable.
   * @return {String|Function|null}
   */
  getVariable: function getVariable(name) {
    if (!this._variables.hasOwnProperty(name)) {
      return null;
    }

    return this._variables[name];
  },

  /**
   * Remove a variable.
   *
   * @param {String} name Name of the varaible.
   */
  removeVariable: function removeVariable(name) {
    delete this._variables[name];
  },

  /**
   * Get all variables.
   *
   * @return {Object}
   */
  getAllVariables: function getAllVariables() {
    return this._variables;
  },
  _parsePart: function _parsePart(part) {
    var c = void 0,
        inInterpolation = false,
        currentIndex = 0;

    var tokens = [];

    if (part.length === 0) {
      error('Unable to parse empty string');
    }

    for (var i = 0; i < part.length; i++) {
      c = part.charAt(i);

      if (c === '$' && part.charAt(i + 1) === '{') {
        if (inInterpolation) {
          error('Nested interpolation not supported');
        }

        var token = part.substring(currentIndex, i);
        if (token.length > 0) {
          tokens.push(part.substring(currentIndex, i));
        }

        currentIndex = i;
        inInterpolation = true;
      } else if (c === '}') {
        if (!inInterpolation) {
          error('} must be preceeded by ${');
        }

        var _token = part.substring(currentIndex, i + 1);
        if (_token.length > 0) {
          tokens.push(part.substring(currentIndex, i + 1));
        }

        currentIndex = i + 1;
        inInterpolation = false;
      }
    }

    if (inInterpolation) {
      error('Unterminated interpolation');
    }

    tokens.push(part.substring(currentIndex, part.length));

    return tokens;
  },
  _replaceToken: function _replaceToken(token) {
    var re = /^\${(.*?)}$/,
        match = token.match(re);

    if (match) {
      var name = match[1].trim();
      var variable = this.getVariable(name);

      if (variable === null) {
        error('Variable "' + name + '" does not exist');
      } else if (typeof variable === 'string') {
        return variable;
      } else {
        var rv = variable();

        if (typeof rv !== 'string') {
          error('Must return a string');
        }

        return rv;
      }
    } else {
      return token;
    }
  },
  _replaceTokens: function _replaceTokens(tokens) {
    return tokens.map(this._replaceToken.bind(this));
  },
  _parseExpression: function _parseExpression(expression) {
    return expression.split(',').map(function (part) {
      return part.trim();
    }).map(this._parsePart.bind(this)).map(this._replaceTokens.bind(this)).map(function (part) {
      return part.join('');
    });
  },

  /**
   * Evaluate an expression.
   *
   * @param {String} expression An page attribute expression.
   * @return {Array}
   */
  evaluate: function evaluate(expression) {
    if (!expression) {
      return [];
    }

    return this._parseExpression(expression);
  }
};

// Define default variables.
pageAttributeExpression.defineVariable('mobileOS', platform.getMobileOS());
pageAttributeExpression.defineVariable('iOSDevice', platform.getIOSDevice());
pageAttributeExpression.defineVariable('runtime', function () {
  return platform.isWebView() ? 'cordova' : 'browser';
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var internal$1 = {};

internal$1.config = {
  autoStatusBarFill: true,
  animationsDisabled: false,
  warningsDisabled: false
};

internal$1.nullElement = window.document.createElement('div');

/**
 * @return {Boolean}
 */
internal$1.isEnabledAutoStatusBarFill = function () {
  return !!internal$1.config.autoStatusBarFill;
};

/**
 * @param {String} html
 * @return {String}
 */
internal$1.normalizePageHTML = function (html) {
  return ('' + html).trim();
};

internal$1.waitDOMContentLoaded = function (callback) {
  if (window.document.readyState === 'loading' || window.document.readyState == 'uninitialized') {
    var wrappedCallback = function wrappedCallback() {
      callback();
      window.document.removeEventListener('DOMContentLoaded', wrappedCallback);
    };
    window.document.addEventListener('DOMContentLoaded', wrappedCallback);
  } else {
    setImmediate(callback);
  }
};

internal$1.autoStatusBarFill = function (action) {
  var onReady = function onReady() {
    if (internal$1.shouldFillStatusBar()) {
      action();
    }
    document.removeEventListener('deviceready', onReady);
  };

  if ((typeof device === 'undefined' ? 'undefined' : _typeof(device)) === 'object') {
    document.addEventListener('deviceready', onReady);
  } else if (['complete', 'interactive'].indexOf(document.readyState) === -1) {
    internal$1.waitDOMContentLoaded(onReady);
  } else {
    onReady();
  }
};

internal$1.shouldFillStatusBar = function () {
  return internal$1.isEnabledAutoStatusBarFill() && (platform.isWebView() && platform.isIOS7above() && !platform.isIPhoneX() || document.body.querySelector('.ons-status-bar-mock.ios'));
};

internal$1.templateStore = {
  _storage: {},

  /**
   * @param {String} key
   * @return {String/null} template
   */
  get: function get$$1(key) {
    return internal$1.templateStore._storage[key] || null;
  },


  /**
   * @param {String} key
   * @param {String} template
   */
  set: function set$$1(key, template) {
    internal$1.templateStore._storage[key] = template;
  }
};

window.document.addEventListener('_templateloaded', function (e) {
  if (e.target.nodeName.toLowerCase() === 'ons-template') {
    internal$1.templateStore.set(e.templateId, e.template);
  }
}, false);

internal$1.waitDOMContentLoaded(function () {
  register('script[type="text/ons-template"]');
  register('script[type="text/template"]');
  register('script[type="text/ng-template"]');
  register('template');

  function register(query) {
    var templates = window.document.querySelectorAll(query);
    for (var i = 0; i < templates.length; i++) {
      internal$1.templateStore.set(templates[i].getAttribute('id'), templates[i].textContent || templates[i].content);
    }
  }
});

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getTemplateHTMLAsync = function (page) {
  return new Promise(function (resolve, reject) {
    internal$1.waitDOMContentLoaded(function () {
      var cache = internal$1.templateStore.get(page);
      if (cache) {
        if (cache instanceof DocumentFragment) {
          return resolve(cache);
        }

        var html = typeof cache === 'string' ? cache : cache[1];
        return resolve(internal$1.normalizePageHTML(html));
      }

      var local = window.document.getElementById(page);
      if (local) {
        var _html = local.textContent || local.content;
        return resolve(_html);
      }

      var xhr = new XMLHttpRequest();
      xhr.open('GET', page, true);
      xhr.onload = function () {
        var html = xhr.responseText;
        if (xhr.status >= 400 && xhr.status < 600) {
          reject(html);
        } else {
          // Refresh script tags
          var fragment = util$1.createFragment(html);
          util$1.arrayFrom(fragment.querySelectorAll('script')).forEach(function (el) {
            var script = document.createElement('script');
            script.type = el.type || 'text/javascript';
            script.appendChild(document.createTextNode(el.text || el.textContent || el.innerHTML));
            el.parentNode.replaceChild(script, el);
          });

          internal$1.templateStore.set(page, fragment);
          resolve(fragment);
        }
      };
      xhr.onerror = function () {
        util$1.throw('Page template not found: ' + page);
      };
      xhr.send(null);
    });
  });
};

/**
 * @param {String} page
 * @return {Promise}
 */
internal$1.getPageHTMLAsync = function (page) {
  var pages = pageAttributeExpression.evaluate(page);

  var getPage = function getPage(page) {
    if (typeof page !== 'string') {
      return Promise.reject('Must specify a page.');
    }

    return internal$1.getTemplateHTMLAsync(page).catch(function (error) {
      if (pages.length === 0) {
        return Promise.reject(error);
      }

      return getPage(pages.shift());
    });
  };

  return getPage(pages.shift());
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AnimatorFactory = function () {

  /**
   * @param {Object} opts
   * @param {Object} opts.animators The dictionary for animator classes
   * @param {Function} opts.baseClass The base class of animators
   * @param {String} [opts.baseClassName] The name of the base class of animators
   * @param {String} [opts.defaultAnimation] The default animation name
   * @param {Object} [opts.defaultAnimationOptions] The default animation options
   */
  function AnimatorFactory(opts) {
    classCallCheck(this, AnimatorFactory);

    this._animators = opts.animators;
    this._baseClass = opts.baseClass;
    this._baseClassName = opts.baseClassName || opts.baseClass.name;
    this._animation = opts.defaultAnimation || 'default';
    this._animationOptions = opts.defaultAnimationOptions || {};

    if (!this._animators[this._animation]) {
      util$1.throw('No such animation: ' + this._animation);
    }
  }

  /**
   * @param {String} jsonString
   * @return {Object/null}
   */


  createClass(AnimatorFactory, [{
    key: 'setAnimationOptions',


    /**
     * @param {Object} options
     */
    value: function setAnimationOptions(options) {
      this._animationOptions = options;
    }

    /**
     * @param {Object} options
     * @param {String} [options.animation] The animation name
     * @param {Object} [options.animationOptions] The animation options
     * @param {Object} defaultAnimator The default animator instance
     * @return {Object} An animator instance
     */

  }, {
    key: 'newAnimator',
    value: function newAnimator() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var defaultAnimator = arguments[1];


      var animator = null;

      if (options.animation instanceof this._baseClass) {
        return options.animation;
      }

      var Animator = null;

      if (typeof options.animation === 'string') {
        Animator = this._animators[options.animation];
      }

      if (!Animator && defaultAnimator) {
        animator = defaultAnimator;
      } else {
        Animator = Animator || this._animators[this._animation];

        var animationOpts = util$1.extend({}, this._animationOptions, options.animationOptions || {}, internal$1.config.animationsDisabled ? { duration: 0, delay: 0 } : {});

        animator = new Animator(animationOpts);

        if (typeof animator === 'function') {
          animator = new animator(animationOpts); // eslint-disable-line new-cap
        }
      }

      if (!(animator instanceof this._baseClass)) {
        util$1.throw('"animator" is not an instance of ' + this._baseClassName);
      }

      return animator;
    }
  }], [{
    key: 'parseAnimationOptionsString',
    value: function parseAnimationOptionsString(jsonString) {
      try {
        if (typeof jsonString === 'string') {
          var result = util$1.animationOptionsParse(jsonString);
          if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
            return result;
          } else {
            console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
          }
        }
        return {};
      } catch (e) {
        console.error('"animation-options" attribute must be a JSON object string: ' + jsonString);
        return {};
      }
    }
  }]);
  return AnimatorFactory;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var autoStyleEnabled = true;

// Modifiers
var modifiersMap = {
  'quiet': 'material--flat',
  'light': 'material--flat',
  'outline': 'material--flat',
  'cta': '',
  'large--quiet': 'material--flat large',
  'large--cta': 'large',
  'noborder': '',
  'tappable': ''
};

var platforms = {};

platforms.android = function (element) {

  var elementName = element.tagName.toLowerCase();

  if (!util$1.hasModifier(element, 'material')) {
    var oldModifier = element.getAttribute('modifier') || '';

    var newModifier = oldModifier.trim().split(/\s+/).map(function (e) {
      return modifiersMap.hasOwnProperty(e) ? modifiersMap[e] : e;
    });
    newModifier.unshift('material');

    element.setAttribute('modifier', newModifier.join(' ').trim());
  }

  var elements = ['ons-alert-dialog-button', 'ons-toolbar-button', 'ons-back-button', 'ons-button', 'ons-list-item', 'ons-fab', 'ons-speed-dial', 'ons-speed-dial-item', 'ons-tab'];

  // Effects
  if (elements.indexOf(elementName) !== -1 && !element.hasAttribute('ripple') && !element.querySelector('ons-ripple')) {

    if (elementName === 'ons-list-item') {
      if (element.hasAttribute('tappable')) {
        element.setAttribute('ripple', '');
        element.removeAttribute('tappable');
      }
    } else {
      element.setAttribute('ripple', '');
    }
  }
};

platforms.ios = function (element) {

  // Modifiers
  if (util$1.removeModifier(element, 'material')) {
    if (util$1.removeModifier(element, 'material--flat')) {
      util$1.addModifier(element, util$1.removeModifier(element, 'large') ? 'large--quiet' : 'quiet');
    }

    if (!element.getAttribute('modifier')) {
      element.removeAttribute('modifier');
    }
  }

  // Effects
  if (element.hasAttribute('ripple')) {
    if (element.tagName.toLowerCase() === 'ons-list-item') {
      element.setAttribute('tappable', '');
    }

    element.removeAttribute('ripple');
  }
};

var unlocked = {
  android: true
};

var getPlatform = function getPlatform(element, force) {
  if (autoStyleEnabled && !element.hasAttribute('disable-auto-styling')) {
    var mobileOS = platform.getMobileOS();
    if (platforms.hasOwnProperty(mobileOS) && (unlocked.hasOwnProperty(mobileOS) || force)) {
      return mobileOS;
    }
  }
  return null;
};

var prepare = function prepare(element, force) {
  var p = getPlatform(element, force);
  p && platforms[p](element);
};

var mapModifier = function mapModifier(modifier, element, force) {
  if (getPlatform(element, force)) {
    return modifier.split(/\s+/).map(function (m) {
      return modifiersMap.hasOwnProperty(m) ? modifiersMap[m] : m;
    }).join(' ');
  }
  return modifier;
};

var restoreModifier = function restoreModifier(element) {
  if (getPlatform(element) === 'android') {
    var modifier = element.getAttribute('modifier') || '';
    var newModifier = mapModifier(modifier, element);

    if (!/(^|\s+)material($|\s+)/i.test(modifier)) {
      newModifier = 'material ' + newModifier;
    }

    if (newModifier !== modifier) {
      element.setAttribute('modifier', newModifier.trim());
      return true;
    }
  }
  return false;
};

var autoStyle = {
  isEnabled: function isEnabled() {
    return autoStyleEnabled;
  },
  enable: function enable() {
    return autoStyleEnabled = true;
  },
  disable: function disable() {
    return autoStyleEnabled = false;
  },
  prepare: prepare,
  mapModifier: mapModifier,
  getPlatform: getPlatform,
  restoreModifier: restoreModifier
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModifierUtil = function () {
  function ModifierUtil() {
    classCallCheck(this, ModifierUtil);
  }

  createClass(ModifierUtil, null, [{
    key: 'diff',

    /**
     * @param {String} last
     * @param {String} current
     */
    value: function diff(last, current) {
      last = makeDict(('' + last).trim());
      current = makeDict(('' + current).trim());

      var removed = Object.keys(last).reduce(function (result, token) {
        if (!current[token]) {
          result.push(token);
        }
        return result;
      }, []);

      var added = Object.keys(current).reduce(function (result, token) {
        if (!last[token]) {
          result.push(token);
        }
        return result;
      }, []);

      return { added: added, removed: removed };

      function makeDict(modifier) {
        var dict = {};
        ModifierUtil.split(modifier).forEach(function (token) {
          return dict[token] = token;
        });
        return dict;
      }
    }

    /**
     * @param {Object} diff
     * @param {Array} diff.removed
     * @param {Array} diff.added
     * @param {Object} classList
     * @param {String} template
     */

  }, {
    key: 'applyDiffToClassList',
    value: function applyDiffToClassList(diff, classList, template) {
      diff.added.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return klass.split(/\s+/).forEach(function (k) {
          return classList.add(k);
        });
      });

      diff.removed.map(function (modifier) {
        return template.replace(/\*/g, modifier);
      }).forEach(function (klass) {
        return klass.split(/\s+/).forEach(function (k) {
          return classList.remove(k);
        });
      });
    }

    /**
     * @param {Object} diff
     * @param {Array} diff.removed
     * @param {Array} diff.added
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'applyDiffToElement',
    value: function applyDiffToElement(diff, element, scheme) {
      Object.keys(scheme).forEach(function (selector) {
        var targetElements = !selector || util$1.match(element, selector) ? [element] : Array.prototype.filter.call(element.querySelectorAll(selector), function (targetElement) {
          return !util$1.findParent(targetElement, element.tagName, function (parent) {
            return parent === element;
          });
        });

        for (var i = 0; i < targetElements.length; i++) {
          ModifierUtil.applyDiffToClassList(diff, targetElements[i].classList, scheme[selector]);
        }
      });
    }

    /**
     * @param {String} last
     * @param {String} current
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'onModifierChanged',
    value: function onModifierChanged(last, current, element, scheme) {
      ModifierUtil.applyDiffToElement(ModifierUtil.diff(last, current), element, scheme);
      autoStyle.restoreModifier(element);
    }
  }, {
    key: 'refresh',
    value: function refresh(element, scheme) {
      ModifierUtil.applyDiffToElement(ModifierUtil.diff('', element.getAttribute('modifier') || ''), element, scheme);
    }

    /**
     * @param {HTMLElement} element
     * @param {Object} scheme
     */

  }, {
    key: 'initModifier',
    value: function initModifier(element, scheme) {
      var modifier = element.getAttribute('modifier');
      if (typeof modifier !== 'string') {
        return;
      }

      ModifierUtil.applyDiffToElement({
        removed: [],
        added: ModifierUtil.split(modifier)
      }, element, scheme);
    }
  }, {
    key: 'split',
    value: function split(modifier) {
      if (typeof modifier !== 'string') {
        return [];
      }

      return modifier.trim().split(/ +/).filter(function (token) {
        return token !== '';
      });
    }

    /**
     * Add modifier token to an element.
     */

  }, {
    key: 'addModifier',
    value: function addModifier(element, modifierToken) {
      if (!element.hasAttribute('modifier')) {
        element.setAttribute('modifier', modifierToken);
      } else {
        var tokens = ModifierUtil.split(element.getAttribute('modifier'));
        if (tokens.indexOf(modifierToken) == -1) {
          tokens.push(modifierToken);
          element.setAttribute('modifier', tokens.join(' '));
        }
      }
    }

    /**
     * Remove modifier token from an element.
     */

  }, {
    key: 'removeModifier',
    value: function removeModifier(element, modifierToken) {
      if (element.hasAttribute('modifier')) {
        var tokens = ModifierUtil.split(element.getAttribute('modifier'));
        var index = tokens.indexOf(modifierToken);
        if (index !== -1) {
          tokens.splice(index, 1);
          element.setAttribute('modifier', tokens.join(' '));
        }
      }
    }
  }]);
  return ModifierUtil;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util$3 = {
  _ready: false,

  _domContentLoaded: false,

  _onDOMContentLoaded: function _onDOMContentLoaded() {
    util$3._domContentLoaded = true;

    if (platform.isWebView()) {
      window.document.addEventListener('deviceready', function () {
        util$3._ready = true;
      }, false);
    } else {
      util$3._ready = true;
    }
  },

  addBackButtonListener: function addBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.addEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.addEventListener('backbutton', fn, false);
      });
    }
  },

  removeBackButtonListener: function removeBackButtonListener(fn) {
    if (!this._domContentLoaded) {
      throw new Error('This method is available after DOMContentLoaded');
    }

    if (this._ready) {
      window.document.removeEventListener('backbutton', fn, false);
    } else {
      window.document.addEventListener('deviceready', function () {
        window.document.removeEventListener('backbutton', fn, false);
      });
    }
  }
};
if (document.readyState === 'complete' || document.readyState === 'loaded' || document.readyState === 'interactive') {
  util$3._onDOMContentLoaded();
} else {
  window.addEventListener('DOMContentLoaded', function () {
    return util$3._onDOMContentLoaded();
  }, false);
}

var HandlerRepository = {
  _store: {},

  _genId: function () {
    var i = 0;
    return function () {
      return i++;
    };
  }(),

  set: function set$$1(element, handler) {
    if (element.dataset.deviceBackButtonHandlerId) {
      this.remove(element);
    }
    var id = element.dataset.deviceBackButtonHandlerId = HandlerRepository._genId();
    this._store[id] = handler;
  },

  remove: function remove(element) {
    if (element.dataset.deviceBackButtonHandlerId) {
      delete this._store[element.dataset.deviceBackButtonHandlerId];
      delete element.dataset.deviceBackButtonHandlerId;
    }
  },

  get: function get$$1(element) {
    if (!element.dataset.deviceBackButtonHandlerId) {
      return undefined;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    if (!this._store[id]) {
      throw new Error();
    }

    return this._store[id];
  },

  has: function has(element) {
    if (!element.dataset) {
      return false;
    }

    var id = element.dataset.deviceBackButtonHandlerId;

    return !!this._store[id];
  }
};

var DeviceBackButtonDispatcher = function () {
  function DeviceBackButtonDispatcher() {
    classCallCheck(this, DeviceBackButtonDispatcher);

    this._isEnabled = false;
    this._boundCallback = this._callback.bind(this);
  }

  /**
   * Enable to handle 'backbutton' events.
   */


  createClass(DeviceBackButtonDispatcher, [{
    key: 'enable',
    value: function enable() {
      if (!this._isEnabled) {
        util$3.addBackButtonListener(this._boundCallback);
        this._isEnabled = true;
      }
    }

    /**
     * Disable to handle 'backbutton' events.
     */

  }, {
    key: 'disable',
    value: function disable() {
      if (this._isEnabled) {
        util$3.removeBackButtonListener(this._boundCallback);
        this._isEnabled = false;
      }
    }

    /**
     * Fire a 'backbutton' event manually.
     */

  }, {
    key: 'fireDeviceBackButtonEvent',
    value: function fireDeviceBackButtonEvent() {
      var event = document.createEvent('Event');
      event.initEvent('backbutton', true, true);
      document.dispatchEvent(event);
    }
  }, {
    key: '_callback',
    value: function _callback() {
      this._dispatchDeviceBackButtonEvent();
    }

    /**
     * @param {HTMLElement} element
     * @param {Function} callback
     */

  }, {
    key: 'createHandler',
    value: function createHandler(element, callback) {
      if (!(element instanceof HTMLElement)) {
        throw new Error('element must be an instance of HTMLElement');
      }

      if (!(callback instanceof Function)) {
        throw new Error('callback must be an instance of Function');
      }

      var handler = {
        _callback: callback,
        _element: element,

        disable: function disable() {
          HandlerRepository.remove(element);
        },

        setListener: function setListener(callback) {
          this._callback = callback;
        },

        enable: function enable() {
          HandlerRepository.set(element, this);
        },

        isEnabled: function isEnabled() {
          return HandlerRepository.get(element) === this;
        },

        destroy: function destroy() {
          HandlerRepository.remove(element);
          this._callback = this._element = null;
        }
      };

      handler.enable();

      return handler;
    }
  }, {
    key: '_dispatchDeviceBackButtonEvent',
    value: function _dispatchDeviceBackButtonEvent() {
      var tree = this._captureTree();

      var element = this._findHandlerLeafElement(tree);

      var handler = HandlerRepository.get(element);
      handler._callback(createEvent(element));

      function createEvent(element) {
        return {
          _element: element,
          callParentHandler: function callParentHandler() {
            var parent = this._element.parentNode;

            while (parent) {
              handler = HandlerRepository.get(parent);
              if (handler) {
                return handler._callback(createEvent(parent));
              }
              parent = parent.parentNode;
            }
          }
        };
      }
    }

    /**
     * @return {Object}
     */

  }, {
    key: '_captureTree',
    value: function _captureTree() {
      return createTree(document.body);

      function createTree(element) {
        var tree = {
          element: element,
          children: Array.prototype.concat.apply([], arrayOf(element.children).map(function (childElement) {

            if (childElement.style.display === 'none' || childElement._isShown === false) {
              return [];
            }

            if (childElement.children.length === 0 && !HandlerRepository.has(childElement)) {
              return [];
            }

            var result = createTree(childElement);

            if (result.children.length === 0 && !HandlerRepository.has(result.element)) {
              return [];
            }

            return [result];
          }))
        };

        if (!HandlerRepository.has(tree.element)) {
          for (var i = 0; i < tree.children.length; i++) {
            var subTree = tree.children[i];
            if (HandlerRepository.has(subTree.element)) {
              return subTree;
            }
          }
        }

        return tree;
      }

      function arrayOf(target) {
        var result = [];
        for (var i = 0; i < target.length; i++) {
          result.push(target[i]);
        }
        return result;
      }
    }

    /**
     * @param {Object} tree
     * @return {HTMLElement}
     */

  }, {
    key: '_findHandlerLeafElement',
    value: function _findHandlerLeafElement(tree) {
      return find(tree);

      function find(node) {
        if (node.children.length === 0) {
          return node.element;
        }

        if (node.children.length === 1) {
          return find(node.children[0]);
        }

        return node.children.map(function (childNode) {
          return childNode.element;
        }).reduce(function (left, right) {
          if (!left) {
            return right;
          }

          var leftZ = parseInt(window.getComputedStyle(left, '').zIndex, 10);
          var rightZ = parseInt(window.getComputedStyle(right, '').zIndex, 10);

          if (!isNaN(leftZ) && !isNaN(rightZ)) {
            return leftZ > rightZ ? left : right;
          }

          throw new Error('Capturing backbutton-handler is failure.');
        }, null);
      }
    }
  }]);
  return DeviceBackButtonDispatcher;
}();

var deviceBackButtonDispatcher = new DeviceBackButtonDispatcher();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
internal$1.AnimatorFactory = AnimatorFactory;
internal$1.ModifierUtil = ModifierUtil;
internal$1.dbbDispatcher = deviceBackButtonDispatcher;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var startsWith = function startsWith(s, c) {
  return s.substr(0, c.length) === c;
};
var endsWith = function endsWith(s, c) {
  return s.substr(s.length - c.length, c.length) === c;
};
var unwrap = function unwrap(s) {
  return s.slice(1, -1);
};
var isObjectString = function isObjectString(s) {
  return startsWith(s, '{') && endsWith(s, '}');
};
var isArrayString = function isArrayString(s) {
  return startsWith(s, '[') && endsWith(s, ']');
};
var isQuotedString = function isQuotedString(s) {
  return startsWith(s, '\'') && endsWith(s, '\'') || startsWith(s, '"') && endsWith(s, '"');
};

var error$1 = function error(token, string, originalString) {
  throw new Error('Unexpected token \'' + token + '\' at position ' + (originalString.length - string.length - 1) + ' in string: \'' + originalString + '\'');
};

var processToken = function processToken(token, string, originalString) {
  if (token === 'true' || token === 'false') {
    return token === 'true';
  } else if (isQuotedString(token)) {
    return unwrap(token);
  } else if (!isNaN(token)) {
    return +token;
  } else if (isObjectString(token)) {
    return parseObject(unwrap(token));
  } else if (isArrayString(token)) {
    return parseArray(unwrap(token));
  } else {
    error$1(token, string, originalString);
  }
};

var nextToken = function nextToken(string) {
  string = string.trim();
  var limit = string.length;

  if (string[0] === ':' || string[0] === ',') {

    limit = 1;
  } else if (string[0] === '{' || string[0] === '[') {

    var c = string.charCodeAt(0);
    var nestedObject = 1;
    for (var i = 1; i < string.length; i++) {
      if (string.charCodeAt(i) === c) {
        nestedObject++;
      } else if (string.charCodeAt(i) === c + 2) {
        nestedObject--;
        if (nestedObject === 0) {
          limit = i + 1;
          break;
        }
      }
    }
  } else if (string[0] === '\'' || string[0] === '"') {

    for (var _i = 1; _i < string.length; _i++) {
      if (string[_i] === string[0]) {
        limit = _i + 1;
        break;
      }
    }
  } else {

    for (var _i2 = 1; _i2 < string.length; _i2++) {
      if ([' ', ',', ':'].indexOf(string[_i2]) !== -1) {
        limit = _i2;
        break;
      }
    }
  }

  return string.slice(0, limit);
};

var parseObject = function parseObject(string) {
  var isValidKey = function isValidKey(key) {
    return (/^[A-Z_$][A-Z0-9_$]*$/i.test(key)
    );
  };

  string = string.trim();
  var originalString = string;
  var object = {};
  var readingKey = true,
      key = void 0,
      previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trim();

    if (token === ':' && (!readingKey || !previousToken || previousToken === ',') || token === ',' && readingKey || token !== ':' && token !== ',' && previousToken && previousToken !== ',' && previousToken !== ':') {
      error$1(token, string, originalString);
    } else if (token === ':' && readingKey && previousToken) {
      previousToken = isQuotedString(previousToken) ? unwrap(previousToken) : previousToken;
      if (isValidKey(previousToken)) {
        key = previousToken;
        readingKey = false;
      } else {
        throw new Error('Invalid key token \'' + previousToken + '\' at position 0 in string: \'' + originalString + '\'');
      }
    } else if (token === ',' && !readingKey && previousToken) {
      object[key] = processToken(previousToken, string, originalString);
      readingKey = true;
    }
  }

  if (token) {
    object[key] = processToken(token, string, originalString);
  }

  return object;
};

var parseArray = function parseArray(string) {
  string = string.trim();
  var originalString = string;
  var array = [];
  var previousToken = void 0,
      token = void 0;

  while (string.length > 0) {
    previousToken = token;
    token = nextToken(string);
    string = string.slice(token.length, string.length).trim();

    if (token === ',' && (!previousToken || previousToken === ',')) {
      error$1(token, string, originalString);
    } else if (token === ',') {
      array.push(processToken(previousToken, string, originalString));
    }
  }

  if (token) {
    if (token !== ',') {
      array.push(processToken(token, string, originalString));
    } else {
      error$1(token, string, originalString);
    }
  }

  return array;
};

var parse = function parse(string) {
  string = string.trim();

  if (isObjectString(string)) {
    return parseObject(unwrap(string));
  } else if (isArrayString(string)) {
    return parseArray(unwrap(string));
  } else {
    throw new Error('Provided string must be object or array like: ' + string);
  }
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var util$1 = {};
var errorPrefix = '[Onsen UI]';

util$1.globals = {
  fabOffset: 0,
  errorPrefix: errorPrefix,
  supportsPassive: false
};

platform._runOnActualPlatform(function () {
  util$1.globals.actualMobileOS = platform.getMobileOS();
  util$1.globals.isUIWebView = platform.isUIWebView();
  util$1.globals.isWKWebView = platform.isWKWebView();
});

try {
  var opts = Object.defineProperty({}, 'passive', {
    get: function get$$1() {
      util$1.globals.supportsPassive = true;
    }
  });
  window.addEventListener('testPassive', null, opts);
  window.removeEventListener('testPassive', null, opts);
} catch (e) {
  
}

/**
 * @param {Element} el Target
 * @param {String} name Event name
 * @param {Function} handler Event handler
 * @param {Object} [opt] Event options (passive, capture...)
 * @param {Boolean} [isGD] If comes from GestureDetector. Just for testing.
 */
util$1.addEventListener = function (el, name, handler, opt, isGD) {
  el.addEventListener(name, handler, util$1.globals.supportsPassive ? opt : (opt || {}).capture);
};
util$1.removeEventListener = function (el, name, handler, opt, isGD) {
  el.removeEventListener(name, handler, util$1.globals.supportsPassive ? opt : (opt || {}).capture);
};

/**
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {Function}
 */
util$1.prepareQuery = function (query) {
  return query instanceof Function ? query : function (element) {
    return util$1.match(element, query);
  };
};

/**
 * @param {Element} e
 * @param {String/Function} s CSS Selector.
 * @return {Boolean}
 */
util$1.match = function (e, s) {
  return (e.matches || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector).call(e, s);
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util$1.findChild = function (element, query) {
  var match = util$1.prepareQuery(query);

  // Caution: `element.children` is `undefined` in some environments if `element` is `svg`
  for (var i = 0; i < element.childNodes.length; i++) {
    var node = element.childNodes[i];
    if (node.nodeType !== Node.ELEMENT_NODE) {
      // process only element nodes
      continue;
    }
    if (match(node)) {
      return node;
    }
  }
  return null;
};

/**
 * @param {Element} element
 * @param {String/Function} query dot class name or node name or matcher function.
 * @return {HTMLElement/null}
 */
util$1.findParent = function (element, query, until) {
  var match = util$1.prepareQuery(query);

  var parent = element.parentNode;
  for (;;) {
    if (!parent || parent === document || parent instanceof DocumentFragment || until && until(parent)) {
      return null;
    } else if (match(parent)) {
      return parent;
    }
    parent = parent.parentNode;
  }
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util$1.isAttached = function (element) {
  return document.body.contains(element);
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util$1.hasAnyComponentAsParent = function (element) {
  while (element && document.documentElement !== element) {
    element = element.parentNode;
    if (element && element.nodeName.toLowerCase().match(/(ons-navigator|ons-tabbar|ons-modal)/)) {
      return true;
    }
  }
  return false;
};

/**
 * @param {Element} element
 * @return {boolean}
 */
util$1.isPageControl = function (element) {
  return element.nodeName.match(/^ons-(navigator|splitter|tabbar|page)$/i);
};

/**
 * @param {Element} element
 * @param {String} action to propagate
 */
util$1.propagateAction = function (element, action) {
  for (var i = 0; i < element.childNodes.length; i++) {
    var child = element.childNodes[i];
    if (child[action] instanceof Function) {
      child[action]();
    } else {
      util$1.propagateAction(child, action);
    }
  }
};

/**
 * @param {String} string - string to be camelized
 * @return {String} Camelized string
 */
util$1.camelize = function (string) {
  return string.toLowerCase().replace(/-([a-z])/g, function (m, l) {
    return l.toUpperCase();
  });
};

/**
 * @param {String} string - string to be hyphenated
 * @return {String} Hyphenated string
 */
util$1.hyphenate = function (string) {
  return string.replace(/([a-zA-Z])([A-Z])/g, '$1-$2').toLowerCase();
};

/**
 * @param {String} selector - tag and class only
 * @param {Object} style
 * @param {Element}
 */
util$1.create = function () {
  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var classList = selector.split('.');
  var element = document.createElement(classList.shift() || 'div');

  if (classList.length) {
    element.className = classList.join(' ');
  }

  styler(element, style);

  return element;
};

/**
 * @param {String} html
 * @return {Element}
 */
util$1.createElement = function (html) {
  var wrapper = document.createElement('div');

  if (html instanceof DocumentFragment) {
    wrapper.appendChild(document.importNode(html, true));
  } else {
    wrapper.innerHTML = html.trim();
  }

  if (wrapper.children.length > 1) {
    util$1.throw('HTML template must contain a single root element');
  }

  var element = wrapper.children[0];
  wrapper.children[0].remove();
  return element;
};

/**
 * @param {String} html
 * @return {HTMLFragment}
 */
util$1.createFragment = function (html) {
  var template = document.createElement('template');
  template.innerHTML = html;
  return document.importNode(template.content, true);
};

/*
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to `dst`.
 */
util$1.extend = function (dst) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  for (var i = 0; i < args.length; i++) {
    if (args[i]) {
      var keys = Object.keys(args[i]);
      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        dst[key] = args[i][key];
      }
    }
  }

  return dst;
};

/**
 * @param {Object} arrayLike
 * @return {Array}
 */
util$1.arrayFrom = function (arrayLike) {
  return Array.prototype.slice.apply(arrayLike);
};

/**
 * @param {String} jsonString
 * @param {Object} [failSafe]
 * @return {Object}
 */
util$1.parseJSONObjectSafely = function (jsonString) {
  var failSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    var result = JSON.parse('' + jsonString);
    if ((typeof result === 'undefined' ? 'undefined' : _typeof(result)) === 'object' && result !== null) {
      return result;
    }
  } catch (e) {
    return failSafe;
  }
  return failSafe;
};

/**
 * @param {String} path - path such as 'myApp.controllers.data.loadData'
 * @return {Any} - whatever is located at that path
 */
util$1.findFromPath = function (path) {
  path = path.split('.');
  var el = window,
      key;
  while (key = path.shift()) {
    // eslint-disable-line no-cond-assign
    el = el[key];
  }
  return el;
};

/**
 * @param {HTMLElement} container - Page or page-container that implements 'topPage'
 * @return {HTMLElement|null} - Visible page element or null if not found.
 */
util$1.getTopPage = function (container) {
  return container && (container.tagName.toLowerCase() === 'ons-page' ? container : container.topPage) || null;
};

/**
 * @param {HTMLElement} container - Element where the search begins
 * @return {HTMLElement|null} - Page element that contains the visible toolbar or null.
 */
util$1.findToolbarPage = function (container) {
  var page = util$1.getTopPage(container);

  if (page) {
    if (page._canAnimateToolbar()) {
      return page;
    }

    for (var i = 0; i < page._contentElement.children.length; i++) {
      var nextPage = util$1.getTopPage(page._contentElement.children[i]);
      if (nextPage && !/ons-tabbar/i.test(page._contentElement.children[i].tagName)) {
        return util$1.findToolbarPage(nextPage);
      }
    }
  }

  return null;
};

/**
 * @param {Element} element
 * @param {String} eventName
 * @param {Object} [detail]
 * @return {CustomEvent}
 */
util$1.triggerElementEvent = function (target, eventName) {
  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


  var event = new CustomEvent(eventName, {
    bubbles: true,
    cancelable: true,
    detail: detail
  });

  Object.keys(detail).forEach(function (key) {
    event[key] = detail[key];
  });

  target.dispatchEvent(event);

  return event;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @return {Boolean}
 */
util$1.hasModifier = function (target, modifierName) {
  if (!target.hasAttribute('modifier')) {
    return false;
  }

  return RegExp('(^|\\s+)' + modifierName + '($|\\s+)', 'i').test(target.getAttribute('modifier'));
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
 * @param {Object} options.forceAutoStyle Ignores platform limitation.
 * @return {Boolean} Whether it was added or not.
 */
util$1.addModifier = function (target, modifierName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (options.autoStyle) {
    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);
  }

  if (util$1.hasModifier(target, modifierName)) {
    return false;
  }

  target.setAttribute('modifier', ((target.getAttribute('modifier') || '') + ' ' + modifierName).trim());
  return true;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
 * @param {Object} options.forceAutoStyle Ignores platform limitation.
 * @return {Boolean} Whether it was found or not.
 */
util$1.removeModifier = function (target, modifierName) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (options.autoStyle) {
    modifierName = autoStyle.mapModifier(modifierName, target, options.forceAutoStyle);
  }

  if (!target.getAttribute('modifier') || !util$1.hasModifier(target, modifierName)) {
    return false;
  }

  var newModifiers = target.getAttribute('modifier').split(/\s+/).filter(function (m) {
    return m && m !== modifierName;
  });
  newModifiers.length ? target.setAttribute('modifier', newModifiers.join(' ')) : target.removeAttribute('modifier');
  return true;
};

/**
 * @param {Element} target
 * @param {String} modifierName
 * @param {Boolean} options.force Forces modifier to be added or removed.
 * @param {Object} options.autoStyle Maps the modifierName to the corresponding styled modifier.
 * @param {Boolean} options.forceAutoStyle Ignores platform limitation.
 * @return {Boolean} Whether it was found or not.
 */
util$1.toggleModifier = function () {
  var options = arguments.length > 2 ? arguments.length <= 2 ? undefined : arguments[2] : {};
  var force = typeof options === 'boolean' ? options : options.force;

  var toggle = typeof force === 'boolean' ? force : !util$1.hasModifier.apply(util$1, arguments);
  toggle ? util$1.addModifier.apply(util$1, arguments) : util$1.removeModifier.apply(util$1, arguments);
};

/**
 * @param {Element} el
 * @param {String} defaultClass
 * @param {Object} scheme
 */
util$1.restoreClass = function (el, defaultClass, scheme) {
  defaultClass.split(/\s+/).forEach(function (c) {
    return c !== '' && !el.classList.contains(c) && el.classList.add(c);
  });
  el.hasAttribute('modifier') && ModifierUtil.refresh(el, scheme);
};

// TODO: FIX
util$1.updateParentPosition = function (el) {
  if (!el._parentUpdated && el.parentElement) {
    if (window.getComputedStyle(el.parentElement).getPropertyValue('position') === 'static') {
      el.parentElement.style.position = 'relative';
    }
    el._parentUpdated = true;
  }
};

util$1.toggleAttribute = function (element, name, value) {
  if (value) {
    element.setAttribute(name, typeof value === 'boolean' ? '' : value);
  } else {
    element.removeAttribute(name);
  }
};

util$1.bindListeners = function (element, listenerNames) {
  listenerNames.forEach(function (name) {
    var boundName = name.replace(/^_[a-z]/, '_bound' + name[1].toUpperCase());
    element[boundName] = element[boundName] || element[name].bind(element);
  });
};

util$1.each = function (obj, f) {
  return Object.keys(obj).forEach(function (key) {
    return f(key, obj[key]);
  });
};

/**
 * @param {Element} target
 * @param {boolean} hasRipple
 * @param {Object} attrs
 */
util$1.updateRipple = function (target, hasRipple) {
  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (hasRipple === undefined) {
    hasRipple = target.hasAttribute('ripple');
  }

  var rippleElement = util$1.findChild(target, 'ons-ripple');

  if (hasRipple) {
    if (!rippleElement) {
      var element = document.createElement('ons-ripple');
      Object.keys(attrs).forEach(function (key) {
        return element.setAttribute(key, attrs[key]);
      });
      target.insertBefore(element, target.firstChild);
    }
  } else if (rippleElement) {
    rippleElement.remove();
  }
};

/**
 * @param {String}
 * @return {Object}
 */
util$1.animationOptionsParse = parse;

/**
 * @param {*} value
 */
util$1.isInteger = function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};

/**
 * @return {Object} Deferred promise.
 */
util$1.defer = function () {
  var deferred = {};
  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
};

/**
 * Show warnings when they are enabled.
 *
 * @param {*} arguments to console.warn
 */
util$1.warn = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  if (!internal$1.config.warningsDisabled) {
    var _console;

    (_console = console).warn.apply(_console, [errorPrefix].concat(args));
  }
};

util$1.throw = function (message) {
  throw new Error(errorPrefix + ' ' + message);
};

util$1.throwAbstract = function () {
  return util$1.throw('Cannot instantiate abstract class');
};
util$1.throwMember = function () {
  return util$1.throw('Class member must be implemented');
};
util$1.throwPageLoader = function () {
  return util$1.throw('First parameter should be an instance of PageLoader');
};
util$1.throwAnimator = function (el) {
  return util$1.throw('"Animator" param must inherit ' + el + 'Animator');
};

var prevent = function prevent(e) {
  return e.cancelable && e.preventDefault();
};

/**
 * Prevent scrolling while draging horizontally on iOS.
 *
 * @param {gd} GestureDetector instance
 */
util$1.iosPreventScroll = function (gd) {
  if (util$1.globals.actualMobileOS === 'ios') {
    var clean = function clean(e) {
      gd.off('touchmove', prevent);
      gd.off('dragend', clean);
    };

    gd.on('touchmove', prevent);
    gd.on('dragend', clean);
  }
};

/**
 * Prevents scroll in underlying pages on iOS. See #2220 #2274 #1949
 *
 * @param {el} HTMLElement that prevents the events
 * @param {add} Boolean Add or remove event listeners
 */
util$1.iosPageScrollFix = function (add) {
  // Full fix - May cause issues with UIWebView's momentum scroll
  if (util$1.globals.actualMobileOS === 'ios') {
    document.body.classList.toggle('ons-ios-scroll', add); // Allows custom and localized fixes (#2274)
    if (!util$1.globals.isUIWebView || internal$1.config.forceUIWebViewScrollFix) {
      document.body.classList.toggle('ons-ios-scroll-fix', add);
    }
  }
};
util$1.iosMaskScrollFix = function (el, add) {
  // Half fix - only prevents scroll on masks
  if (util$1.globals.isUIWebView) {
    var action = (add ? 'add' : 'remove') + 'EventListener';
    el[action]('touchmove', prevent, false);
  }
};

/**
 * Distance and deltaTime filter some weird dragstart events that are not fired immediately.
 *
 * @param {event}
 */
util$1.isValidGesture = function (event) {
  return event.gesture !== undefined && (event.gesture.distance <= 15 || event.gesture.deltaTime <= 100);
};

util$1.checkMissingImport = function () {
  for (var _len3 = arguments.length, elementNames = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    elementNames[_key3] = arguments[_key3];
  }

  elementNames.forEach(function (name) {
    if (!onsElements[name]) {
      util$1.throw('Ons' + name + ' is required but was not imported (Custom Elements)');
    }
  });
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Minimal animation library for managing css transition on mobile browsers.
 */
var TIMEOUT_RATIO = 1.4;

var util$4 = {};

// capitalize string
util$4.capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

/**
 * @param {Object} params
 * @param {String} params.property
 * @param {Float} params.duration
 * @param {String} params.timing
 */
util$4.buildTransitionValue = function (params) {
  params.property = params.property || 'all';
  params.duration = params.duration || 0.4;
  params.timing = params.timing || 'linear';

  var props = params.property.split(/ +/);

  return props.map(function (prop) {
    return prop + ' ' + params.duration + 's ' + params.timing;
  }).join(', ');
};

/**
 * Add an event handler on "transitionend" event.
 */
util$4.onceOnTransitionEnd = function (element, callback) {
  if (!element) {
    return function () {};
  }

  var fn = function fn(event) {
    if (element == event.target) {
      event.stopPropagation();
      removeListeners();

      callback();
    }
  };

  var removeListeners = function removeListeners() {
    util$4._transitionEndEvents.forEach(function (eventName) {
      element.removeEventListener(eventName, fn, false);
    });
  };

  util$4._transitionEndEvents.forEach(function (eventName) {
    element.addEventListener(eventName, fn, false);
  });

  return removeListeners;
};

util$4._transitionEndEvents = function () {

  if ('ontransitionend' in window) {
    return ['transitionend'];
  }

  if ('onwebkittransitionend' in window) {
    return ['webkitTransitionEnd'];
  }

  if (util$4.vendorPrefix === 'webkit' || util$4.vendorPrefix === 'o' || util$4.vendorPrefix === 'moz' || util$4.vendorPrefix === 'ms') {
    return [util$4.vendorPrefix + 'TransitionEnd', 'transitionend'];
  }

  return [];
}();

util$4._cssPropertyDict = function () {
  var styles = window.getComputedStyle(document.documentElement, '');
  var dict = {};
  var a = 'A'.charCodeAt(0);
  var z = 'z'.charCodeAt(0);

  var upper = function upper(s) {
    return s.substr(1).toUpperCase();
  };

  for (var i = 0; i < styles.length; i++) {

    var key = styles[i].replace(/^[-]+/, '').replace(/[-][a-z]/g, upper).replace(/^moz/, 'Moz');

    if (a <= key.charCodeAt(0) && z >= key.charCodeAt(0)) {
      if (key !== 'cssText' && key !== 'parentText') {
        dict[key] = true;
      }
    }
  }

  return dict;
}();

util$4.hasCssProperty = function (name) {
  return name in util$4._cssPropertyDict;
};

/**
 * Vendor prefix for css property.
 */
util$4.vendorPrefix = function () {
  var styles = window.getComputedStyle(document.documentElement, ''),
      pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];
  return pre;
}();

util$4.forceLayoutAtOnce = function (elements, callback) {
  this.batchImmediate(function () {
    elements.forEach(function (element) {
      // force layout
      element.offsetHeight;
    });
    callback();
  });
};

util$4.batchImmediate = function () {
  var callbacks = [];

  return function (callback) {
    if (callbacks.length === 0) {
      setImmediate(function () {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function (callback) {
          callback();
        });
      });
    }

    callbacks.push(callback);
  };
}();

util$4.batchAnimationFrame = function () {
  var callbacks = [];

  var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
    setTimeout(callback, 1000 / 60);
  };

  return function (callback) {
    if (callbacks.length === 0) {
      raf(function () {
        var concreateCallbacks = callbacks.slice(0);
        callbacks = [];
        concreateCallbacks.forEach(function (callback) {
          callback();
        });
      });
    }

    callbacks.push(callback);
  };
}();

util$4.transitionPropertyName = function () {
  if (util$4.hasCssProperty('transitionDuration')) {
    return 'transition';
  }

  if (util$4.hasCssProperty(util$4.vendorPrefix + 'TransitionDuration')) {
    return util$4.vendorPrefix + 'Transition';
  }

  throw new Error('Invalid state');
}();

/**
 * @param {HTMLElement} element
 */
var Animit = function Animit(element, defaults) {
  if (!(this instanceof Animit)) {
    return new Animit(element, defaults);
  }

  if (element instanceof HTMLElement) {
    this.elements = [element];
  } else if (Object.prototype.toString.call(element) === '[object Array]') {
    this.elements = element;
  } else {
    throw new Error('First argument must be an array or an instance of HTMLElement.');
  }

  this.defaults = defaults;
  this.transitionQueue = [];
  this.lastStyleAttributeDict = [];
};

Animit.prototype = {

  /**
   * @property {Array}
   */
  transitionQueue: undefined,

  /**
   * @property {Array}
   */
  elements: undefined,

  /**
   * @property {Object}
   */
  defaults: undefined,

  /**
   * Start animation sequence with passed animations.
   *
   * @param {Function} callback
   */
  play: function play(callback) {
    if (typeof callback === 'function') {
      this.transitionQueue.push(function (done) {
        callback();
        done();
      });
    }

    this.startAnimation();

    return this;
  },

  /**
   * Most of the animations follow this default process.
   *
   * @param {from} css or options object containing css
   * @param {to} css or options object containing css
   * @param {delay} delay to wait
   */
  default: function _default(from, to, delay) {
    function step(params, duration, timing) {
      if (params.duration !== undefined) {
        duration = params.duration;
      }
      if (params.timing !== undefined) {
        timing = params.timing;
      }

      return {
        css: params.css || params,
        duration: duration,
        timing: timing
      };
    }

    return this.saveStyle().queue(step(from, 0, this.defaults.timing)).wait(delay === undefined ? this.defaults.delay : delay).queue(step(to, this.defaults.duration, this.defaults.timing)).restoreStyle();
  },

  /**
   * Queue transition animations or other function.
   *
   * e.g. animit(elt).queue({color: 'red'})
   * e.g. animit(elt).queue({color: 'red'}, {duration: 0.4})
   * e.g. animit(elt).queue({css: {color: 'red'}, duration: 0.2})
   *
   * @param {Object|Animit.Transition|Function} transition
   * @param {Object} [options]
   */
  queue: function queue(transition, options) {
    var queue = this.transitionQueue;

    if (transition && options) {
      options.css = transition;
      transition = new Animit.Transition(options);
    }

    if (!(transition instanceof Function || transition instanceof Animit.Transition)) {
      if (transition.css) {
        transition = new Animit.Transition(transition);
      } else {
        transition = new Animit.Transition({
          css: transition
        });
      }
    }

    if (transition instanceof Function) {
      queue.push(transition);
    } else if (transition instanceof Animit.Transition) {
      queue.push(transition.build());
    } else {
      throw new Error('Invalid arguments');
    }

    return this;
  },

  /**
   * Queue transition animations.
   *
   * @param {Float} seconds
   */
  wait: function wait(seconds) {
    if (seconds > 0) {
      this.transitionQueue.push(function (done) {
        setTimeout(done, 1000 * seconds);
      });
    }

    return this;
  },

  saveStyle: function saveStyle() {

    this.transitionQueue.push(function (done) {
      this.elements.forEach(function (element, index) {
        var css = this.lastStyleAttributeDict[index] = {};

        for (var i = 0; i < element.style.length; i++) {
          css[element.style[i]] = element.style[element.style[i]];
        }
      }.bind(this));
      done();
    }.bind(this));

    return this;
  },

  /**
   * Restore element's style.
   *
   * @param {Object} [options]
   * @param {Float} [options.duration]
   * @param {String} [options.timing]
   * @param {String} [options.transition]
   */
  restoreStyle: function restoreStyle(options) {
    options = options || {};
    var self = this;

    if (options.transition && !options.duration) {
      throw new Error('"options.duration" is required when "options.transition" is enabled.');
    }

    var transitionName = util$4.transitionPropertyName;

    if (options.transition || options.duration && options.duration > 0) {
      var transitionValue = options.transition || 'all ' + options.duration + 's ' + (options.timing || 'linear');

      this.transitionQueue.push(function (done) {
        var elements = this.elements;
        var timeoutId;

        var clearTransition = function clearTransition() {
          elements.forEach(function (element) {
            element.style[transitionName] = '';
          });
        };

        // add "transitionend" event handler
        var removeListeners = util$4.onceOnTransitionEnd(elements[0], function () {
          clearTimeout(timeoutId);
          clearTransition();
          done();
        });

        // for fail safe.
        timeoutId = setTimeout(function () {
          removeListeners();
          clearTransition();
          done();
        }, options.duration * 1000 * TIMEOUT_RATIO);

        // transition and style settings
        elements.forEach(function (element, index) {

          var css = self.lastStyleAttributeDict[index];

          if (!css) {
            throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
          }

          self.lastStyleAttributeDict[index] = undefined;

          var name;
          for (var i = 0, len = element.style.length; i < len; i++) {
            name = element.style[i];
            if (css[name] === undefined) {
              css[name] = '';
            }
          }

          element.style[transitionName] = transitionValue;

          Object.keys(css).forEach(function (key) {
            if (key !== transitionName) {
              element.style[key] = css[key];
            }
          });

          element.style[transitionName] = transitionValue;
        });
      });
    } else {
      this.transitionQueue.push(function (done) {
        reset();
        done();
      });
    }

    return this;

    function reset() {
      // Clear transition animation settings.
      self.elements.forEach(function (element, index) {
        element.style[transitionName] = 'none';

        var css = self.lastStyleAttributeDict[index];

        if (!css) {
          throw new Error('restoreStyle(): The style is not saved. Invoke saveStyle() before.');
        }

        self.lastStyleAttributeDict[index] = undefined;

        for (var i = 0, name = ''; i < element.style.length; i++) {
          name = element.style[i];
          if (typeof css[element.style[i]] === 'undefined') {
            css[element.style[i]] = '';
          }
        }

        Object.keys(css).forEach(function (key) {
          element.style[key] = css[key];
        });
      });
    }
  },

  /**
   * Start animation sequence.
   */
  startAnimation: function startAnimation() {
    this._dequeueTransition();

    return this;
  },

  _dequeueTransition: function _dequeueTransition() {
    var transition = this.transitionQueue.shift();
    if (this._currentTransition) {
      throw new Error('Current transition exists.');
    }
    this._currentTransition = transition;
    var self = this;
    var called = false;

    var done = function done() {
      if (!called) {
        called = true;
        self._currentTransition = undefined;
        self._dequeueTransition();
      } else {
        throw new Error('Invalid state: This callback is called twice.');
      }
    };

    if (transition) {
      transition.call(this, done);
    }
  }

};

/**
 * @param {Animit} arguments
 */
Animit.runAll = function () /* arguments... */{
  for (var i = 0; i < arguments.length; i++) {
    arguments[i].play();
  }
};

/**
 * @param {Object} options
 * @param {Float} [options.duration]
 * @param {String} [options.property]
 * @param {String} [options.timing]
 */
Animit.Transition = function (options) {
  this.options = options || {};
  this.options.duration = this.options.duration || 0;
  this.options.timing = this.options.timing || 'linear';
  this.options.css = this.options.css || {};
  this.options.property = this.options.property || 'all';
};

Animit.Transition.prototype = {

  /**
   * @param {HTMLElement} element
   * @return {Function}
   */
  build: function build() {

    if (Object.keys(this.options.css).length === 0) {
      throw new Error('options.css is required.');
    }

    var css = createActualCssProps(this.options.css);

    if (this.options.duration > 0) {
      var transitionValue = util$4.buildTransitionValue(this.options);
      var self = this;

      return function (callback) {
        var elements = this.elements;
        var timeout = self.options.duration * 1000 * TIMEOUT_RATIO;
        var timeoutId;

        var removeListeners = util$4.onceOnTransitionEnd(elements[0], function () {
          clearTimeout(timeoutId);
          callback();
        });

        timeoutId = setTimeout(function () {
          removeListeners();
          callback();
        }, timeout);

        elements.forEach(function (element) {
          element.style[util$4.transitionPropertyName] = transitionValue;

          Object.keys(css).forEach(function (name) {
            element.style[name] = css[name];
          });
        });
      };
    }

    if (this.options.duration <= 0) {
      return function (callback) {
        var elements = this.elements;

        elements.forEach(function (element) {
          element.style[util$4.transitionPropertyName] = '';

          Object.keys(css).forEach(function (name) {
            element.style[name] = css[name];
          });
        });

        if (elements.length > 0) {
          util$4.forceLayoutAtOnce(elements, function () {
            util$4.batchAnimationFrame(callback);
          });
        } else {
          util$4.batchAnimationFrame(callback);
        }
      };
    }

    function createActualCssProps(css) {
      var result = {};

      Object.keys(css).forEach(function (name) {
        var value = css[name];

        if (util$4.hasCssProperty(name)) {
          result[name] = value;
          return;
        }

        var prefixed = util$4.vendorPrefix + util$4.capitalize(name);
        if (util$4.hasCssProperty(prefixed)) {
          result[prefixed] = value;
        } else {
          result[prefixed] = value;
          result[name] = value;
        }
      });

      return result;
    }
  }
};

/*
 * Gesture detector library that forked from github.com/EightMedia/hammer.js.
 */

var Event$1;
var Utils;
var Detection;
var PointerEvent;

/**
 * @object ons.GestureDetector
 * @category gesture
 * @description
 *   [en]Utility class for gesture detection.[/en]
 *   [ja]ジェスチャを検知するためのユーティリティクラスです。[/ja]
 */

/**
 * @method constructor
 * @signature constructor(element[, options])
 * @description
 *  [en]Create a new GestureDetector instance.[/en]
 *  [ja]GestureDetectorのインスタンスを生成します。[/ja]
 * @param {Element} element
 *   [en]Name of the event.[/en]
 *   [ja]ジェスチャを検知するDOM要素を指定します。[/ja]
 * @param {Object} [options]
 *   [en]Options object.[/en]
 *   [ja]オプションを指定します。[/ja]
 * @return {ons.GestureDetector.Instance}
 */
var GestureDetector = function GestureDetector(element, options) {
  return new GestureDetector.Instance(element, options || {});
};

/**
 * default settings.
 * more settings are defined per gesture at `/gestures`. Each gesture can be disabled/enabled
 * by setting it's name (like `swipe`) to false.
 * You can set the defaults for all instances by changing this object before creating an instance.
 * @example
 * ````
 *  GestureDetector.defaults.drag = false;
 *  GestureDetector.defaults.behavior.touchAction = 'pan-y';
 *  delete GestureDetector.defaults.behavior.userSelect;
 * ````
 * @property defaults
 * @type {Object}
 */
GestureDetector.defaults = {
  behavior: {
    // userSelect: 'none', // Also disables selection in `input` children
    touchAction: 'pan-y',
    touchCallout: 'none',
    contentZooming: 'none',
    userDrag: 'none',
    tapHighlightColor: 'rgba(0,0,0,0)'
  }
};

/**
 * GestureDetector document where the base events are added at
 * @property DOCUMENT
 * @type {HTMLElement}
 * @default window.document
 */
GestureDetector.DOCUMENT = document;

/**
 * detect support for pointer events
 * @property HAS_POINTEREVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;

/**
 * detect support for touch events
 * @property HAS_TOUCHEVENTS
 * @type {Boolean}
 */
GestureDetector.HAS_TOUCHEVENTS = 'ontouchstart' in window;

/**
 * detect mobile browsers
 * @property IS_MOBILE
 * @type {Boolean}
 */
GestureDetector.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent);

/**
 * detect if we want to support mouseevents at all
 * @property NO_MOUSEEVENTS
 * @type {Boolean}
 */
GestureDetector.NO_MOUSEEVENTS = GestureDetector.HAS_TOUCHEVENTS && GestureDetector.IS_MOBILE || GestureDetector.HAS_POINTEREVENTS;

/**
 * interval in which GestureDetector recalculates current velocity/direction/angle in ms
 * @property CALCULATE_INTERVAL
 * @type {Number}
 * @default 25
 */
GestureDetector.CALCULATE_INTERVAL = 25;

/**
 * eventtypes per touchevent (start, move, end) are filled by `Event.determineEventTypes` on `setup`
 * the object contains the DOM event names per type (`EVENT_START`, `EVENT_MOVE`, `EVENT_END`)
 * @property EVENT_TYPES
 * @private
 * @writeOnce
 * @type {Object}
 */
var EVENT_TYPES = {};

/**
 * direction strings, for safe comparisons
 * @property DIRECTION_DOWN|LEFT|UP|RIGHT
 * @final
 * @type {String}
 * @default 'down' 'left' 'up' 'right'
 */
var DIRECTION_DOWN = GestureDetector.DIRECTION_DOWN = 'down';
var DIRECTION_LEFT = GestureDetector.DIRECTION_LEFT = 'left';
var DIRECTION_UP = GestureDetector.DIRECTION_UP = 'up';
var DIRECTION_RIGHT = GestureDetector.DIRECTION_RIGHT = 'right';

/**
 * pointertype strings, for safe comparisons
 * @property POINTER_MOUSE|TOUCH|PEN
 * @final
 * @type {String}
 * @default 'mouse' 'touch' 'pen'
 */
var POINTER_MOUSE = GestureDetector.POINTER_MOUSE = 'mouse';
var POINTER_TOUCH = GestureDetector.POINTER_TOUCH = 'touch';
var POINTER_PEN = GestureDetector.POINTER_PEN = 'pen';

/**
 * eventtypes
 * @property EVENT_START|MOVE|END|RELEASE|TOUCH
 * @final
 * @type {String}
 * @default 'start' 'change' 'move' 'end' 'release' 'touch'
 */
var EVENT_START = GestureDetector.EVENT_START = 'start';
var EVENT_MOVE = GestureDetector.EVENT_MOVE = 'move';
var EVENT_END = GestureDetector.EVENT_END = 'end';
var EVENT_RELEASE = GestureDetector.EVENT_RELEASE = 'release';
var EVENT_TOUCH = GestureDetector.EVENT_TOUCH = 'touch';

/**
 * if the window events are set...
 * @property READY
 * @writeOnce
 * @type {Boolean}
 * @default false
 */
GestureDetector.READY = false;

/**
 * plugins namespace
 * @property plugins
 * @type {Object}
 */
GestureDetector.plugins = GestureDetector.plugins || {};

/**
 * gestures namespace
 * see `/gestures` for the definitions
 * @property gestures
 * @type {Object}
 */
GestureDetector.gestures = GestureDetector.gestures || {};

/**
 * setup events to detect gestures on the document
 * this function is called when creating an new instance
 * @private
 */
function setup(opts) {
  if (GestureDetector.READY) {
    return;
  }

  // find what eventtypes we add listeners to
  Event$1.determineEventTypes();

  // Register all gestures inside GestureDetector.gestures
  Utils.each(GestureDetector.gestures, function (gesture) {
    Detection.register(gesture);
  });

  // Add touch events on the document
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_MOVE, Detection.detect, opts);
  Event$1.onTouch(GestureDetector.DOCUMENT, EVENT_END, Detection.detect, opts);

  // GestureDetector is ready...!
  GestureDetector.READY = true;
}

/**
 * @module GestureDetector
 *
 * @class Utils
 * @static
 */
Utils = GestureDetector.utils = {
  /**
   * extend method, could also be used for cloning when `dest` is an empty object.
   * changes the dest object
   * @param {Object} dest
   * @param {Object} src
   * @param {Boolean} [merge=false]  do a merge
   * @return {Object} dest
   */
  extend: function extend(dest, src, merge) {
    for (var key in src) {
      if (src.hasOwnProperty(key) && (dest[key] === undefined || !merge)) {
        dest[key] = src[key];
      }
    }
    return dest;
  },

  /**
   * simple addEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  on: function on(element, type, handler, opt) {
    util$1.addEventListener(element, type, handler, opt, true);
  },

  /**
   * simple removeEventListener wrapper
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   */
  off: function off(element, type, handler, opt) {
    util$1.removeEventListener(element, type, handler, opt, true);
  },

  /**
   * forEach over arrays and objects
   * @param {Object|Array} obj
   * @param {Function} iterator
   * @param {any} iterator.item
   * @param {Number} iterator.index
   * @param {Object|Array} iterator.obj the source object
   * @param {Object} context value to use as `this` in the iterator
   */
  each: function each(obj, iterator, context) {
    var i, len;

    // native forEach on arrays
    if ('forEach' in obj) {
      obj.forEach(iterator, context);
      // arrays
    } else if (obj.length !== undefined) {
      for (i = 0, len = obj.length; i < len; i++) {
        if (iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
      // objects
    } else {
      for (i in obj) {
        if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {
          return;
        }
      }
    }
  },

  /**
   * find if a string contains the string using indexOf
   * @param {String} src
   * @param {String} find
   * @return {Boolean} found
   */
  inStr: function inStr(src, find) {
    return src.indexOf(find) > -1;
  },

  /**
   * find if a array contains the object using indexOf or a simple polyfill
   * @param {String} src
   * @param {String} find
   * @return {Boolean|Number} false when not found, or the index
   */
  inArray: function inArray(src, find, deep) {
    if (deep) {
      for (var i = 0, len = src.length; i < len; i++) {
        // Array.findIndex
        if (Object.keys(find).every(function (key) {
          return src[i][key] === find[key];
        })) {
          return i;
        }
      }
      return -1;
    }

    if (src.indexOf) {
      return src.indexOf(find);
    } else {
      for (var i = 0, len = src.length; i < len; i++) {
        if (src[i] === find) {
          return i;
        }
      }
      return -1;
    }
  },

  /**
   * convert an array-like object (`arguments`, `touchlist`) to an array
   * @param {Object} obj
   * @return {Array}
   */
  toArray: function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
  },

  /**
   * find if a node is in the given parent
   * @param {HTMLElement} node
   * @param {HTMLElement} parent
   * @return {Boolean} found
   */
  hasParent: function hasParent(node, parent) {
    while (node) {
      if (node == parent) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  },

  /**
   * get the center of all the touches
   * @param {Array} touches
   * @return {Object} center contains `pageX`, `pageY`, `clientX` and `clientY` properties
   */
  getCenter: function getCenter(touches) {
    var pageX = [],
        pageY = [],
        clientX = [],
        clientY = [],
        min = Math.min,
        max = Math.max;

    // no need to loop when only one touch
    if (touches.length === 1) {
      return {
        pageX: touches[0].pageX,
        pageY: touches[0].pageY,
        clientX: touches[0].clientX,
        clientY: touches[0].clientY
      };
    }

    Utils.each(touches, function (touch) {
      pageX.push(touch.pageX);
      pageY.push(touch.pageY);
      clientX.push(touch.clientX);
      clientY.push(touch.clientY);
    });

    return {
      pageX: (min.apply(Math, pageX) + max.apply(Math, pageX)) / 2,
      pageY: (min.apply(Math, pageY) + max.apply(Math, pageY)) / 2,
      clientX: (min.apply(Math, clientX) + max.apply(Math, clientX)) / 2,
      clientY: (min.apply(Math, clientY) + max.apply(Math, clientY)) / 2
    };
  },

  /**
   * calculate the velocity between two points. unit is in px per ms.
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   * @return {Object} velocity `x` and `y`
   */
  getVelocity: function getVelocity(deltaTime, deltaX, deltaY) {
    return {
      x: Math.abs(deltaX / deltaTime) || 0,
      y: Math.abs(deltaY / deltaTime) || 0
    };
  },

  /**
   * calculate the angle between two coordinates
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {Number} angle
   */
  getAngle: function getAngle(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.atan2(y, x) * 180 / Math.PI;
  },

  /**
   * do a small comparison to get the direction between two touches.
   * @param {Touch} touch1
   * @param {Touch} touch2
   * @return {String} direction matches `DIRECTION_LEFT|RIGHT|UP|DOWN`
   */
  getDirection: function getDirection(touch1, touch2) {
    var x = Math.abs(touch1.clientX - touch2.clientX),
        y = Math.abs(touch1.clientY - touch2.clientY);

    if (x >= y) {
      return touch1.clientX - touch2.clientX > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return touch1.clientY - touch2.clientY > 0 ? DIRECTION_UP : DIRECTION_DOWN;
  },

  /**
   * calculate the distance between two touches
   * @param {Touch}touch1
   * @param {Touch} touch2
   * @return {Number} distance
   */
  getDistance: function getDistance(touch1, touch2) {
    var x = touch2.clientX - touch1.clientX,
        y = touch2.clientY - touch1.clientY;

    return Math.sqrt(x * x + y * y);
  },

  /**
   * calculate the scale factor between two touchLists
   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} scale
   */
  getScale: function getScale(start, end) {
    // need two fingers...
    if (start.length >= 2 && end.length >= 2) {
      return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);
    }
    return 1;
  },

  /**
   * calculate the rotation degrees between two touchLists
   * @param {Array} start array of touches
   * @param {Array} end array of touches
   * @return {Number} rotation
   */
  getRotation: function getRotation(start, end) {
    // need two fingers
    if (start.length >= 2 && end.length >= 2) {
      return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);
    }
    return 0;
  },

  /**
   * find out if the direction is vertical   *
   * @param {String} direction matches `DIRECTION_UP|DOWN`
   * @return {Boolean} is_vertical
   */
  isVertical: function isVertical(direction) {
    return direction == DIRECTION_UP || direction == DIRECTION_DOWN;
  },

  /**
   * set css properties with their prefixes
   * @param {HTMLElement} element
   * @param {String} prop
   * @param {String} value
   * @param {Boolean} [toggle=true]
   * @return {Boolean}
   */
  setPrefixedCss: function setPrefixedCss(element, prop, value, toggle) {
    var prefixes = ['', 'Webkit', 'Moz', 'O', 'ms'];
    prop = Utils.toCamelCase(prop);

    for (var i = 0; i < prefixes.length; i++) {
      var p = prop;
      // prefixes
      if (prefixes[i]) {
        p = prefixes[i] + p.slice(0, 1).toUpperCase() + p.slice(1);
      }

      // test the style
      if (p in element.style) {
        element.style[p] = (toggle === null || toggle) && value || '';
        break;
      }
    }
  },

  /**
   * toggle browser default behavior by setting css properties.
   * `userSelect='none'` also sets `element.onselectstart` to false
   * `userDrag='none'` also sets `element.ondragstart` to false
   *
   * @param {HtmlElement} element
   * @param {Object} props
   * @param {Boolean} [toggle=true]
   */
  toggleBehavior: function toggleBehavior(element, props, toggle) {
    if (!props || !element || !element.style) {
      return;
    }

    // set the css properties
    Utils.each(props, function (value, prop) {
      Utils.setPrefixedCss(element, prop, value, toggle);
    });

    var falseFn = toggle && function () {
      return false;
    };

    // also the disable onselectstart
    if (props.userSelect == 'none') {
      element.onselectstart = falseFn;
    }
    // and disable ondragstart
    if (props.userDrag == 'none') {
      element.ondragstart = falseFn;
    }
  },

  /**
   * convert a string with underscores to camelCase
   * so prevent_default becomes preventDefault
   * @param {String} str
   * @return {String} camelCaseStr
   */
  toCamelCase: function toCamelCase(str) {
    return str.replace(/[_-]([a-z])/g, function (s) {
      return s[1].toUpperCase();
    });
  }
};

/**
 * @module GestureDetector
 */
/**
 * @class Event
 * @static
 */
Event$1 = GestureDetector.event = {
  /**
   * when touch events have been fired, this is true
   * this is used to stop mouse events
   * @property prevent_mouseevents
   * @private
   * @type {Boolean}
   */
  preventMouseEvents: false,

  /**
   * if EVENT_START has been fired
   * @property started
   * @private
   * @type {Boolean}
   */
  started: false,

  /**
   * when the mouse is hold down, this is true
   * @property should_detect
   * @private
   * @type {Boolean}
   */
  shouldDetect: false,

  /**
   * simple event binder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Object} [opt]
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  on: function on(element, type, handler, opt, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.on(element, type, handler, opt);
      hook && hook(type);
    });
  },

  /**
   * simple event unbinder with a hook and support for multiple types
   * @param {HTMLElement} element
   * @param {String} type
   * @param {Function} handler
   * @param {Object} [opt]
   * @param {Function} [hook]
   * @param {Object} hook.type
   */
  off: function off(element, type, handler, opt, hook) {
    var types = type.split(' ');
    Utils.each(types, function (type) {
      Utils.off(element, type, handler, opt);
      hook && hook(type);
    });
  },

  /**
   * the core touch event handler.
   * this finds out if we should to detect gestures
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Function} handler
   * @return onTouchHandler {Function} the core event handler
   */
  onTouch: function onTouch(element, eventType, handler, opt) {
    var self = this;

    var onTouchHandler = function onTouchHandler(ev) {
      var srcType = ev.type.toLowerCase(),
          isPointer = GestureDetector.HAS_POINTEREVENTS,
          isMouse = Utils.inStr(srcType, 'mouse'),
          triggerType;

      // if we are in a mouseevent, but there has been a touchevent triggered in this session
      // we want to do nothing. simply break out of the event.
      if (isMouse && self.preventMouseEvents) {
        return;

        // mousebutton must be down
      } else if (isMouse && eventType == EVENT_START && ev.button === 0) {
        self.preventMouseEvents = false;
        self.shouldDetect = true;
      } else if (isPointer && eventType == EVENT_START) {
        self.shouldDetect = ev.buttons === 1 || PointerEvent.matchType(POINTER_TOUCH, ev);
        // just a valid start event, but no mouse
      } else if (!isMouse && eventType == EVENT_START) {
        self.preventMouseEvents = true;
        self.shouldDetect = true;
      }

      // update the pointer event before entering the detection
      if (isPointer && eventType != EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }

      // we are in a touch/down state, so allowed detection of gestures
      if (self.shouldDetect) {
        triggerType = self.doDetect.call(self, ev, eventType, element, handler);
      }

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      if (triggerType == EVENT_END) {
        self.preventMouseEvents = false;
        self.shouldDetect = false;
        PointerEvent.reset();
        // update the pointerevent object after the detection
      }

      if (isPointer && eventType == EVENT_END) {
        PointerEvent.updatePointer(eventType, ev);
      }
    };

    this.on(element, EVENT_TYPES[eventType], onTouchHandler, opt);
    return onTouchHandler;
  },

  /**
   * the core detection method
   * this finds out what GestureDetector-touch-events to trigger
   * @param {Object} ev
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {HTMLElement} element
   * @param {Function} handler
   * @return {String} triggerType matches `EVENT_START|MOVE|END`
   */
  doDetect: function doDetect(ev, eventType, element, handler) {
    var touchList = this.getTouchList(ev, eventType);
    var touchListLength = touchList.length;
    var triggerType = eventType;
    var triggerChange = touchList.trigger; // used by fakeMultitouch plugin
    var changedLength = touchListLength;

    // at each touchstart-like event we want also want to trigger a TOUCH event...
    if (eventType == EVENT_START) {
      triggerChange = EVENT_TOUCH;
      // ...the same for a touchend-like event
    } else if (eventType == EVENT_END) {
      triggerChange = EVENT_RELEASE;

      // keep track of how many touches have been removed
      changedLength = touchList.length - (ev.changedTouches ? ev.changedTouches.length : 1);
    }

    // after there are still touches on the screen,
    // we just want to trigger a MOVE event. so change the START or END to a MOVE
    // but only after detection has been started, the first time we actually want a START
    if (changedLength > 0 && this.started) {
      triggerType = EVENT_MOVE;
    }

    // detection has been started, we keep track of this, see above
    this.started = true;

    // generate some event data, some basic information
    var evData = this.collectEventData(element, triggerType, touchList, ev);

    // trigger the triggerType event before the change (TOUCH, RELEASE) events
    // but the END event should be at last
    if (eventType != EVENT_END) {
      handler.call(Detection, evData);
    }

    // trigger a change (TOUCH, RELEASE) event, this means the length of the touches changed
    if (triggerChange) {
      evData.changedLength = changedLength;
      evData.eventType = triggerChange;

      handler.call(Detection, evData);

      evData.eventType = triggerType;
      delete evData.changedLength;
    }

    // trigger the END event
    if (triggerType == EVENT_END) {
      handler.call(Detection, evData);

      // ...and we are done with the detection
      // so reset everything to start each detection totally fresh
      this.started = false;
    }

    return triggerType;
  },

  /**
   * we have different events for each device/browser
   * determine what we need and set them in the EVENT_TYPES constant
   * the `onTouch` method is bind to these properties.
   * @return {Object} events
   */
  determineEventTypes: function determineEventTypes() {
    var types;
    if (GestureDetector.HAS_POINTEREVENTS) {
      if (window.PointerEvent) {
        types = ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'];
      } else {
        types = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'];
      }
    } else if (GestureDetector.NO_MOUSEEVENTS) {
      types = ['touchstart', 'touchmove', 'touchend touchcancel'];
    } else {
      types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];
    }

    EVENT_TYPES[EVENT_START] = types[0];
    EVENT_TYPES[EVENT_MOVE] = types[1];
    EVENT_TYPES[EVENT_END] = types[2];
    return EVENT_TYPES;
  },

  /**
   * create touchList depending on the event
   * @param {Object} ev
   * @param {String} eventType
   * @return {Array} touches
   */
  getTouchList: function getTouchList(ev, eventType) {
    // get the fake pointerEvent touchlist
    if (GestureDetector.HAS_POINTEREVENTS) {
      return PointerEvent.getTouchList();
    }

    // get the touchlist
    if (ev.touches) {
      if (eventType == EVENT_MOVE) {
        return ev.touches;
      }

      var identifiers = [];
      var concat = [].concat(Utils.toArray(ev.touches), Utils.toArray(ev.changedTouches));
      var touchList = [];

      Utils.each(concat, function (touch) {
        if (Utils.inArray(identifiers, touch.identifier) === -1) {
          touchList.push(touch);
        }
        identifiers.push(touch.identifier);
      });

      return touchList;
    }

    // make fake touchList from mouse position
    ev.identifier = 1;
    return [ev];
  },

  /**
   * collect basic event data
   * @param {HTMLElement} element
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Array} touches
   * @param {Object} ev
   * @return {Object} ev
   */
  collectEventData: function collectEventData(element, eventType, touches, ev) {
    // find out pointerType
    var pointerType = POINTER_TOUCH;
    if (Utils.inStr(ev.type, 'mouse') || PointerEvent.matchType(POINTER_MOUSE, ev)) {
      pointerType = POINTER_MOUSE;
    } else if (PointerEvent.matchType(POINTER_PEN, ev)) {
      pointerType = POINTER_PEN;
    }

    return {
      center: Utils.getCenter(touches),
      timeStamp: Date.now(),
      target: ev.target,
      touches: touches,
      eventType: eventType,
      pointerType: pointerType,
      srcEvent: ev,

      /**
       * prevent the browser default actions
       * mostly used to disable scrolling of the browser
       */
      preventDefault: function preventDefault() {
        var srcEvent = this.srcEvent;
        srcEvent.preventManipulation && srcEvent.preventManipulation();
        srcEvent.preventDefault && srcEvent.preventDefault();
      },

      /**
       * stop bubbling the event up to its parents
       */
      stopPropagation: function stopPropagation() {
        this.srcEvent.stopPropagation();
      },

      /**
       * immediately stop gesture detection
       * might be useful after a swipe was detected
       * @return {*}
       */
      stopDetect: function stopDetect() {
        return Detection.stopDetect();
      }
    };
  }
};

/**
 * @module GestureDetector
 *
 * @class PointerEvent
 * @static
 */
PointerEvent = GestureDetector.PointerEvent = {
  /**
   * holds all pointers, by `identifier`
   * @property pointers
   * @type {Object}
   */
  pointers: {},

  /**
   * get the pointers as an array
   * @return {Array} touchlist
   */
  getTouchList: function getTouchList() {
    var touchlist = [];
    // we can use forEach since pointerEvents only is in IE10
    Utils.each(this.pointers, function (pointer) {
      touchlist.push(pointer);
    });
    return touchlist;
  },

  /**
   * update the position of a pointer
   * @param {String} eventType matches `EVENT_START|MOVE|END`
   * @param {Object} pointerEvent
   */
  updatePointer: function updatePointer(eventType, pointerEvent) {
    if (eventType == EVENT_END || eventType != EVENT_END && pointerEvent.buttons !== 1) {
      delete this.pointers[pointerEvent.pointerId];
    } else {
      pointerEvent.identifier = pointerEvent.pointerId;
      this.pointers[pointerEvent.pointerId] = pointerEvent;
    }
  },

  /**
   * check if ev matches pointertype
   * @param {String} pointerType matches `POINTER_MOUSE|TOUCH|PEN`
   * @param {PointerEvent} ev
   */
  matchType: function matchType(pointerType, ev) {
    if (!ev.pointerType) {
      return false;
    }

    var pt = ev.pointerType,
        types = {};

    types[POINTER_MOUSE] = pt === (ev.MSPOINTER_TYPE_MOUSE || POINTER_MOUSE);
    types[POINTER_TOUCH] = pt === (ev.MSPOINTER_TYPE_TOUCH || POINTER_TOUCH);
    types[POINTER_PEN] = pt === (ev.MSPOINTER_TYPE_PEN || POINTER_PEN);
    return types[pointerType];
  },

  /**
   * reset the stored pointers
   */
  reset: function resetList() {
    this.pointers = {};
  }
};

/**
 * @module GestureDetector
 *
 * @class Detection
 * @static
 */
Detection = GestureDetector.detection = {
  // contains all registered GestureDetector.gestures in the correct order
  gestures: [],

  // data of the current GestureDetector.gesture detection session
  current: null,

  // the previous GestureDetector.gesture session data
  // is a full clone of the previous gesture.current object
  previous: null,

  // when this becomes true, no gestures are fired
  stopped: false,

  /**
   * start GestureDetector.gesture detection
   * @param {GestureDetector.Instance} inst
   * @param {Object} eventData
   */
  startDetect: function startDetect(inst, eventData) {
    // already busy with a GestureDetector.gesture detection on an element
    if (this.current) {
      return;
    }

    this.stopped = false;

    // holds current session
    this.current = {
      inst: inst, // reference to GestureDetectorInstance we're working for
      startEvent: Utils.extend({}, eventData), // start eventData for distances, timing etc
      lastEvent: false, // last eventData
      lastCalcEvent: false, // last eventData for calculations.
      futureCalcEvent: false, // last eventData for calculations.
      lastCalcData: {}, // last lastCalcData
      name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
    };

    this.detect(eventData);
  },

  /**
   * GestureDetector.gesture detection
   * @param {Object} eventData
   * @return {any}
   */
  detect: function detect(eventData) {
    if (!this.current || this.stopped) {
      return;
    }

    // extend event data with calculations about scale, distance etc
    eventData = this.extendEventData(eventData);

    // GestureDetector instance and instance options
    var inst = this.current.inst,
        instOptions = inst.options;

    // call GestureDetector.gesture handlers
    Utils.each(this.gestures, function triggerGesture(gesture) {
      // only when the instance options have enabled this gesture
      if (!this.stopped && inst.enabled && instOptions[gesture.name]) {
        gesture.handler.call(gesture, eventData, inst);
      }
    }, this);

    // store as previous event event
    if (this.current) {
      this.current.lastEvent = eventData;
    }

    if (eventData.eventType == EVENT_END) {
      this.stopDetect();
    }

    return eventData; // eslint-disable-line consistent-return
  },

  /**
   * clear the GestureDetector.gesture vars
   * this is called on endDetect, but can also be used when a final GestureDetector.gesture has been detected
   * to stop other GestureDetector.gestures from being fired
   */
  stopDetect: function stopDetect() {
    // clone current data to the store as the previous gesture
    // used for the double tap gesture, since this is an other gesture detect session
    this.previous = Utils.extend({}, this.current);

    // reset the current
    this.current = null;
    this.stopped = true;
  },

  /**
   * calculate velocity, angle and direction
   * @param {Object} ev
   * @param {Object} center
   * @param {Number} deltaTime
   * @param {Number} deltaX
   * @param {Number} deltaY
   */
  getCalculatedData: function getCalculatedData(ev, center, deltaTime, deltaX, deltaY) {
    var cur = this.current,
        recalc = false,
        calcEv = cur.lastCalcEvent,
        calcData = cur.lastCalcData;

    if (calcEv && ev.timeStamp - calcEv.timeStamp > GestureDetector.CALCULATE_INTERVAL) {
      center = calcEv.center;
      deltaTime = ev.timeStamp - calcEv.timeStamp;
      deltaX = ev.center.clientX - calcEv.center.clientX;
      deltaY = ev.center.clientY - calcEv.center.clientY;
      recalc = true;
    }

    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      cur.futureCalcEvent = ev;
    }

    if (!cur.lastCalcEvent || recalc) {
      calcData.velocity = Utils.getVelocity(deltaTime, deltaX, deltaY);
      calcData.angle = Utils.getAngle(center, ev.center);
      calcData.direction = Utils.getDirection(center, ev.center);

      cur.lastCalcEvent = cur.futureCalcEvent || ev;
      cur.futureCalcEvent = ev;
    }

    ev.velocityX = calcData.velocity.x;
    ev.velocityY = calcData.velocity.y;
    ev.interimAngle = calcData.angle;
    ev.interimDirection = calcData.direction;
  },

  /**
   * extend eventData for GestureDetector.gestures
   * @param {Object} ev
   * @return {Object} ev
   */
  extendEventData: function extendEventData(ev) {
    var cur = this.current,
        startEv = cur.startEvent,
        lastEv = cur.lastEvent || startEv;

    // update the start touchlist to calculate the scale/rotation
    if (ev.eventType == EVENT_TOUCH || ev.eventType == EVENT_RELEASE) {
      startEv.touches = [];
      Utils.each(ev.touches, function (touch) {
        startEv.touches.push({
          clientX: touch.clientX,
          clientY: touch.clientY
        });
      });
    }

    var deltaTime = ev.timeStamp - startEv.timeStamp,
        deltaX = ev.center.clientX - startEv.center.clientX,
        deltaY = ev.center.clientY - startEv.center.clientY;

    this.getCalculatedData(ev, lastEv.center, deltaTime, deltaX, deltaY);

    Utils.extend(ev, {
      startEvent: startEv,

      deltaTime: deltaTime,
      deltaX: deltaX,
      deltaY: deltaY,

      distance: Utils.getDistance(startEv.center, ev.center),
      angle: Utils.getAngle(startEv.center, ev.center),
      direction: Utils.getDirection(startEv.center, ev.center),
      scale: Utils.getScale(startEv.touches, ev.touches),
      rotation: Utils.getRotation(startEv.touches, ev.touches)
    });

    return ev;
  },

  /**
   * register new gesture
   * @param {Object} gesture object, see `gestures/` for documentation
   * @return {Array} gestures
   */
  register: function register(gesture) {
    // add an enable gesture options if there is no given
    var options = gesture.defaults || {};
    if (options[gesture.name] === undefined) {
      options[gesture.name] = true;
    }

    // extend GestureDetector default options with the GestureDetector.gesture options
    Utils.extend(GestureDetector.defaults, options, true);

    // set its index
    gesture.index = gesture.index || 1000;

    // add GestureDetector.gesture to the list
    this.gestures.push(gesture);

    // sort the list by index
    this.gestures.sort(function (a, b) {
      if (a.index < b.index) {
        return -1;
      }
      if (a.index > b.index) {
        return 1;
      }
      return 0;
    });

    return this.gestures;
  }
};

/**
 * @module GestureDetector
 */

/**
 * create new GestureDetector instance
 * all methods should return the instance itself, so it is chainable.
 *
 * @class Instance
 * @constructor
 * @param {HTMLElement} element
 * @param {Object} [options={}] options are merged with `GestureDetector.defaults`
 * @return {GestureDetector.Instance}
 */
GestureDetector.Instance = function (element, options) {
  var self = this;
  var listenerOptions = options && options.passive ? { passive: true } : undefined;

  // setup GestureDetectorJS window events and register all gestures
  // this also sets up the default options
  setup(listenerOptions);

  /**
   * @property element
   * @type {HTMLElement}
   */
  this.element = element;

  /**
   * @property enabled
   * @type {Boolean}
   * @protected
   */
  this.enabled = true;

  /**
   * options, merged with the defaults
   * options with an _ are converted to camelCase
   * @property options
   * @type {Object}
   */
  Utils.each(options, function (value, name) {
    delete options[name];
    options[Utils.toCamelCase(name)] = value;
  });

  this.options = Utils.extend(Utils.extend({}, GestureDetector.defaults), options || {});
  this.options.listenerOptions = listenerOptions;

  // add some css to the element to prevent the browser from doing its native behavior
  if (this.options.behavior) {
    Utils.toggleBehavior(this.element, this.options.behavior, true);
  }

  /**
   * event start handler on the element to start the detection
   * @property eventStartHandler
   * @type {Object}
   */
  this.eventStartHandler = Event$1.onTouch(element, EVENT_START, function (ev) {
    if (self.enabled && ev.eventType == EVENT_START) {
      Detection.startDetect(self, ev);
    } else if (ev.eventType == EVENT_TOUCH) {
      Detection.detect(ev);
    }
  }, listenerOptions);

  /**
   * keep a list of user event handlers which needs to be removed when calling 'dispose'
   * @property eventHandlers
   * @type {Array}
   */
  this.eventHandlers = [];
};

GestureDetector.Instance.prototype = {
  /**
   * @method on
   * @signature on(gestures, handler)
   * @description
   *  [en]Adds an event handler for a gesture. Available gestures are: drag, dragleft, dragright, dragup, dragdown, hold, release, swipe, swipeleft, swiperight, swipeup, swipedown, tap, doubletap, touch, transform, pinch, pinchin, pinchout and rotate. [/en]
   *  [ja]ジェスチャに対するイベントハンドラを追加します。指定できるジェスチャ名は、drag dragleft dragright dragup dragdown hold release swipe swipeleft swiperight swipeup swipedown tap doubletap touch transform pinch pinchin pinchout rotate です。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]検知するジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  on: function onEvent(gestures, handler, opt) {
    var self = this;

    Event$1.on(self.element, gestures, handler, util$1.extend({}, self.options.listenerOptions, opt), function (type) {
      self.eventHandlers.push({ gesture: type, handler: handler });
    });
    return self;
  },

  /**
   * @method off
   * @signature off(gestures, handler)
   * @description
   *  [en]Remove an event listener.[/en]
   *  [ja]イベントリスナーを削除します。[/ja]
   * @param {String} gestures
   *   [en]A space separated list of gestures.[/en]
   *   [ja]ジェスチャ名を指定します。スペースで複数指定することができます。[/ja]
   * @param {Function} handler
   *   [en]An event handling function.[/en]
   *   [ja]イベントハンドラとなる関数オブジェクトを指定します。[/ja]
   */
  off: function offEvent(gestures, handler, opt) {
    var self = this;

    Event$1.off(self.element, gestures, handler, util$1.extend({}, self.options.listenerOptions, opt), function (type) {
      var index = Utils.inArray(self.eventHandlers, { gesture: type, handler: handler }, true);
      if (index >= 0) {
        self.eventHandlers.splice(index, 1);
      }
    });
    return self;
  },

  /**
   * trigger gesture event
   * @method trigger
   * @signature trigger(gesture, eventData)
   * @param {String} gesture
   * @param {Object} [eventData]
   */
  trigger: function triggerEvent(gesture, eventData) {
    // optional
    if (!eventData) {
      eventData = {};
    }

    // create DOM event
    var event = GestureDetector.DOCUMENT.createEvent('Event');
    event.initEvent(gesture, true, true);
    event.gesture = eventData;

    // trigger on the target if it is in the instance element,
    // this is for event delegation tricks
    var element = this.element;
    if (Utils.hasParent(eventData.target, element)) {
      element = eventData.target;
    }

    element.dispatchEvent(event);
    return this;
  },

  /**
   * @method enable
   * @signature enable(state)
   * @description
   *  [en]Enable or disable gesture detection.[/en]
   *  [ja]ジェスチャ検知を有効化/無効化します。[/ja]
   * @param {Boolean} state
   *   [en]Specify if it should be enabled or not.[/en]
   *   [ja]有効にするかどうかを指定します。[/ja]
   */
  enable: function enable(state) {
    this.enabled = state;
    return this;
  },

  /**
   * @method dispose
   * @signature dispose()
   * @description
   *  [en]Remove and destroy all event handlers for this instance.[/en]
   *  [ja]このインスタンスでのジェスチャの検知や、イベントハンドラを全て解除して廃棄します。[/ja]
   */
  dispose: function dispose() {
    var i, eh;

    // undo all changes made by stop_browser_behavior
    Utils.toggleBehavior(this.element, this.options.behavior, false);

    // unbind all custom event handlers
    for (i = -1; eh = this.eventHandlers[++i];) {
      // eslint-disable-line no-cond-assign
      Utils.off(this.element, eh.gesture, eh.handler);
    }

    this.eventHandlers = [];

    // unbind the start event listener
    Event$1.off(this.element, EVENT_TYPES[EVENT_START], this.eventStartHandler);

    return null;
  }
};

/**
 * @module gestures
 */
/**
 * Move with x fingers (default 1) around on the page.
 * Preventing the default browser behavior is a good way to improve feel and working.
 * ````
 *  GestureDetectortime.on("drag", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Drag
 * @static
 */
/**
 * @event drag
 * @param {Object} ev
 */
/**
 * @event dragstart
 * @param {Object} ev
 */
/**
 * @event dragend
 * @param {Object} ev
 */
/**
 * @event drapleft
 * @param {Object} ev
 */
/**
 * @event dragright
 * @param {Object} ev
 */
/**
 * @event dragup
 * @param {Object} ev
 */
/**
 * @event dragdown
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function dragGesture(ev, inst) {
    var cur = Detection.current;

    // max touches
    if (inst.options.dragMaxTouches > 0 && ev.touches.length > inst.options.dragMaxTouches) {
      return;
    }

    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (ev.distance < inst.options.dragMinDistance && cur.name != name) {
          return;
        }

        var startCenter = cur.startEvent.center;

        // we are dragging!
        if (cur.name != name) {
          cur.name = name;
          if (inst.options.dragDistanceCorrection && ev.distance > 0) {
            // When a drag is triggered, set the event center to dragMinDistance pixels from the original event center.
            // Without this correction, the dragged distance would jumpstart at dragMinDistance pixels instead of at 0.
            // It might be useful to save the original start point somewhere
            var factor = Math.abs(inst.options.dragMinDistance / ev.distance);
            startCenter.pageX += ev.deltaX * factor;
            startCenter.pageY += ev.deltaY * factor;
            startCenter.clientX += ev.deltaX * factor;
            startCenter.clientY += ev.deltaY * factor;

            // recalculate event data using new start point
            ev = Detection.extendEventData(ev);
          }
        }

        // lock drag to axis?
        if (cur.lastEvent.dragLockToAxis || inst.options.dragLockToAxis && inst.options.dragLockMinDistance <= ev.distance) {
          ev.dragLockToAxis = true;
        }

        // keep direction on the axis that the drag gesture started on
        var lastDirection = cur.lastEvent.direction;
        if (ev.dragLockToAxis && lastDirection !== ev.direction) {
          if (Utils.isVertical(lastDirection)) {
            ev.direction = ev.deltaY < 0 ? DIRECTION_UP : DIRECTION_DOWN;
          } else {
            ev.direction = ev.deltaX < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
        }

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        // trigger events
        inst.trigger(name, ev);
        inst.trigger(name + ev.direction, ev);

        var isVertical = Utils.isVertical(ev.direction);

        // block the browser events
        if (inst.options.dragBlockVertical && isVertical || inst.options.dragBlockHorizontal && !isVertical) {
          ev.preventDefault();
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength <= inst.options.dragMaxTouches) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;

      case EVENT_END:
        triggered = false;
        break;
    }
  }

  GestureDetector.gestures.Drag = {
    name: name,
    index: 50,
    handler: dragGesture,
    defaults: {
      /**
       * minimal movement that have to be made before the drag event gets triggered
       * @property dragMinDistance
       * @type {Number}
       * @default 10
       */
      dragMinDistance: 10,

      /**
       * Set dragDistanceCorrection to true to make the starting point of the drag
       * be calculated from where the drag was triggered, not from where the touch started.
       * Useful to avoid a jerk-starting drag, which can make fine-adjustments
       * through dragging difficult, and be visually unappealing.
       * @property dragDistanceCorrection
       * @type {Boolean}
       * @default true
       */
      dragDistanceCorrection: true,

      /**
       * set 0 for unlimited, but this can conflict with transform
       * @property dragMaxTouches
       * @type {Number}
       * @default 1
       */
      dragMaxTouches: 1,

      /**
       * prevent default browser behavior when dragging occurs
       * be careful with it, it makes the element a blocking element
       * when you are using the drag gesture, it is a good practice to set this true
       * @property dragBlockHorizontal
       * @type {Boolean}
       * @default false
       */
      dragBlockHorizontal: false,

      /**
       * same as `dragBlockHorizontal`, but for vertical movement
       * @property dragBlockVertical
       * @type {Boolean}
       * @default false
       */
      dragBlockVertical: false,

      /**
       * dragLockToAxis keeps the drag gesture on the axis that it started on,
       * It disallows vertical directions if the initial direction was horizontal, and vice versa.
       * @property dragLockToAxis
       * @type {Boolean}
       * @default false
       */
      dragLockToAxis: false,

      /**
       * drag lock only kicks in when distance > dragLockMinDistance
       * This way, locking occurs only when the distance has become large enough to reliably determine the direction
       * @property dragLockMinDistance
       * @type {Number}
       * @default 25
       */
      dragLockMinDistance: 25
    }
  };
})('drag');

/**
 * @module gestures
 */
/**
 * trigger a simple gesture event, so you can do anything in your handler.
 * only usable if you know what your doing...
 *
 * @class Gesture
 * @static
 */
/**
 * @event gesture
 * @param {Object} ev
 */
GestureDetector.gestures.Gesture = {
  name: 'gesture',
  index: 1337,
  handler: function releaseGesture(ev, inst) {
    inst.trigger(this.name, ev);
  }
};

/**
 * @module gestures
 */
/**
 * Touch stays at the same place for x time
 *
 * @class Hold
 * @static
 */
/**
 * @event hold
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var timer;

  function holdGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current;

    switch (ev.eventType) {
      case EVENT_START:
        clearTimeout(timer);

        // set the gesture so we can check in the timeout if it still is
        current.name = name;

        // set timer and if after the timeout it still is hold,
        // we trigger the hold event
        timer = setTimeout(function () {
          if (current && current.name == name) {
            inst.trigger(name, ev);
          }
        }, options.holdTimeout);
        break;

      case EVENT_MOVE:
        if (ev.distance > options.holdThreshold) {
          clearTimeout(timer);
        }
        break;

      case EVENT_RELEASE:
        clearTimeout(timer);
        break;
    }
  }

  GestureDetector.gestures.Hold = {
    name: name,
    index: 10,
    defaults: {
      /**
       * @property holdTimeout
       * @type {Number}
       * @default 500
       */
      holdTimeout: 500,

      /**
       * movement allowed while holding
       * @property holdThreshold
       * @type {Number}
       * @default 2
       */
      holdThreshold: 2
    },
    handler: holdGesture
  };
})('hold');

/**
 * @module gestures
 */
/**
 * when a touch is being released from the page
 *
 * @class Release
 * @static
 */
/**
 * @event release
 * @param {Object} ev
 */
GestureDetector.gestures.Release = {
  name: 'release',
  index: Infinity,
  handler: function releaseGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      inst.trigger(this.name, ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * triggers swipe events when the end velocity is above the threshold
 * for best usage, set `preventDefault` (on the drag gesture) to `true`
 * ````
 *  GestureDetectortime.on("dragleft swipeleft", function(ev) {
 *    console.log(ev);
 *    ev.gesture.preventDefault();
 *  });
 * ````
 *
 * @class Swipe
 * @static
 */
/**
 * @event swipe
 * @param {Object} ev
 */
/**
 * @event swipeleft
 * @param {Object} ev
 */
/**
 * @event swiperight
 * @param {Object} ev
 */
/**
 * @event swipeup
 * @param {Object} ev
 */
/**
 * @event swipedown
 * @param {Object} ev
 */
GestureDetector.gestures.Swipe = {
  name: 'swipe',
  index: 40,
  defaults: {
    /**
     * @property swipeMinTouches
     * @type {Number}
     * @default 1
     */
    swipeMinTouches: 1,

    /**
     * @property swipeMaxTouches
     * @type {Number}
     * @default 1
     */
    swipeMaxTouches: 1,

    /**
     * horizontal swipe velocity
     * @property swipeVelocityX
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityX: 0.6,

    /**
     * vertical swipe velocity
     * @property swipeVelocityY
     * @type {Number}
     * @default 0.6
     */
    swipeVelocityY: 0.6
  },

  handler: function swipeGesture(ev, inst) {
    if (ev.eventType == EVENT_RELEASE) {
      var touches = ev.touches.length,
          options = inst.options;

      // max touches
      if (touches < options.swipeMinTouches || touches > options.swipeMaxTouches) {
        return;
      }

      // when the distance we moved is too small we skip this gesture
      // or we can be already in dragging
      if (ev.velocityX > options.swipeVelocityX || ev.velocityY > options.swipeVelocityY) {
        // trigger swipe events
        inst.trigger(this.name, ev);
        inst.trigger(this.name + ev.direction, ev);
      }
    }
  }
};

/**
 * @module gestures
 */
/**
 * Single tap and a double tap on a place
 *
 * @class Tap
 * @static
 */
/**
 * @event tap
 * @param {Object} ev
 */
/**
 * @event doubletap
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var hasMoved = false;

  function tapGesture(ev, inst) {
    var options = inst.options,
        current = Detection.current,
        prev = Detection.previous,
        sincePrev,
        didDoubleTap;

    switch (ev.eventType) {
      case EVENT_START:
        hasMoved = false;
        break;

      case EVENT_MOVE:
        hasMoved = hasMoved || ev.distance > options.tapMaxDistance;
        break;

      case EVENT_END:
        if (!Utils.inStr(ev.srcEvent.type, 'cancel') && ev.deltaTime < options.tapMaxTime && !hasMoved) {
          // previous gesture, for the double tap since these are two different gesture detections
          sincePrev = prev && prev.lastEvent && ev.timeStamp - prev.lastEvent.timeStamp;
          didDoubleTap = false;

          // check if double tap
          if (prev && prev.name == name && sincePrev && sincePrev < options.doubleTapInterval && ev.distance < options.doubleTapDistance) {
            inst.trigger('doubletap', ev);
            didDoubleTap = true;
          }

          // do a single tap
          if (!didDoubleTap || options.tapAlways) {
            current.name = name;
            inst.trigger(current.name, ev);
          }
        }
        break;
    }
  }

  GestureDetector.gestures.Tap = {
    name: name,
    index: 100,
    handler: tapGesture,
    defaults: {
      /**
       * max time of a tap, this is for the slow tappers
       * @property tapMaxTime
       * @type {Number}
       * @default 250
       */
      tapMaxTime: 250,

      /**
       * max distance of movement of a tap, this is for the slow tappers
       * @property tapMaxDistance
       * @type {Number}
       * @default 10
       */
      tapMaxDistance: 10,

      /**
       * always trigger the `tap` event, even while double-tapping
       * @property tapAlways
       * @type {Boolean}
       * @default true
       */
      tapAlways: true,

      /**
       * max distance between two taps
       * @property doubleTapDistance
       * @type {Number}
       * @default 20
       */
      doubleTapDistance: 20,

      /**
       * max time between two taps
       * @property doubleTapInterval
       * @type {Number}
       * @default 300
       */
      doubleTapInterval: 300
    }
  };
})('tap');

/**
 * @module gestures
 */
/**
 * when a touch is being touched at the page
 *
 * @class Touch
 * @static
 */
/**
 * @event touch
 * @param {Object} ev
 */
GestureDetector.gestures.Touch = {
  name: 'touch',
  index: -Infinity,
  defaults: {
    /**
     * call preventDefault at touchstart, and makes the element blocking by disabling the scrolling of the page,
     * but it improves gestures like transforming and dragging.
     * be careful with using this, it can be very annoying for users to be stuck on the page
     * @property preventDefault
     * @type {Boolean}
     * @default false
     */
    preventDefault: false,

    /**
     * disable mouse events, so only touch (or pen!) input triggers events
     * @property preventMouse
     * @type {Boolean}
     * @default false
     */
    preventMouse: false
  },
  handler: function touchGesture(ev, inst) {
    if (inst.options.preventMouse && ev.pointerType == POINTER_MOUSE) {
      ev.stopDetect();
      return;
    }

    if (inst.options.preventDefault) {
      ev.preventDefault();
    }

    if (ev.eventType == EVENT_TOUCH) {
      inst.trigger('touch', ev);
    }
  }
};

/**
 * @module gestures
 */
/**
 * User want to scale or rotate with 2 fingers
 * Preventing the default browser behavior is a good way to improve feel and working. This can be done with the
 * `preventDefault` option.
 *
 * @class Transform
 * @static
 */
/**
 * @event transform
 * @param {Object} ev
 */
/**
 * @event transformstart
 * @param {Object} ev
 */
/**
 * @event transformend
 * @param {Object} ev
 */
/**
 * @event pinchin
 * @param {Object} ev
 */
/**
 * @event pinchout
 * @param {Object} ev
 */
/**
 * @event rotate
 * @param {Object} ev
 */

/**
 * @param {String} name
 */
(function (name) {
  var triggered = false;

  function transformGesture(ev, inst) {
    switch (ev.eventType) {
      case EVENT_START:
        triggered = false;
        break;

      case EVENT_MOVE:
        // at least multitouch
        if (ev.touches.length < 2) {
          return;
        }

        var scaleThreshold = Math.abs(1 - ev.scale);
        var rotationThreshold = Math.abs(ev.rotation);

        // when the distance we moved is too small we skip this gesture
        // or we can be already in dragging
        if (scaleThreshold < inst.options.transformMinScale && rotationThreshold < inst.options.transformMinRotation) {
          return;
        }

        // we are transforming!
        Detection.current.name = name;

        // first time, trigger dragstart event
        if (!triggered) {
          inst.trigger(name + 'start', ev);
          triggered = true;
        }

        inst.trigger(name, ev); // basic transform event

        // trigger rotate event
        if (rotationThreshold > inst.options.transformMinRotation) {
          inst.trigger('rotate', ev);
        }

        // trigger pinch event
        if (scaleThreshold > inst.options.transformMinScale) {
          inst.trigger('pinch', ev);
          inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);
        }
        break;

      case EVENT_RELEASE:
        if (triggered && ev.changedLength < 2) {
          inst.trigger(name + 'end', ev);
          triggered = false;
        }
        break;
    }
  }

  GestureDetector.gestures.Transform = {
    name: name,
    index: 45,
    defaults: {
      /**
       * minimal scale factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
       * @property transformMinScale
       * @type {Number}
       * @default 0.01
       */
      transformMinScale: 0.01,

      /**
       * rotation in degrees
       * @property transformMinRotation
       * @type {Number}
       * @default 1
       */
      transformMinRotation: 1
    },

    handler: transformGesture
  };
})('transform');

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var readyMap = void 0;
var queueMap = void 0;

function isContentReady(element) {
  if (element.childNodes.length > 0) {
    setContentReady(element);
  }
  return readyMap.has(element);
}

function setContentReady(element) {
  readyMap.set(element, true);
}

function addCallback(element, fn) {
  if (!queueMap.has(element)) {
    queueMap.set(element, []);
  }
  queueMap.get(element).push(fn);
}

function consumeQueue(element) {
  var callbacks = queueMap.get(element, []) || [];
  queueMap.delete(element);
  callbacks.forEach(function (callback) {
    return callback();
  });
}

function contentReady(element) {
  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};

  if (readyMap === undefined) {
    readyMap = new WeakMap();
    queueMap = new WeakMap();
  }

  addCallback(element, fn);

  if (isContentReady(element)) {
    consumeQueue(element);
    return;
  }

  var observer = new MutationObserver(function (changes) {
    setContentReady(element);
    consumeQueue(element);
  });
  observer.observe(element, { childList: true, characterData: true });

  // failback for elements has empty content.
  setImmediate(function () {
    setContentReady(element);
    consumeQueue(element);
  });
}

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ToastQueue = function () {
  function ToastQueue() {
    classCallCheck(this, ToastQueue);

    this.queue = [];
  }

  createClass(ToastQueue, [{
    key: "add",
    value: function add(fn, promise) {
      var _this = this;

      this.queue.push(fn);

      if (this.queue.length === 1) {
        setImmediate(this.queue[0]);
      }

      promise.then(function () {
        _this.queue.shift();

        if (_this.queue.length > 0) {
          setTimeout(_this.queue[0], 1000 / 30); // Apply some visual delay
        }
      });
    }
  }]);
  return ToastQueue;
}();

var ToastQueue$1 = new ToastQueue();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _setAttributes = function _setAttributes(element, options) {
  ['id', 'class', 'animation'].forEach(function (a) {
    return options.hasOwnProperty(a) && element.setAttribute(a, options[a]);
  });

  if (options.modifier) {
    util$1.addModifier(element, options.modifier);
  }
};

var _normalizeArguments = function _normalizeArguments(message) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var defaults$$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  options = _extends({}, options);
  typeof message === 'string' ? options.message = message : options = message;
  if (!options || !options.message && !options.messageHTML) {
    util$1.throw('Notifications must contain a message');
  }

  if (options.hasOwnProperty('buttonLabels') || options.hasOwnProperty('buttonLabel')) {
    options.buttonLabels = options.buttonLabels || options.buttonLabel;
    if (!Array.isArray(options.buttonLabels)) {
      options.buttonLabels = [options.buttonLabels || ''];
    }
  }

  return util$1.extend({
    compile: function compile(param) {
      return param;
    },
    callback: function callback(param) {
      return param;
    },
    animation: 'default',
    cancelable: false,
    primaryButtonIndex: (options.buttonLabels || defaults$$1.buttonLabels || []).length - 1
  }, defaults$$1, options);
};

/**
 * @object ons.notification
 * @category dialog
 * @tutorial vanilla/Reference/notification
 * @description
 *   [en]
 *     Utility methods to create different kinds of notifications. There are three methods available:
 *
 *     * `ons.notification.alert()`
 *     * `ons.notification.confirm()`
 *     * `ons.notification.prompt()`
 *     * `ons.notification.toast()`
 *
 *     It will automatically display a Material Design dialog on Android devices.
 *   [/en]
 *   [ja]いくつかの種類のアラートダイアログを作成するためのユーティリティメソッドを収めたオブジェクトです。[/ja]
 * @example
 * ons.notification.alert('Hello, world!');
 *
 * ons.notification.confirm('Are you ready?')
 *   .then(
 *     function(answer) {
 *       if (answer === 1) {
 *         ons.notification.alert('Let\'s go!');
 *       }
 *     }
 *   );
 *
 * ons.notification.prompt('How old are ?')
 *   .then(
 *     function(age) {
 *       ons.notification.alert('You are ' + age + ' years old.');
 *     }
 *   );
 */
var notification = {};

notification._createAlertDialog = function () {
  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return new Promise(function (resolve) {
    var options = _normalizeArguments.apply(undefined, params);
    util$1.checkMissingImport('AlertDialog', 'AlertDialogButton');

    // Prompt input string
    var inputString = '';
    if (options.isPrompt) {
      inputString = '\n      <input\n        class="text-input text-input--underbar"\n        type="' + (options.inputType || 'text') + '"\n        placeholder="' + (options.placeholder || '') + '"\n        value="' + (options.defaultValue || '') + '"\n        style="width: 100%; margin-top: 10px;"\n      />\n    ';
    }

    // Buttons string
    var buttons = '';
    options.buttonLabels.forEach(function (label, index) {
      buttons += '\n      <ons-alert-dialog-button\n        class="\n          ' + (index === options.primaryButtonIndex ? ' alert-dialog-button--primal' : '') + '\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-button--rowfooter' : '') + '\n        "\n        style="position: relative;">\n        ' + label + '\n      </ons-alert-dialog-button>\n    ';
    });

    // Dialog Element
    var el = {};
    var _destroyDialog = function _destroyDialog() {
      if (el.dialog.onDialogCancel) {
        el.dialog.removeEventListener('dialog-cancel', el.dialog.onDialogCancel);
      }

      Object.keys(el).forEach(function (key) {
        return delete el[key];
      });
      el = null;

      if (options.destroy instanceof Function) {
        options.destroy();
      }
    };

    el.dialog = document.createElement('ons-alert-dialog');
    el.dialog.innerHTML = '\n    <div class="alert-dialog-mask"\n      style="\n        ' + (options.maskColor ? 'background-color: ' + options.maskColor : '') + '\n      "></div>\n    <div class="alert-dialog">\n      <div class="alert-dialog-container">\n        <div class="alert-dialog-title">\n          ' + (options.title || '') + '\n        </div>\n        <div class="alert-dialog-content">\n          ' + (options.message || options.messageHTML) + '\n          ' + inputString + '\n        </div>\n        <div class="\n          alert-dialog-footer\n          ' + (options.buttonLabels.length <= 2 ? ' alert-dialog-footer--rowfooter' : '') + '\n        ">\n          ' + buttons + '\n        </div>\n      </div>\n    </div>\n  ';
    contentReady(el.dialog);

    // Set attributes
    _setAttributes(el.dialog, options);

    // Prompt events
    if (options.isPrompt && options.submitOnEnter) {
      el.input = el.dialog.querySelector('.text-input');
      el.input.onkeypress = function (event) {
        if (event.keyCode === 13) {
          el.dialog.hide().then(function () {
            if (el) {
              var resolveValue = el.input.value;
              _destroyDialog();
              options.callback(resolveValue);
              resolve(resolveValue);
            }
          });
        }
      };
    }

    // Button events
    el.footer = el.dialog.querySelector('.alert-dialog-footer');
    util$1.arrayFrom(el.dialog.querySelectorAll('.alert-dialog-button')).forEach(function (buttonElement, index) {
      buttonElement.onclick = function () {
        el.dialog.hide().then(function () {
          if (el) {
            var resolveValue = index;
            if (options.isPrompt) {
              resolveValue = index === options.primaryButtonIndex ? el.input.value : null;
            }
            el.dialog.remove();
            _destroyDialog();
            options.callback(resolveValue);
            resolve(resolveValue);
          }
        });
      };

      el.footer.appendChild(buttonElement);
    });

    // Cancel events
    if (options.cancelable) {
      el.dialog.cancelable = true;
      el.dialog.onDialogCancel = function () {
        setImmediate(function () {
          el.dialog.remove();
          _destroyDialog();
        });
        var resolveValue = options.isPrompt ? null : -1;
        options.callback(resolveValue);
        resolve(resolveValue);
      };
      el.dialog.addEventListener('dialog-cancel', el.dialog.onDialogCancel, false);
    }

    // Show dialog
    document.body.appendChild(el.dialog);
    options.compile(el.dialog);
    setImmediate(function () {
      el.dialog.show().then(function () {
        if (el.input && options.isPrompt && options.autofocus) {
          var strLength = el.input.value.length;
          el.input.focus();
          el.input.setSelectionRange(strLength, strLength);
        }
      });
    });
  });
};

/**
 * @method alert
 * @signature alert(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve to the index of the button that was pressed or `-1` when canceled.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String} [options.message]
 *   [en]Notification message.[/en]
 *   [ja]アラートダイアログに表示する文字列を指定します。[/ja]
 * @param {String} [options.messageHTML]
 *   [en]Notification message in HTML.[/en]
 *   [ja]アラートダイアログに表示するHTMLを指定します。[/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is the last one.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
 * @param {Boolean} [options.cancelable]
 *   [en]Whether the dialog is cancelable or not. Default is `false`. If the dialog is cancelable it can be closed by clicking the background or pressing the Android back button.[/en]
 *   [ja]ダイアログがキャンセル可能かどうかを指定します。[/ja]
 * @param {String} [options.animation]
 *   [en]Animation name. Available animations are `none` and `fade`. Default is `fade`.[/en]
 *   [ja]アラートダイアログを表示する際のアニメーション名を指定します。"none", "fade"のいずれかを指定できます。[/ja]
 * @param {String} [options.id]
 *   [en]The `<ons-alert-dialog>` element's ID.[/en]
 *   [ja]ons-alert-dialog要素のID。[/ja]
 * @param {String} [options.class]
 *   [en]The `<ons-alert-dialog>` element's class.[/en]
 *   [ja]ons-alert-dialog要素のclass。[/ja]
 * @param {String} [options.title]
 *   [en]Dialog title. Default is `"Alert"`.[/en]
 *   [ja]アラートダイアログの上部に表示するタイトルを指定します。"Alert"がデフォルトです。[/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier for the dialog.[/en]
 *   [ja]アラートダイアログのmodifier属性の値を指定します。[/ja]
 * @param {String} [options.maskColor]
 *   [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)" ("rgba(0, 0, 0, 0.3)" for Material).[/en]
 *   [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
 * @param {Function} [options.callback]
 *   [en]Function that executes after dialog has been closed.[/en]
 *   [ja]アラートダイアログが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]
 *     Display an alert dialog to show the user a message.
 *
 *     The content of the message can be either simple text or HTML.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.alert(message, options);
 *     ons.notification.alert(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザーへメッセージを見せるためのアラートダイアログを表示します。
 *     表示するメッセージは、テキストかもしくはHTMLを指定できます。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.alert = function (message, options) {
  return notification._createAlertDialog(message, options, {
    buttonLabels: ['OK'],
    title: 'Alert'
  });
};

/**
 * @method confirm
 * @signature confirm(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve to the index of the button that was pressed or `-1` when canceled.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 * @param {Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `["Cancel", "OK"]`.[/en]
 *   [ja]ボタンのラベルの配列を指定します。["Cancel", "OK"]がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is the last one.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 1 です。[/ja]
 * @description
 *   [en]
 *     Display a dialog to ask the user for confirmation. Extends `alert()` parameters.
 *     The default button labels are `"Cancel"` and `"OK"` but they can be customized.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.confirm(message, options);
 *     ons.notification.confirm(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザに確認を促すダイアログを表示します。
 *     デオルとのボタンラベルは、"Cancel"と"OK"ですが、これはこのメソッドの引数でカスタマイズできます。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.confirm = function (message, options) {
  return notification._createAlertDialog(message, options, {
    buttonLabels: ['Cancel', 'OK'],
    title: 'Confirm'
  });
};

/**
 * @method prompt
 * @signature prompt(message [, options] | options)
 * @param {String} message
 *   [en]Notification message. This argument is optional but if it's not defined either `options.message` or `options.messageHTML` must be defined instead.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Will resolve to the input value when the dialog is closed or `null` when canceled.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String | Array} [options.buttonLabels]
 *   [en]Labels for the buttons. Default is `"OK"`.[/en]
 *   [ja]確認ボタンのラベルを指定します。"OK"がデフォルトです。[/ja]
 * @param {Number} [options.primaryButtonIndex]
 *   [en]Index of primary button. Default is the last one.[/en]
 *   [ja]プライマリボタンのインデックスを指定します。デフォルトは 0 です。[/ja]
 * @param {String} [options.placeholder]
 *   [en]Placeholder for the text input.[/en]
 *   [ja]テキスト欄のプレースホルダに表示するテキストを指定します。[/ja]
 * @param {String} [options.defaultValue]
 *   [en]Default value for the text input.[/en]
 *   [ja]テキスト欄のデフォルトの値を指定します。[/ja]
 * @param {String} [options.inputType]
 *   [en]Type of the input element (`password`, `date`...). Default is `text`.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.autofocus]
 *   [en]Autofocus the input element. Default is `true`. In Cordova, `KeyboardDisplayRequiresUserAction` in `config.xml` must be `false` to activate this feature.[/en]
 *   [ja]input要素に自動的にフォーカスするかどうかを指定します。デフォルトはtrueです。Cordova環境では、この機能を有効にするためには `config.xml` で `KeyboardDisplayRequiresUserAction` を `false` に設定する必要があります。[/ja]
 * @param {Boolean} [options.submitOnEnter]
 *   [en]Submit automatically when enter is pressed. Default is `true`.[/en]
 *   [ja]Enterが押された際にそのformをsubmitするかどうかを指定します。デフォルトはtrueです。[/ja]
 * @description
 *   [en]
 *     Display a dialog with a prompt to ask the user a question. Extends `alert()` parameters.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.prompt(message, options);
 *     ons.notification.prompt(options);
 *     ```
 *
 *     Must specify either `message` or `messageHTML`.
 *   [/en]
 *   [ja]
 *     ユーザーに入力を促すダイアログを表示します。
 *     このメソッドの引数には、options.messageもしくはoptions.messageHTMLのどちらかを必ず指定する必要があります。
 *   [/ja]
 */
notification.prompt = function (message, options) {
  return notification._createAlertDialog(message, options, {
    buttonLabels: ['OK'],
    title: 'Alert',
    isPrompt: true,
    autofocus: true,
    submitOnEnter: true
  });
};

/**
 * @method toast
 * @signature toast(message [, options] | options)
 * @return {Promise}
 *   [en]Will resolve when the toast is hidden.[/en]
 *   [ja][/ja]
 * @param {String} message
 *   [en]Toast message. This argument is optional but if it's not defined then `options.message` must be defined instead.[/en]
 *   [ja][/ja]
 * @param {Object} options
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクトです。[/ja]
 * @param {String} [options.message]
 *   [en]Notification message.[/en]
 *   [ja]トーストに表示する文字列を指定します。[/ja]
 * @param {String} [options.buttonLabel]
 *   [en]Label for the button.[/en]
 *   [ja]確認ボタンのラベルを指定します。[/ja]
 * @param {String} [options.animation]
 *   [en]Animation name. Available animations are `none`, `fade`, `ascend`, `lift` and `fall`. Default is `ascend` for Android and `lift` for iOS.[/en]
 *   [ja]トーストを表示する際のアニメーション名を指定します。"none", "fade", "ascend", "lift", "fall"のいずれかを指定できます。[/ja]
 * @param {Number} [options.timeout]
 *   [en]Number of miliseconds where the toast is visible before hiding automatically.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.force]
 *   [en]If `true`, the toast skips the notification queue and is shown immediately. Defaults to `false`.[/en]
 *   [ja][/ja]
 * @param {String} [options.id]
 *   [en]The `<ons-toast>` element's ID.[/en]
 *   [ja]ons-toast要素のID。[/ja]
 * @param {String} [options.class]
 *   [en]The `<ons-toast>` element's class.[/en]
 *   [ja]ons-toast要素のclass。[/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier for the element.[/en]
 *   [ja]トーストのmodifier属性の値を指定します。[/ja]
 * @param {Function} [options.callback]
 *   [en]Function that executes after toast has been hidden.[/en]
 *   [ja]トーストが閉じられた時に呼び出される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]
 *     Display a simple notification toast with an optional button that can be used for simple actions.
 *
 *     It can be called in the following ways:
 *
 *     ```
 *     ons.notification.toast(message, options);
 *     ons.notification.toast(options);
 *     ```
 *   [/en]
 *   [ja][/ja]
 */
notification.toast = function (message, options) {
  var promise = new Promise(function (resolve) {
    util$1.checkMissingImport('Toast'); // Throws error, must be inside promise

    options = _normalizeArguments(message, options, {
      timeout: 0,
      force: false
    });

    var toast = util$1.createElement('\n      <ons-toast>\n        ' + options.message + '\n        ' + (options.buttonLabels ? '<button>' + options.buttonLabels[0] + '</button>' : '') + '\n      </ons-toast>\n    ');

    _setAttributes(toast, options);

    var finish = function finish(value) {
      if (toast) {
        toast.hide().then(function () {
          if (toast) {
            toast.remove();
            toast = null;
            options.callback(value);
            resolve(value);
          }
        });
      }
    };

    if (options.buttonLabels) {
      util$1.findChild(toast._toast, 'button').onclick = function () {
        return finish(0);
      };
    }

    document.body.appendChild(toast);
    options.compile(toast);

    var show = function show() {
      toast.parentElement && toast.show(options).then(function () {
        if (options.timeout) {
          setTimeout(function () {
            return finish(-1);
          }, options.timeout);
        }
      });
    };

    setImmediate(function () {
      return options.force ? show() : ToastQueue$1.add(show, promise);
    });
  });

  return promise;
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

// Validate parameters
var checkOptions = function checkOptions(options) {
  var err = function err(prop) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Function';
    return util$1.throw('"options.' + prop + '" must be an instance of ' + type);
  };
  var hasOwnProperty = function hasOwnProperty(prop) {
    return Object.hasOwnProperty.call(options, prop);
  };
  var instanceOf = function instanceOf(prop) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Function;
    return options[prop] instanceof type;
  };

  var b = 'buttons',
      cb = 'callback',
      c = 'compile',
      d = 'destroy';
  (!hasOwnProperty(b) || !instanceOf(b, Array)) && err(b, 'Array');
  hasOwnProperty(cb) && !instanceOf(cb) && err(cb);
  hasOwnProperty(c) && !instanceOf(c) && err(c);
  hasOwnProperty(d) && !instanceOf(d) && err(d);
};

// Action Sheet
var actionSheet = (function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new Promise(function (resolve) {
    util$1.checkMissingImport('ActionSheet');
    checkOptions(options);

    // Main component
    var actionSheet = util$1.createElement('\n    <ons-action-sheet\n      ' + (options.title ? 'title="' + options.title + '"' : '') + '\n      ' + (options.cancelable ? 'cancelable' : '') + '\n      ' + (options.modifier ? 'modifier="' + options.modifier + '"' : '') + '\n      ' + (options.maskColor ? 'mask-color="' + options.maskColor + '"' : '') + '\n      ' + (options.id ? 'id="' + options.id + '"' : '') + '\n      ' + (options.class ? 'class="' + options.class + '"' : '') + '\n    >\n      <div class="action-sheet"></div>\n    </ons-action-sheet>\n  ');

    // Resolve action and clean up
    var finish = function finish(event) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

      if (actionSheet) {
        options.destroy && options.destroy(actionSheet);

        actionSheet.removeEventListener('dialog-cancel', finish, false);
        actionSheet.remove();
        actionSheet = null;

        options.callback && options.callback(index);
        resolve(index);
      }
    };

    // Link cancel handler
    actionSheet.addEventListener('dialog-cancel', finish, false);

    // Create buttons and link action handler
    var buttons = document.createDocumentFragment();
    options.buttons.forEach(function (item, index) {
      var buttonOptions = typeof item === 'string' ? { label: item } : _extends({}, item);
      if (options.destructive === index) {
        buttonOptions.modifier = (buttonOptions.modifier || '') + ' destructive';
      }

      var button = util$1.createElement('\n      <ons-action-sheet-button\n        ' + (buttonOptions.icon ? 'icon="' + buttonOptions.icon + '"' : '') + '\n        ' + (buttonOptions.modifier ? 'modifier="' + buttonOptions.modifier + '"' : '') + '\n      >\n        ' + buttonOptions.label + '\n      </ons-action-sheet-button>\n    ');

      button.onclick = function (event) {
        return actionSheet.hide().then(function () {
          return finish(event, index);
        });
      };
      buttons.appendChild(button);
    });

    // Finish component and attach
    util$1.findChild(actionSheet, '.action-sheet').appendChild(buttons);
    document.body.appendChild(actionSheet);
    options.compile && options.compile(el.dialog);

    // Show
    setImmediate(function () {
      return actionSheet.show({
        animation: options.animation,
        animationOptions: options.animationOptions
      });
    });
  });
});

/**
 * MicroEvent - to make any js object an event emitter (server or browser)
 *
 * - pure javascript - server compatible, browser compatible
 * - dont rely on the browser doms
 * - super simple - you get it immediately, no mystery, no magic involved
 *
 * - create a MicroEventDebug with goodies to debug
 *   - make it safer to use
*/

/** NOTE: This library is customized for Onsen UI. */

var MicroEvent = function MicroEvent() {};
MicroEvent.prototype = {
  on: function on(event, fct) {
    this._events = this._events || {};
    this._events[event] = this._events[event] || [];
    this._events[event].push(fct);
  },
  once: function once(event, fct) {
    var self = this;
    var wrapper = function wrapper() {
      self.off(event, wrapper);
      return fct.apply(null, arguments);
    };
    this.on(event, wrapper);
  },
  off: function off(event, fct) {
    this._events = this._events || {};
    if (event in this._events === false) {
      return;
    }

    this._events[event] = this._events[event].filter(function (_fct) {
      if (fct) {
        return fct !== _fct;
      } else {
        return false;
      }
    });
  },
  emit: function emit(event /* , args... */) {
    this._events = this._events || {};
    if (event in this._events === false) {
      return;
    }
    for (var i = 0; i < this._events[event].length; i++) {
      this._events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/**
 * mixin will delegate all MicroEvent.js function in the destination object
 *
 * - require('MicroEvent').mixin(Foobar) will make Foobar able to use MicroEvent
 *
 * @param {Object} the object which will support MicroEvent
*/
MicroEvent.mixin = function (destObject) {
  var props = ['on', 'once', 'off', 'emit'];
  for (var i = 0; i < props.length; i++) {
    if (typeof destObject === 'function') {
      destObject.prototype[props[i]] = MicroEvent.prototype[props[i]];
    } else {
      destObject[props[i]] = MicroEvent.prototype[props[i]];
    }
  }
};

window.MicroEvent = MicroEvent;

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var create = function create() {

  /**
   * @object ons.orientation
   * @category util
   * @description
   *   [en]Utility methods for orientation detection.[/en]
   *   [ja]画面のオリエンテーション検知のためのユーティリティメソッドを収めているオブジェクトです。[/ja]
   */
  var obj = {
    /**
     * @event change
     * @description
     *   [en]Fired when the device orientation changes.[/en]
     *   [ja]デバイスのオリエンテーションが変化した際に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクトです。[/ja]
     * @param {Boolean} event.isPortrait
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]現在のオリエンテーションがportraitの場合にtrueを返します。[/ja]
     */

    /**
     * @method on
     * @signature on(eventName, listener)
     * @description
     *   [en]Add an event listener.[/en]
     *   [ja]イベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]このイベントが発火された際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @method once
     * @signature once(eventName, listener)
     * @description
     *  [en]Add an event listener that's only triggered once.[/en]
     *  [ja]一度だけ呼び出されるイベントリスナーを追加します。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]イベントが発火した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

    /**
     * @method off
     * @signature off(eventName, [listener])
     * @description
     *  [en]Remove an event listener. If the listener is not specified all listeners for the event type will be removed.[/en]
     *  [ja]イベントリスナーを削除します。もしイベントリスナーを指定しなかった場合には、そのイベントに紐づく全てのイベントリスナーが削除されます。[/ja]
     * @param {String} eventName
     *   [en]Name of the event.[/en]
     *   [ja]イベント名を指定します。[/ja]
     * @param {Function} listener
     *   [en]Function to execute when the event is triggered.[/en]
     *   [ja]削除するイベントリスナーを指定します。[/ja]
     */

    // actual implementation to detect if whether current screen is portrait or not
    _isPortrait: false,

    /**
     * @method isPortrait
     * @signature isPortrait()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is portrait mode.[/en]
     *   [ja]オリエンテーションがportraitモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is portrait or not.[/en]
     *   [ja]オリエンテーションがportraitモードかどうかを返します。[/ja]
     */
    isPortrait: function isPortrait() {
      return this._isPortrait();
    },

    /**
     * @method isLandscape
     * @signature isLandscape()
     * @return {Boolean}
     *   [en]Will be true if the current orientation is landscape mode.[/en]
     *   [ja]オリエンテーションがlandscapeモードの場合にtrueになります。[/ja]
     * @description
     *   [en]Returns whether the current screen orientation is landscape or not.[/en]
     *   [ja]オリエンテーションがlandscapeモードかどうかを返します。[/ja]
     */
    isLandscape: function isLandscape() {
      return !this.isPortrait();
    },

    _init: function _init() {
      document.addEventListener('DOMContentLoaded', this._onDOMContentLoaded.bind(this), false);

      if ('orientation' in window) {
        window.addEventListener('orientationchange', this._onOrientationChange.bind(this), false);
      } else {
        window.addEventListener('resize', this._onResize.bind(this), false);
      }

      this._isPortrait = function () {
        return window.innerHeight > window.innerWidth;
      };

      return this;
    },

    _onDOMContentLoaded: function _onDOMContentLoaded() {
      this._installIsPortraitImplementation();
      this.emit('change', { isPortrait: this.isPortrait() });
    },

    _installIsPortraitImplementation: function _installIsPortraitImplementation() {
      var isPortrait = window.innerWidth < window.innerHeight;

      if (!('orientation' in window)) {
        this._isPortrait = function () {
          return window.innerHeight > window.innerWidth;
        };
      } else if (window.orientation % 180 === 0) {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 0 ? isPortrait : !isPortrait;
        };
      } else {
        this._isPortrait = function () {
          return Math.abs(window.orientation % 180) === 90 ? isPortrait : !isPortrait;
        };
      }
    },

    _onOrientationChange: function _onOrientationChange() {
      var _this = this;

      var isPortrait = this._isPortrait();

      // Wait for the dimensions to change because
      // of Android inconsistency.
      var nIter = 0;
      var interval = setInterval(function () {
        nIter++;

        var w = window.innerWidth;
        var h = window.innerHeight;

        if (isPortrait && w <= h || !isPortrait && w >= h) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        } else if (nIter === 50) {
          _this.emit('change', { isPortrait: isPortrait });
          clearInterval(interval);
        }
      }, 20);
    },

    // Run on not mobile browser.
    _onResize: function _onResize() {
      this.emit('change', { isPortrait: this.isPortrait() });
    }
  };

  MicroEvent.mixin(obj);

  return obj;
};

var orientation = create()._init();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons.modifier
 * @category visual
 * @description
 *   [en]
 *     Utility methods to change modifier attributes of Onsen UI elements..
 *   [/en]
 *   [ja][/ja]
 * @example
 * ons.modifier.add(myOnsInputElement, 'underbar');
 * ons.modifier.toggle(myOnsToastElement, 'custom-modifier');
 *
 */
var modifier = {
  /**
   * @method add
   * @signature add(element, modifier [, modifier])
   * @description
   *   [en]Add the specified modifiers to the element if they are not already included.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   */
  add: function add(element) {
    for (var _len = arguments.length, modifiers = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      modifiers[_key - 1] = arguments[_key];
    }

    return modifiers.forEach(function (modifier) {
      return util$1.addModifier(element, modifier);
    });
  },
  /**
   * @method remove
   * @signature remove(element, modifier [, modifier])
   * @description
   *   [en]Remove the specified modifiers from the element if they are included.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   */
  remove: function remove(element) {
    for (var _len2 = arguments.length, modifiers = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      modifiers[_key2 - 1] = arguments[_key2];
    }

    return modifiers.forEach(function (modifier) {
      return util$1.removeModifier(element, modifier);
    });
  },
  /**
   * @method contains
   * @signature contains(element, modifier)
   * @description
   *   [en]Check whether the specified modifier is included in the element.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   * @return {Boolean}
   *   [en]`true` when the specified modifier is found in the element's `modifier` attribute. `false` otherwise.[/en]
   *   [ja][/ja]
   */
  contains: util$1.hasModifier,
  /**
   * @method toggle
   * @signature toggle(element, modifier [, force])
   * @description
   *   [en]Toggle the specified modifier.[/en]
   *   [ja][/ja]
   * @param {HTMLElement} element
   *   [en]Target element.[/en]
   *   [ja][/ja]
   * @param {String} modifier
   *   [en]Name of the modifier.[/en]
   *   [ja][/ja]
   * @param {String} force
   *   [en]If it evaluates to true, add specified modifier value, and if it evaluates to false, remove it.[/en]
   *   [ja][/ja]
   */
  toggle: util$1.toggleModifier
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var softwareKeyboard = new MicroEvent();
softwareKeyboard._visible = false;

var onShow = function onShow() {
  softwareKeyboard._visible = true;
  softwareKeyboard.emit('show');
};

var onHide = function onHide() {
  softwareKeyboard._visible = false;
  softwareKeyboard.emit('hide');
};

var bindEvents = function bindEvents() {
  if (typeof Keyboard !== 'undefined') {
    // https://github.com/martinmose/cordova-keyboard/blob/95f3da3a38d8f8e1fa41fbf40145352c13535a00/README.md
    Keyboard.onshow = onShow;
    Keyboard.onhide = onHide;
    softwareKeyboard.emit('init', { visible: Keyboard.isVisible });

    return true;
  } else if (typeof cordova.plugins !== 'undefined' && typeof cordova.plugins.Keyboard !== 'undefined') {
    // https://github.com/driftyco/ionic-plugins-keyboard/blob/ca27ecf/README.md
    window.addEventListener('native.keyboardshow', onShow);
    window.addEventListener('native.keyboardhide', onHide);
    softwareKeyboard.emit('init', { visible: cordova.plugins.Keyboard.isVisible });

    return true;
  }

  return false;
};

var noPluginError = function noPluginError() {
  util$1.warn('ons-keyboard: Cordova Keyboard plugin is not present.');
};

document.addEventListener('deviceready', function () {
  if (!bindEvents()) {
    if (document.querySelector('[ons-keyboard-active]') || document.querySelector('[ons-keyboard-inactive]')) {
      noPluginError();
    }

    softwareKeyboard.on = noPluginError;
  }
});

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var generateId = function () {
  var i = 0;
  return function () {
    return i++;
  };
}();

/**
 * Door locking system.
 *
 * @param {Object} [options]
 * @param {Function} [options.log]
 */

var DoorLock = function () {
  function DoorLock() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, DoorLock);

    this._lockList = [];
    this._waitList = [];
    this._log = options.log || function () {};
  }

  /**
   * Register a lock.
   *
   * @return {Function} Callback for unlocking.
   */


  createClass(DoorLock, [{
    key: 'lock',
    value: function lock() {
      var _this = this;

      var unlock = function unlock() {
        _this._unlock(unlock);
      };
      unlock.id = generateId();
      this._lockList.push(unlock);
      this._log('lock: ' + unlock.id);

      return unlock;
    }
  }, {
    key: '_unlock',
    value: function _unlock(fn) {
      var index = this._lockList.indexOf(fn);
      if (index === -1) {
        throw new Error('This function is not registered in the lock list.');
      }

      this._lockList.splice(index, 1);
      this._log('unlock: ' + fn.id);

      this._tryToFreeWaitList();
    }
  }, {
    key: '_tryToFreeWaitList',
    value: function _tryToFreeWaitList() {
      while (!this.isLocked() && this._waitList.length > 0) {
        this._waitList.shift()();
      }
    }

    /**
     * Register a callback for waiting unlocked door.
     *
     * @params {Function} callback Callback on unlocking the door completely.
     */

  }, {
    key: 'waitUnlock',
    value: function waitUnlock(callback) {
      if (!(callback instanceof Function)) {
        throw new Error('The callback param must be a function.');
      }

      if (this.isLocked()) {
        this._waitList.push(callback);
      } else {
        callback();
      }
    }

    /**
     * @return {Boolean}
     */

  }, {
    key: 'isLocked',
    value: function isLocked() {
      return this._lockList.length > 0;
    }
  }]);
  return DoorLock;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
// Default implementation for global PageLoader.
function loadPage(_ref, done) {
  var page = _ref.page,
      parent = _ref.parent,
      _ref$params = _ref.params;

  internal$1.getPageHTMLAsync(page).then(function (html) {
    var pageElement = util$1.createElement(html);
    parent.appendChild(pageElement);

    done(pageElement);
  });
}

function unloadPage(element) {
  if (element._destroy instanceof Function) {
    element._destroy();
  } else {
    element.remove();
  }
}

var PageLoader = function () {
  /**
   * @param {Function} [fn] Returns an object that has "element" property and "unload" function.
   */
  function PageLoader(loader, unloader) {
    classCallCheck(this, PageLoader);

    this._loader = loader instanceof Function ? loader : loadPage;
    this._unloader = unloader instanceof Function ? unloader : unloadPage;
  }

  /**
   * Set internal loader implementation.
   */


  createClass(PageLoader, [{
    key: 'load',


    /**
     * @param {any} options.page
     * @param {Element} options.parent A location to load page.
     * @param {Object} [options.params] Extra parameters for ons-page.
     * @param {Function} done Take an object that has "element" property and "unload" function.
     */
    value: function load(_ref2, done) {
      var page = _ref2.page,
          parent = _ref2.parent,
          _ref2$params = _ref2.params,
          params = _ref2$params === undefined ? {} : _ref2$params;

      this._loader({ page: page, parent: parent, params: params }, function (pageElement) {
        if (!(pageElement instanceof Element)) {
          throw Error('pageElement must be an instance of Element.');
        }

        done(pageElement);
      });
    }
  }, {
    key: 'unload',
    value: function unload(pageElement) {
      if (!(pageElement instanceof Element)) {
        throw Error('pageElement must be an instance of Element.');
      }

      this._unloader(pageElement);
    }
  }, {
    key: 'internalLoader',
    set: function set$$1(fn) {
      if (!(fn instanceof Function)) {
        throw Error('First parameter must be an instance of Function');
      }
      this._loader = fn;
    },
    get: function get$$1() {
      return this._loader;
    }
  }]);
  return PageLoader;
}();

var defaultPageLoader = new PageLoader();

var instantPageLoader = new PageLoader(function (_ref3, done) {
  var page = _ref3.page,
      parent = _ref3.parent,
      _ref3$params = _ref3.params;

  var element = util$1.createElement(page.trim());
  parent.appendChild(element);

  done(element);
}, unloadPage);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @object ons
 * @category util
 * @description
 *   [ja]Onsen UIで利用できるグローバルなオブジェクトです。[/ja]
 *   [en]A global object that's used in Onsen UI. [/en]
 */
var ons$1 = {
  animit: Animit,
  defaultPageLoader: defaultPageLoader,
  elements: onsElements,
  GestureDetector: GestureDetector,
  modifier: modifier,
  notification: notification,
  orientation: orientation,
  pageAttributeExpression: pageAttributeExpression,
  PageLoader: PageLoader,
  platform: platform,
  softwareKeyboard: softwareKeyboard,
  _autoStyle: autoStyle,
  _internal: internal$1,
  _readyLock: new DoorLock(),
  _util: util$1
};

ons$1.platform.select((window.location.search.match(/platform=([\w-]+)/) || [])[1]);

waitDeviceReady();

var readyError = function readyError(after) {
  return util$1.throw('This method must be called ' + (after ? 'after' : 'before') + ' ons.isReady() is true');
};

/**
 * @method isReady
 * @signature isReady()
 * @return {Boolean}
 *   [en]Will be true if Onsen UI is initialized.[/en]
 *   [ja]初期化されているかどうかを返します。[/ja]
 * @description
 *   [en]Returns true if Onsen UI is initialized.[/en]
 *   [ja]Onsen UIがすでに初期化されているかどうかを返すメソッドです。[/ja]
 */
ons$1.isReady = function () {
  return !ons$1._readyLock.isLocked();
};

/**
 * @method isWebView
 * @signature isWebView()
 * @return {Boolean}
 *   [en]Will be true if the app is running in Cordova.[/en]
 *   [ja]Cordovaで実行されている場合にtrueになります。[/ja]
 * @description
 *   [en]Returns true if running inside Cordova.[/en]
 *   [ja]Cordovaで実行されているかどうかを返すメソッドです。[/ja]
 */
ons$1.isWebView = ons$1.platform.isWebView;

/**
 * @method ready
 * @signature ready(callback)
 * @description
 *   [ja]アプリの初期化に利用するメソッドです。渡された関数は、Onsen UIの初期化が終了している時点で必ず呼ばれます。[/ja]
 *   [en]Method used to wait for app initialization. Waits for `DOMContentLoaded` and `deviceready`, when necessary, before executing the callback.[/en]
 * @param {Function} callback
 *   [en]Function that executes after Onsen UI has been initialized.[/en]
 *   [ja]Onsen UIが初期化が完了した後に呼び出される関数オブジェクトを指定します。[/ja]
 */
ons$1.ready = function (callback) {
  if (ons$1.isReady()) {
    callback();
  } else {
    ons$1._readyLock.waitUnlock(callback);
  }
};

/**
 * @method setDefaultDeviceBackButtonListener
 * @signature setDefaultDeviceBackButtonListener(listener)
 * @param {Function} listener
 *   [en]Function that executes when device back button is pressed. Must be called on `ons.ready`.[/en]
 *   [ja]デバイスのバックボタンが押された時に実行される関数オブジェクトを指定します。[/ja]
 * @description
 *   [en]Set default handler for device back button.[/en]
 *   [ja]デバイスのバックボタンのためのデフォルトのハンドラを設定します。[/ja]
 */
ons$1.setDefaultDeviceBackButtonListener = function (listener) {
  if (!ons$1.isReady()) {
    readyError(true);
  }
  ons$1._defaultDeviceBackButtonHandler.setListener(listener);
};

/**
 * @method disableDeviceBackButtonHandler
 * @signature disableDeviceBackButtonHandler()
 * @description
 * [en]Disable device back button event handler. Must be called on `ons.ready`.[/en]
 * [ja]デバイスのバックボタンのイベントを受け付けないようにします。[/ja]
 */
ons$1.disableDeviceBackButtonHandler = function () {
  if (!ons$1.isReady()) {
    readyError(true);
  }
  internal$1.dbbDispatcher.disable();
};

/**
 * @method enableDeviceBackButtonHandler
 * @signature enableDeviceBackButtonHandler()
 * @description
 * [en]Enable device back button event handler. Must be called on `ons.ready`.[/en]
 * [ja]デバイスのバックボタンのイベントを受け付けるようにします。[/ja]
 */
ons$1.enableDeviceBackButtonHandler = function () {
  if (!ons$1.isReady()) {
    readyError(true);
  }
  internal$1.dbbDispatcher.enable();
};

ons$1.fireDeviceBackButtonEvent = function () {
  internal$1.dbbDispatcher.fireDeviceBackButtonEvent();
};

/**
 * @method enableAutoStatusBarFill
 * @signature enableAutoStatusBarFill()
 * @description
 *   [en]Enable status bar fill feature on iOS7 and above (except for iPhone X). Must be called before `ons.ready`.[/en]
 *   [ja]iOS7以上（iPhone Xは除く）で、ステータスバー部分の高さを自動的に埋める処理を有効にします。[/ja]
 */
ons$1.enableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    readyError(false);
  }
  internal$1.config.autoStatusBarFill = true;
};

/**
 * @method disableAutoStatusBarFill
 * @signature disableAutoStatusBarFill()
 * @description
 *   [en]Disable status bar fill feature on iOS7 and above (except for iPhone X). Must be called before `ons.ready`.[/en]
 *   [ja]iOS7以上（iPhone Xは除く）で、ステータスバー部分の高さを自動的に埋める処理を無効にします。[/ja]
 */
ons$1.disableAutoStatusBarFill = function () {
  if (ons$1.isReady()) {
    readyError(false);
  }
  internal$1.config.autoStatusBarFill = false;
};

/**
 * @method mockStatusBar
 * @signature mockStatusBar()
 * @description
 *   [en]Creates a static element similar to iOS status bar. Only useful for browser testing. Must be called before `ons.ready`.[/en]
 *   [ja][/ja]
 */
ons$1.mockStatusBar = function () {
  if (ons$1.isReady()) {
    readyError(false);
  }

  var mock = function mock() {
    if (!document.body.children[0] || !document.body.children[0].classList.contains('ons-status-bar-mock')) {
      var android = platform.isAndroid(),
          i = function i(_i) {
        return '<i class="' + _i.split('-')[0] + ' ' + _i + '"></i>';
      };
      var left = android ? i('zmdi-twitter') + ' ' + i('zmdi-google-play') : 'No SIM ' + i('fa-wifi'),
          center = android ? '' : '12:28 PM',
          right = android ? i('zmdi-network') + ' ' + i('zmdi-wifi') + ' ' + i('zmdi-battery') + ' 12:28 PM' : '80% ' + i('fa-battery-three-quarters');

      document.body.insertBefore(util$1.createElement('<div class="ons-status-bar-mock ' + (android ? 'android' : 'ios') + '">' + ('<div>' + left + '</div><div>' + center + '</div><div>' + right + '</div>') + '</div>'), document.body.firstChild);
    }
  };

  document.body ? mock() : internal$1.waitDOMContentLoaded(mock);
};

/**
 * @method disableAnimations
 * @signature disableAnimations()
 * @description
 *   [en]Disable all animations. Could be handy for testing and older devices.[/en]
 *   [ja]アニメーションを全て無効にします。テストの際に便利です。[/ja]
 */
ons$1.disableAnimations = function () {
  internal$1.config.animationsDisabled = true;
};

/**
 * @method enableAnimations
 * @signature enableAnimations()
 * @description
 *   [en]Enable animations (default).[/en]
 *   [ja]アニメーションを有効にします。[/ja]
 */
ons$1.enableAnimations = function () {
  internal$1.config.animationsDisabled = false;
};

ons$1._disableWarnings = function () {
  internal$1.config.warningsDisabled = true;
};

ons$1._enableWarnings = function () {
  internal$1.config.warningsDisabled = false;
};

/**
 * @method disableAutoStyling
 * @signature disableAutoStyling()
 * @description
 *   [en]Disable automatic styling.[/en]
 *   [ja][/ja]
 */
ons$1.disableAutoStyling = autoStyle.disable;

/**
 * @method enableAutoStyling
 * @signature enableAutoStyling()
 * @description
 *   [en]Enable automatic styling based on OS (default).[/en]
 *   [ja][/ja]
 */
ons$1.enableAutoStyling = autoStyle.enable;

/**
 * @method disableIconAutoPrefix
 * @signature disableIconAutoPrefix()
 * @description
 *   [en]Disable adding `fa-` prefix automatically to `ons-icon` classes. Useful when including custom icon packs.[/en]
 *   [ja][/ja]
 */
ons$1.disableIconAutoPrefix = function () {
  util$1.checkMissingImport('Icon');
  onsElements.Icon.setAutoPrefix(false);
};

/**
 * @method forceUIWebViewScrollFix
 * @signature forceUIWebViewScrollFix()
 * @param {Boolean} force Enable or disable the fix.
 * @description
 *   [en]Applies a fix for iOS UIWebView which prevents scroll events jumping to pages under the top layer. This may visually affect normal scrolling of UIWebView if you open a dialog/menu before the scroll momentum finished. Disabled by default.[/en]
 *   [ja][/ja]
 */
ons$1.forceUIWebViewScrollFix = function () {
  var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  internal$1.config.forceUIWebViewScrollFix = force;
};

/**
 * @method forcePlatformStyling
 * @signature forcePlatformStyling(platform)
 * @description
 *   [en]Refresh styling for the given platform. Only useful for demos. Use `ons.platform.select(...)` instead for development and production.[/en]
 *   [ja][/ja]
 * @param {string} platform New platform to style the elements.
 */
ons$1.forcePlatformStyling = function (newPlatform) {
  ons$1.enableAutoStyling();
  ons$1.platform.select(newPlatform || 'ios');

  ons$1._util.arrayFrom(document.querySelectorAll('*')).forEach(function (element) {
    if (element.tagName.toLowerCase() === 'ons-if') {
      element._platformUpdate();
    } else if (element.tagName.match(/^ons-/i)) {
      autoStyle.prepare(element, true);
      if (element.tagName.toLowerCase() === 'ons-tabbar') {
        element._updatePosition();
      }
    }
  });
};

/**
 * @method preload
 * @signature preload(templatePaths)
 * @param {String|Array} templatePaths
 *   [en]Set of HTML file paths containing 'ons-page' elements.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Promise that resolves when all the templates are cached.[/en]
 *   [ja][/ja]
 * @description
 *   [en]Separated files need to be requested on demand and this can slightly delay pushing new pages. This method requests and caches templates for later use.[/en]
 *   [ja][/ja]
 */
ons$1.preload = function () {
  var templates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  return Promise.all((templates instanceof Array ? templates : [templates]).map(function (template) {
    if (typeof template !== 'string') {
      util$1.throw('Expected string arguments but got ' + (typeof template === 'undefined' ? 'undefined' : _typeof(template)));
    }
    return internal$1.getTemplateHTMLAsync(template);
  }));
};

/**
 * @method createElement
 * @signature createElement(template, options)
 * @param {String} template
 *   [en]Either an HTML file path, a `<template>` id or an HTML string such as `'<div id="foo">hoge</div>'`.[/en]
 *   [ja][/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @param {Boolean|HTMLElement} [options.append]
 *   [en]Whether or not the element should be automatically appended to the DOM.  Defaults to `false`. If `true` value is given, `document.body` will be used as the target.[/en]
 *   [ja][/ja]
 * @param {HTMLElement} [options.insertBefore]
 *   [en]Reference node that becomes the next sibling of the new node (`options.append` element).[/en]
 *   [ja][/ja]
 * @return {HTMLElement|Promise}
 *   [en]If the provided template was an inline HTML string, it returns the new element. Otherwise, it returns a promise that resolves to the new element.[/en]
 *   [ja][/ja]
 * @description
 *   [en]Create a new element from a template. Both inline HTML and external files are supported although the return value differs.[/en]
 *   [ja][/ja]
 */
ons$1.createElement = function (template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  template = template.trim();

  var create = function create(html) {
    var element = ons$1._util.createElement(html);
    element.remove();

    if (options.append) {
      var target = options.append instanceof HTMLElement ? options.append : document.body;
      target.insertBefore(element, options.insertBefore || null);
      options.link instanceof Function && options.link(element);
    }

    return element;
  };

  return template.charAt(0) === '<' ? create(template) : internal$1.getPageHTMLAsync(template).then(create);
};

/**
 * @method createPopover
 * @signature createPopover(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or a <template> containing a <ons-dialog> component.[/en]
 *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @param {Object} [options.parentScope]
 *   [en]Parent scope of the dialog. Used to bind models and access scope methods from the dialog.[/en]
 *   [ja]ダイアログ内で利用する親スコープを指定します。ダイアログからモデルやスコープのメソッドにアクセスするのに使います。このパラメータはAngularJSバインディングでのみ利用できます。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the popover component object.[/en]
 *   [ja]ポップオーバーのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a popover instance from a template.[/en]
 *   [ja]テンプレートからポップオーバーのインスタンスを生成します。[/ja]
 */
/**
 * @method createDialog
 * @signature createDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an `<template>` containing a <ons-dialog> component.[/en]
 *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the dialog component object.[/en]
 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a dialog instance from a template.[/en]
 *   [ja]テンプレートからダイアログのインスタンスを生成します。[/ja]
 */
/**
 * @method createAlertDialog
 * @signature createAlertDialog(page, [options])
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or an `<template>` containing a <ons-alert-dialog> component.[/en]
 *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @return {Promise}
 *   [en]Promise object that resolves to the alert dialog component object.[/en]
 *   [ja]ダイアログのコンポーネントオブジェクトを解決するPromiseオブジェクトを返します。[/ja]
 * @description
 *   [en]Create a alert dialog instance from a template.[/en]
 *   [ja]テンプレートからアラートダイアログのインスタンスを生成します。[/ja]
 */
ons$1.createPopover = ons$1.createDialog = ons$1.createAlertDialog = function (template) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return ons$1.createElement(template, _extends({ append: true }, options));
};

/**
 * @method openActionSheet
 * @signature openActionSheet(options)
 * @description
 *   [en]Shows an instant Action Sheet and lets the user choose an action.[/en]
 *   [ja][/ja]
 * @param {Object} [options]
 *   [en]Parameter object.[/en]
 *   [ja]オプションを指定するオブジェクト。[/ja]
 * @param {Array} [options.buttons]
 *   [en]Represent each button of the action sheet following the specified order. Every item can be either a string label or an object containing `label`, `icon` and `modifier` properties.[/en]
 *   [ja][/ja]
 * @param {String} [options.title]
 *   [en]Optional title for the action sheet.[/en]
 *   [ja][/ja]
 * @param {Number} [options.destructive]
 *   [en]Optional index of the "destructive" button (only for iOS). It can be specified in the button array as well.[/en]
 *   [ja][/ja]
 * @param {Boolean} [options.cancelable]
 *   [en]Whether the action sheet can be canceled by tapping on the background mask or not.[/en]
 *   [ja][/ja]
 * @param {String} [options.modifier]
 *   [en]Modifier attribute of the action sheet. E.g. `'destructive'`.[/en]
 *   [ja][/ja]
 * @param {String} [options.maskColor]
 *   [en]Optionally change the background mask color.[/en]
 *   [ja][/ja]
 * @param {String} [options.id]
 *   [en]The element's id attribute.[/en]
 *   [ja][/ja]
 * @param {String} [options.class]
 *   [en]The element's class attribute.[/en]
 *   [ja][/ja]
 * @return {Promise}
 *   [en]Will resolve when the action sheet is closed. The resolve value is either the index of the tapped button or -1 when canceled.[/en]
 *   [ja][/ja]
 */
ons$1.openActionSheet = actionSheet;

/**
 * @method resolveLoadingPlaceholder
 * @signature resolveLoadingPlaceholder(page)
 * @param {String} page
 *   [en]Page name. Can be either an HTML file or a `<template>` id.[/en]
 *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
 * @description
 *   [en]If no page is defined for the `ons-loading-placeholder` attribute it will wait for this method being called before loading the page.[/en]
 *   [ja]ons-loading-placeholderの属性値としてページが指定されていない場合は、ページロード前に呼ばれるons.resolveLoadingPlaceholder処理が行われるまで表示されません。[/ja]
 */
ons$1.resolveLoadingPlaceholder = function (page, link) {
  var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));
  if (elements.length === 0) {
    util$1.throw('No ons-loading-placeholder exists');
  }

  elements.filter(function (element) {
    return !element.getAttribute('page');
  }).forEach(function (element) {
    element.setAttribute('ons-loading-placeholder', page);
    ons$1._resolveLoadingPlaceholder(element, page, link);
  });
};

ons$1._setupLoadingPlaceHolders = function () {
  ons$1.ready(function () {
    var elements = ons$1._util.arrayFrom(window.document.querySelectorAll('[ons-loading-placeholder]'));

    elements.forEach(function (element) {
      var page = element.getAttribute('ons-loading-placeholder');
      if (typeof page === 'string') {
        ons$1._resolveLoadingPlaceholder(element, page);
      }
    });
  });
};

ons$1._resolveLoadingPlaceholder = function (parent, page) {
  var link = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function (el, done) {
    return done();
  };

  page && ons$1.createElement(page).then(function (element) {
    element.style.display = 'none';
    parent.appendChild(element);
    link(element, function () {
      while (parent.firstChild && parent.firstChild !== element) {
        parent.removeChild(parent.firstChild);
      }
      element.style.display = '';
    });
  }).catch(function (error) {
    return Promise.reject('Unabled to resolve placeholder: ' + error);
  });
};

function waitDeviceReady() {
  var unlockDeviceReady = ons$1._readyLock.lock();
  var execUnlock = function execUnlock() {
    if (ons$1.isWebView()) {
      // Callback for event DeviceReady is called even if the event has already been fired
      window.document.addEventListener('deviceready', unlockDeviceReady, false);
    } else {
      unlockDeviceReady();
    }
  };
  if (document.readyState === 'complete' || document.readyState === 'loaded' || document.readyState === 'interactive') {
    setImmediate(execUnlock);
  } else {
    window.addEventListener('DOMContentLoaded', execUnlock, false);
  }
}

/**
 * @method getScriptPage
 * @signature getScriptPage()
 * @description
 *   [en]Access the last created page from the current `script` scope. Only works inside `<script></script>` tags that are direct children of `ons-page` element. Use this to add lifecycle hooks to a page.[/en]
 *   [ja][/ja]
 * @return {HTMLElement}
 *   [en]Returns the corresponding page element.[/en]
 *   [ja][/ja]
 */
var getCS = 'currentScript' in document ? function () {
  return document.currentScript;
} : function () {
  return document.scripts[document.scripts.length - 1];
};
ons$1.getScriptPage = function () {
  return getCS() && /ons-page/i.test(getCS().parentElement.tagName) && getCS().parentElement || null;
};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var fastclick = createCommonjsModule(function (module) {
	(function () {
		function FastClick(layer, options) {
			var oldOnClick;

			options = options || {};

			/**
    * Whether a click is currently being tracked.
    *
    * @type boolean
    */
			this.trackingClick = false;

			/**
    * Timestamp for when click tracking started.
    *
    * @type number
    */
			this.trackingClickStart = 0;

			/**
    * The element being tracked for a click.
    *
    * @type EventTarget
    */
			this.targetElement = null;

			/**
    * X-coordinate of touch start event.
    *
    * @type number
    */
			this.touchStartX = 0;

			/**
    * Y-coordinate of touch start event.
    *
    * @type number
    */
			this.touchStartY = 0;

			/**
    * ID of the last touch, retrieved from Touch.identifier.
    *
    * @type number
    */
			this.lastTouchIdentifier = 0;

			/**
    * Touchmove boundary, beyond which a click will be cancelled.
    *
    * @type number
    */
			this.touchBoundary = options.touchBoundary || 10;

			/**
    * The FastClick layer.
    *
    * @type Element
    */
			this.layer = layer;

			/**
    * The minimum time between tap(touchstart and touchend) events
    *
    * @type number
    */
			this.tapDelay = options.tapDelay || 200;

			/**
    * The maximum time for a tap
    *
    * @type number
    */
			this.tapTimeout = options.tapTimeout || 700;

			if (FastClick.notNeeded(layer)) {
				return;
			}

			// Some old versions of Android don't have Function.prototype.bind
			function bind(method, context) {
				return function () {
					return method.apply(context, arguments);
				};
			}

			var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
			var context = this;
			for (var i = 0, l = methods.length; i < l; i++) {
				context[methods[i]] = bind(context[methods[i]], context);
			}

			// Set up event handlers as required
			if (deviceIsAndroid) {
				layer.addEventListener('mouseover', this.onMouse, true);
				layer.addEventListener('mousedown', this.onMouse, true);
				layer.addEventListener('mouseup', this.onMouse, true);
			}

			layer.addEventListener('click', this.onClick, true);
			layer.addEventListener('touchstart', this.onTouchStart, false);
			layer.addEventListener('touchmove', this.onTouchMove, false);
			layer.addEventListener('touchend', this.onTouchEnd, false);
			layer.addEventListener('touchcancel', this.onTouchCancel, false);

			// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
			// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
			// layer when they are cancelled.
			if (!Event.prototype.stopImmediatePropagation) {
				layer.removeEventListener = function (type, callback, capture) {
					var rmv = Node.prototype.removeEventListener;
					if (type === 'click') {
						rmv.call(layer, type, callback.hijacked || callback, capture);
					} else {
						rmv.call(layer, type, callback, capture);
					}
				};

				layer.addEventListener = function (type, callback, capture) {
					var adv = Node.prototype.addEventListener;
					if (type === 'click') {
						adv.call(layer, type, callback.hijacked || (callback.hijacked = function (event) {
							if (!event.propagationStopped) {
								callback(event);
							}
						}), capture);
					} else {
						adv.call(layer, type, callback, capture);
					}
				};
			}

			// If a handler is already declared in the element's onclick attribute, it will be fired before
			// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
			// adding it as listener.
			if (typeof layer.onclick === 'function') {

				// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
				// - the old one won't work if passed to addEventListener directly.
				oldOnClick = layer.onclick;
				layer.addEventListener('click', function (event) {
					oldOnClick(event);
				}, false);
				layer.onclick = null;
			}
		}

		/**
  * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
  *
  * @type boolean
  */
		var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

		/**
   * Android requires exceptions.
   *
   * @type boolean
   */
		var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;

		/**
   * iOS requires exceptions.
   *
   * @type boolean
   */
		var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;

		/**
   * iOS 4 requires an exception for select elements.
   *
   * @type boolean
   */
		var deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent);

		/**
   * iOS 6.0-7.* requires the target element to be manually derived
   *
   * @type boolean
   */
		var deviceIsIOSWithBadTarget = deviceIsIOS && /OS [6-7]_\d/.test(navigator.userAgent);

		/**
   * BlackBerry requires exceptions.
   *
   * @type boolean
   */
		var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

		/**
   * Valid types for text inputs
   *
   * @type array
   */
		var textFields = ['email', 'number', 'password', 'search', 'tel', 'text', 'url'];

		/**
   * Determine whether a given element requires a native click.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element needs a native click
   */
		FastClick.prototype.needsClick = function (target) {
			switch (target.nodeName.toLowerCase()) {

				// Don't send a synthetic click to disabled inputs (issue #62)
				case 'button':
				case 'select':
				case 'textarea':
					if (target.disabled) {
						return true;
					}

					break;
				case 'input':

					// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
					if (deviceIsIOS && target.type === 'file' || target.disabled) {
						return true;
					}

					break;
				case 'label':
				case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
				case 'video':
					return true;
			}

			return (/\bneedsclick\b/.test(target.className)
			);
		};

		/**
   * Determine whether a given element requires a call to focus to simulate click into element.
   *
   * @param {EventTarget|Element} target Target DOM element
   * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
   */
		FastClick.prototype.needsFocus = function (target) {
			switch (target.nodeName.toLowerCase()) {
				case 'textarea':
					return true;
				case 'select':
					return !deviceIsAndroid;
				case 'input':
					switch (target.type) {
						case 'button':
						case 'checkbox':
						case 'file':
						case 'image':
						case 'radio':
						case 'submit':
							return false;
					}

					// No point in attempting to focus disabled inputs
					return !target.disabled && !target.readOnly;
				default:
					return (/\bneedsfocus\b/.test(target.className)
					);
			}
		};

		/**
   * Send a click event to the specified element.
   *
   * @param {EventTarget|Element} targetElement
   * @param {Event} event
   */
		FastClick.prototype.sendClick = function (targetElement, event) {
			var clickEvent, touch;

			// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
			if (document.activeElement && document.activeElement !== targetElement) {
				document.activeElement.blur();
			}

			touch = event.changedTouches[0];

			// Synthesise a click event, with an extra attribute so it can be tracked
			clickEvent = document.createEvent('MouseEvents');
			clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
			clickEvent.forwardedTouchEvent = true;
			targetElement.dispatchEvent(clickEvent);
		};

		FastClick.prototype.determineEventType = function (targetElement) {

			//Issue #159: Android Chrome Select Box does not open with a synthetic click event
			if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
				return 'mousedown';
			}

			return 'click';
		};

		/**
   * @param {EventTarget|Element} targetElement
   */
		FastClick.prototype.focus = function (targetElement) {
			var length;

			// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
			if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month' && targetElement.type !== 'email' && targetElement.type !== 'number') {
				length = targetElement.value.length;
				targetElement.setSelectionRange(length, length);
			} else {
				targetElement.focus();
			}
		};

		/**
   * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
   *
   * @param {EventTarget|Element} targetElement
   */
		FastClick.prototype.updateScrollParent = function (targetElement) {
			var scrollParent, parentElement;

			scrollParent = targetElement.fastClickScrollParent;

			// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
			// target element was moved to another parent.
			if (!scrollParent || !scrollParent.contains(targetElement)) {
				parentElement = targetElement;
				do {
					if (parentElement.scrollHeight > parentElement.offsetHeight) {
						scrollParent = parentElement;
						targetElement.fastClickScrollParent = parentElement;
						break;
					}

					parentElement = parentElement.parentElement;
				} while (parentElement);
			}

			// Always update the scroll top tracker if possible.
			if (scrollParent) {
				scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
			}
		};

		/**
   * @param {EventTarget} targetElement
   * @returns {Element|EventTarget}
   */
		FastClick.prototype.getTargetElementFromEventTarget = function (eventTarget) {

			// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
			if (eventTarget.nodeType === Node.TEXT_NODE) {
				return eventTarget.parentNode;
			}

			return eventTarget;
		};

		/**
   * @param {EventTarget} targetElement
   * @returns {boolean}
   */
		FastClick.prototype.isTextField = function (targetElement) {
			return targetElement.tagName.toLowerCase() === 'textarea' || textFields.indexOf(targetElement.type) !== -1;
		};

		/**
   * On touch start, record the position and scroll offset.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.onTouchStart = function (event) {
			var targetElement, touch;

			// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
			if (event.targetTouches.length > 1) {
				return true;
			}

			targetElement = this.getTargetElementFromEventTarget(event.target);
			touch = event.targetTouches[0];

			// Ignore touches on contenteditable elements to prevent conflict with text selection.
			// (For details: https://github.com/ftlabs/fastclick/pull/211 )
			if (targetElement.isContentEditable) {
				return true;
			}

			if (deviceIsIOS) {
				// Ignore touchstart in focused text field
				// Allows normal text selection and commands (select/paste/cut) when a field has focus, while still allowing fast tap-to-focus.
				// Without this fix, user needs to tap-and-hold a text field for context menu, and double-tap to select text doesn't work at all.
				if (targetElement === document.activeElement && this.isTextField(targetElement)) {
					return true;
				}

				if (!deviceIsIOS4) {

					// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
					// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
					// with the same identifier as the touch event that previously triggered the click that triggered the alert.
					// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
					// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
					// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
					// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
					// random integers, it's safe to to continue if the identifier is 0 here.
					if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
						event.preventDefault();
						return false;
					}

					this.lastTouchIdentifier = touch.identifier;

					// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
					// 1) the user does a fling scroll on the scrollable layer
					// 2) the user stops the fling scroll with another tap
					// then the event.target of the last 'touchend' event will be the element that was under the user's finger
					// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
					// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
					this.updateScrollParent(targetElement);
				}
			}

			this.trackingClick = true;
			this.trackingClickStart = event.timeStamp;
			this.targetElement = targetElement;

			this.touchStartX = touch.pageX;
			this.touchStartY = touch.pageY;

			// Prevent phantom clicks on fast double-tap (issue #36)
			if (event.timeStamp - this.lastClickTime < this.tapDelay && event.timeStamp - this.lastClickTime > -1) {
				event.preventDefault();
			}

			return true;
		};

		/**
   * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.touchHasMoved = function (event) {
			var touch = event.changedTouches[0],
			    boundary = this.touchBoundary;

			if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
				return true;
			}

			return false;
		};

		/**
   * Update the last position.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.onTouchMove = function (event) {
			if (!this.trackingClick) {
				return true;
			}

			// If the touch has moved, cancel the click tracking
			if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
				this.trackingClick = false;
				this.targetElement = null;
			}

			return true;
		};

		/**
   * Attempt to find the labelled control for the given label element.
   *
   * @param {EventTarget|HTMLLabelElement} labelElement
   * @returns {Element|null}
   */
		FastClick.prototype.findControl = function (labelElement) {

			// Fast path for newer browsers supporting the HTML5 control attribute
			if (labelElement.control !== undefined) {
				return labelElement.control;
			}

			// All browsers under test that support touch events also support the HTML5 htmlFor attribute
			if (labelElement.htmlFor) {
				return document.getElementById(labelElement.htmlFor);
			}

			// If no for attribute exists, attempt to retrieve the first labellable descendant element
			// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
			return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
		};

		/**
   * On touch end, determine whether to send a click event at once.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.onTouchEnd = function (event) {
			var forElement,
			    trackingClickStart,
			    targetTagName,
			    scrollParent,
			    touch,
			    targetElement = this.targetElement;

			if (!this.trackingClick) {
				return true;
			}

			// Prevent phantom clicks on fast double-tap (issue #36)
			if (event.timeStamp - this.lastClickTime < this.tapDelay && event.timeStamp - this.lastClickTime > -1) {
				this.cancelNextClick = true;
				return true;
			}

			if (event.timeStamp - this.trackingClickStart > this.tapTimeout) {
				return true;
			}

			// Reset to prevent wrong click cancel on input (issue #156).
			this.cancelNextClick = false;

			this.lastClickTime = event.timeStamp;

			trackingClickStart = this.trackingClickStart;
			this.trackingClick = false;
			this.trackingClickStart = 0;

			// On some iOS devices, the targetElement supplied with the event is invalid if the layer
			// is performing a transition or scroll, and has to be re-detected manually. Note that
			// for this to function correctly, it must be called *after* the event target is checked!
			// See issue #57; also filed as rdar://13048589 .
			if (deviceIsIOSWithBadTarget) {
				touch = event.changedTouches[0];

				// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
				targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
				targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
			}

			targetTagName = targetElement.tagName.toLowerCase();
			if (targetTagName === 'label') {
				forElement = this.findControl(targetElement);
				if (forElement) {
					this.focus(targetElement);
					if (deviceIsAndroid) {
						return false;
					}

					targetElement = forElement;
				}
			} else if (this.needsFocus(targetElement)) {

				// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
				// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
				if (event.timeStamp - trackingClickStart > 100 || deviceIsIOS && window.top !== window && targetTagName === 'input') {
					this.targetElement = null;
					return false;
				}

				this.focus(targetElement);
				this.sendClick(targetElement, event);

				// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
				// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
				if (!deviceIsIOS4 || targetTagName !== 'select') {
					this.targetElement = null;
					event.preventDefault();
				}

				return false;
			}

			if (deviceIsIOS && !deviceIsIOS4) {

				// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
				// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
				scrollParent = targetElement.fastClickScrollParent;
				if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
					return true;
				}
			}

			// Prevent the actual click from going though - unless the target node is marked as requiring
			// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
			if (!this.needsClick(targetElement)) {
				event.preventDefault();
				this.sendClick(targetElement, event);
			}

			return false;
		};

		/**
   * On touch cancel, stop tracking the click.
   *
   * @returns {void}
   */
		FastClick.prototype.onTouchCancel = function () {
			this.trackingClick = false;
			this.targetElement = null;
		};

		/**
   * Determine mouse events which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.onMouse = function (event) {

			// If a target element was never set (because a touch event was never fired) allow the event
			if (!this.targetElement) {
				return true;
			}

			if (event.forwardedTouchEvent) {
				return true;
			}

			// Programmatically generated events targeting a specific element should be permitted
			if (!event.cancelable) {
				return true;
			}

			// Derive and check the target element to see whether the mouse event needs to be permitted;
			// unless explicitly enabled, prevent non-touch click events from triggering actions,
			// to prevent ghost/doubleclicks.
			if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

				// Prevent any user-added listeners declared on FastClick element from being fired.
				if (event.stopImmediatePropagation) {
					event.stopImmediatePropagation();
				} else {

					// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
					event.propagationStopped = true;
				}

				// Cancel the event
				event.stopPropagation();
				event.preventDefault();

				return false;
			}

			// If the mouse event is permitted, return true for the action to go through.
			return true;
		};

		/**
   * On actual clicks, determine whether this is a touch-generated click, a click action occurring
   * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
   * an actual click which should be permitted.
   *
   * @param {Event} event
   * @returns {boolean}
   */
		FastClick.prototype.onClick = function (event) {
			var permitted;

			// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
			if (this.trackingClick) {
				this.targetElement = null;
				this.trackingClick = false;
				return true;
			}

			// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
			if (event.target.type === 'submit' && event.detail === 0) {
				return true;
			}

			permitted = this.onMouse(event);

			// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
			if (!permitted) {
				this.targetElement = null;
			}

			// If clicks are permitted, return true for the action to go through.
			return permitted;
		};

		/**
   * Remove all FastClick's event listeners.
   *
   * @returns {void}
   */
		FastClick.prototype.destroy = function () {
			var layer = this.layer;

			if (deviceIsAndroid) {
				layer.removeEventListener('mouseover', this.onMouse, true);
				layer.removeEventListener('mousedown', this.onMouse, true);
				layer.removeEventListener('mouseup', this.onMouse, true);
			}

			layer.removeEventListener('click', this.onClick, true);
			layer.removeEventListener('touchstart', this.onTouchStart, false);
			layer.removeEventListener('touchmove', this.onTouchMove, false);
			layer.removeEventListener('touchend', this.onTouchEnd, false);
			layer.removeEventListener('touchcancel', this.onTouchCancel, false);
		};

		/**
   * Check whether FastClick is needed.
   *
   * @param {Element} layer The layer to listen on
   */
		FastClick.notNeeded = function (layer) {
			var metaViewport;
			var chromeVersion;
			var blackberryVersion;
			var firefoxVersion;

			// Devices that don't support touch don't need FastClick
			if (typeof window.ontouchstart === 'undefined') {
				return true;
			}

			// Chrome version - zero for other browsers
			chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

			if (chromeVersion) {

				if (deviceIsAndroid) {
					metaViewport = document.querySelector('meta[name=viewport]');

					if (metaViewport) {
						// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
						if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
							return true;
						}
						// Chrome 32 and above with width=device-width or less don't need FastClick
						if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
							return true;
						}
					}

					// Chrome desktop doesn't need FastClick (issue #15)
				} else {
					return true;
				}
			}

			if (deviceIsBlackBerry10) {
				blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

				// BlackBerry 10.3+ does not require Fastclick library.
				// https://github.com/ftlabs/fastclick/issues/251
				if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
					metaViewport = document.querySelector('meta[name=viewport]');

					if (metaViewport) {
						// user-scalable=no eliminates click delay.
						if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
							return true;
						}
						// width=device-width (or less than device-width) eliminates click delay.
						if (document.documentElement.scrollWidth <= window.outerWidth) {
							return true;
						}
					}
				}
			}

			// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
			if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
				return true;
			}

			// Firefox version - zero for other browsers
			firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

			if (firefoxVersion >= 27) {
				// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896

				metaViewport = document.querySelector('meta[name=viewport]');
				if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
					return true;
				}
			}

			// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
			// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
			if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
				return true;
			}

			return false;
		};

		/**
   * Factory method for creating a FastClick object
   *
   * @param {Element} layer The layer to listen on
   * @param {Object} [options={}] The options to override the defaults
   */
		FastClick.attach = function (layer, options) {
			return new FastClick(layer, options);
		};

		if (typeof undefined === 'function' && _typeof(undefined.amd) === 'object' && undefined.amd) {

			// AMD. Register as an anonymous module.
			undefined(function () {
				return FastClick;
			});
		} else if ('object' !== 'undefined' && module.exports) {
			module.exports = FastClick.attach;
			module.exports.FastClick = FastClick;
		} else {
			window.FastClick = FastClick;
		}
	})();
});

var fastclick_1 = fastclick.FastClick;

// For @onsenui/custom-elements
if (window.customElements) {
    // even if native CE1 impl exists, use polyfill
    window.customElements.forcePolyfill = true;
}

var _global = createCommonjsModule(function (module) {
  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
});

var _core = createCommonjsModule(function (module) {
  var core = module.exports = { version: '2.5.1' };
  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
});

var _core_1 = _core.version;

var _isObject = function _isObject(it) {
  return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) === 'object' ? it !== null : typeof it === 'function';
};

var _anObject = function _anObject(it) {
  if (!_isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

var _fails = function _fails(exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

// Thank's IE8 for his funny defineProperty
var _descriptors = !_fails(function () {
  return Object.defineProperty({}, 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

var document$1 = _global.document;
// typeof document.createElement is 'object' in old IE
var is = _isObject(document$1) && _isObject(document$1.createElement);
var _domCreate = function _domCreate(it) {
  return is ? document$1.createElement(it) : {};
};

var _ie8DomDefine = !_descriptors && !_fails(function () {
  return Object.defineProperty(_domCreate('div'), 'a', { get: function get() {
      return 7;
    } }).a != 7;
});

// 7.1.1 ToPrimitive(input [, PreferredType])

// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var _toPrimitive = function _toPrimitive(it, S) {
  if (!_isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !_isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !_isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

var dP = Object.defineProperty;

var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  _anObject(O);
  P = _toPrimitive(P, true);
  _anObject(Attributes);
  if (_ie8DomDefine) try {
    return dP(O, P, Attributes);
  } catch (e) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

var _objectDp = {
  f: f
};

var _propertyDesc = function _propertyDesc(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

var _hide = _descriptors ? function (object, key, value) {
  return _objectDp.f(object, key, _propertyDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

var hasOwnProperty = {}.hasOwnProperty;
var _has = function _has(it, key) {
  return hasOwnProperty.call(it, key);
};

var id = 0;
var px = Math.random();
var _uid = function _uid(key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

var _redefine = createCommonjsModule(function (module) {
  var SRC = _uid('src');
  var TO_STRING = 'toString';
  var $toString = Function[TO_STRING];
  var TPL = ('' + $toString).split(TO_STRING);

  _core.inspectSource = function (it) {
    return $toString.call(it);
  };

  (module.exports = function (O, key, val, safe) {
    var isFunction = typeof val == 'function';
    if (isFunction) _has(val, 'name') || _hide(val, 'name', key);
    if (O[key] === val) return;
    if (isFunction) _has(val, SRC) || _hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
    if (O === _global) {
      O[key] = val;
    } else if (!safe) {
      delete O[key];
      _hide(O, key, val);
    } else if (O[key]) {
      O[key] = val;
    } else {
      _hide(O, key, val);
    }
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, TO_STRING, function toString() {
    return typeof this == 'function' && this[SRC] || $toString.call(this);
  });
});

var _aFunction = function _aFunction(it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

// optional / simple context binding

var _ctx = function _ctx(fn, that, length) {
  _aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };
    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };
    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }
  return function () /* ...args */{
    return fn.apply(that, arguments);
  };
};

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == 'function' ? _ctx(Function.call, out) : out;
    // extend global
    if (target) _redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) _hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
_global.core = _core;
// type bitmap
$export.F = 1; // forced
$export.G = 2; // global
$export.S = 4; // static
$export.P = 8; // proto
$export.B = 16; // bind
$export.W = 32; // wrap
$export.U = 64; // safe
$export.R = 128; // real proto method for `library`
var _export = $export;

var f$2 = {}.propertyIsEnumerable;

var _objectPie = {
	f: f$2
};

var toString = {}.toString;

var _cof = function _cof(it) {
  return toString.call(it).slice(8, -1);
};

// fallback for non-array-like ES3 and non-enumerable old V8 strings

// eslint-disable-next-line no-prototype-builtins
var _iobject = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return _cof(it) == 'String' ? it.split('') : Object(it);
};

// 7.2.1 RequireObjectCoercible(argument)
var _defined = function _defined(it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

// to indexed object, toObject with fallback for non-array-like ES3 strings


var _toIobject = function _toIobject(it) {
  return _iobject(_defined(it));
};

var gOPD = Object.getOwnPropertyDescriptor;

var f$1 = _descriptors ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = _toIobject(O);
  P = _toPrimitive(P, true);
  if (_ie8DomDefine) try {
    return gOPD(O, P);
  } catch (e) {/* empty */}
  if (_has(O, P)) return _propertyDesc(!_objectPie.f.call(O, P), O[P]);
};

var _objectGopd = {
  f: f$1
};

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */

var check = function check(O, proto) {
  _anObject(O);
  if (!_isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
var _setProto = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = _ctx(Function.call, _objectGopd.f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }
    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

// 19.1.3.19 Object.setPrototypeOf(O, proto)

_export(_export.S, 'Object', { setPrototypeOf: _setProto.set });

var setPrototypeOf = _core.Object.setPrototypeOf;

var SHARED = '__core-js_shared__';
var store = _global[SHARED] || (_global[SHARED] = {});
var _shared = function _shared(key) {
  return store[key] || (store[key] = {});
};

var _wks = createCommonjsModule(function (module) {
  var store = _shared('wks');

  var _Symbol = _global.Symbol;
  var USE_SYMBOL = typeof _Symbol == 'function';

  var $exports = module.exports = function (name) {
    return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : _uid)('Symbol.' + name));
  };

  $exports.store = store;
});

// getting tag from 19.1.3.6 Object.prototype.toString()

var TAG = _wks('toStringTag');
// ES3 wrong here
var ARG = _cof(function () {
  return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {/* empty */}
};

var _classof = function _classof(it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
  // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
  // builtinTag case
  : ARG ? _cof(O)
  // ES3 arguments fallback
  : (B = _cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

// 19.1.3.6 Object.prototype.toString()

var test = {};
test[_wks('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  _redefine(Object.prototype, 'toString', function toString() {
    return '[object ' + _classof(this) + ']';
  }, true);
}

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
var _toInteger = function _toInteger(it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

// true  -> String#at
// false -> String#codePointAt
var _stringAt = function _stringAt(TO_STRING) {
  return function (that, pos) {
    var s = String(_defined(that));
    var i = _toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

var _library = false;

var _iterators = {};

// 7.1.15 ToLength

var min = Math.min;
var _toLength = function _toLength(it) {
  return it > 0 ? min(_toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

var max = Math.max;
var min$1 = Math.min;
var _toAbsoluteIndex = function _toAbsoluteIndex(index, length) {
  index = _toInteger(index);
  return index < 0 ? max(index + length, 0) : min$1(index, length);
};

// false -> Array#indexOf
// true  -> Array#includes


var _arrayIncludes = function _arrayIncludes(IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = _toIobject($this);
    var length = _toLength(O.length);
    var index = _toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }return !IS_INCLUDES && -1;
  };
};

var shared = _shared('keys');

var _sharedKey = function _sharedKey(key) {
  return shared[key] || (shared[key] = _uid(key));
};

var arrayIndexOf = _arrayIncludes(false);
var IE_PROTO$1 = _sharedKey('IE_PROTO');

var _objectKeysInternal = function _objectKeysInternal(object, names) {
  var O = _toIobject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) {
    if (key != IE_PROTO$1) _has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys
  while (names.length > i) {
    if (_has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }return result;
};

// IE 8- don't enum bug keys
var _enumBugKeys = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

// 19.1.2.14 / 15.2.3.14 Object.keys(O)


var _objectKeys = Object.keys || function keys(O) {
  return _objectKeysInternal(O, _enumBugKeys);
};

var _objectDps = _descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
  _anObject(O);
  var keys = _objectKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) {
    _objectDp.f(O, P = keys[i++], Properties[P]);
  }return O;
};

var document$2 = _global.document;
var _html = document$2 && document$2.documentElement;

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


var IE_PROTO = _sharedKey('IE_PROTO');
var Empty = function Empty() {/* empty */};
var PROTOTYPE$1 = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = _domCreate('iframe');
  var i = _enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  _html.appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;
  while (i--) {
    delete _createDict[PROTOTYPE$1][_enumBugKeys[i]];
  }return _createDict();
};

var _objectCreate = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE$1] = _anObject(O);
    result = new Empty();
    Empty[PROTOTYPE$1] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = _createDict();
  return Properties === undefined ? result : _objectDps(result, Properties);
};

var def = _objectDp.f;

var TAG$1 = _wks('toStringTag');

var _setToStringTag = function _setToStringTag(it, tag, stat) {
  if (it && !_has(it = stat ? it : it.prototype, TAG$1)) def(it, TAG$1, { configurable: true, value: tag });
};

var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
_hide(IteratorPrototype, _wks('iterator'), function () {
  return this;
});

var _iterCreate = function _iterCreate(Constructor, NAME, next) {
  Constructor.prototype = _objectCreate(IteratorPrototype, { next: _propertyDesc(1, next) });
  _setToStringTag(Constructor, NAME + ' Iterator');
};

// 7.1.13 ToObject(argument)

var _toObject = function _toObject(it) {
  return Object(_defined(it));
};

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)


var IE_PROTO$2 = _sharedKey('IE_PROTO');
var ObjectProto = Object.prototype;

var _objectGpo = Object.getPrototypeOf || function (O) {
  O = _toObject(O);
  if (_has(O, IE_PROTO$2)) return O[IE_PROTO$2];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }return O instanceof Object ? ObjectProto : null;
};

var ITERATOR = _wks('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

var _iterDefine = function _iterDefine(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  _iterCreate(Constructor, NAME, next);
  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };
      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }return function entries() {
      return new Constructor(this, kind);
    };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = _objectGpo($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      _setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!_library && !_has(IteratorPrototype, ITERATOR)) _hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() {
      return $native.call(this);
    };
  }
  // Define iterator
  if ((!_library || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    _hide(proto, ITERATOR, $default);
  }
  // Plug for library
  _iterators[NAME] = $default;
  _iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) _redefine(proto, key, methods[key]);
    } else _export(_export.P + _export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

var $at = _stringAt(true);

// 21.1.3.27 String.prototype[@@iterator]()
_iterDefine(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = _wks('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) _hide(ArrayProto, UNSCOPABLES, {});
var _addToUnscopables = function _addToUnscopables(key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

var _iterStep = function _iterStep(done, value) {
  return { value: value, done: !!done };
};

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
var es6_array_iterator = _iterDefine(Array, 'Array', function (iterated, kind) {
  this._t = _toIobject(iterated); // target
  this._i = 0; // next index
  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return _iterStep(1);
  }
  if (kind == 'keys') return _iterStep(0, index);
  if (kind == 'values') return _iterStep(0, O[index]);
  return _iterStep(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
_iterators.Arguments = _iterators.Array;

_addToUnscopables('keys');
_addToUnscopables('values');
_addToUnscopables('entries');

var ITERATOR$1 = _wks('iterator');
var TO_STRING_TAG = _wks('toStringTag');
var ArrayValues = _iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = _objectKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = _global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR$1]) _hide(proto, ITERATOR$1, ArrayValues);
    if (!proto[TO_STRING_TAG]) _hide(proto, TO_STRING_TAG, NAME);
    _iterators[NAME] = ArrayValues;
    if (explicit) for (key in es6_array_iterator) {
      if (!proto[key]) _redefine(proto, key, es6_array_iterator[key], true);
    }
  }
}

var _redefineAll = function _redefineAll(target, src, safe) {
  for (var key in src) {
    _redefine(target, key, src[key], safe);
  }return target;
};

var _anInstance = function _anInstance(it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }return it;
};

// call something on iterator step with safe closing on error

var _iterCall = function _iterCall(iterator, fn, value, entries) {
  try {
    return entries ? fn(_anObject(value)[0], value[1]) : fn(value);
    // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) _anObject(ret.call(iterator));
    throw e;
  }
};

// check on default Array iterator

var ITERATOR$2 = _wks('iterator');
var ArrayProto$1 = Array.prototype;

var _isArrayIter = function _isArrayIter(it) {
  return it !== undefined && (_iterators.Array === it || ArrayProto$1[ITERATOR$2] === it);
};

var ITERATOR$3 = _wks('iterator');

var core_getIteratorMethod = _core.getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR$3] || it['@@iterator'] || _iterators[_classof(it)];
};

var _forOf = createCommonjsModule(function (module) {
  var BREAK = {};
  var RETURN = {};
  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
    var iterFn = ITERATOR ? function () {
      return iterable;
    } : core_getIteratorMethod(iterable);
    var f = _ctx(fn, that, entries ? 2 : 1);
    var index = 0;
    var length, step, iterator, result;
    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
    // fast case for arrays with default iterator
    if (_isArrayIter(iterFn)) for (length = _toLength(iterable.length); length > index; index++) {
      result = entries ? f(_anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      if (result === BREAK || result === RETURN) return result;
    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
      result = _iterCall(iterator, f, step.value, entries);
      if (result === BREAK || result === RETURN) return result;
    }
  };
  exports.BREAK = BREAK;
  exports.RETURN = RETURN;
});

var SPECIES = _wks('species');

var _setSpecies = function _setSpecies(KEY) {
  var C = _global[KEY];
  if (_descriptors && C && !C[SPECIES]) _objectDp.f(C, SPECIES, {
    configurable: true,
    get: function get() {
      return this;
    }
  });
};

var _meta = createCommonjsModule(function (module) {
  var META = _uid('meta');

  var setDesc = _objectDp.f;
  var id = 0;
  var isExtensible = Object.isExtensible || function () {
    return true;
  };
  var FREEZE = !_fails(function () {
    return isExtensible(Object.preventExtensions({}));
  });
  var setMeta = function setMeta(it) {
    setDesc(it, META, { value: {
        i: 'O' + ++id, // object ID
        w: {} // weak collections IDs
      } });
  };
  var fastKey = function fastKey(it, create) {
    // return primitive with prefix
    if (!_isObject(it)) return (typeof it === 'undefined' ? 'undefined' : _typeof(it)) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return 'F';
      // not necessary to add metadata
      if (!create) return 'E';
      // add missing metadata
      setMeta(it);
      // return object ID
    }return it[META].i;
  };
  var getWeak = function getWeak(it, create) {
    if (!_has(it, META)) {
      // can't set metadata to uncaught frozen object
      if (!isExtensible(it)) return true;
      // not necessary to add metadata
      if (!create) return false;
      // add missing metadata
      setMeta(it);
      // return hash weak collections IDs
    }return it[META].w;
  };
  // add metadata on freeze-family methods calling
  var onFreeze = function onFreeze(it) {
    if (FREEZE && meta.NEED && isExtensible(it) && !_has(it, META)) setMeta(it);
    return it;
  };
  var meta = module.exports = {
    KEY: META,
    NEED: false,
    fastKey: fastKey,
    getWeak: getWeak,
    onFreeze: onFreeze
  };
});

var _meta_1 = _meta.KEY;
var _meta_2 = _meta.NEED;
var _meta_3 = _meta.fastKey;
var _meta_4 = _meta.getWeak;
var _meta_5 = _meta.onFreeze;

var _validateCollection = function _validateCollection(it, TYPE) {
  if (!_isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

var dP$1 = _objectDp.f;

var fastKey = _meta.fastKey;

var SIZE = _descriptors ? '_s' : 'size';

var getEntry = function getEntry(that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

var _collectionStrong = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      _anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type
      that._i = _objectCreate(null); // index
      that._f = undefined; // first entry
      that._l = undefined; // last entry
      that[SIZE] = 0; // size
      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
    });
    _redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = _validateCollection(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = _validateCollection(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        _validateCollection(this, NAME);
        var f = _ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) {
            entry = entry.p;
          }
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(_validateCollection(this, NAME), key);
      }
    });
    if (_descriptors) dP$1(C.prototype, 'size', {
      get: function get() {
        return _validateCollection(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
      // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key, // <- key
        v: value, // <- value
        p: prev = that._l, // <- previous entry
        n: undefined, // <- next entry
        r: false // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    }return that;
  },
  getEntry: getEntry,
  setStrong: function setStrong(C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    _iterDefine(C, NAME, function (iterated, kind) {
      this._t = _validateCollection(iterated, NAME); // target
      this._k = kind; // kind
      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) {
        entry = entry.p;
      } // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return _iterStep(1);
      }
      // return step by kind
      if (kind == 'keys') return _iterStep(0, entry.k);
      if (kind == 'values') return _iterStep(0, entry.v);
      return _iterStep(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    _setSpecies(NAME);
  }
};

var ITERATOR$4 = _wks('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR$4]();
  riter['return'] = function () {
    SAFE_CLOSING = true;
  };
  // eslint-disable-next-line no-throw-literal
  
} catch (e) {/* empty */}

var _iterDetect = function _iterDetect(exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR$4]();
    iter.next = function () {
      return { done: safe = true };
    };
    arr[ITERATOR$4] = function () {
      return iter;
    };
    exec(arr);
  } catch (e) {/* empty */}
  return safe;
};

var setPrototypeOf$2 = _setProto.set;
var _inheritIfRequired = function _inheritIfRequired(that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && _isObject(P) && setPrototypeOf$2) {
    setPrototypeOf$2(that, P);
  }return that;
};

var _collection = function _collection(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = _global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function fixMethod(KEY) {
    var fn = proto[KEY];
    _redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !_isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !_isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);return this;
    });
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !_fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    _redefineAll(C.prototype, methods);
    _meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = _fails(function () {
      instance.has(1);
    });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = _iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && _fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) {
        $instance[ADDER](index, index);
      }return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        _anInstance(target, C, NAME);
        var that = _inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  _setToStringTag(C, NAME);

  O[NAME] = C;
  _export(_export.G + _export.W + _export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

var SET = 'Set';

// 23.2 Set Objects
var es6_set = _collection(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return _collectionStrong.def(_validateCollection(this, SET), value = value === 0 ? 0 : value, value);
  }
}, _collectionStrong);

var _arrayFromIterable = function _arrayFromIterable(iter, ITERATOR) {
  var result = [];
  _forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

// https://github.com/DavidBruant/Map-Set.prototype.toJSON


var _collectionToJson = function _collectionToJson(NAME) {
  return function toJSON() {
    if (_classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return _arrayFromIterable(this);
  };
};

// https://github.com/DavidBruant/Map-Set.prototype.toJSON


_export(_export.P + _export.R, 'Set', { toJSON: _collectionToJson('Set') });

// https://tc39.github.io/proposal-setmap-offrom/


var _setCollectionOf = function _setCollectionOf(COLLECTION) {
  _export(_export.S, COLLECTION, { of: function of() {
      var length = arguments.length;
      var A = Array(length);
      while (length--) {
        A[length] = arguments[length];
      }return new this(A);
    } });
};

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
_setCollectionOf('Set');

// https://tc39.github.io/proposal-setmap-offrom/


var _setCollectionFrom = function _setCollectionFrom(COLLECTION) {
  _export(_export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
      var mapFn = arguments[1];
      var mapping, A, n, cb;
      _aFunction(this);
      mapping = mapFn !== undefined;
      if (mapping) _aFunction(mapFn);
      if (source == undefined) return new this();
      A = [];
      if (mapping) {
        n = 0;
        cb = _ctx(mapFn, arguments[2], 2);
        _forOf(source, false, function (nextItem) {
          A.push(cb(nextItem, n++));
        });
      } else {
        _forOf(source, false, A.push, A);
      }
      return new this(A);
    } });
};

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
_setCollectionFrom('Set');

var set$1 = _core.Set;

var MAP = 'Map';

// 23.1 Map Objects
var es6_map = _collection(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = _collectionStrong.getEntry(_validateCollection(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return _collectionStrong.def(_validateCollection(this, MAP), key === 0 ? 0 : key, value);
  }
}, _collectionStrong, true);

// https://github.com/DavidBruant/Map-Set.prototype.toJSON


_export(_export.P + _export.R, 'Map', { toJSON: _collectionToJson('Map') });

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
_setCollectionOf('Map');

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
_setCollectionFrom('Map');

var map = _core.Map;

// 7.2.2 IsArray(argument)

var _isArray = Array.isArray || function isArray(arg) {
  return _cof(arg) == 'Array';
};

var SPECIES$1 = _wks('species');

var _arraySpeciesConstructor = function _arraySpeciesConstructor(original) {
  var C;
  if (_isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || _isArray(C.prototype))) C = undefined;
    if (_isObject(C)) {
      C = C[SPECIES$1];
      if (C === null) C = undefined;
    }
  }return C === undefined ? Array : C;
};

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)


var _arraySpeciesCreate = function _arraySpeciesCreate(original, length) {
  return new (_arraySpeciesConstructor(original))(length);
};

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex


var _arrayMethods = function _arrayMethods(TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || _arraySpeciesCreate;
  return function ($this, callbackfn, that) {
    var O = _toObject($this);
    var self = _iobject(O);
    var f = _ctx(callbackfn, that, 3);
    var length = _toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);
        if (TYPE) {
          if (IS_MAP) result[index] = res; // map
          else if (res) switch (TYPE) {
              case 3:
                return true; // some
              case 5:
                return val; // find
              case 6:
                return index; // findIndex
              case 2:
                result.push(val); // filter
            } else if (IS_EVERY) return false; // every
        }
      }
    }return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

var f$3 = Object.getOwnPropertySymbols;

var _objectGops = {
	f: f$3
};

// 19.1.2.1 Object.assign(target, source, ...)


var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
var _objectAssign = !$assign || _fails(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = _toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = _objectGops.f;
  var isEnum = _objectPie.f;
  while (aLen > index) {
    var S = _iobject(arguments[index++]);
    var keys = getSymbols ? _objectKeys(S).concat(getSymbols(S)) : _objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
    }
  }return T;
} : $assign;

var getWeak = _meta.getWeak;

var arrayFind = _arrayMethods(5);
var arrayFindIndex = _arrayMethods(6);
var id$1 = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.a = [];
};
var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function get(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function has(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function _delete(key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

var _collectionWeak = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      _anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type
      that._i = id$1++; // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) _forOf(iterable, IS_MAP, that[ADDER], that);
    });
    _redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function _delete(key) {
        if (!_isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME))['delete'](key);
        return data && _has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!_isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(_validateCollection(this, NAME)).has(key);
        return data && _has(data, this._i);
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var data = getWeak(_anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

var es6_weakMap = createCommonjsModule(function (module) {
  var each = _arrayMethods(0);

  var WEAK_MAP = 'WeakMap';
  var getWeak = _meta.getWeak;
  var isExtensible = Object.isExtensible;
  var uncaughtFrozenStore = _collectionWeak.ufstore;
  var tmp = {};
  var InternalMap;

  var wrapper = function wrapper(get) {
    return function WeakMap() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  };

  var methods = {
    // 23.3.3.3 WeakMap.prototype.get(key)
    get: function get(key) {
      if (_isObject(key)) {
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(_validateCollection(this, WEAK_MAP)).get(key);
        return data ? data[this._i] : undefined;
      }
    },
    // 23.3.3.5 WeakMap.prototype.set(key, value)
    set: function set(key, value) {
      return _collectionWeak.def(_validateCollection(this, WEAK_MAP), key, value);
    }
  };

  // 23.3 WeakMap Objects
  var $WeakMap = module.exports = _collection(WEAK_MAP, wrapper, methods, _collectionWeak, true, true);

  // IE11 WeakMap frozen keys fix
  if (_fails(function () {
    return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
  })) {
    InternalMap = _collectionWeak.getConstructor(wrapper, WEAK_MAP);
    _objectAssign(InternalMap.prototype, methods);
    _meta.NEED = true;
    each(['delete', 'has', 'get', 'set'], function (key) {
      var proto = $WeakMap.prototype;
      var method = proto[key];
      _redefine(proto, key, function (a, b) {
        // store frozen objects on internal weakmap shim
        if (_isObject(a) && !isExtensible(a)) {
          if (!this._f) this._f = new InternalMap();
          var result = this._f[key](a, b);
          return key == 'set' ? this : result;
          // store all the rest on native weakmap
        }return method.call(this, a, b);
      });
    });
  }
});

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
_setCollectionOf('WeakMap');

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
_setCollectionFrom('WeakMap');

var weakMap = _core.WeakMap;

var _createProperty = function _createProperty(object, index, value) {
  if (index in object) _objectDp.f(object, index, _propertyDesc(0, value));else object[index] = value;
};

_export(_export.S + _export.F * !_iterDetect(function (iter) {
  
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = _toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = core_getIteratorMethod(O);
    var length, result, step, iterator;
    if (mapping) mapfn = _ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && _isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        _createProperty(result, index, mapping ? _iterCall(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = _toLength(O.length);
      for (result = new C(length); length > index; index++) {
        _createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

var from$1 = _core.Array.from;

var reservedTagList = new Set(['annotation-xml', 'color-profile', 'font-face', 'font-face-src', 'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph']);

/**
 * @param {string} localName
 * @returns {boolean}
 */
function isValidCustomElementName(localName) {
  var reserved = reservedTagList.has(localName);
  var validForm = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(localName);
  return !reserved && validForm;
}

/**
 * @private
 * @param {!Node} node
 * @return {boolean}
 */
function isConnected(node) {
  // Use `Node#isConnected`, if defined.
  var nativeValue = node.isConnected;
  if (nativeValue !== undefined) {
    return nativeValue;
  }

  /** @type {?Node|undefined} */
  var current = node;
  while (current && !(current.__CE_isImportDocument || current instanceof Document)) {
    current = current.parentNode || (window.ShadowRoot && current instanceof ShadowRoot ? current.host : undefined);
  }
  return !!(current && (current.__CE_isImportDocument || current instanceof Document));
}

/**
 * @param {!Node} root
 * @param {!Node} start
 * @return {?Node}
 */
function nextSiblingOrAncestorSibling(root, start) {
  var node = start;
  while (node && node !== root && !node.nextSibling) {
    node = node.parentNode;
  }
  return !node || node === root ? null : node.nextSibling;
}

/**
 * @param {!Node} root
 * @param {!Node} start
 * @return {?Node}
 */
function nextNode(root, start) {
  return start.firstChild ? start.firstChild : nextSiblingOrAncestorSibling(root, start);
}

/**
 * @param {!Node} root
 * @param {!function(!Element)} callback
 * @param {!Set<Node>=} visitedImports
 */
function walkDeepDescendantElements(root, callback) {
  var visitedImports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();

  var node = root;
  while (node) {
    if (node.nodeType === Node.ELEMENT_NODE) {
      var element = /** @type {!Element} */node;

      callback(element);

      var localName = element.localName;
      if (localName === 'link' && element.getAttribute('rel') === 'import') {
        // If this import (polyfilled or not) has it's root node available,
        // walk it.
        var importNode = /** @type {!Node} */element.import;
        if (importNode instanceof Node && !visitedImports.has(importNode)) {
          // Prevent multiple walks of the same import root.
          visitedImports.add(importNode);

          for (var child = importNode.firstChild; child; child = child.nextSibling) {
            walkDeepDescendantElements(child, callback, visitedImports);
          }
        }

        // Ignore descendants of import links to prevent attempting to walk the
        // elements created by the HTML Imports polyfill that we just walked
        // above.
        node = nextSiblingOrAncestorSibling(root, element);
        continue;
      } else if (localName === 'template') {
        // Ignore descendants of templates. There shouldn't be any descendants
        // because they will be moved into `.content` during construction in
        // browsers that support template but, in case they exist and are still
        // waiting to be moved by a polyfill, they will be ignored.
        node = nextSiblingOrAncestorSibling(root, element);
        continue;
      }

      // Walk shadow roots.
      var shadowRoot = element.__CE_shadowRoot;
      if (shadowRoot) {
        for (var _child = shadowRoot.firstChild; _child; _child = _child.nextSibling) {
          walkDeepDescendantElements(_child, callback, visitedImports);
        }
      }
    }

    node = nextNode(root, node);
  }
}

/**
 * Used to suppress Closure's "Modifying the prototype is only allowed if the
 * constructor is in the same scope" warning without using
 * `@suppress {newCheckTypes, duplicate}` because `newCheckTypes` is too broad.
 *
 * @param {!Object} destination
 * @param {string} name
 * @param {*} value
 */
function setPropertyUnchecked(destination, name, value) {
  destination[name] = value;
}

/**
 * @enum {number}
 */
var CustomElementState = {
  custom: 1,
  failed: 2
};

var CustomElementInternals = function () {
  function CustomElementInternals() {
    classCallCheck(this, CustomElementInternals);

    /** @type {!Map<string, !CustomElementDefinition>} */
    this._localNameToDefinition = new Map();

    /** @type {!Map<!Function, !CustomElementDefinition>} */
    this._constructorToDefinition = new Map();

    /** @type {!Array<!function(!Node)>} */
    this._patches = [];

    /** @type {boolean} */
    this._hasPatches = false;
  }

  /**
   * @param {string} localName
   * @param {!CustomElementDefinition} definition
   */


  createClass(CustomElementInternals, [{
    key: 'setDefinition',
    value: function setDefinition(localName, definition) {
      this._localNameToDefinition.set(localName, definition);
      this._constructorToDefinition.set(definition.constructor, definition);
    }

    /**
     * @param {string} localName
     * @return {!CustomElementDefinition|undefined}
     */

  }, {
    key: 'localNameToDefinition',
    value: function localNameToDefinition(localName) {
      return this._localNameToDefinition.get(localName);
    }

    /**
     * @param {!Function} constructor
     * @return {!CustomElementDefinition|undefined}
     */

  }, {
    key: 'constructorToDefinition',
    value: function constructorToDefinition(constructor) {
      return this._constructorToDefinition.get(constructor);
    }

    /**
     * @param {!function(!Node)} listener
     */

  }, {
    key: 'addPatch',
    value: function addPatch(listener) {
      this._hasPatches = true;
      this._patches.push(listener);
    }

    /**
     * @param {!Node} node
     */

  }, {
    key: 'patchTree',
    value: function patchTree(node) {
      var _this = this;

      if (!this._hasPatches) return;

      walkDeepDescendantElements(node, function (element) {
        return _this.patch(element);
      });
    }

    /**
     * @param {!Node} node
     */

  }, {
    key: 'patch',
    value: function patch(node) {
      if (!this._hasPatches) return;

      if (node.__CE_patched) return;
      node.__CE_patched = true;

      for (var i = 0; i < this._patches.length; i++) {
        this._patches[i](node);
      }
    }

    /**
     * @param {!Node} root
     */

  }, {
    key: 'connectTree',
    value: function connectTree(root) {
      var elements = [];

      walkDeepDescendantElements(root, function (element) {
        return elements.push(element);
      });

      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        if (element.__CE_state === CustomElementState.custom) {
          if (isConnected(element)) {
            this.connectedCallback(element);
          }
        } else {
          this.upgradeElement(element);
        }
      }
    }

    /**
     * @param {!Node} root
     */

  }, {
    key: 'disconnectTree',
    value: function disconnectTree(root) {
      var elements = [];

      walkDeepDescendantElements(root, function (element) {
        return elements.push(element);
      });

      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        if (element.__CE_state === CustomElementState.custom) {
          this.disconnectedCallback(element);
        }
      }
    }

    /**
     * Upgrades all uncustomized custom elements at and below a root node for
     * which there is a definition. When custom element reaction callbacks are
     * assumed to be called synchronously (which, by the current DOM / HTML spec
     * definitions, they are *not*), callbacks for both elements customized
     * synchronously by the parser and elements being upgraded occur in the same
     * relative order.
     *
     * NOTE: This function, when used to simulate the construction of a tree that
     * is already created but not customized (i.e. by the parser), does *not*
     * prevent the element from reading the 'final' (true) state of the tree. For
     * example, the element, during truly synchronous parsing / construction would
     * see that it contains no children as they have not yet been inserted.
     * However, this function does not modify the tree, the element will
     * (incorrectly) have children. Additionally, self-modification restrictions
     * for custom element constructors imposed by the DOM spec are *not* enforced.
     *
     *
     * The following nested list shows the steps extending down from the HTML
     * spec's parsing section that cause elements to be synchronously created and
     * upgraded:
     *
     * The "in body" insertion mode:
     * https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
     * - Switch on token:
     *   .. other cases ..
     *   -> Any other start tag
     *      - [Insert an HTML element](below) for the token.
     *
     * Insert an HTML element:
     * https://html.spec.whatwg.org/multipage/syntax.html#insert-an-html-element
     * - Insert a foreign element for the token in the HTML namespace:
     *   https://html.spec.whatwg.org/multipage/syntax.html#insert-a-foreign-element
     *   - Create an element for a token:
     *     https://html.spec.whatwg.org/multipage/syntax.html#create-an-element-for-the-token
     *     - Will execute script flag is true?
     *       - (Element queue pushed to the custom element reactions stack.)
     *     - Create an element:
     *       https://dom.spec.whatwg.org/#concept-create-element
     *       - Sync CE flag is true?
     *         - Constructor called.
     *         - Self-modification restrictions enforced.
     *       - Sync CE flag is false?
     *         - (Upgrade reaction enqueued.)
     *     - Attributes appended to element.
     *       (`attributeChangedCallback` reactions enqueued.)
     *     - Will execute script flag is true?
     *       - (Element queue popped from the custom element reactions stack.
     *         Reactions in the popped stack are invoked.)
     *   - (Element queue pushed to the custom element reactions stack.)
     *   - Insert the element:
     *     https://dom.spec.whatwg.org/#concept-node-insert
     *     - Shadow-including descendants are connected. During parsing
     *       construction, there are no shadow-*excluding* descendants.
     *       However, the constructor may have validly attached a shadow
     *       tree to itself and added descendants to that shadow tree.
     *       (`connectedCallback` reactions enqueued.)
     *   - (Element queue popped from the custom element reactions stack.
     *     Reactions in the popped stack are invoked.)
     *
     * @param {!Node} root
     * @param {!Set<Node>=} visitedImports
     */

  }, {
    key: 'patchAndUpgradeTree',
    value: function patchAndUpgradeTree(root) {
      var _this2 = this;

      var visitedImports = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

      var elements = [];

      var gatherElements = function gatherElements(element) {
        if (element.localName === 'link' && element.getAttribute('rel') === 'import') {
          // The HTML Imports polyfill sets a descendant element of the link to
          // the `import` property, specifically this is *not* a Document.
          var importNode = /** @type {?Node} */element.import;

          if (importNode instanceof Node && importNode.readyState === 'complete') {
            importNode.__CE_isImportDocument = true;

            // Connected links are associated with the registry.
            importNode.__CE_hasRegistry = true;
          } else {
            // If this link's import root is not available, its contents can't be
            // walked. Wait for 'load' and walk it when it's ready.
            element.addEventListener('load', function () {
              var importNode = /** @type {!Node} */element.import;

              if (importNode.__CE_documentLoadHandled) return;
              importNode.__CE_documentLoadHandled = true;

              importNode.__CE_isImportDocument = true;

              // Connected links are associated with the registry.
              importNode.__CE_hasRegistry = true;

              // Clone the `visitedImports` set that was populated sync during
              // the `patchAndUpgradeTree` call that caused this 'load' handler to
              // be added. Then, remove *this* link's import node so that we can
              // walk that import again, even if it was partially walked later
              // during the same `patchAndUpgradeTree` call.
              visitedImports.delete(importNode);

              _this2.patchAndUpgradeTree(importNode, visitedImports);
            });
          }
        } else {
          elements.push(element);
        }
      };

      // `walkDeepDescendantElements` populates (and internally checks against)
      // `visitedImports` when traversing a loaded import.
      walkDeepDescendantElements(root, gatherElements, visitedImports);

      if (this._hasPatches) {
        for (var i = 0; i < elements.length; i++) {
          this.patch(elements[i]);
        }
      }

      for (var _i = 0; _i < elements.length; _i++) {
        this.upgradeElement(elements[_i]);
      }
    }

    /**
     * @param {!Element} element
     */

  }, {
    key: 'upgradeElement',
    value: function upgradeElement(element) {
      var currentState = element.__CE_state;
      if (currentState !== undefined) return;

      var definition = this.localNameToDefinition(element.localName);
      if (!definition) return;

      definition.constructionStack.push(element);

      var constructor = definition.constructor;
      try {
        try {
          var result = new constructor();
          if (result !== element) {
            throw new Error('The custom element constructor did not produce the element being upgraded.');
          }
        } finally {
          definition.constructionStack.pop();
        }
      } catch (e) {
        element.__CE_state = CustomElementState.failed;
        throw e;
      }

      element.__CE_state = CustomElementState.custom;
      element.__CE_definition = definition;

      if (definition.attributeChangedCallback) {
        var observedAttributes = definition.observedAttributes;
        for (var i = 0; i < observedAttributes.length; i++) {
          var name = observedAttributes[i];
          var value = element.getAttribute(name);
          if (value !== null) {
            this.attributeChangedCallback(element, name, null, value, null);
          }
        }
      }

      if (isConnected(element)) {
        this.connectedCallback(element);
      }
    }

    /**
     * @param {!Element} element
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback(element) {
      var definition = element.__CE_definition;
      if (definition.connectedCallback) {
        definition.connectedCallback.call(element);
      }

      element.__CE_isConnectedCallbackCalled = true;
    }

    /**
     * @param {!Element} element
     */

  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback(element) {
      if (!element.__CE_isConnectedCallbackCalled) {
        this.connectedCallback(element);
      }

      var definition = element.__CE_definition;
      if (definition.disconnectedCallback) {
        definition.disconnectedCallback.call(element);
      }

      element.__CE_isConnectedCallbackCalled = undefined;
    }

    /**
     * @param {!Element} element
     * @param {string} name
     * @param {?string} oldValue
     * @param {?string} newValue
     * @param {?string} namespace
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(element, name, oldValue, newValue, namespace) {
      var definition = element.__CE_definition;
      if (definition.attributeChangedCallback && definition.observedAttributes.indexOf(name) > -1) {
        definition.attributeChangedCallback.call(element, name, oldValue, newValue, namespace);
      }
    }
  }]);
  return CustomElementInternals;
}();

var DocumentConstructionObserver = function () {
  function DocumentConstructionObserver(internals, doc) {
    classCallCheck(this, DocumentConstructionObserver);

    /**
     * @type {!CustomElementInternals}
     */
    this._internals = internals;

    /**
     * @type {!Document}
     */
    this._document = doc;

    /**
     * @type {MutationObserver|undefined}
     */
    this._observer = undefined;

    // Simulate tree construction for all currently accessible nodes in the
    // document.
    this._internals.patchAndUpgradeTree(this._document);

    if (this._document.readyState === 'loading') {
      this._observer = new MutationObserver(this._handleMutations.bind(this));

      // Nodes created by the parser are given to the observer *before* the next
      // task runs. Inline scripts are run in a new task. This means that the
      // observer will be able to handle the newly parsed nodes before the inline
      // script is run.
      this._observer.observe(this._document, {
        childList: true,
        subtree: true
      });
    }
  }

  createClass(DocumentConstructionObserver, [{
    key: 'disconnect',
    value: function disconnect() {
      if (this._observer) {
        this._observer.disconnect();
      }
    }

    /**
     * @param {!Array<!MutationRecord>} mutations
     */

  }, {
    key: '_handleMutations',
    value: function _handleMutations(mutations) {
      // Once the document's `readyState` is 'interactive' or 'complete', all new
      // nodes created within that document will be the result of script and
      // should be handled by patching.
      var readyState = this._document.readyState;
      if (readyState === 'interactive' || readyState === 'complete') {
        this.disconnect();
      }

      for (var i = 0; i < mutations.length; i++) {
        var addedNodes = mutations[i].addedNodes;
        for (var j = 0; j < addedNodes.length; j++) {
          var node = addedNodes[j];
          this._internals.patchAndUpgradeTree(node);
        }
      }
    }
  }]);
  return DocumentConstructionObserver;
}();

/**
 * @template T
 */
var Deferred = function () {
  function Deferred() {
    var _this = this;

    classCallCheck(this, Deferred);

    /**
     * @private
     * @type {T|undefined}
     */
    this._value = undefined;

    /**
     * @private
     * @type {Function|undefined}
     */
    this._resolve = undefined;

    /**
     * @private
     * @type {!Promise<T>}
     */
    this._promise = new Promise(function (resolve) {
      _this._resolve = resolve;

      if (_this._value) {
        resolve(_this._value);
      }
    });
  }

  /**
   * @param {T} value
   */


  createClass(Deferred, [{
    key: 'resolve',
    value: function resolve(value) {
      if (this._value) {
        throw new Error('Already resolved.');
      }

      this._value = value;

      if (this._resolve) {
        this._resolve(value);
      }
    }

    /**
     * @return {!Promise<T>}
     */

  }, {
    key: 'toPromise',
    value: function toPromise() {
      return this._promise;
    }
  }]);
  return Deferred;
}();

/**
 * @unrestricted
 */

var CustomElementRegistry = function () {

  /**
   * @param {!CustomElementInternals} internals
   */
  function CustomElementRegistry(internals) {
    classCallCheck(this, CustomElementRegistry);

    /**
     * @private
     * @type {boolean}
     */
    this._elementDefinitionIsRunning = false;

    /**
     * @private
     * @type {!CustomElementInternals}
     */
    this._internals = internals;

    /**
     * @private
     * @type {!Map<string, !Deferred<undefined>>}
     */
    this._whenDefinedDeferred = new Map();

    /**
     * The default flush callback triggers the document walk synchronously.
     * @private
     * @type {!Function}
     */
    this._flushCallback = function (fn) {
      return fn();
    };

    /**
     * @private
     * @type {boolean}
     */
    this._flushPending = false;

    /**
     * @private
     * @type {!Array<string>}
     */
    this._unflushedLocalNames = [];

    /**
     * @private
     * @type {!DocumentConstructionObserver}
     */
    this._documentConstructionObserver = new DocumentConstructionObserver(internals, document);
  }

  /**
   * @param {string} localName
   * @param {!Function} constructor
   */


  createClass(CustomElementRegistry, [{
    key: 'define',
    value: function define(localName, constructor) {
      var _this = this;

      if (!(constructor instanceof Function)) {
        throw new TypeError('Custom element constructors must be functions.');
      }

      if (!isValidCustomElementName(localName)) {
        throw new SyntaxError('The element name \'' + localName + '\' is not valid.');
      }

      if (this._internals.localNameToDefinition(localName)) {
        throw new Error('A custom element with name \'' + localName + '\' has already been defined.');
      }

      if (this._elementDefinitionIsRunning) {
        throw new Error('A custom element is already being defined.');
      }
      this._elementDefinitionIsRunning = true;

      var connectedCallback = void 0;
      var disconnectedCallback = void 0;
      var adoptedCallback = void 0;
      var attributeChangedCallback = void 0;
      var observedAttributes = void 0;
      try {
        var getCallback = function getCallback(name) {
          var callbackValue = prototype[name];
          if (callbackValue !== undefined && !(callbackValue instanceof Function)) {
            throw new Error('The \'' + name + '\' callback must be a function.');
          }
          return callbackValue;
        };

        /** @type {!Object} */
        var prototype = constructor.prototype;
        if (!(prototype instanceof Object)) {
          throw new TypeError('The custom element constructor\'s prototype is not an object.');
        }

        connectedCallback = getCallback('connectedCallback');
        disconnectedCallback = getCallback('disconnectedCallback');
        adoptedCallback = getCallback('adoptedCallback');
        attributeChangedCallback = getCallback('attributeChangedCallback');
        observedAttributes = constructor['observedAttributes'] || [];
      } catch (e) {
        return;
      } finally {
        this._elementDefinitionIsRunning = false;
      }

      var definition = {
        localName: localName,
        constructor: constructor,
        connectedCallback: connectedCallback,
        disconnectedCallback: disconnectedCallback,
        adoptedCallback: adoptedCallback,
        attributeChangedCallback: attributeChangedCallback,
        observedAttributes: observedAttributes,
        constructionStack: []
      };

      this._internals.setDefinition(localName, definition);

      this._unflushedLocalNames.push(localName);

      // If we've already called the flush callback and it hasn't called back yet,
      // don't call it again.
      if (!this._flushPending) {
        this._flushPending = true;
        this._flushCallback(function () {
          return _this._flush();
        });
      }
    }
  }, {
    key: '_flush',
    value: function _flush() {
      // If no new definitions were defined, don't attempt to flush. This could
      // happen if a flush callback keeps the function it is given and calls it
      // multiple times.
      if (this._flushPending === false) return;

      this._flushPending = false;
      this._internals.patchAndUpgradeTree(document);

      while (this._unflushedLocalNames.length > 0) {
        var localName = this._unflushedLocalNames.shift();
        var deferred = this._whenDefinedDeferred.get(localName);
        if (deferred) {
          deferred.resolve(undefined);
        }
      }
    }

    /**
     * @param {string} localName
     * @return {Function|undefined}
     */

  }, {
    key: 'get',
    value: function get$$1(localName) {
      var definition = this._internals.localNameToDefinition(localName);
      if (definition) {
        return definition.constructor;
      }

      return undefined;
    }

    /**
     * @param {string} localName
     * @return {!Promise<undefined>}
     */

  }, {
    key: 'whenDefined',
    value: function whenDefined(localName) {
      if (!isValidCustomElementName(localName)) {
        return Promise.reject(new SyntaxError('\'' + localName + '\' is not a valid custom element name.'));
      }

      var prior = this._whenDefinedDeferred.get(localName);
      if (prior) {
        return prior.toPromise();
      }

      var deferred = new Deferred();
      this._whenDefinedDeferred.set(localName, deferred);

      var definition = this._internals.localNameToDefinition(localName);
      // Resolve immediately only if the given local name has a definition *and*
      // the full document walk to upgrade elements with that local name has
      // already happened.
      if (definition && this._unflushedLocalNames.indexOf(localName) === -1) {
        deferred.resolve(undefined);
      }

      return deferred.toPromise();
    }
  }, {
    key: 'polyfillWrapFlushCallback',
    value: function polyfillWrapFlushCallback(outer) {
      this._documentConstructionObserver.disconnect();
      var inner = this._flushCallback;
      this._flushCallback = function (flush) {
        return outer(function () {
          return inner(flush);
        });
      };
    }
  }]);
  return CustomElementRegistry;
}();

window['CustomElementRegistry'] = CustomElementRegistry;
CustomElementRegistry.prototype['define'] = CustomElementRegistry.prototype.define;
CustomElementRegistry.prototype['get'] = CustomElementRegistry.prototype.get;
CustomElementRegistry.prototype['whenDefined'] = CustomElementRegistry.prototype.whenDefined;
CustomElementRegistry.prototype['polyfillWrapFlushCallback'] = CustomElementRegistry.prototype.polyfillWrapFlushCallback;

var Native = {
  Document_createElement: window.Document.prototype.createElement,
  Document_createElementNS: window.Document.prototype.createElementNS,
  Document_importNode: window.Document.prototype.importNode,
  Document_prepend: window.Document.prototype['prepend'],
  Document_append: window.Document.prototype['append'],
  Node_cloneNode: window.Node.prototype.cloneNode,
  Node_appendChild: window.Node.prototype.appendChild,
  Node_insertBefore: window.Node.prototype.insertBefore,
  Node_removeChild: window.Node.prototype.removeChild,
  Node_replaceChild: window.Node.prototype.replaceChild,
  Node_textContent: Object.getOwnPropertyDescriptor(window.Node.prototype, 'textContent'),
  Element_attachShadow: window.Element.prototype['attachShadow'],
  Element_innerHTML: Object.getOwnPropertyDescriptor(window.Element.prototype, 'innerHTML'),
  Element_getAttribute: window.Element.prototype.getAttribute,
  Element_setAttribute: window.Element.prototype.setAttribute,
  Element_removeAttribute: window.Element.prototype.removeAttribute,
  Element_getAttributeNS: window.Element.prototype.getAttributeNS,
  Element_setAttributeNS: window.Element.prototype.setAttributeNS,
  Element_removeAttributeNS: window.Element.prototype.removeAttributeNS,
  Element_insertAdjacentElement: window.Element.prototype['insertAdjacentElement'],
  Element_prepend: window.Element.prototype['prepend'],
  Element_append: window.Element.prototype['append'],
  Element_before: window.Element.prototype['before'],
  Element_after: window.Element.prototype['after'],
  Element_replaceWith: window.Element.prototype['replaceWith'],
  Element_remove: window.Element.prototype['remove'],
  HTMLElement: window.HTMLElement,
  HTMLElement_innerHTML: Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, 'innerHTML'),
  HTMLElement_insertAdjacentElement: window.HTMLElement.prototype['insertAdjacentElement']
};

/**
 * This class exists only to work around Closure's lack of a way to describe
 * singletons. It represents the 'already constructed marker' used in custom
 * element construction stacks.
 *
 * https://html.spec.whatwg.org/#concept-already-constructed-marker
 */
var AlreadyConstructedMarker = function AlreadyConstructedMarker() {
  classCallCheck(this, AlreadyConstructedMarker);
};

var AlreadyConstructedMarker$1 = new AlreadyConstructedMarker();

/**
 * @param {!CustomElementInternals} internals
 */
var PatchHTMLElement = function (internals) {
  window['HTMLElement'] = function () {
    /**
     * @type {function(new: HTMLElement): !HTMLElement}
     */
    function HTMLElement() {
      // This should really be `new.target` but `new.target` can't be emulated
      // in ES5. Assuming the user keeps the default value of the constructor's
      // prototype's `constructor` property, this is equivalent.
      /** @type {!Function} */
      var constructor = this.constructor;

      var definition = internals.constructorToDefinition(constructor);
      if (!definition) {
        throw new Error('The custom element being constructed was not registered with `customElements`.');
      }

      var constructionStack = definition.constructionStack;

      if (constructionStack.length === 0) {
        var _element = Native.Document_createElement.call(document, definition.localName);
        Object.setPrototypeOf(_element, constructor.prototype);
        _element.__CE_state = CustomElementState.custom;
        _element.__CE_definition = definition;
        internals.patch(_element);
        return _element;
      }

      var lastIndex = constructionStack.length - 1;
      var element = constructionStack[lastIndex];
      if (element === AlreadyConstructedMarker$1) {
        throw new Error('The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.');
      }
      constructionStack[lastIndex] = AlreadyConstructedMarker$1;

      Object.setPrototypeOf(element, constructor.prototype);
      internals.patch( /** @type {!HTMLElement} */element);

      return element;
    }

    HTMLElement.prototype = Native.HTMLElement.prototype;

    return HTMLElement;
  }();
};

/**
 * @param {!CustomElementInternals} internals
 * @param {!Object} destination
 * @param {!ParentNodeNativeMethods} builtIn
 */
var PatchParentNode = function (internals, destination, builtIn) {
  /**
   * @param {...(!Node|string)} nodes
   */
  destination['prepend'] = function () {
    for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
      nodes[_key] = arguments[_key];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.prepend.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i = 0; _i < nodes.length; _i++) {
        var node = nodes[_i];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  /**
   * @param {...(!Node|string)} nodes
   */
  destination['append'] = function () {
    for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      nodes[_key2] = arguments[_key2];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.append.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i2 = 0; _i2 < nodes.length; _i2++) {
        var node = nodes[_i2];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };
};

/**
 * @param {!CustomElementInternals} internals
 */
var PatchDocument = function (internals) {
  setPropertyUnchecked(Document.prototype, 'createElement',
  /**
   * @this {Document}
   * @param {string} localName
   * @return {!Element}
   */
  function (localName) {
    // Only create custom elements if this document is associated with the registry.
    if (this.__CE_hasRegistry) {
      var definition = internals.localNameToDefinition(localName);
      if (definition) {
        return new definition.constructor();
      }
    }

    var result = /** @type {!Element} */
    Native.Document_createElement.call(this, localName);
    internals.patch(result);
    return result;
  });

  setPropertyUnchecked(Document.prototype, 'importNode',
  /**
   * @this {Document}
   * @param {!Node} node
   * @param {boolean=} deep
   * @return {!Node}
   */
  function (node, deep) {
    var clone = Native.Document_importNode.call(this, node, deep);
    // Only create custom elements if this document is associated with the registry.
    if (!this.__CE_hasRegistry) {
      internals.patchTree(clone);
    } else {
      internals.patchAndUpgradeTree(clone);
    }
    return clone;
  });

  var NS_HTML = "http://www.w3.org/1999/xhtml";

  setPropertyUnchecked(Document.prototype, 'createElementNS',
  /**
   * @this {Document}
   * @param {?string} namespace
   * @param {string} localName
   * @return {!Element}
   */
  function (namespace, localName) {
    // Only create custom elements if this document is associated with the registry.
    if (this.__CE_hasRegistry && (namespace === null || namespace === NS_HTML)) {
      var definition = internals.localNameToDefinition(localName);
      if (definition) {
        return new definition.constructor();
      }
    }

    var result = /** @type {!Element} */
    Native.Document_createElementNS.call(this, namespace, localName);
    internals.patch(result);
    return result;
  });

  PatchParentNode(internals, Document.prototype, {
    prepend: Native.Document_prepend,
    append: Native.Document_append
  });
};

/**
 * @param {!CustomElementInternals} internals
 */
var PatchNode = function (internals) {
  // `Node#nodeValue` is implemented on `Attr`.
  // `Node#textContent` is implemented on `Attr`, `Element`.

  setPropertyUnchecked(Node.prototype, 'insertBefore',
  /**
   * @this {Node}
   * @param {!Node} node
   * @param {?Node} refNode
   * @return {!Node}
   */
  function (node, refNode) {
    if (node instanceof DocumentFragment) {
      var insertedNodes = Array.prototype.slice.apply(node.childNodes);
      var _nativeResult = Native.Node_insertBefore.call(this, node, refNode);

      // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (isConnected(this)) {
        for (var i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return _nativeResult;
    }

    var nodeWasConnected = isConnected(node);
    var nativeResult = Native.Node_insertBefore.call(this, node, refNode);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    if (isConnected(this)) {
      internals.connectTree(node);
    }

    return nativeResult;
  });

  setPropertyUnchecked(Node.prototype, 'appendChild',
  /**
   * @this {Node}
   * @param {!Node} node
   * @return {!Node}
   */
  function (node) {
    if (node instanceof DocumentFragment) {
      var insertedNodes = Array.prototype.slice.apply(node.childNodes);
      var _nativeResult2 = Native.Node_appendChild.call(this, node);

      // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (isConnected(this)) {
        for (var i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return _nativeResult2;
    }

    var nodeWasConnected = isConnected(node);
    var nativeResult = Native.Node_appendChild.call(this, node);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    if (isConnected(this)) {
      internals.connectTree(node);
    }

    return nativeResult;
  });

  setPropertyUnchecked(Node.prototype, 'cloneNode',
  /**
   * @this {Node}
   * @param {boolean=} deep
   * @return {!Node}
   */
  function (deep) {
    var clone = Native.Node_cloneNode.call(this, deep);
    // Only create custom elements if this element's owner document is
    // associated with the registry.
    if (!this.ownerDocument.__CE_hasRegistry) {
      internals.patchTree(clone);
    } else {
      internals.patchAndUpgradeTree(clone);
    }
    return clone;
  });

  setPropertyUnchecked(Node.prototype, 'removeChild',
  /**
   * @this {Node}
   * @param {!Node} node
   * @return {!Node}
   */
  function (node) {
    var nodeWasConnected = isConnected(node);
    var nativeResult = Native.Node_removeChild.call(this, node);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    return nativeResult;
  });

  setPropertyUnchecked(Node.prototype, 'replaceChild',
  /**
   * @this {Node}
   * @param {!Node} nodeToInsert
   * @param {!Node} nodeToRemove
   * @return {!Node}
   */
  function (nodeToInsert, nodeToRemove) {
    if (nodeToInsert instanceof DocumentFragment) {
      var insertedNodes = Array.prototype.slice.apply(nodeToInsert.childNodes);
      var _nativeResult3 = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);

      // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (isConnected(this)) {
        internals.disconnectTree(nodeToRemove);
        for (var i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return _nativeResult3;
    }

    var nodeToInsertWasConnected = isConnected(nodeToInsert);
    var nativeResult = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);
    var thisIsConnected = isConnected(this);

    if (thisIsConnected) {
      internals.disconnectTree(nodeToRemove);
    }

    if (nodeToInsertWasConnected) {
      internals.disconnectTree(nodeToInsert);
    }

    if (thisIsConnected) {
      internals.connectTree(nodeToInsert);
    }

    return nativeResult;
  });

  function patch_textContent(destination, baseDescriptor) {
    Object.defineProperty(destination, 'textContent', {
      enumerable: baseDescriptor.enumerable,
      configurable: true,
      get: baseDescriptor.get,
      set: /** @this {Node} */function set(assignedValue) {
        // If this is a text node then there are no nodes to disconnect.
        if (this.nodeType === Node.TEXT_NODE) {
          baseDescriptor.set.call(this, assignedValue);
          return;
        }

        var removedNodes = undefined;
        // Checking for `firstChild` is faster than reading `childNodes.length`
        // to compare with 0.
        if (this.firstChild) {
          // Using `childNodes` is faster than `children`, even though we only
          // care about elements.
          var childNodes = this.childNodes;
          var childNodesLength = childNodes.length;
          if (childNodesLength > 0 && isConnected(this)) {
            // Copying an array by iterating is faster than using slice.
            removedNodes = new Array(childNodesLength);
            for (var i = 0; i < childNodesLength; i++) {
              removedNodes[i] = childNodes[i];
            }
          }
        }

        baseDescriptor.set.call(this, assignedValue);

        if (removedNodes) {
          for (var _i = 0; _i < removedNodes.length; _i++) {
            internals.disconnectTree(removedNodes[_i]);
          }
        }
      }
    });
  }

  if (Native.Node_textContent && Native.Node_textContent.get) {
    patch_textContent(Node.prototype, Native.Node_textContent);
  } else {
    internals.addPatch(function (element) {
      patch_textContent(element, {
        enumerable: true,
        configurable: true,
        // NOTE: This implementation of the `textContent` getter assumes that
        // text nodes' `textContent` getter will not be patched.
        get: /** @this {Node} */function get() {
          /** @type {!Array<string>} */
          var parts = [];

          for (var i = 0; i < this.childNodes.length; i++) {
            parts.push(this.childNodes[i].textContent);
          }

          return parts.join('');
        },
        set: /** @this {Node} */function set(assignedValue) {
          while (this.firstChild) {
            Native.Node_removeChild.call(this, this.firstChild);
          }
          Native.Node_appendChild.call(this, document.createTextNode(assignedValue));
        }
      });
    });
  }
};

/**
 * @param {!CustomElementInternals} internals
 * @param {!Object} destination
 * @param {!ChildNodeNativeMethods} builtIn
 */
var PatchChildNode = function (internals, destination, builtIn) {
  /**
   * @param {...(!Node|string)} nodes
   */
  destination['before'] = function () {
    for (var _len = arguments.length, nodes = Array(_len), _key = 0; _key < _len; _key++) {
      nodes[_key] = arguments[_key];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.before.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i = 0; _i < nodes.length; _i++) {
        var node = nodes[_i];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  /**
   * @param {...(!Node|string)} nodes
   */
  destination['after'] = function () {
    for (var _len2 = arguments.length, nodes = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      nodes[_key2] = arguments[_key2];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    builtIn.after.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (isConnected(this)) {
      for (var _i2 = 0; _i2 < nodes.length; _i2++) {
        var node = nodes[_i2];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  /**
   * @param {...(!Node|string)} nodes
   */
  destination['replaceWith'] = function () {
    for (var _len3 = arguments.length, nodes = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      nodes[_key3] = arguments[_key3];
    }

    // TODO: Fix this for when one of `nodes` is a DocumentFragment!
    var connectedBefore = /** @type {!Array<!Node>} */nodes.filter(function (node) {
      // DocumentFragments are not connected and will not be added to the list.
      return node instanceof Node && isConnected(node);
    });

    var wasConnected = isConnected(this);

    builtIn.replaceWith.apply(this, nodes);

    for (var i = 0; i < connectedBefore.length; i++) {
      internals.disconnectTree(connectedBefore[i]);
    }

    if (wasConnected) {
      internals.disconnectTree(this);
      for (var _i3 = 0; _i3 < nodes.length; _i3++) {
        var node = nodes[_i3];
        if (node instanceof Element) {
          internals.connectTree(node);
        }
      }
    }
  };

  destination['remove'] = function () {
    var wasConnected = isConnected(this);

    builtIn.remove.call(this);

    if (wasConnected) {
      internals.disconnectTree(this);
    }
  };
};

/**
 * @param {!CustomElementInternals} internals
 */
var PatchElement = function (internals) {
  if (Native.Element_attachShadow) {
    setPropertyUnchecked(Element.prototype, 'attachShadow',
    /**
     * @this {Element}
     * @param {!{mode: string}} init
     * @return {ShadowRoot}
     */
    function (init) {
      var shadowRoot = Native.Element_attachShadow.call(this, init);
      this.__CE_shadowRoot = shadowRoot;
      return shadowRoot;
    });
  } else {
    console.warn('Custom Elements: `Element#attachShadow` was not patched.');
  }

  function patch_innerHTML(destination, baseDescriptor) {
    Object.defineProperty(destination, 'innerHTML', {
      enumerable: baseDescriptor.enumerable,
      configurable: true,
      get: baseDescriptor.get,
      set: /** @this {Element} */function set(htmlString) {
        var _this = this;

        var isConnected$$1 = isConnected(this);

        // NOTE: In IE11, when using the native `innerHTML` setter, all nodes
        // that were previously descendants of the context element have all of
        // their children removed as part of the set - the entire subtree is
        // 'disassembled'. This work around walks the subtree *before* using the
        // native setter.
        /** @type {!Array<!Element>|undefined} */
        var removedElements = undefined;
        if (isConnected$$1) {
          removedElements = [];
          walkDeepDescendantElements(this, function (element) {
            if (element !== _this) {
              removedElements.push(element);
            }
          });
        }

        baseDescriptor.set.call(this, htmlString);

        if (removedElements) {
          for (var i = 0; i < removedElements.length; i++) {
            var element = removedElements[i];
            if (element.__CE_state === CustomElementState.custom) {
              internals.disconnectedCallback(element);
            }
          }
        }

        // Only create custom elements if this element's owner document is
        // associated with the registry.
        if (!this.ownerDocument.__CE_hasRegistry) {
          internals.patchTree(this);
        } else {
          internals.patchAndUpgradeTree(this);
        }
        return htmlString;
      }
    });
  }

  if (Native.Element_innerHTML && Native.Element_innerHTML.get) {
    patch_innerHTML(Element.prototype, Native.Element_innerHTML);
  } else if (Native.HTMLElement_innerHTML && Native.HTMLElement_innerHTML.get) {
    patch_innerHTML(HTMLElement.prototype, Native.HTMLElement_innerHTML);
  } else {

    /** @type {HTMLDivElement} */
    var rawDiv = Native.Document_createElement.call(document, 'div');

    internals.addPatch(function (element) {
      patch_innerHTML(element, {
        enumerable: true,
        configurable: true,
        // Implements getting `innerHTML` by performing an unpatched `cloneNode`
        // of the element and returning the resulting element's `innerHTML`.
        // TODO: Is this too expensive?
        get: /** @this {Element} */function get() {
          return Native.Node_cloneNode.call(this, true).innerHTML;
        },
        // Implements setting `innerHTML` by creating an unpatched element,
        // setting `innerHTML` of that element and replacing the target
        // element's children with those of the unpatched element.
        set: /** @this {Element} */function set(assignedValue) {
          // NOTE: re-route to `content` for `template` elements.
          // We need to do this because `template.appendChild` does not
          // route into `template.content`.
          /** @type {!Node} */
          var content = this.localName === 'template' ? /** @type {!HTMLTemplateElement} */this.content : this;
          rawDiv.innerHTML = assignedValue;

          while (content.childNodes.length > 0) {
            Native.Node_removeChild.call(content, content.childNodes[0]);
          }
          while (rawDiv.childNodes.length > 0) {
            Native.Node_appendChild.call(content, rawDiv.childNodes[0]);
          }
        }
      });
    });
  }

  setPropertyUnchecked(Element.prototype, 'setAttribute',
  /**
   * @this {Element}
   * @param {string} name
   * @param {string} newValue
   */
  function (name, newValue) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_setAttribute.call(this, name, newValue);
    }

    var oldValue = Native.Element_getAttribute.call(this, name);
    Native.Element_setAttribute.call(this, name, newValue);
    newValue = Native.Element_getAttribute.call(this, name);
    internals.attributeChangedCallback(this, name, oldValue, newValue, null);
  });

  setPropertyUnchecked(Element.prototype, 'setAttributeNS',
  /**
   * @this {Element}
   * @param {?string} namespace
   * @param {string} name
   * @param {string} newValue
   */
  function (namespace, name, newValue) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_setAttributeNS.call(this, namespace, name, newValue);
    }

    var oldValue = Native.Element_getAttributeNS.call(this, namespace, name);
    Native.Element_setAttributeNS.call(this, namespace, name, newValue);
    newValue = Native.Element_getAttributeNS.call(this, namespace, name);
    internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
  });

  setPropertyUnchecked(Element.prototype, 'removeAttribute',
  /**
   * @this {Element}
   * @param {string} name
   */
  function (name) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_removeAttribute.call(this, name);
    }

    var oldValue = Native.Element_getAttribute.call(this, name);
    Native.Element_removeAttribute.call(this, name);
    if (oldValue !== null) {
      internals.attributeChangedCallback(this, name, oldValue, null, null);
    }
  });

  setPropertyUnchecked(Element.prototype, 'removeAttributeNS',
  /**
   * @this {Element}
   * @param {?string} namespace
   * @param {string} name
   */
  function (namespace, name) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== CustomElementState.custom) {
      return Native.Element_removeAttributeNS.call(this, namespace, name);
    }

    var oldValue = Native.Element_getAttributeNS.call(this, namespace, name);
    Native.Element_removeAttributeNS.call(this, namespace, name);
    // In older browsers, `Element#getAttributeNS` may return the empty string
    // instead of null if the attribute does not exist. For details, see;
    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS#Notes
    var newValue = Native.Element_getAttributeNS.call(this, namespace, name);
    if (oldValue !== newValue) {
      internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
    }
  });

  function patch_insertAdjacentElement(destination, baseMethod) {
    setPropertyUnchecked(destination, 'insertAdjacentElement',
    /**
     * @this {Element}
     * @param {string} where
     * @param {!Element} element
     * @return {?Element}
     */
    function (where, element) {
      var wasConnected = isConnected(element);
      var insertedElement = /** @type {!Element} */
      baseMethod.call(this, where, element);

      if (wasConnected) {
        internals.disconnectTree(element);
      }

      if (isConnected(insertedElement)) {
        internals.connectTree(element);
      }
      return insertedElement;
    });
  }

  if (Native.HTMLElement_insertAdjacentElement) {
    patch_insertAdjacentElement(HTMLElement.prototype, Native.HTMLElement_insertAdjacentElement);
  } else if (Native.Element_insertAdjacentElement) {
    patch_insertAdjacentElement(Element.prototype, Native.Element_insertAdjacentElement);
  } else {
    console.warn('Custom Elements: `Element#insertAdjacentElement` was not patched.');
  }

  PatchParentNode(internals, Element.prototype, {
    prepend: Native.Element_prepend,
    append: Native.Element_append
  });

  PatchChildNode(internals, Element.prototype, {
    before: Native.Element_before,
    after: Native.Element_after,
    replaceWith: Native.Element_replaceWith,
    remove: Native.Element_remove
  });
};

/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

var priorCustomElements = window['customElements'];

if (!priorCustomElements || priorCustomElements['forcePolyfill'] || typeof priorCustomElements['define'] != 'function' || typeof priorCustomElements['get'] != 'function') {
  /** @type {!CustomElementInternals} */
  var internals = new CustomElementInternals();

  PatchHTMLElement(internals);
  PatchDocument(internals);
  PatchNode(internals);
  PatchElement(internals);

  // The main document is always associated with the registry.
  document.__CE_hasRegistry = true;

  /** @type {!CustomElementRegistry} */
  var customElements$1 = new CustomElementRegistry(internals);

  Object.defineProperty(window, 'customElements', {
    configurable: true,
    enumerable: true,
    value: customElements$1
  });
}

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.22

(function (global) {
  if (global.JsMutationObserver) {
    return;
  }
  var registrationsTable = new WeakMap();
  var setImmediate;
  if (/Trident|Edge/.test(navigator.userAgent)) {
    setImmediate = setTimeout;
  } else if (window.setImmediate) {
    setImmediate = window.setImmediate;
  } else {
    var setImmediateQueue = [];
    var sentinel = String(Math.random());
    window.addEventListener("message", function (e) {
      if (e.data === sentinel) {
        var queue = setImmediateQueue;
        setImmediateQueue = [];
        queue.forEach(function (func) {
          func();
        });
      }
    });
    setImmediate = function setImmediate(func) {
      setImmediateQueue.push(func);
      window.postMessage(sentinel, "*");
    };
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      setImmediate(dispatchCallbacks);
    }
  }
  function wrapIfNeeded(node) {
    return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(node) || node;
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function (o1, o2) {
      return o1.uid_ - o2.uid_;
    });
    var anyNonEmpty = false;
    observers.forEach(function (observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback_(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty) dispatchCallbacks();
  }
  function removeTransientObserversFor(observer) {
    observer.nodes_.forEach(function (node) {
      var registrations = registrationsTable.get(node);
      if (!registrations) return;
      registrations.forEach(function (registration) {
        if (registration.observer === observer) registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree) continue;
          var record = callback(options);
          if (record) registration.enqueue(record);
        }
      }
    }
  }
  var uidCounter = 0;
  function JsMutationObserver(callback) {
    this.callback_ = callback;
    this.nodes_ = [];
    this.records_ = [];
    this.uid_ = ++uidCounter;
  }
  JsMutationObserver.prototype = {
    observe: function observe(target, options) {
      target = wrapIfNeeded(target);
      if (!options.childList && !options.attributes && !options.characterData || options.attributeOldValue && !options.attributes || options.attributeFilter && options.attributeFilter.length && !options.attributes || options.characterDataOldValue && !options.characterData) {
        throw new SyntaxError();
      }
      var registrations = registrationsTable.get(target);
      if (!registrations) registrationsTable.set(target, registrations = []);
      var registration;
      for (var i = 0; i < registrations.length; i++) {
        if (registrations[i].observer === this) {
          registration = registrations[i];
          registration.removeListeners();
          registration.options = options;
          break;
        }
      }
      if (!registration) {
        registration = new Registration(this, target, options);
        registrations.push(registration);
        this.nodes_.push(target);
      }
      registration.addListeners();
    },
    disconnect: function disconnect() {
      this.nodes_.forEach(function (node) {
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          var registration = registrations[i];
          if (registration.observer === this) {
            registration.removeListeners();
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
      this.records_ = [];
    },
    takeRecords: function takeRecords() {
      var copyOfRecords = this.records_;
      this.records_ = [];
      return copyOfRecords;
    }
  };
  function MutationRecord(type, target) {
    this.type = type;
    this.target = target;
    this.addedNodes = [];
    this.removedNodes = [];
    this.previousSibling = null;
    this.nextSibling = null;
    this.attributeName = null;
    this.attributeNamespace = null;
    this.oldValue = null;
  }
  function copyMutationRecord(original) {
    var record = new MutationRecord(original.type, original.target);
    record.addedNodes = original.addedNodes.slice();
    record.removedNodes = original.removedNodes.slice();
    record.previousSibling = original.previousSibling;
    record.nextSibling = original.nextSibling;
    record.attributeName = original.attributeName;
    record.attributeNamespace = original.attributeNamespace;
    record.oldValue = original.oldValue;
    return record;
  }
  var currentRecord, recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue) return recordWithOldValue;
    recordWithOldValue = copyMutationRecord(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = undefined;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord) return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;
    return null;
  }
  function Registration(observer, target, options) {
    this.observer = observer;
    this.target = target;
    this.options = options;
    this.transientObservedNodes = [];
  }
  Registration.prototype = {
    enqueue: function enqueue(record) {
      var records = this.observer.records_;
      var length = records.length;
      if (records.length > 0) {
        var lastRecord = records[length - 1];
        var recordToReplaceLast = selectRecord(lastRecord, record);
        if (recordToReplaceLast) {
          records[length - 1] = recordToReplaceLast;
          return;
        }
      } else {
        scheduleCallback(this.observer);
      }
      records[length] = record;
    },
    addListeners: function addListeners() {
      this.addListeners_(this.target);
    },
    addListeners_: function addListeners_(node) {
      var options = this.options;
      if (options.attributes) node.addEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.addEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.addEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.addEventListener("DOMNodeRemoved", this, true);
    },
    removeListeners: function removeListeners() {
      this.removeListeners_(this.target);
    },
    removeListeners_: function removeListeners_(node) {
      var options = this.options;
      if (options.attributes) node.removeEventListener("DOMAttrModified", this, true);
      if (options.characterData) node.removeEventListener("DOMCharacterDataModified", this, true);
      if (options.childList) node.removeEventListener("DOMNodeInserted", this, true);
      if (options.childList || options.subtree) node.removeEventListener("DOMNodeRemoved", this, true);
    },
    addTransientObserver: function addTransientObserver(node) {
      if (node === this.target) return;
      this.addListeners_(node);
      this.transientObservedNodes.push(node);
      var registrations = registrationsTable.get(node);
      if (!registrations) registrationsTable.set(node, registrations = []);
      registrations.push(this);
    },
    removeTransientObservers: function removeTransientObservers() {
      var transientObservedNodes = this.transientObservedNodes;
      this.transientObservedNodes = [];
      transientObservedNodes.forEach(function (node) {
        this.removeListeners_(node);
        var registrations = registrationsTable.get(node);
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i] === this) {
            registrations.splice(i, 1);
            break;
          }
        }
      }, this);
    },
    handleEvent: function handleEvent(e) {
      e.stopImmediatePropagation();
      switch (e.type) {
        case "DOMAttrModified":
          var name = e.attrName;
          var namespace = e.relatedNode.namespaceURI;
          var target = e.target;
          var record = new getRecord("attributes", target);
          record.attributeName = name;
          record.attributeNamespace = namespace;
          var oldValue = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function (options) {
            if (!options.attributes) return;
            if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name) === -1 && options.attributeFilter.indexOf(namespace) === -1) {
              return;
            }
            if (options.attributeOldValue) return getRecordWithOldValue(oldValue);
            return record;
          });
          break;

        case "DOMCharacterDataModified":
          var target = e.target;
          var record = getRecord("characterData", target);
          var oldValue = e.prevValue;
          forEachAncestorAndObserverEnqueueRecord(target, function (options) {
            if (!options.characterData) return;
            if (options.characterDataOldValue) return getRecordWithOldValue(oldValue);
            return record;
          });
          break;

        case "DOMNodeRemoved":
          this.addTransientObserver(e.target);

        case "DOMNodeInserted":
          var changedNode = e.target;
          var addedNodes, removedNodes;
          if (e.type === "DOMNodeInserted") {
            addedNodes = [changedNode];
            removedNodes = [];
          } else {
            addedNodes = [];
            removedNodes = [changedNode];
          }
          var previousSibling = changedNode.previousSibling;
          var nextSibling = changedNode.nextSibling;
          var record = getRecord("childList", e.target.parentNode);
          record.addedNodes = addedNodes;
          record.removedNodes = removedNodes;
          record.previousSibling = previousSibling;
          record.nextSibling = nextSibling;
          forEachAncestorAndObserverEnqueueRecord(e.relatedNode, function (options) {
            if (!options.childList) return;
            return record;
          });
      }
      clearRecords();
    }
  };
  global.JsMutationObserver = JsMutationObserver;
  if (!global.MutationObserver) {
    global.MutationObserver = JsMutationObserver;
    JsMutationObserver._isPolyfilled = true;
  }
})(self);

/*
Copyright (c) 2012 Barnesandnoble.com, llc, Donavon West, and Domenic Denicola

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/
(function (global, undefined) {
    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function () {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                new Function("" + handler)();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function setImmediate() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(self);

// Caution:
// Do not replace this import statement with codes.
//
// If you replace this import statement with codes,
// the codes will be executed after the following polyfills are imported
// because import statements are hoisted during compilation.
// Polyfill ECMAScript standard features with global namespace pollution
// Polyfill Custom Elements v1 with global namespace pollution
// Polyfill MutationObserver with global namespace pollution
// Polyfill setImmediate with global namespace pollution

(function () {
  var DEFAULT_VIEWPORT = 'width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no';

  var Viewport = {
    ensureViewportElement: function ensureViewportElement() {
      var viewportElement = document.querySelector('meta[name=viewport]');

      if (!viewportElement) {
        viewportElement = document.createElement('meta');
        viewportElement.name = 'viewport';
        document.head.appendChild(viewportElement);
      }

      return viewportElement;
    },

    setup: function setup() {
      var viewportElement = Viewport.ensureViewportElement();

      if (!viewportElement) {
        return;
      }

      if (!viewportElement.hasAttribute('content')) {
        viewportElement.setAttribute('content', DEFAULT_VIEWPORT);
      }
    }
  };

  window.Viewport = Viewport;
})();

function setup$1(ons) {
  if (window._onsLoaded) {
    ons._util.warn('Onsen UI is loaded more than once.');
  }
  window._onsLoaded = true;

  // fastclick
  window.addEventListener('load', function () {
    ons.fastClick = fastclick_1.attach(document.body);

    var supportTouchAction = 'touch-action' in document.body.style;

    ons.platform._runOnActualPlatform(function () {
      if (ons.platform.isAndroid()) {
        // In Android4.4+, correct viewport settings can remove click delay.
        // So disable FastClick on Android.
        ons.fastClick.destroy();
      } else if (ons.platform.isIOS()) {
        if (supportTouchAction && (ons.platform.isIOSSafari() || ons.platform.isWKWebView())) {
          // If 'touch-action' supported in iOS Safari or WKWebView, disable FastClick.
          ons.fastClick.destroy();
        } else {
          // Do nothing. 'touch-action: manipulation' has no effect on UIWebView.
        }
      }
    });
  }, false);

  ons.ready(function () {
    ons.enableDeviceBackButtonHandler();
    ons._defaultDeviceBackButtonHandler = ons._internal.dbbDispatcher.createHandler(window.document.body, function () {
      if (Object.hasOwnProperty.call(navigator, 'app')) {
        navigator.app.exitApp();
      } else {
        console.warn('Could not close the app. Is \'cordova.js\' included?\nError: \'window.navigator.app\' is undefined.');
      }
    });
    document.body._gestureDetector = new ons.GestureDetector(document.body, { passive: true });

    // Simulate Device Back Button on ESC press
    if (!ons.platform.isWebView()) {
      document.body.addEventListener('keydown', function (event) {
        if (event.keyCode === 27) {
          ons.fireDeviceBackButtonEvent();
        }
      });
    }

    // setup loading placeholder
    ons._setupLoadingPlaceHolders();
  });

  // viewport.js
  Viewport.setup();
}

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

function getElementClass() {
  if (typeof HTMLElement !== 'function') {
    // case of Safari
    var _BaseElement = function _BaseElement() {};
    _BaseElement.prototype = document.createElement('div');
    return _BaseElement;
  } else {
    return HTMLElement;
  }
}

var BaseElement = function (_getElementClass) {
  inherits(BaseElement, _getElementClass);

  function BaseElement() {
    classCallCheck(this, BaseElement);
    return possibleConstructorReturn(this, (BaseElement.__proto__ || Object.getPrototypeOf(BaseElement)).call(this));
  }

  return BaseElement;
}(getElementClass());

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-template
 * @category util
 * @description
 *   [en]
 *     Define a separate HTML fragment and use as a template. These templates can be loaded as pages in `<ons-navigator>`, `<ons-tabbar>` and `<ons-splitter>`. They can also be used to generate dialogs. Since Onsen UI 2.4.0, the native `<template>` element can be used instead of `<ons-template>` for better performance and features. `<ons-template>` is still supported for backward compatibility.
 *   [/en]
 *   [ja]テンプレートとして使用するためのHTMLフラグメントを定義します。この要素でHTMLを宣言すると、id属性に指定した名前をpageのURLとしてons-navigatorなどのコンポーネントから参照できます。[/ja]
 * @seealso ons-navigator
 *   [en]The `<ons-navigator>` component enables stack based navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-tabbar
 *   [en]The `<ons-tabbar>` component is used to add tab navigation.[/en]
 *   [ja][/ja]
 * @seealso ons-splitter
 *   [en]The `<ons-splitter>` component can be used to create a draggable menu or column based layout.[/en]
 *   [ja][/ja]
 * @example
 * <ons-template id="foobar.html">
 *   <ons-page>
 *     Page content
 *   </ons-page>
 * </ons-template>
 *
 * <ons-navigator page="foobar.html"></ons-navigator>
 */

var TemplateElement = function (_BaseElement) {
  inherits(TemplateElement, _BaseElement);

  /**
   * @property template
   * @type {String}
   * @description
   *  [en]Template content. This property can not be used with AngularJS bindings.[/en]
   *  [ja][/ja]
   */

  function TemplateElement() {
    classCallCheck(this, TemplateElement);

    var _this = possibleConstructorReturn(this, (TemplateElement.__proto__ || Object.getPrototypeOf(TemplateElement)).call(this));

    _this.template = _this.innerHTML;

    while (_this.firstChild) {
      _this.removeChild(_this.firstChild);
    }
    return _this;
  }

  createClass(TemplateElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (this.parentNode) {
        // Note: this.parentNode is not set in some CE0/CE1 polyfills.
        // Show warning when the ons-template is not located just under document.body
        if (this.parentNode !== document.body) {
          // if the parent is not document.body
          util$1.warn('ons-template (id = ' + this.getAttribute('id') + ') must be located just under document.body' + (this.parentNode.outerHTML ? ':\n\n' + this.parentNode.outerHTML : '.'));
        }
      }

      var event = new CustomEvent('_templateloaded', { bubbles: true, cancelable: true });
      event.template = this.template;
      event.templateId = this.getAttribute('id');

      this.dispatchEvent(event);
    }
  }]);
  return TemplateElement;
}(BaseElement);

onsElements.Template = TemplateElement;
customElements.define('ons-template', TemplateElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-if
 * @category conditional
 * @tutorial vanilla/Reference/if
 * @description
 *   [en]
 *     Conditionally display content depending on the platform, device orientation or both.
 *
 *     Sometimes it is useful to conditionally hide or show certain components based on platform. When running on iOS the `<ons-if>` element can be used to hide the `<ons-fab>` element.
 *   [/en]
 *   [ja][/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-page>
 *   <ons-if orientation="landscape">
 *     Landscape view!
 *   </ons-if>
 *   <ons-if platform="android">
 *     This is Android.
 *   </ons-if>
 *   <ons-if platform="ios other">
 *     This is not Android.
 *   </ons-if>
 * </ons-page>
 */

var IfElement = function (_BaseElement) {
  inherits(IfElement, _BaseElement);

  /**
   * @attribute platform
   * @initonly
   * @type {string}
   * @description
   *  [en]Space-separated platform names. Possible values are `"ios"`, `"android"`, `"windows"` and `"other"`.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute orientation
   * @type {string}
   * @description
   *  [en]Either `"portrait"` or `"landscape"`.[/en]
   *  [ja]portraitもしくはlandscapeを指定します[/ja]
   */

  function IfElement() {
    classCallCheck(this, IfElement);

    var _this = possibleConstructorReturn(this, (IfElement.__proto__ || Object.getPrototypeOf(IfElement)).call(this));

    contentReady(_this, function () {
      if (platform._getSelectedPlatform() !== null) {
        _this._platformUpdate();
      } else if (!_this._isAllowedPlatform()) {
        while (_this.childNodes[0]) {
          _this.childNodes[0].remove();
        }
        _this._platformUpdate();
      }
    });

    _this._onOrientationChange();
    return _this;
  }

  createClass(IfElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      orientation.on('change', this._onOrientationChange.bind(this));
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name) {
      if (name === 'orientation') {
        this._onOrientationChange();
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      orientation.off('change', this._onOrientationChange);
    }
  }, {
    key: '_platformUpdate',
    value: function _platformUpdate() {
      this.style.display = this._isAllowedPlatform() ? '' : 'none';
    }
  }, {
    key: '_isAllowedPlatform',
    value: function _isAllowedPlatform() {
      return !this.getAttribute('platform') || this.getAttribute('platform').split(/\s+/).indexOf(platform.getMobileOS()) >= 0;
    }
  }, {
    key: '_onOrientationChange',
    value: function _onOrientationChange() {
      if (this.hasAttribute('orientation') && this._isAllowedPlatform()) {
        var conditionalOrientation = this.getAttribute('orientation').toLowerCase();
        var currentOrientation = orientation.isPortrait() ? 'portrait' : 'landscape';

        this.style.display = conditionalOrientation === currentOrientation ? '' : 'none';
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['orientation'];
    }
  }]);
  return IfElement;
}(BaseElement);

onsElements.If = IfElement;
customElements.define('ons-if', IfElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var BaseAnimator = function () {

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function BaseAnimator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, BaseAnimator);

    this.timing = options.timing || 'linear';
    this.duration = options.duration || 0;
    this.delay = options.delay || 0;

    this.def = {
      timing: this.timing,
      duration: this.duration,
      delay: this.delay
    };
  }

  createClass(BaseAnimator, null, [{
    key: 'extend',
    value: function extend() {
      var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var extendedAnimator = this;
      var newAnimator = function newAnimator() {
        extendedAnimator.apply(this, arguments);
        util$1.extend(this, properties);
      };

      newAnimator.prototype = this.prototype;
      return newAnimator;
    }
  }]);
  return BaseAnimator;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

// This object should not be exposed to users. Please keep this private.
var iPhoneXPatch = {};

iPhoneXPatch.isIPhoneXPortraitPatchActive = function () {
  return document.documentElement.getAttribute('onsflag-iphonex-portrait') != null && window.innerWidth < window.innerHeight;
};

iPhoneXPatch.isIPhoneXLandscapePatchActive = function () {
  // If width === height, treat it as landscape
  return document.documentElement.getAttribute('onsflag-iphonex-landscape') != null && window.innerWidth >= window.innerHeight;
};

/**
 * Returns the safe area lengths based on the current state of the safe areas.
 */
iPhoneXPatch.getSafeAreaLengths = function () {
  var safeAreaLengths = void 0;
  if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
    safeAreaLengths = {
      top: 44,
      right: 0,
      bottom: 34,
      left: 0
    };
  } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
    safeAreaLengths = {
      top: 0,
      right: 44,
      bottom: 21,
      left: 44
    };
  } else {
    safeAreaLengths = {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  return safeAreaLengths;
};

/**
 * Returns the safe area rect based on the current state of the safe areas.
 */
iPhoneXPatch.getSafeAreaDOMRect = function () {
  var safeAreaRect = void 0;
  if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
    safeAreaRect = {
      x: 0,
      y: 44, /* 0 + 44 (top safe area) */
      width: window.innerWidth,
      height: window.innerHeight - 78 /* height - 44 (top safe area) - 34 (bottom safe area) */
    };
  } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
    safeAreaRect = {
      x: 44, /* 0 + 44 (left safe area) */
      y: 0,
      width: window.innerWidth - 88, /* width - 44 (left safe area) - 34 (right safe area) */
      height: window.innerHeight - 21 /* height - 21 (bottom safe area) */
    };
  } else {
    safeAreaRect = {
      x: 0,
      y: 0,
      width: window.innerWidth,
      height: window.innerHeight
    };
  }

  return _extends({}, safeAreaRect, {
    left: safeAreaRect.x,
    top: safeAreaRect.y,
    right: safeAreaRect.x + safeAreaRect.width,
    bottom: safeAreaRect.y + safeAreaRect.height
  });
};

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ActionSheetAnimator = function (_BaseAnimator) {
  inherits(ActionSheetAnimator, _BaseAnimator);

  function ActionSheetAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ActionSheetAnimator);
    return possibleConstructorReturn(this, (ActionSheetAnimator.__proto__ || Object.getPrototypeOf(ActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(ActionSheetAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return ActionSheetAnimator;
}(BaseAnimator);

/**
 * Android style animator for Action Sheet.
 */
var MDActionSheetAnimator = function (_ActionSheetAnimator) {
  inherits(MDActionSheetAnimator, _ActionSheetAnimator);

  function MDActionSheetAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'ease' : _ref2$timing,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.4 : _ref2$duration;

    classCallCheck(this, MDActionSheetAnimator);

    var _this2 = possibleConstructorReturn(this, (MDActionSheetAnimator.__proto__ || Object.getPrototypeOf(MDActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this2.maskTiming = 'linear';
    _this2.maskDuration = 0.2;
    return _this2;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(MDActionSheetAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {

      Animit.runAll(Animit(dialog._mask).queue({ opacity: 0 }).wait(this.delay).queue({ opacity: 1.0 }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, 80%, 0)', opacity: 0 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }).queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      Animit.runAll(Animit(dialog._mask).queue({ opacity: 1 }).wait(this.delay).queue({ opacity: 0 }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 1 }, { transform: 'translate3d(0, 80%, 0)', opacity: 0 }).queue(function (done) {
        callback && callback();
        done();
      }));
    }
  }]);
  return MDActionSheetAnimator;
}(ActionSheetAnimator);

/**
 * iOS style animator for dialog.
 */
var IOSActionSheetAnimator = function (_ActionSheetAnimator2) {
  inherits(IOSActionSheetAnimator, _ActionSheetAnimator2);

  function IOSActionSheetAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'ease' : _ref3$timing,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.3 : _ref3$duration;

    classCallCheck(this, IOSActionSheetAnimator);

    var _this3 = possibleConstructorReturn(this, (IOSActionSheetAnimator.__proto__ || Object.getPrototypeOf(IOSActionSheetAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this3.maskTiming = 'linear';
    _this3.maskDuration = 0.2;
    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
      _this3.liftAmount = 'calc(100% + 48px)';
    } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
      _this3.liftAmount = 'calc(100% + 33px)';
    } else {
      _this3.liftAmount = document.body.clientHeight / 2.0 - 1 + 'px'; // avoid Forced Synchronous Layout
    }
    return _this3;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSActionSheetAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      Animit.runAll(Animit(dialog._mask).queue({ opacity: 0 }).wait(this.delay).queue({ opacity: 1 }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, ' + this.liftAmount + ', 0)' }, { transform: 'translate3d(0, 0, 0)' }).queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      Animit.runAll(Animit(dialog._mask).queue({ opacity: 1 }).wait(this.delay).queue({ opacity: 0 }, {
        duration: this.maskDuration,
        timing: this.maskTiming
      }), Animit(dialog._sheet, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, ' + this.liftAmount + ', 0)' }).queue(function (done) {
        callback && callback();
        done();
      }));
    }
  }]);
  return IOSActionSheetAnimator;
}(ActionSheetAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var BaseDialogElement = function (_BaseElement) {
  inherits(BaseDialogElement, _BaseElement);
  createClass(BaseDialogElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      util$1.throwMember();
    }
  }, {
    key: '_toggleStyle',
    value: function _toggleStyle(shouldShow) {
      this.style.display = shouldShow ? 'block' : 'none';
    }
  }, {
    key: '_scheme',
    get: function get$$1() {
      util$1.throwMember();
    }
  }]);

  function BaseDialogElement() {
    classCallCheck(this, BaseDialogElement);

    var _this = possibleConstructorReturn(this, (BaseDialogElement.__proto__ || Object.getPrototypeOf(BaseDialogElement)).call(this));

    if (_this.constructor === BaseDialogElement) {
      util$1.throwAbstract();
    }

    _this._visible = false;
    _this._doorLock = new DoorLock();
    _this._cancel = _this._cancel.bind(_this);
    _this._selfCamelName = util$1.camelize(_this.tagName.slice(4));
    _this._defaultDBB = function (e) {
      return _this.cancelable ? _this._cancel() : e.callParentHandler();
    };
    _this._animatorFactory = _this._updateAnimatorFactory();
    return _this;
  }

  createClass(BaseDialogElement, [{
    key: '_cancel',
    value: function _cancel() {
      var _this2 = this;

      if (this.cancelable && !this._running) {
        this._running = true;
        this.hide().then(function () {
          _this2._running = false;
          util$1.triggerElementEvent(_this2, 'dialog-cancel');
        }, function () {
          return _this2._running = false;
        });
      }
    }
  }, {
    key: 'show',
    value: function show() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return this._setVisible.apply(this, [true].concat(args));
    }
  }, {
    key: 'hide',
    value: function hide() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return this._setVisible.apply(this, [false].concat(args));
    }
  }, {
    key: 'toggle',
    value: function toggle() {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this._setVisible.apply(this, [!this.visible].concat(args));
    }
  }, {
    key: '_setVisible',
    value: function _setVisible(shouldShow) {
      var _util$triggerElementE,
          _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var action = shouldShow ? 'show' : 'hide';

      options = _extends({}, options);
      options.animationOptions = util$1.extend(options.animationOptions || {}, AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options')));

      var canceled = false;
      util$1.triggerElementEvent(this, 'pre' + action, (_util$triggerElementE = {}, defineProperty(_util$triggerElementE, this._selfCamelName, this), defineProperty(_util$triggerElementE, 'cancel', function cancel() {
        return canceled = true;
      }), _util$triggerElementE));

      if (canceled) {
        return Promise.reject('Canceled in pre' + action + ' event.');
      }

      return new Promise(function (resolve) {
        _this3._doorLock.waitUnlock(function () {
          var unlock = _this3._doorLock.lock();
          var animator = _this3._animatorFactory.newAnimator(options);

          shouldShow && _this3._toggleStyle(true, options);
          _this3._visible = shouldShow;
          util$1.iosPageScrollFix(shouldShow);

          contentReady(_this3, function () {
            animator[action](_this3, function () {
              !shouldShow && _this3._toggleStyle(false, options);

              unlock();

              util$1.propagateAction(_this3, '_' + action);
              util$1.triggerElementEvent(_this3, 'post' + action, defineProperty({}, _this3._selfCamelName, _this3)); // postshow posthide

              if (options.callback instanceof Function) {
                options.callback(_this3);
              }

              resolve(_this3);
            });
          });
        });
      });
    }
  }, {
    key: '_updateMask',
    value: function _updateMask() {
      var _this4 = this;

      contentReady(this, function () {
        if (_this4._mask && _this4.getAttribute('mask-color')) {
          _this4._mask.style.backgroundColor = _this4.getAttribute('mask-color');
        }
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this5 = this;

      this.onDeviceBackButton = this._defaultDBB.bind(this);

      contentReady(this, function () {
        if (_this5._mask) {
          _this5._mask.addEventListener('click', _this5._cancel, false);
          util$1.iosMaskScrollFix(_this5._mask, true);
        }
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      if (this._mask) {
        this._mask.removeEventListener('click', this._cancel, false);
        util$1.iosMaskScrollFix(this._mask, false);
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, this._scheme);
          break;
        case 'animation':
          this._animatorFactory = this._updateAnimatorFactory();
          break;
        case 'mask-color':
          this._updateMask();
          break;
      }
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }, {
    key: 'visible',
    get: function get$$1() {
      return this._visible;
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }, {
    key: 'cancelable',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'cancelable', value);
    },
    get: function get$$1() {
      return this.hasAttribute('cancelable');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'animation', 'mask-color'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['preshow', 'postshow', 'prehide', 'posthide', 'dialog-cancel'];
    }
  }]);
  return BaseDialogElement;
}(BaseElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme = {
  '.action-sheet': 'action-sheet--*',
  '.action-sheet-mask': 'action-sheet-mask--*',
  '.action-sheet-title': 'action-sheet-title--*'
};

var _animatorDict = {
  'default': function _default() {
    return platform.isAndroid() ? MDActionSheetAnimator : IOSActionSheetAnimator;
  },
  'none': ActionSheetAnimator
};

/**
 * @element ons-action-sheet
 * @category dialog
 * @description
 *   [en]
 *     Action/bottom sheet that is displayed on top of current screen.
 *
 *     This element can either be attached directly to the `<body>` or dynamically created from a template using the `ons.createElement(template, { append: true })` utility function and the `<template>` tag.
 *
 *     The action sheet is useful for displaying a list of options and asking the user to make a decision. A `ons-action-sheet-button` is provided for this purpose, although it can contain any type of content.
 *
 *     It will automatically be displayed as Material Design (bottom sheet) when running on an Android device.
 *   [/en]
 *   [ja]
 *     アクションシート、もしくはボトムシートを現在のスクリーン上に表示します。
 *
 *     この要素は、`<body>`要素に直接アタッチされるか、もしくは`ons.createElement(template, { append: true })`と`<template>`タグを使ってテンプレートから動的に生成されます。
 *
 *     アクションシートは、選択肢のリストを表示してユーザーに尋ねるのに便利です。`ons-action-sheet-button`は、この要素の中に置くために提供されていますが、それ以外にも他のどのような要素を含むことができます。
 *
 *     Androidデバイスで実行されるときには、自動的にマテリアルデザイン(ボトムシート)として表示されます。
 *   [/ja]
 * @modifier material
 *   [en]Display a Material Design bottom sheet.[/en]
 *   [ja]マテリアルデザインのボトムシートを表示します。[/ja]
 * @tutorial vanilla/reference/action-sheet
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-popover
 *   [en]`<ons-popover>` component[/en]
 *   [ja]ons-popoverコンポーネント[/ja]
 * @seealso ons-modal
 *   [en]`<ons-modal>` component[/en]
 *   [ja]ons-modalコンポーネント[/ja]
 * @example
 * <ons-action-sheet id="sheet">
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 * </ons-action-sheet>
 *
 * <script>
 *   document.getElementById('sheet').show();
 * </script>
 */

var ActionSheetElement = function (_BaseDialogElement) {
  inherits(ActionSheetElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   * [en]Fired just before the action sheet is displayed.[/en]
   * [ja]ダイアログが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the action sheet from being shown.[/en]
   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   * [en]Fired just after the action sheet is displayed.[/en]
   * [ja]ダイアログが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   * [en]Fired just before the action sheet is hidden.[/en]
   * [ja]ダイアログが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the action sheet from being hidden.[/en]
   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the action sheet is hidden.[/en]
   * [ja]ダイアログが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.actionSheet
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute title
   * @type {String}
   * @description
   *  [en]Optional title of the action sheet. A new element will be created containing this string.[/en]
   *  [ja]アクションシートのタイトルを指定します。ここで指定した文字列を含む新しい要素が作成されます。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the action sheet.[/en]
   *  [ja]ダイアログの表現を指定します。[/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *  [en]If this attribute is set the action sheet can be closed by tapping the background or by pressing the back button on Android devices.[/en]
   *  [ja]この属性が設定されると、アクションシートの背景やAndroidデバイスのバックボタンを推すことでアクションシートが閉じるようになります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *  [en]If this attribute is set the action sheet is disabled.[/en]
   *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the action sheet. Can be either `"none"` or `"default"`.[/en]
   *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
   */

  /**
   * @attribute mask-color
   * @type {String}
   * @default rgba(0, 0, 0, 0.2)
   * @description
   *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
   */

  function ActionSheetElement() {
    classCallCheck(this, ActionSheetElement);

    var _this = possibleConstructorReturn(this, (ActionSheetElement.__proto__ || Object.getPrototypeOf(ActionSheetElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ActionSheetElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict,
        baseClass: ActionSheetAnimator,
        baseClassName: 'ActionSheetAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /* Expected result:
       *   <ons-action-sheet>
       *     <div class="action-sheet-mask"></div>
       *     <div class="action-sheet">
       *       <div class="action-sheet-title></div>
       *       ...
       *     </div>
       *   </ons-action-sheet>
       */

      if (!this._sheet) {
        var sheet = document.createElement('div');
        sheet.classList.add('action-sheet');

        while (this.firstChild) {
          sheet.appendChild(this.firstChild);
        }

        this.appendChild(sheet);
      }

      if (!this._title && this.hasAttribute('title')) {
        var title = document.createElement('div');
        title.innerHTML = this.getAttribute('title');
        title.classList.add('action-sheet-title');
        this._sheet.insertBefore(title, this._sheet.firstChild);
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('action-sheet-mask');
        this.insertBefore(mask, this.firstChild);
      }

      this._sheet.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      ModifierUtil.initModifier(this, this._scheme);
    }
  }, {
    key: '_updateTitle',
    value: function _updateTitle() {
      if (this._title) {
        this._title.innerHTML = this.getAttribute('title');
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the action sheet has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *  [en]Show the action sheet.[/en]
     *  [ja]ダイアログを開きます。[/ja]
     * @return {Promise} Resolves to the displayed element.
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the action sheet has been hidden.[/en]
     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Hide the action sheet.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja]隠れた要素を解決します。[/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the action sheet is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the action sheet is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the action sheet is cancelable or not. A cancelable action sheet can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja]アクションシートがキャンセル可能かどうかを設定します。キャンセル可能なアクションシートは、背景をタップしたりAndroidデバイスのバックボタンを推すことで閉じるようになります。[/ja]
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'title') {
        this._updateTitle();
      } else {
        get(ActionSheetElement.prototype.__proto__ || Object.getPrototypeOf(ActionSheetElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }

    /**
     * @param {String} name
     * @param {ActionSheetAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme;
    }
  }, {
    key: '_mask',
    get: function get$$1() {
      return util$1.findChild(this, '.action-sheet-mask');
    }
  }, {
    key: '_sheet',
    get: function get$$1() {
      return util$1.findChild(this, '.action-sheet');
    }
  }, {
    key: '_title',
    get: function get$$1() {
      return this.querySelector('.action-sheet-title');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ActionSheetAnimator)) {
        util$1.throwAnimator('ActionSheet');
      }
      _animatorDict[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(ActionSheetElement.__proto__ || Object.getPrototypeOf(ActionSheetElement), 'observedAttributes', this)), ['title']);
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict;
    }
  }, {
    key: 'ActionSheetAnimator',
    get: function get$$1() {
      return ActionSheetAnimator;
    }
  }]);
  return ActionSheetElement;
}(BaseDialogElement);

onsElements.ActionSheet = ActionSheetElement;
customElements.define('ons-action-sheet', ActionSheetElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var BaseButtonElement = function (_BaseElement) {
  inherits(BaseButtonElement, _BaseElement);
  createClass(BaseButtonElement, [{
    key: '_scheme',
    get: function get$$1() {
      util$1.throwMember();
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      util$1.throwMember();
    }
  }, {
    key: '_rippleOpt',
    get: function get$$1() {
      return [this];
    }
  }]);

  function BaseButtonElement() {
    classCallCheck(this, BaseButtonElement);

    var _this = possibleConstructorReturn(this, (BaseButtonElement.__proto__ || Object.getPrototypeOf(BaseButtonElement)).call(this));

    if (_this.constructor === BaseButtonElement) {
      util$1.throwAbstract();
    }

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(BaseButtonElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(this._defaultClassName);

      if (!this._icon && this.hasAttribute('icon')) {
        util$1.checkMissingImport('Icon');
        var icon = util$1.createElement('<ons-icon icon="' + this.getAttribute('icon') + '"></ons-icon>');
        icon.classList.add(this._defaultClassName.replace('button', 'icon'));
        this.insertBefore(icon, this.firstChild);
      }

      this._updateRipple();

      ModifierUtil.initModifier(this, this._scheme);
    }
  }, {
    key: '_updateIcon',
    value: function _updateIcon() {
      if (this._icon) {
        this._icon.setAttribute('icon', this.getAttribute('icon'));
      }
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      this._rippleOpt && util$1.updateRipple.apply(util$1, toConsumableArray(this._rippleOpt));
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, this._defaultClassName, this._scheme);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, this._scheme);
          break;
        case 'icon':
          this._updateIcon();
          break;
        case 'ripple':
          this.classList.contains(this._defaultClassName) && this._updateRipple();
          break;
      }
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }, {
    key: '_icon',
    get: function get$$1() {
      return util$1.findChild(this, 'ons-icon');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class', 'icon', 'ripple'];
    }
  }]);
  return BaseButtonElement;
}(BaseElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-action-sheet-button
 * @category dialog
 * @modifier destructive
 *   [en]Shows a "destructive" button (only for iOS).[/en]
 *   [ja]"destructive"なボタンを表示します(iOSでのみ有効)。[/ja]
 * @description
 *   [en]Component that represent each button of the action sheet.[/en]
 *   [ja]アクションシートに表示される各ボタンを表現するコンポーネントです。[/ja]
 * @seealso ons-action-sheet
 *   [en]The `<ons-action-sheet>` component[/en]
 *   [ja]ons-action-sheetコンポーネント[/ja]
 * @seealso ons-list-item
 *   [en]The `<ons-list-item>` component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @seealso ons-icon
 *   [en]The `<ons-icon>` component[/en]
 *   [ja]ons-iconコンポーネント[/ja]
 * @tutorial vanilla/Reference/action-sheet
 * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
 * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
 * @modifier material
 *   [en]Display a Material Design action sheet button.[/en]
 *   [ja]マテリアルデザインのアクションシート用のボタンを表示します。[/ja]
 * @example
 * <ons-action-sheet id="sheet">
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 *   <ons-action-sheet-button>Label</ons-action-sheet-button>
 * </ons-action-sheet>
 *
 * <script>
 *   document.getElementById('sheet').show();
 * </script>
 */

var ActionSheetButtonElement = function (_BaseButtonElement) {
  inherits(ActionSheetButtonElement, _BaseButtonElement);

  function ActionSheetButtonElement() {
    classCallCheck(this, ActionSheetButtonElement);
    return possibleConstructorReturn(this, (ActionSheetButtonElement.__proto__ || Object.getPrototypeOf(ActionSheetButtonElement)).apply(this, arguments));
  }

  createClass(ActionSheetButtonElement, [{
    key: '_scheme',


    /**
     * @attribute icon
     * @type {String}
     * @description
     *  [en]Creates an `ons-icon` component with this string. Only visible on Android. Check [See also](#seealso) section for more information.[/en]
     *  [ja]`ons-icon`コンポーネントを悪性します。Androidでのみ表示されます。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the action sheet button.[/en]
     *   [ja]アクションシートボタンの見た目を設定します。[/ja]
     */

    get: function get$$1() {
      return {
        '': 'action-sheet-button--*',
        '.action-sheet-icon': 'action-sheet-icon--*'
      };
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'action-sheet-button';
    }
  }, {
    key: '_rippleOpt',
    get: function get$$1() {
      return undefined;
    }
  }]);
  return ActionSheetButtonElement;
}(BaseButtonElement);

onsElements.ActionSheetButton = ActionSheetButtonElement;
customElements.define('ons-action-sheet-button', ActionSheetButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var AlertDialogAnimator = function (_BaseAnimator) {
  inherits(AlertDialogAnimator, _BaseAnimator);

  function AlertDialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, AlertDialogAnimator);
    return possibleConstructorReturn(this, (AlertDialogAnimator.__proto__ || Object.getPrototypeOf(AlertDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(AlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return AlertDialogAnimator;
}(BaseAnimator);

/**
 * Android style animator for alert dialog.
 */
var AndroidAlertDialogAnimator = function (_AlertDialogAnimator) {
  inherits(AndroidAlertDialogAnimator, _AlertDialogAnimator);

  function AndroidAlertDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref2$timing,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.2 : _ref2$duration,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay;

    classCallCheck(this, AndroidAlertDialogAnimator);
    return possibleConstructorReturn(this, (AndroidAlertDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0) scale3d(.9, .9, 1)', opacity: 0 }, { transform: 'translate3d(-50%, -50%, 0) scale3d(1, 1, 1)', opacity: 1 }).queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0) scale3d(1, 1, 1)', opacity: 1 }, { transform: 'translate3d(-50%, -50%, 0) scale3d(.9, .9, 1)', opacity: 0 }).queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidAlertDialogAnimator;
}(AlertDialogAnimator);

/**
 * iOS style animator for alert dialog.
 */
var IOSAlertDialogAnimator = function (_AlertDialogAnimator2) {
  inherits(IOSAlertDialogAnimator, _AlertDialogAnimator2);

  function IOSAlertDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref3$timing,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay;

    classCallCheck(this, IOSAlertDialogAnimator);
    return possibleConstructorReturn(this, (IOSAlertDialogAnimator.__proto__ || Object.getPrototypeOf(IOSAlertDialogAnimator)).call(this, { duration: duration, timing: timing, delay: delay }));
  }

  /*
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSAlertDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0) scale3d(1.3, 1.3, 1)', opacity: 0 }, { transform: 'translate3d(-50%, -50%, 0) scale3d(1, 1, 1)', opacity: 1 }).queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ opacity: 1 }, { opacity: 0 }).queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSAlertDialogAnimator;
}(AlertDialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$1 = {
  '.alert-dialog': 'alert-dialog--*',
  '.alert-dialog-container': 'alert-dialog-container--*',
  '.alert-dialog-title': 'alert-dialog-title--*',
  '.alert-dialog-content': 'alert-dialog-content--*',
  '.alert-dialog-footer': 'alert-dialog-footer--*',
  '.alert-dialog-footer--rowfooter': 'alert-dialog-footer--rowfooter--*',
  '.alert-dialog-button--rowfooter': 'alert-dialog-button--rowfooter--*',
  '.alert-dialog-button--primal': 'alert-dialog-button--primal--*',
  '.alert-dialog-button': 'alert-dialog-button--*',
  'ons-alert-dialog-button': 'alert-dialog-button--*',
  '.alert-dialog-mask': 'alert-dialog-mask--*',
  '.text-input': 'text-input--*'
};

var _animatorDict$1 = {
  'none': AlertDialogAnimator,
  'default': function _default() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? AndroidAlertDialogAnimator : IOSAlertDialogAnimator;
  }
};

/**
 * @element ons-alert-dialog
 * @category dialog
 * @description
 *   [en]
 *     Alert dialog that is displayed on top of the current screen. Useful for displaying questions, warnings or error messages to the user. The title, content and buttons can be easily customized and it will automatically switch style based on the platform.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createAlertDialog(template)` utility function and the `<template>` tag.
 *   [/en]
 *   [ja]
 *     現在のスクリーンの上に表示するアラートダイアログです。ユーザに対する問いかけ、警告、エラーメッセージを表示するのに利用できます。タイトルやコンテンツやボタンは簡単にカスタマイズでき、実行しているプラットフォームに併せてスタイルが自動的に切り替わります。
 *   [/ja]
 * @codepen Qwwxyp
 * @tutorial vanilla/Reference/alert-dialog
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja]マテリアルデザインのスタイル[/ja]
 * @modifier rowfooter
 *   [en]Horizontally aligns the footer buttons.[/en]
 *   [ja]フッターの複数のボタンを水平に配置[/ja]
 * @seealso ons-dialog
 *   [en]ons-dialog component[/en]
 *   [ja]ons-dialogコンポーネント[/ja]
 * @seealso ons-popover
 *   [en]ons-popover component[/en]
 *   [ja]ons-dialogコンポーネント[/ja]
 * @seealso ons.notification
 *   [en]Using ons.notification utility functions.[/en]
 *   [ja]アラートダイアログを表示するには、ons.notificationオブジェクトのメソッドを使うこともできます。[/ja]
 * @example
 * <ons-alert-dialog id="alert-dialog">
 *   <div class="alert-dialog-title">Warning!</div>
 *   <div class="alert-dialog-content">
 *     An error has occurred!
 *   </div>
 *   <div class="alert-dialog-footer">
 *     <button id="alert-dialog-button" class="alert-dialog-button">OK</button>
 *   </div>
 * </ons-alert-dialog>
 * <script>
 *   document.getElementById('alert-dialog').show();
 * </script>
 */

var AlertDialogElement = function (_BaseDialogElement) {
  inherits(AlertDialogElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   *   [en]Fired just before the alert dialog is displayed.[/en]
   *   [ja]アラートダイアログが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute to stop the dialog from showing.[/en]
   *   [ja]この関数を実行すると、アラートダイアログの表示を止めます。[/ja]
   */

  /**
   * @event postshow
   * @description
   *   [en]Fired just after the alert dialog is displayed.[/en]
   *   [ja]アラートダイアログが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   *   [en]Fired just before the alert dialog is hidden.[/en]
   *   [ja]アラートダイアログが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute to stop the dialog from hiding.[/en]
   *   [ja]この関数を実行すると、アラートダイアログが閉じようとするのを止めます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the alert dialog is hidden.[/en]
   * [ja]アラートダイアログが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.alertDialog
   *   [en]Alert dialog object.[/en]
   *   [ja]アラートダイアログのオブジェクト。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the dialog.[/en]
   *  [ja]ダイアログの見た目を指定します。[/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
   *  [ja]この属性を設定すると、ダイアログの背景をタップしたりAndroidデバイスのバックボタンを押すとダイアログが閉じるようになります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *  [en]If this attribute is set the dialog is disabled.[/en]
   *  [ja]この属性がある時、アラートダイアログはdisabled状態になります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
   *  [ja]ダイアログを表示する際のアニメーション名を指定します。デフォルトでは"none"か"default"が指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute mask-color
   * @type {String}
   * @default rgba(0, 0, 0, 0.2)
   * @description
   *  [en]Color of the background mask. Default is "rgba(0, 0, 0, 0.2)".[/en]
   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
   */

  function AlertDialogElement() {
    classCallCheck(this, AlertDialogElement);

    var _this = possibleConstructorReturn(this, (AlertDialogElement.__proto__ || Object.getPrototypeOf(AlertDialogElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(AlertDialogElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$1,
        baseClass: AlertDialogAnimator,
        baseClassName: 'AlertDialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /**
       * Expected result after compile:
       *
       * <ons-alert-dialog style="none">
       *   <div class="alert-dialog-mask"></div>
       *   <div class="alert-dialog">
       *     <div class="alert-dialog-container">...</div>
       *   </div>
       * </ons-alert-dialog>
       */

      var content = document.createDocumentFragment();

      if (!this._mask && !this._dialog) {
        while (this.firstChild) {
          content.appendChild(this.firstChild);
        }
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('alert-dialog-mask');
        this.insertBefore(mask, this.children[0]);
      }

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('alert-dialog');
        this.insertBefore(dialog, null);
      }

      if (!util$1.findChild(this._dialog, '.alert-dialog-container')) {
        var container = document.createElement('div');
        container.classList.add('alert-dialog-container');
        this._dialog.appendChild(container);
      }

      this._dialog.children[0].appendChild(content);

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja]そのダイアログがキャンセル可能かどうかを表します。キャンセル可能なダイアログは、背景をタップするかAndroidデバイスのバックボタンを押すことで閉じることが出来るようになります。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクトです。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。指定できるのは、"fade", "none"のいずれかです。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった時に呼び出されるコールバックを指定します。[/ja]
     * @description
     *   [en]Show the alert dialog.[/en]
     *   [ja]ダイアログを表示します。[/ja]
     * @return {Promise}
     *   [en]A `Promise` object that resolves to the displayed element.[/en]
     *   [ja]表示される要素を解決する`Promise`オブジェクトを返します。[/ja]
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"fade"` and `"none"`.[/en]
     *   [ja]アニメーション名を指定します。"fade", "none"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g.  <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code>[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. <code>{duration: 0.2, delay: 0.4, timing: 'ease-in'}</code> [/ja]
     * @param {Function} [options.callback]
     *   [en]Function to execute after the dialog has been hidden.[/en]
     *   [ja]このダイアログが閉じた時に呼び出されるコールバックを指定します。[/ja]
     * @description
     *   [en]Hide the alert dialog.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja]隠れた要素を解決する`Promise`オブジェクトを返します。[/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$1;
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_mask',
    get: function get$$1() {
      return util$1.findChild(this, '.alert-dialog-mask');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_dialog',
    get: function get$$1() {
      return util$1.findChild(this, '.alert-dialog');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_titleElement',
    get: function get$$1() {
      return util$1.findChild(this._dialog.children[0], '.alert-dialog-title');
    }

    /**
     * @return {Element}
     */

  }, {
    key: '_contentElement',
    get: function get$$1() {
      return util$1.findChild(this._dialog.children[0], '.alert-dialog-content');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof AlertDialogAnimator)) {
        util$1.throwAnimator('AlertDialog');
      }
      _animatorDict$1[name] = Animator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$1;
    }
  }, {
    key: 'AlertDialogAnimator',
    get: function get$$1() {
      return AlertDialogAnimator;
    }
  }]);
  return AlertDialogElement;
}(BaseDialogElement);

onsElements.AlertDialog = AlertDialogElement;
customElements.define('ons-alert-dialog', AlertDialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-alert-dialog-button
 * @modifier material
 *   [en]Material Design alert-dialog button.[/en]
 *   [ja]マテリアルデザインのボタンを表示します。[/ja]
 * @description
 *   [en][/en]
 *   [ja][/ja]
 * @seealso ons-alert-dialog
 *   [en]The `<ons-alert-dialog>` component displays a alert dialog.[/en]
 *   [ja]ons-alert-dialogコンポーネント[/ja]
 * @example
 *  <ons-alert-dialog>
 *    <div class="alert-dialog-title">Warning!</div>
 *    <div class="alert-dialog-content">
 *      An error has occurred!
 *    </div>
 *    <div class="alert-dialog-footer">
 *      <alert-dialog-button onclick="app.close()">Cancel</alert-dialog-button>
 *      <alert-dialog-button class="alert-dialog-button" onclick="app.close()">OK</alert-dialog-button>
 *    </div>
 *  </ons-alert-dialog>
 */

var AlertDialogButtonElement = function (_BaseButtonElement) {
  inherits(AlertDialogButtonElement, _BaseButtonElement);

  function AlertDialogButtonElement() {
    classCallCheck(this, AlertDialogButtonElement);
    return possibleConstructorReturn(this, (AlertDialogButtonElement.__proto__ || Object.getPrototypeOf(AlertDialogButtonElement)).apply(this, arguments));
  }

  createClass(AlertDialogButtonElement, [{
    key: '_scheme',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the button.[/en]
     *   [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定してください。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    get: function get$$1() {
      return { '': 'alert-dialog-button--*' };
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'alert-dialog-button';
    }
  }, {
    key: '_rippleOpt',
    get: function get$$1() {
      return [this, undefined, { 'modifier': 'light-gray' }];
    }
  }]);
  return AlertDialogButtonElement;
}(BaseButtonElement);

onsElements.AlertDialogButton = AlertDialogButtonElement;
customElements.define('ons-alert-dialog-button', AlertDialogButtonElement);

var iosBackButtonIcon = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"13px\" height=\"21px\" viewBox=\"0 0 13 21\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <title>ios-back-button-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"toolbar-back-button\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n        <g id=\"ios\" transform=\"translate(-34.000000, -30.000000)\">\n            <polygon id=\"ios-back-button-icon\" points=\"34 40.5 44.5 30 46.5 32 38 40.5 46.5 49 44.5 51\"></polygon>\n        </g>\n    </g>\n</svg>\n";

var mdBackButtonIcon = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"16px\" height=\"16px\" viewBox=\"0 0 16 16\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <title>md-back-button-icon</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id=\"toolbar-back-button\" stroke=\"none\" stroke-width=\"1\" fill-rule=\"evenodd\">\n        <g id=\"android\" transform=\"translate(-32.000000, -32.000000)\" fill-rule=\"nonzero\">\n            <polygon id=\"md-back-button-icon\" points=\"48 39 35.83 39 41.42 33.41 40 32 32 40 40 48 41.41 46.59 35.83 41 48 41\"></polygon>\n        </g>\n    </g>\n</svg>\n";

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName = 'back-button';

var scheme$2 = {
  '': 'back-button--*',
  '.back-button__icon': 'back-button--*__icon',
  '.back-button__label': 'back-button--*__label'
};

/**
 * @element ons-back-button
 * @category navigation
 * @description
 *   [en]
 *     Back button component for `<ons-toolbar>`. Put it in the left part of the `<ons-toolbar>`.
 *
 *     It will find the parent `<ons-navigator>` element and pop a page when clicked. This behavior can be overriden by specifying the `onClick` property.
 *   [/en]
 *   [ja][/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/back-button
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @seealso ons-toolbar
 *   [en]ons-toolbar component[/en]
 *   [ja]ons-toolbarコンポーネント[/ja]
 * @seealso ons-navigator
 *   [en]ons-navigator component[/en]
 *   [ja]ons-navigatorコンポーネント[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-back-button>Back</ons-back-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   <div>
 * </ons-toolbar>
 */

var BackButtonElement = function (_BaseElement) {
  inherits(BackButtonElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the back button.[/en]
   *  [ja]バックボタンの見た目を指定します。[/ja]
   */

  function BackButtonElement() {
    classCallCheck(this, BackButtonElement);

    var _this = possibleConstructorReturn(this, (BackButtonElement.__proto__ || Object.getPrototypeOf(BackButtonElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });

    _this._options = {};
    _this._boundOnClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(BackButtonElement, [{
    key: '_updateIcon',
    value: function _updateIcon() {
      var icon = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : util$1.findChild(this, '.back-button__icon');

      icon.innerHTML = autoStyle.getPlatform(this) === 'android' || util$1.hasModifier(this, 'material') ? mdBackButtonIcon : iosBackButtonIcon;
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName);

      if (!util$1.findChild(this, '.back-button__label')) {
        var label = util$1.create('span.back-button__label');

        while (this.childNodes[0]) {
          label.appendChild(this.childNodes[0]);
        }
        this.appendChild(label);
      }

      if (!util$1.findChild(this, '.back-button__icon')) {
        var icon = util$1.create('span.back-button__icon');
        this._updateIcon(icon);

        this.insertBefore(icon, this.children[0]);
      }

      util$1.updateRipple(this, undefined, { center: '', 'size': 'contain', 'background': 'transparent' });

      ModifierUtil.initModifier(this, scheme$2);
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Options object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]Animation name. Available animations are "slide", "lift", "fade" and "none".
     *     These are platform based animations. For fixed animations, add "-ios" or "-md"
     *     suffix to the animation name. E.g. "lift-ios", "lift-md". Defaults values are "slide-ios" and "fade-md".
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g.  `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

  }, {
    key: '_onClick',


    /**
     * @property onClick
     * @type {Function}
     * @description
     *   [en]Used to override the default back button behavior.[/en]
     *   [ja][/ja]
     */
    value: function _onClick() {
      if (this.onClick) {
        this.onClick.apply(this);
      } else {
        var navigator = util$1.findParent(this, 'ons-navigator');
        if (navigator) {
          navigator.popPage(this.options);
        }
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName, scheme$2);
          break;

        case 'modifier':
          {
            ModifierUtil.onModifierChanged(last, current, this, scheme$2) && this._updateIcon();
            break;
          }
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'show',
    value: function show() {
      this.style.display = 'inline-block';
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.style.display = 'none';
    }
  }, {
    key: 'options',
    get: function get$$1() {
      return this._options;
    },
    set: function set$$1(object) {
      this._options = object;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return BackButtonElement;
}(BaseElement);

onsElements.BackButton = BackButtonElement;
customElements.define('ons-back-button', BackButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$1 = 'bottom-bar';
var scheme$3 = { '': 'bottom-bar--*' };

/**
 * @element ons-bottom-toolbar
 * @category page
 * @description
 *   [en]Toolbar component that is positioned at the bottom of the page. Since bottom toolbars are very versatile elements, `ons-bottom-toolbar` does not provide any specific layout syntax for its children. Modifiers or custom CSS must be used.[/en]
 *   [ja]ページ下部に配置されるツールバー用コンポーネントです。[/ja]
 * @modifier transparent
 *   [en]Make the toolbar transparent.[/en]
 *   [ja]ツールバーの背景を透明にして表示します。[/ja]
 * @modifier aligned
 *   [en]Vertically aligns its children and applies flexbox for block elements. `justify-content` CSS rule can be used to change horizontal align.[/en]
 *   [ja]ツールバーの背景を透明にして表示します。[/ja]
 * @seealso ons-toolbar [en]ons-toolbar component[/en][ja]ons-toolbarコンポーネント[/ja]
 * @example
 * <ons-bottom-toolbar>
 *   Content
 * </ons-bottom-toolbar>
 */

var BottomToolbarElement = function (_BaseElement) {
  inherits(BottomToolbarElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the toolbar.[/en]
   *   [ja]ツールバーの見た目の表現を指定します。[/ja]
   */

  function BottomToolbarElement() {
    classCallCheck(this, BottomToolbarElement);

    var _this = possibleConstructorReturn(this, (BottomToolbarElement.__proto__ || Object.getPrototypeOf(BottomToolbarElement)).call(this));

    _this.classList.add(defaultClassName$1);
    ModifierUtil.initModifier(_this, scheme$3);
    return _this;
  }

  createClass(BottomToolbarElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (util$1.match(this.parentNode, 'ons-page')) {
        this.parentNode.classList.add('page-with-bottom-toolbar');
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$1, scheme$3);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$3);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return BottomToolbarElement;
}(BaseElement);

onsElements.BottomToolbar = BottomToolbarElement;
customElements.define('ons-bottom-toolbar', BottomToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-button
 * @category form
 * @modifier outline
 *   [en]Button with outline and transparent background[/en]
 *   [ja]アウトラインを持ったボタンを表示します。[/ja]
 * @modifier light
 *   [en]Button that doesn't stand out.[/en]
 *   [ja]目立たないボタンを表示します。[/ja]
 * @modifier quiet
 *   [en]Button with no outline and or background..[/en]
 *   [ja]枠線や背景が無い文字だけのボタンを表示します。[/ja]
 * @modifier cta
 *   [en]Button that really stands out.[/en]
 *   [ja]目立つボタンを表示します。[/ja]
 * @modifier large
 *   [en]Large button that covers the width of the screen.[/en]
 *   [ja]横いっぱいに広がる大きなボタンを表示します。[/ja]
 * @modifier large--quiet
 *   [en]Large quiet button.[/en]
 *   [ja]横いっぱいに広がるquietボタンを表示します。[/ja]
 * @modifier large--cta
 *   [en]Large call to action button.[/en]
 *   [ja]横いっぱいに広がるctaボタンを表示します。[/ja]
 * @modifier material
 *   [en]Material Design button[/en]
 *   [ja]マテリアルデザインのボタン[/ja]
 * @modifier material--flat
 *   [en]Material Design flat button[/en]
 *   [ja]マテリアルデザインのフラットボタン[/ja]
 * @description
 *   [en]
 *     Button component. If you want to place a button in a toolbar, use `<ons-toolbar-button>` or `<ons-back-button>` instead.
 *
 *     Will automatically display as a Material Design button with a ripple effect on Android.
 *   [/en]
 *   [ja]ボタン用コンポーネント。ツールバーにボタンを設置する場合は、ons-toolbar-buttonもしくはons-back-buttonコンポーネントを使用します。[/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/button
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-button modifier="large--cta">
 *   Tap Me
 * </ons-button>
 */

var ButtonElement = function (_BaseButtonElement) {
  inherits(ButtonElement, _BaseButtonElement);

  function ButtonElement() {
    classCallCheck(this, ButtonElement);
    return possibleConstructorReturn(this, (ButtonElement.__proto__ || Object.getPrototypeOf(ButtonElement)).apply(this, arguments));
  }

  createClass(ButtonElement, [{
    key: '_scheme',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the button.[/en]
     *  [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute ripple
     * @description
     *  [en]If this attribute is defined, the button will have a ripple effect.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定します。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the button is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    get: function get$$1() {
      return { '': 'button--*' };
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'button';
    }
  }]);
  return ButtonElement;
}(BaseButtonElement);

onsElements.Button = ButtonElement;
customElements.define('ons-button', ButtonElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$2 = 'card';
var scheme$4 = {
  '': 'card--*',
  '.card__title': 'card--*__title',
  '.card__content': 'card--*__content'
};

/**
 * @element ons-card
 * @category visual
 * @modifier material
 *   [en]A card with material design.[/en]
 *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
 * @description
 *   [en]
 *    Component to create a card that displays some information.
 *
 *    The card may be composed by divs with specially prepared classes `title` and/or `content`. You can also add your own content as you please.[/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/card
 * @example
 * <ons-card>
 *   <p>Some content</p>
 * </ons-card>
 */

var CardElement = function (_BaseElement) {
  inherits(CardElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the card.[/en]
   *   [ja]リストの表現を指定します。[/ja]
   */

  function CardElement() {
    classCallCheck(this, CardElement);

    var _this = possibleConstructorReturn(this, (CardElement.__proto__ || Object.getPrototypeOf(CardElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(CardElement, [{
    key: '_compile',
    value: function _compile() {
      for (var i = 0; i < this.children.length; i++) {
        var el = this.children[i];

        if (el.classList.contains('title')) {
          el.classList.add('card__title');
          
        } else if (el.classList.contains('content')) {
          el.classList.add('card__content');
          
        }
      }

      autoStyle.prepare(this);
      this.classList.add(defaultClassName$2);
      ModifierUtil.initModifier(this, scheme$4);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$2, scheme$4);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$4);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return CardElement;
}(BaseElement);

onsElements.Card = CardElement;
customElements.define('ons-card', CardElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$5 = { '': 'carousel-item--*' };

/**
 * @element ons-carousel-item
 * @category carousel
 * @description
 *   [en]
 *     Carousel item component. Used as a child of the `<ons-carousel>` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel
 *   [en]`<ons-carousel>` components[/en]
 *   [ja]<ons-carousel>コンポーネント[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselItemElement = function (_BaseElement) {
  inherits(CarouselItemElement, _BaseElement);

  function CarouselItemElement() {
    classCallCheck(this, CarouselItemElement);

    var _this = possibleConstructorReturn(this, (CarouselItemElement.__proto__ || Object.getPrototypeOf(CarouselItemElement)).call(this));

    _this.style.width = '100%';
    ModifierUtil.initModifier(_this, scheme$5);
    return _this;
  }

  createClass(CarouselItemElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        return ModifierUtil.onModifierChanged(last, current, this, scheme$5);
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier'];
    }
  }]);
  return CarouselItemElement;
}(BaseElement);

onsElements.CarouselItem = CarouselItemElement;
customElements.define('ons-carousel-item', CarouselItemElement);

var directionMap = {
  vertical: {
    axis: 'Y',
    size: 'Height',
    dir: ['up', 'down'],
    t3d: ['0px, ', 'px, 0px']
  },
  horizontal: {
    axis: 'X',
    size: 'Width',
    dir: ['left', 'right'],
    t3d: ['', 'px, 0px, 0px']
  }
};

var Swiper = function () {
  function Swiper(params) {
    var _this = this;

    classCallCheck(this, Swiper);

    // Parameters
    var FALSE = function FALSE() {
      return false;
    };
    'getInitialIndex getBubbleWidth isVertical isOverScrollable isCentered\n    isAutoScrollable refreshHook preChangeHook postChangeHook overScrollHook'.split(/\s+/).forEach(function (key) {
      return _this[key] = params[key] || FALSE;
    });

    this.getElement = params.getElement; // Required
    this.scrollHook = params.scrollHook; // Optional
    this.itemSize = params.itemSize || '100%';

    this.getAutoScrollRatio = function () {
      var ratio = params.getAutoScrollRatio && params.getAutoScrollRatio.apply(params, arguments);
      ratio = typeof ratio === 'number' && ratio === ratio ? ratio : .5;
      if (ratio < 0.0 || ratio > 1.0) {
        util$1.throw('Invalid auto-scroll-ratio ' + ratio + '. Must be between 0 and 1');
      }
      return ratio;
    };

    // Prevent clicks only on desktop
    this.shouldBlock = util$1.globals.actualMobileOS === 'other';

    // Bind handlers
    this.onDragStart = this.onDragStart.bind(this);
    this.onDrag = this.onDrag.bind(this);
    this.onDragEnd = this.onDragEnd.bind(this);
    this.onResize = this.onResize.bind(this);

    this._shouldFixScroll = util$1.globals.actualMobileOS === 'ios';
  }

  createClass(Swiper, [{
    key: 'init',
    value: function init() {
      var _this2 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          swipeable = _ref.swipeable,
          autoRefresh = _ref.autoRefresh;

      this.initialized = true;
      this.target = this.getElement().children[0];
      this.blocker = this.getElement().children[1];
      if (!this.target || !this.blocker) {
        util$1.throw('Expected "target" and "blocker" elements to exist before initializing Swiper');
      }

      if (!this.shouldBlock) {
        this.blocker.style.display = 'none';
      }

      // Add classes
      this.getElement().classList.add('ons-swiper');
      this.target.classList.add('ons-swiper-target');
      this.blocker.classList.add('ons-swiper-blocker');

      // Setup listeners
      this._gestureDetector = new GestureDetector(this.getElement(), { dragMinDistance: 1, dragLockToAxis: true, passive: !this._shouldFixScroll });
      this._mutationObserver = new MutationObserver(function () {
        return _this2.refresh();
      });
      this.updateSwipeable(swipeable);
      this.updateAutoRefresh(autoRefresh);

      // Setup initial layout
      this._scroll = this._offset = this._lastActiveIndex = 0;
      this._updateLayout();
      this._setupInitialIndex();
      setImmediate(function () {
        return _this2.initialized && _this2._setupInitialIndex();
      });

      // Fix rendering glitch on Android 4.1
      // Fix for iframes where the width is inconsistent at the beginning
      if (window !== window.parent || this.offsetHeight === 0) {
        window.requestAnimationFrame(function () {
          return _this2.initialized && _this2.onResize();
        });
      }
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this.initialized = false;
      this.updateSwipeable(false);
      this.updateAutoRefresh(false);

      this._gestureDetector && this._gestureDetector.dispose();
      this.target = this.blocker = this._gestureDetector = this._mutationObserver = null;

      this.setupResize(false);
    }
  }, {
    key: 'onResize',
    value: function onResize() {
      var i = this._scroll / this.targetSize;
      this._reset();
      this.setActiveIndex(i);
      this.refresh();
    }
  }, {
    key: '_calculateItemSize',
    value: function _calculateItemSize() {
      var matches = this.itemSize.match(/^(\d+)(px|%)/);

      if (!matches) {
        util$1.throw('Invalid state: swiper\'s size unit must be \'%\' or \'px\'');
      }

      var value = parseInt(matches[1], 10);
      return matches[2] === '%' ? Math.round(value / 100 * this.targetSize) : value;
    }
  }, {
    key: '_setupInitialIndex',
    value: function _setupInitialIndex() {
      this._reset();
      this._lastActiveIndex = Math.max(Math.min(Number(this.getInitialIndex()), this.itemCount), 0);
      this._scroll = this._offset + this.itemNumSize * this._lastActiveIndex;
      this._scrollTo(this._scroll);
    }
  }, {
    key: '_setSwiping',
    value: function _setSwiping(toggle) {
      this.target.classList.toggle('swiping', toggle); // Hides everything except shown pages
    }
  }, {
    key: 'setActiveIndex',
    value: function setActiveIndex(index) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._setSwiping(true);
      index = Math.max(0, Math.min(index, this.itemCount - 1));
      var scroll = Math.max(0, Math.min(this.maxScroll, this._offset + this.itemNumSize * index));

      if (platform.isUIWebView()) {
        /* Dirty fix for #2231(https://github.com/OnsenUI/OnsenUI/issues/2231). begin */
        var concat = function concat(arrayOfArray) {
          return Array.prototype.concat.apply([], arrayOfArray);
        };
        var contents = concat(util$1.arrayFrom(this.target.children).map(function (page) {
          return util$1.arrayFrom(page.children).filter(function (child) {
            return child.classList.contains('page__content');
          });
        }));

        var map = new Map();
        return new Promise(function (resolve) {
          contents.forEach(function (content) {
            map.set(content, content.getAttribute('class'));
            content.classList.add('page__content--suppress-layer-creation');
          });
          requestAnimationFrame(resolve);
        }).then(function () {
          return _this3._changeTo(scroll, options);
        }).then(function () {
          return new Promise(function (resolve) {
            contents.forEach(function (content) {
              content.setAttribute('class', map.get(content));
            });
            requestAnimationFrame(resolve);
          });
        });
        /* end */
      } else {
        return this._changeTo(scroll, options);
      }
    }
  }, {
    key: 'getActiveIndex',
    value: function getActiveIndex() {
      var scroll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._scroll;

      scroll -= this._offset;
      var count = this.itemCount,
          size = this.itemNumSize;

      if (this.itemNumSize === 0 || !util$1.isInteger(scroll)) {
        return this._lastActiveIndex;
      }

      if (scroll <= 0) {
        return 0;
      }

      for (var i = 0; i < count; i++) {
        if (size * i <= scroll && size * (i + 1) > scroll) {
          return i;
        }
      }

      return count - 1;
    }
  }, {
    key: 'setupResize',
    value: function setupResize(add) {
      window[(add ? 'add' : 'remove') + 'EventListener']('resize', this.onResize, true);
    }
  }, {
    key: 'show',
    value: function show() {
      var _this4 = this;

      this.setupResize(true);
      this.onResize();
      setTimeout(function () {
        return _this4.target && _this4.target.classList.add('active');
      }, 1000 / 60); // Hide elements after animations
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.setupResize(false);
      this.target.classList.remove('active'); // Show elements before animations
    }
  }, {
    key: 'updateSwipeable',
    value: function updateSwipeable(shouldUpdate) {
      if (this._gestureDetector) {
        var action = shouldUpdate ? 'on' : 'off';
        this._gestureDetector[action]('drag', this.onDrag);
        this._gestureDetector[action]('dragstart', this.onDragStart);
        this._gestureDetector[action]('dragend', this.onDragEnd);
      }
    }
  }, {
    key: 'updateAutoRefresh',
    value: function updateAutoRefresh(shouldWatch) {
      if (this._mutationObserver) {
        shouldWatch ? this._mutationObserver.observe(this.target, { childList: true }) : this._mutationObserver.disconnect();
      }
    }
  }, {
    key: 'updateItemSize',
    value: function updateItemSize(newSize) {
      this.itemSize = newSize || '100%';
      this.refresh();
    }
  }, {
    key: 'toggleBlocker',
    value: function toggleBlocker(block) {
      this.blocker.style.pointerEvents = block ? 'auto' : 'none';
    }
  }, {
    key: '_canConsumeGesture',
    value: function _canConsumeGesture(gesture) {
      var d = gesture.direction;
      var isFirst = this._scroll === 0 && !this.isOverScrollable();
      var isLast = this._scroll === this.maxScroll && !this.isOverScrollable();

      return this.isVertical() ? d === 'down' && !isFirst || d === 'up' && !isLast : d === 'right' && !isFirst || d === 'left' && !isLast;
    }
  }, {
    key: 'onDragStart',
    value: function onDragStart(event) {
      var _this5 = this;

      this._ignoreDrag = event.consumed || !util$1.isValidGesture(event);

      if (!this._ignoreDrag) {
        var consume = event.consume;
        event.consume = function () {
          consume && consume();_this5._ignoreDrag = true;
        };

        if (this._canConsumeGesture(event.gesture)) {
          var startX = event.gesture.center && event.gesture.center.clientX || 0,
              distFromEdge = this.getBubbleWidth() || 0,
              start = function start() {
            consume && consume();
            event.consumed = true;
            _this5._started = true; // Avoid starting drag from outside
            _this5.shouldBlock && _this5.toggleBlocker(true);
            _this5._setSwiping(true);
            util$1.iosPreventScroll(_this5._gestureDetector);
          };

          // Let parent elements consume the gesture or consume it right away
          startX < distFromEdge || startX > this.targetSize - distFromEdge ? setImmediate(function () {
            return !_this5._ignoreDrag && start();
          }) : start();
        }
      }
    }
  }, {
    key: 'onDrag',
    value: function onDrag(event) {
      if (!event.gesture || this._ignoreDrag || !this._started) {
        return;
      }

      this._continued = true; // Fix for random 'dragend' without 'drag'
      event.stopPropagation();

      this._scrollTo(this._scroll - this._getDelta(event), { throttle: true });
    }
  }, {
    key: 'onDragEnd',
    value: function onDragEnd(event) {
      this._started = false;
      if (!event.gesture || this._ignoreDrag || !this._continued) {
        this._ignoreDrag = true; // onDragEnd might fire before onDragStart's setImmediate
        return;
      }

      this._continued = false;
      event.stopPropagation();

      var scroll = this._scroll - this._getDelta(event);
      var normalizedScroll = this._normalizeScroll(scroll);
      scroll === normalizedScroll ? this._startMomentumScroll(scroll, event) : this._killOverScroll(normalizedScroll);
      this.shouldBlock && this.toggleBlocker(false);
    }
  }, {
    key: '_startMomentumScroll',
    value: function _startMomentumScroll(scroll, event) {
      var velocity = this._getVelocity(event),
          matchesDirection = event.gesture.interimDirection === this.dM.dir[this._getDelta(event) < 0 ? 0 : 1];

      var nextScroll = this._getAutoScroll(scroll, velocity, matchesDirection);
      var duration = Math.abs(nextScroll - scroll) / (velocity + 0.01) / 1000;
      duration = Math.min(.25, Math.max(.1, duration));

      this._changeTo(nextScroll, { swipe: true, animationOptions: { duration: duration, timing: 'cubic-bezier(.4, .7, .5, 1)' } });
    }
  }, {
    key: '_killOverScroll',
    value: function _killOverScroll(scroll) {
      var _this6 = this;

      this._scroll = scroll;
      var direction = this.dM.dir[Number(scroll > 0)];
      var killOverScroll = function killOverScroll() {
        return _this6._changeTo(scroll, { animationOptions: { duration: .4, timing: 'cubic-bezier(.1, .4, .1, 1)' } });
      };
      this.overScrollHook({ direction: direction, killOverScroll: killOverScroll }) || killOverScroll();
    }
  }, {
    key: '_changeTo',
    value: function _changeTo(scroll) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var e = { activeIndex: this.getActiveIndex(scroll), lastActiveIndex: this._lastActiveIndex, swipe: options.swipe || false };
      var change = e.activeIndex !== e.lastActiveIndex;
      var canceled = change ? this.preChangeHook(e) : false;

      this._scroll = canceled ? this._offset + e.lastActiveIndex * this.itemNumSize : scroll;
      this._lastActiveIndex = canceled ? e.lastActiveIndex : e.activeIndex;

      return this._scrollTo(this._scroll, options).then(function () {
        if (scroll === _this7._scroll && !canceled) {
          _this7._setSwiping(false);
          change && _this7.postChangeHook(e);
        } else if (options.reject) {
          _this7._setSwiping(false);
          return Promise.reject('Canceled');
        }
      });
    }
  }, {
    key: '_scrollTo',
    value: function _scrollTo(scroll) {
      var _this8 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (options.throttle) {
        var ratio = 0.35;
        if (scroll < 0) {
          scroll = this.isOverScrollable() ? Math.round(scroll * ratio) : 0;
        } else {
          var maxScroll = this.maxScroll;
          if (maxScroll < scroll) {
            scroll = this.isOverScrollable() ? maxScroll + Math.round((scroll - maxScroll) * ratio) : maxScroll;
          }
        }
      }

      var opt = options.animation === 'none' ? {} : options.animationOptions;
      this.scrollHook && this.itemNumSize > 0 && this.scrollHook((scroll / this.itemNumSize).toFixed(2), options.animationOptions || {});

      return new Promise(function (resolve) {
        return Animit(_this8.target).queue({ transform: _this8._getTransform(scroll) }, opt).play(resolve);
      });
    }
  }, {
    key: '_getAutoScroll',
    value: function _getAutoScroll(scroll, velocity, matchesDirection) {
      var max = this.maxScroll,
          offset = this._offset,
          size = this.itemNumSize;

      if (!this.isAutoScrollable()) {
        return Math.max(0, Math.min(max, scroll));
      }

      var arr = [];
      for (var s = offset; s < max; s += size) {
        arr.push(s);
      }
      arr.push(max);

      arr = arr.sort(function (left, right) {
        return Math.abs(left - scroll) - Math.abs(right - scroll);
      }).filter(function (item, pos) {
        return !pos || item !== arr[pos - 1];
      });

      var result = arr[0];
      var lastScroll = this._lastActiveIndex * size + offset;
      var scrollRatio = Math.abs(scroll - lastScroll) / size;

      if (scrollRatio <= this.getAutoScrollRatio(matchesDirection, velocity, size)) {
        result = lastScroll;
      } else {
        if (scrollRatio < 1.0 && arr[0] === lastScroll && arr.length > 1) {
          result = arr[1];
        }
      }
      return Math.max(0, Math.min(max, result));
    }
  }, {
    key: '_reset',
    value: function _reset() {
      this._targetSize = this._itemNumSize = undefined;
    }
  }, {
    key: '_normalizeScroll',
    value: function _normalizeScroll(scroll) {
      return Math.max(Math.min(scroll, this.maxScroll), 0);
    }
  }, {
    key: 'refresh',
    value: function refresh() {
      this._reset();
      this._updateLayout();

      if (util$1.isInteger(this._scroll)) {
        var scroll = this._normalizeScroll(this._scroll);
        scroll !== this._scroll ? this._killOverScroll(scroll) : this._changeTo(scroll);
      } else {
        this._setupInitialIndex();
      }

      this.refreshHook();
    }
  }, {
    key: '_getDelta',
    value: function _getDelta(event) {
      return event.gesture['delta' + this.dM.axis];
    }
  }, {
    key: '_getVelocity',
    value: function _getVelocity(event) {
      return event.gesture['velocity' + this.dM.axis];
    }
  }, {
    key: '_getTransform',
    value: function _getTransform(scroll) {
      return 'translate3d(' + this.dM.t3d[0] + -scroll + this.dM.t3d[1] + ')';
    }
  }, {
    key: '_updateLayout',
    value: function _updateLayout() {
      this.dM = directionMap[this.isVertical() ? 'vertical' : 'horizontal'];
      this.target.classList.toggle('ons-swiper-target--vertical', this.isVertical());

      for (var c = this.target.children[0]; c; c = c.nextElementSibling) {
        c.style[this.dM.size.toLowerCase()] = this.itemSize;
      }

      if (this.isCentered()) {
        this._offset = (this.targetSize - this.itemNumSize) / -2 || 0;
      }
    }
  }, {
    key: 'itemCount',
    get: function get$$1() {
      return this.target.children.length;
    }
  }, {
    key: 'itemNumSize',
    get: function get$$1() {
      if (typeof this._itemNumSize !== 'number' || this._itemNumSize !== this._itemNumSize) {
        this._itemNumSize = this._calculateItemSize();
      }
      return this._itemNumSize;
    }
  }, {
    key: 'maxScroll',
    get: function get$$1() {
      var max = this.itemCount * this.itemNumSize - this.targetSize;
      return Math.ceil(max < 0 ? 0 : max); // Need to return an integer value.
    }
  }, {
    key: 'targetSize',
    get: function get$$1() {
      if (!this._targetSize) {
        this._targetSize = this.target['offset' + this.dM.size];
      }
      return this._targetSize;
    }
  }]);
  return Swiper;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-carousel
 * @category carousel
 * @description
 *   [en]
 *     Carousel component. A carousel can be used to display several items in the same space.
 *
 *     The component supports displaying content both horizontally and vertically. The user can scroll through the items by dragging and it can also be controller programmatically.
 *   [/en]
 *   [ja][/ja]
 * @codepen xbbzOQ
 * @tutorial vanilla/Reference/carousel
 * @seealso ons-carousel-item
 *   [en]`<ons-carousel-item>` component[/en]
 *   [ja]ons-carousel-itemコンポーネント[/ja]
 * @example
 * <ons-carousel style="width: 100%; height: 200px">
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 *   <ons-carousel-item>
 *    ...
 *   </ons-carousel-item>
 * </ons-carousel>
 */

var CarouselElement = function (_BaseElement) {
  inherits(CarouselElement, _BaseElement);

  /**
   * @event postchange
   * @description
   *   [en]Fired just after the current carousel item has changed.[/en]
   *   [ja]現在表示しているカルーセルの要素が変わった時に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.carousel
   *   [en]Carousel object.[/en]
   *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
   * @param {Number} event.activeIndex
   *   [en]Current active index.[/en]
   *   [ja]現在アクティブになっている要素のインデックス。[/ja]
   * @param {Number} event.lastActiveIndex
   *   [en]Previous active index.[/en]
   *   [ja]以前アクティブだった要素のインデックス。[/ja]
   */

  /**
   * @event refresh
   * @description
   *   [en]Fired when the carousel has been refreshed.[/en]
   *   [ja]カルーセルが更新された時に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.carousel
   *   [en]Carousel object.[/en]
   *   [ja]イベントが発火したCarouselオブジェクトです。[/ja]
   */

  /**
   * @event overscroll
   * @description
   *   [en]Fired when the carousel has been overscrolled.[/en]
   *   [ja]カルーセルがオーバースクロールした時に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.carousel
   *   [en]Fired when the carousel has been refreshed.[/en]
   *   [ja]カルーセルが更新された時に発火します。[/ja]
   * @param {Number} event.activeIndex
   *   [en]Current active index.[/en]
   *   [ja]現在アクティブになっている要素のインデックス。[/ja]
   * @param {String} event.direction
   *   [en]Can be one of either "up", "down", "left" or "right".[/en]
   *   [ja]オーバースクロールされた方向が得られます。"up", "down", "left", "right"のいずれかの方向が渡されます。[/ja]
   * @param {Function} event.waitToReturn
   *   [en]Takes a <code>Promise</code> object as an argument. The carousel will not scroll back until the promise has been resolved or rejected.[/en]
   *   [ja]この関数はPromiseオブジェクトを引数として受け取ります。渡したPromiseオブジェクトがresolveされるかrejectされるまで、カルーセルはスクロールバックしません。[/ja]
   */

  /**
   * @attribute direction
   * @type {String}
   * @description
   *   [en]The direction of the carousel. Can be either "horizontal" or "vertical". Default is "horizontal".[/en]
   *   [ja]カルーセルの方向を指定します。"horizontal"か"vertical"を指定できます。"horizontal"がデフォルト値です。[/ja]
   */

  /**
   * @attribute fullscreen
   * @description
   *   [en]If this attribute is set the carousel will cover the whole screen.[/en]
   *   [ja]この属性があると、absoluteポジションを使ってカルーセルが自動的に画面いっぱいに広がります。[/ja]
   */

  /**
   * @attribute overscrollable
   * @description
   *   [en]If this attribute is set the carousel will be scrollable over the edge. It will bounce back when released.[/en]
   *   [ja]この属性がある時、タッチやドラッグで端までスクロールした時に、バウンドするような効果が当たります。[/ja]
   */

  /**
   * @attribute centered
   * @description
   *   [en]If this attribute is set the carousel then the selected item will be in the center of the carousel instead of the beginning. Useful only when the items are smaller than the carousel. [/en]
   *   [ja]この属性がある時、選んでいるons-carousel-itemはカルーセルの真ん中へ行きます。項目がカルーセルよりも小さい場合にのみ、これは便利です。[/ja]
   */

  /**
   * @attribute item-width
   * @type {String}
   * @description
   *    [en]ons-carousel-item's width. Only works when the direction is set to "horizontal".[/en]
   *    [ja]ons-carousel-itemの幅を指定します。この属性は、direction属性に"horizontal"を指定した時のみ有効になります。[/ja]
   */

  /**
   * @attribute item-height
   * @type {String}
   * @description
   *   [en]ons-carousel-item's height. Only works when the direction is set to "vertical".[/en]
   *   [ja]ons-carousel-itemの高さを指定します。この属性は、direction属性に"vertical"を指定した時のみ有効になります。[/ja]
   */

  /**
   * @attribute auto-scroll
   * @description
   *   [en]If this attribute is set the carousel will be automatically scrolled to the closest item border when released.[/en]
   *   [ja]この属性がある時、一番近いcarousel-itemの境界まで自動的にスクロールするようになります。[/ja]
   */

  /**
   * @attribute auto-scroll-ratio
   * @type {Number}
   * @description
   *    [en]A number between 0.0 and 1.0 that specifies how much the user must drag the carousel in order for it to auto scroll to the next item.[/en]
   *    [ja]0.0から1.0までの値を指定します。カルーセルの要素をどれぐらいの割合までドラッグすると次の要素に自動的にスクロールするかを指定します。[/ja]
   */

  /**
   * @attribute swipeable
   * @description
   *   [en]If this attribute is set the carousel can be scrolled by drag or swipe.[/en]
   *   [ja]この属性がある時、カルーセルをスワイプやドラッグで移動できるようになります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]If this attribute is set the carousel is disabled.[/en]
   *   [ja]この属性がある時、dragやtouchやswipeを受け付けなくなります。[/ja]
   */

  /**
   * @attribute initial-index
   * @initonly
   * @default 0
   * @type {Number}
   * @description
   *   [en]Specify the index of the ons-carousel-item to show initially. Default is 0.[/en]
   *   [ja]最初に表示するons-carousel-itemを0始まりのインデックスで指定します。デフォルト値は 0 です。[/ja]
   */

  /**
   * @attribute auto-refresh
   * @description
   *   [en]When this attribute is set the carousel will automatically refresh when the number of child nodes change.[/en]
   *   [ja]この属性がある時、子要素の数が変わるとカルーセルは自動的に更新されるようになります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @description
   *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *   [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *   [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。例：{duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  function CarouselElement() {
    classCallCheck(this, CarouselElement);

    var _this = possibleConstructorReturn(this, (CarouselElement.__proto__ || Object.getPrototypeOf(CarouselElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(CarouselElement, [{
    key: '_compile',
    value: function _compile() {
      var target = this.children[0] && this.children[0].tagName !== 'ONS-CAROUSEL-ITEM' && this.children[0] || document.createElement('div');
      if (!target.parentNode) {
        while (this.firstChild) {
          target.appendChild(this.firstChild);
        }
        this.appendChild(target);
      }

      !this.children[1] && this.appendChild(document.createElement('div'));

      this.appendChild = this.appendChild.bind(target);
      this.insertBefore = this.insertBefore.bind(target);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (!this._swiper) {
        this._swiper = new Swiper({
          getElement: function getElement() {
            return _this2;
          },
          getInitialIndex: function getInitialIndex() {
            return _this2.getAttribute('initial-index');
          },
          getAutoScrollRatio: function getAutoScrollRatio() {
            return _this2.autoScrollRatio;
          },
          isVertical: function isVertical() {
            return _this2.vertical;
          },
          isOverScrollable: function isOverScrollable() {
            return _this2.overscrollable;
          },
          isCentered: function isCentered() {
            return _this2.centered;
          },
          isAutoScrollable: function isAutoScrollable() {
            return _this2.autoScroll;
          },
          itemSize: this.itemSize,
          overScrollHook: this._onOverScroll.bind(this),
          preChangeHook: this._onChange.bind(this, 'prechange'),
          postChangeHook: this._onChange.bind(this, 'postchange'),
          refreshHook: this._onRefresh.bind(this),
          scrollHook: function scrollHook() {
            return _this2._onSwipe && _this2._onSwipe.apply(_this2, arguments);
          }
        });

        contentReady(this, function () {
          return _this2._swiper.init({
            swipeable: _this2.hasAttribute('swipeable'),
            autoRefresh: _this2.hasAttribute('auto-refresh')
          });
        });
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._swiper && this._swiper.initialized) {
        this._swiper.dispose();
        this._swiper = null;
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (!this._swiper) {
        return;
      }

      switch (name) {
        case 'swipeable':
          this._swiper.updateSwipeable(this.hasAttribute('swipeable'));
          break;
        case 'auto-refresh':
          this._swiper.updateAutoRefresh(this.hasAttribute('auto-refresh'));
          break;
        case 'item-height':
          this.vertical && this._swiper.updateItemSize(this.itemSize);
          break;
        case 'item-width':
          this.vertical || this._swiper.updateItemSize(this.itemSize);
          break;
        case 'direction':
          this._swiper.refresh();
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      this._swiper.show();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this._swiper.hide();
    }
  }, {
    key: '_onOverScroll',
    value: function _onOverScroll(_ref) {
      var direction = _ref.direction,
          killOverScroll = _ref.killOverScroll;

      var waitForAction = false;
      util$1.triggerElementEvent(this, 'overscroll', {
        carousel: this,
        activeIndex: this.getActiveIndex(),
        direction: direction,
        waitToReturn: function waitToReturn(promise) {
          waitForAction = true;
          promise.then(killOverScroll);
        }
      });

      return waitForAction;
    }
  }, {
    key: '_onChange',
    value: function _onChange(eventName, _ref2) {
      var activeIndex = _ref2.activeIndex,
          lastActiveIndex = _ref2.lastActiveIndex;

      util$1.triggerElementEvent(this, eventName, { carousel: this, activeIndex: activeIndex, lastActiveIndex: lastActiveIndex });
    }
  }, {
    key: '_onRefresh',
    value: function _onRefresh() {
      util$1.triggerElementEvent(this, 'refresh', { carousel: this });
    }

    /**
     * @method setActiveIndex
     * @signature setActiveIndex(index, [options])
     * @param {Number} index
     *   [en]The index that the carousel should be set to.[/en]
     *   [ja]carousel要素のインデックスを指定します。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be called after the animation is finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Specify the index of the `<ons-carousel-item>` to show.[/en]
     *   [ja]表示するons-carousel-itemをindexで指定します。[/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveIndex',
    value: function setActiveIndex(index) {
      var _this3 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      options = _extends({
        animation: this.getAttribute('animation'),
        animationOptions: this.hasAttribute('animation-options') ? util$1.animationOptionsParse(this.getAttribute('animation-options')) : { duration: .3, timing: 'cubic-bezier(.4, .7, .5, 1)' }
      }, options);

      return this._swiper.setActiveIndex(index, options).then(function () {
        options.callback instanceof Function && options.callback(_this3);
        return Promise.resolve(_this3);
      });
    }

    /**
     * @method getActiveIndex
     * @signature getActiveIndex()
     * @return {Number}
     *   [en]The current carousel item index.[/en]
     *   [ja]現在表示しているカルーセル要素のインデックスが返されます。[/ja]
     * @description
     *   [en]Returns the index of the currently visible `<ons-carousel-item>`.[/en]
     *   [ja]現在表示されているons-carousel-item要素のインデックスを返します。[/ja]
     */

  }, {
    key: 'getActiveIndex',
    value: function getActiveIndex() {
      return this._swiper.getActiveIndex();
    }

    /**
     * @method next
     * @signature next([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show next `<ons-carousel-item>`.[/en]
     *   [ja]次のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'next',
    value: function next(options) {
      return this.setActiveIndex(this.getActiveIndex() + 1, options);
    }

    /**
     * @method prev
     * @signature prev([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show previous `<ons-carousel-item>`.[/en]
     *   [ja]前のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'prev',
    value: function prev(options) {
      return this.setActiveIndex(this.getActiveIndex() - 1, options);
    }

    /**
     * @method first
     * @signature first()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this is set to `"none"`, the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja][/ja]
     * @description
     *   [en]Show first `<ons-carousel-item>`.[/en]
     *   [ja]最初のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'first',
    value: function first(options) {
      return this.setActiveIndex(0, options);
    }

    /**
     * @method last
     * @signature last()
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja][/ja]
     * @param {Function} [options.callback]
     *   [en]A function that will be executed after the animation has finished.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
     *   [ja][/ja]
     * @param {Object} [options.animationOptions]
     *   [en]An object that can be used to specify the duration, delay and timing function of the animation.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the carousel element[/en]
     *   [ja]Resolves to the carousel element[/ja]
     * @description
     *   [en]Show last ons-carousel item.[/en]
     *   [ja]最後のons-carousel-itemを表示します。[/ja]
     */

  }, {
    key: 'last',
    value: function last(options) {
      this.setActiveIndex(Math.max(this.itemCount - 1, 0), options);
    }

    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Update the layout of the carousel. Used when adding `<ons-carousel-items>` dynamically or to automatically adjust the size.[/en]
     *   [ja]レイアウトや内部の状態を最新のものに更新します。ons-carousel-itemを動的に増やしたり、ons-carouselの大きさを動的に変える際に利用します。[/ja]
     */

  }, {
    key: 'refresh',
    value: function refresh() {
      this._swiper.refresh();
    }

    /**
     * @property itemCount
     * @readonly
     * @type {Number}
     * @description
     *   [en]The number of carousel items.[/en]
     *   [ja]カルーセル要素の数です。[/ja]
     */

  }, {
    key: 'itemCount',
    get: function get$$1() {
      return this._swiper.itemCount;
    }

    /**
     * @property swipeable
     * @type {Boolean}
     * @description
     *   [en]true if the carousel is swipeable.[/en]
     *   [ja]swipeableであればtrueを返します。[/ja]
     */

  }, {
    key: 'swipeable',
    get: function get$$1() {
      return this.hasAttribute('swipeable');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'swipeable', value);
    }

    /**
     * @property onSwipe
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user slides the carousel. It gets a decimal index and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onSwipe',
    get: function get$$1() {
      return this._onSwipe;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        util$1.throw('"onSwipe" must be a function');
      }
      this._onSwipe = value;
    }

    /**
     * @property autoScroll
     * @type {Boolean}
     * @description
     *   [en]true if auto scroll is enabled.[/en]
     *   [ja]オートスクロールが有効であればtrueを返します。[/ja]
     */

  }, {
    key: 'autoScroll',
    get: function get$$1() {
      return this.hasAttribute('auto-scroll');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'auto-scroll', value);
    }
  }, {
    key: 'vertical',
    get: function get$$1() {
      return this.getAttribute('direction') === 'vertical';
    }
  }, {
    key: 'itemSize',
    get: function get$$1() {
      var itemSizeAttr = (this.getAttribute('item-' + (this.vertical ? 'height' : 'width')) || '').trim();
      return itemSizeAttr.match(/^\d+(px|%)$/) ? itemSizeAttr : '100%';
    }

    /**
     * @property autoScrollRatio
     * @type {Number}
     * @description
     *   [en]The current auto scroll ratio. [/en]
     *   [ja]現在のオートスクロールのratio値。[/ja]
     */

  }, {
    key: 'autoScrollRatio',
    get: function get$$1() {
      return parseFloat(this.getAttribute('auto-scroll-ratio'));
    },
    set: function set$$1(ratio) {
      this.setAttribute('auto-scroll-ratio', ratio);
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    get: function get$$1() {
      return this.hasAttribute('disabled');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    }

    /**
     * @property overscrollable
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is overscrollable or not.[/en]
     *   [ja]overscrollできればtrueを返します。[/ja]
     */

  }, {
    key: 'overscrollable',
    get: function get$$1() {
      return this.hasAttribute('overscrollable');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'overscrollable', value);
    }

    /**
     * @property centered
     * @type {Boolean}
     * @description
     *   [en]Whether the carousel is centered or not.[/en]
     *   [ja]centered状態になっていればtrueを返します。[/ja]
     */

  }, {
    key: 'centered',
    get: function get$$1() {
      return this.hasAttribute('centered');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'centered', value);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['swipeable', 'auto-refresh', 'direction', 'item-height', 'item-width'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['postchange', 'refresh', 'overscroll'];
    }
  }]);
  return CarouselElement;
}(BaseElement);

onsElements.Carousel = CarouselElement;
customElements.define('ons-carousel', CarouselElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-col
 * @category grid
 * @description
 *   [en]Represents a column in the grid system. Use with `<ons-row>` to layout components.[/en]
 *   [ja]グリッドシステムにて列を定義します。ons-rowとともに使用し、コンポーネントのレイアウトに利用します。[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-column, they may not be displayed correctly. You can use only one alignment.[/en]
 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-columnを組み合わせた場合に描画が崩れる場合があります。[/ja]
 * @codepen GgujC {wide}
 * @guide theming.html [en]Layouting guide[/en][ja]レイアウト機能[/ja]
 * @seealso ons-row
 *   [en]The `<ons-row>` component is the parent of `<ons-col>`.[/en]
 *   [ja]ons-rowコンポーネント[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Vertical alignment of the column. Valid values are "top", "center", and "bottom".[/en]
 *   [ja]縦の配置を指定する。"top", "center", "bottom"のいずれかを指定します。[/ja]
 */

/**
 * @attribute width
 * @type {String}
 * @description
 *   [en]The width of the column. Valid values are css width values ("10%", "50px").[/en]
 *   [ja]カラムの横幅を指定する。パーセントもしくはピクセルで指定します（10%や50px）。[/ja]
 */

var ColElement = function (_BaseElement) {
  inherits(ColElement, _BaseElement);

  function ColElement() {
    classCallCheck(this, ColElement);

    var _this = possibleConstructorReturn(this, (ColElement.__proto__ || Object.getPrototypeOf(ColElement)).call(this));

    if (_this.getAttribute('width')) {
      _this._updateWidth();
    }
    return _this;
  }

  createClass(ColElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'width') {
        this._updateWidth();
      }
    }
  }, {
    key: '_updateWidth',
    value: function _updateWidth() {
      var width = this.getAttribute('width');
      if (!width) {
        styler.clear(this, 'flex maxWidth');
      } else {
        width = width.trim().match(/^\d+$/) ? width + '%' : width;

        styler(this, {
          flex: '0 0 ' + width,
          maxWidth: width
        });
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['width'];
    }
  }]);
  return ColElement;
}(BaseElement);

onsElements.Col = ColElement;
customElements.define('ons-col', ColElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var DialogAnimator = function (_BaseAnimator) {
  inherits(DialogAnimator, _BaseAnimator);

  function DialogAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, DialogAnimator);
    return possibleConstructorReturn(this, (DialogAnimator.__proto__ || Object.getPrototypeOf(DialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} dialog
   * @param {Function} done
   */


  createClass(DialogAnimator, [{
    key: 'show',
    value: function show(dialog, done) {
      done();
    }

    /**
     * @param {HTMLElement} dialog
     * @param {Function} done
     */

  }, {
    key: 'hide',
    value: function hide(dialog, done) {
      done();
    }
  }]);
  return DialogAnimator;
}(BaseAnimator);

/**
 * Android style animator for dialog.
 */
var AndroidDialogAnimator = function (_DialogAnimator) {
  inherits(AndroidDialogAnimator, _DialogAnimator);

  function AndroidDialogAnimator() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref2$timing = _ref2.timing,
        timing = _ref2$timing === undefined ? 'ease-in-out' : _ref2$timing,
        _ref2$delay = _ref2.delay,
        delay = _ref2$delay === undefined ? 0 : _ref2$delay,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === undefined ? 0.3 : _ref2$duration;

    classCallCheck(this, AndroidDialogAnimator);
    return possibleConstructorReturn(this, (AndroidDialogAnimator.__proto__ || Object.getPrototypeOf(AndroidDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(AndroidDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -60%, 0)', opacity: 0 }, { transform: 'translate3d(-50%, -50%, 0)', opacity: 1 }).queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0)', opacity: 1 }, { transform: 'translate3d(-50%, -60%, 0)', opacity: 0 }).queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return AndroidDialogAnimator;
}(DialogAnimator);

/**
 * iOS style animator for dialog.
 */
var IOSDialogAnimator = function (_DialogAnimator2) {
  inherits(IOSDialogAnimator, _DialogAnimator2);

  function IOSDialogAnimator() {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref3$timing = _ref3.timing,
        timing = _ref3$timing === undefined ? 'ease-in-out' : _ref3$timing,
        _ref3$delay = _ref3.delay,
        delay = _ref3$delay === undefined ? 0 : _ref3$delay,
        _ref3$duration = _ref3.duration,
        duration = _ref3$duration === undefined ? 0.2 : _ref3$duration;

    classCallCheck(this, IOSDialogAnimator);

    var _this3 = possibleConstructorReturn(this, (IOSDialogAnimator.__proto__ || Object.getPrototypeOf(IOSDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this3.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    return _this3;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(IOSDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)' }, { transform: 'translate3d(-50%, -50%, 0)' }).queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0)' }, { transform: 'translate3d(-50%, ' + (this.bodyHeight / 2.0 - 1) + 'px, 0)' }).queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return IOSDialogAnimator;
}(DialogAnimator);

/**
 * Slide animator for dialog.
 */
var SlideDialogAnimator = function (_DialogAnimator3) {
  inherits(SlideDialogAnimator, _DialogAnimator3);

  function SlideDialogAnimator() {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$timing = _ref4.timing,
        timing = _ref4$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref4$timing,
        _ref4$delay = _ref4.delay,
        delay = _ref4$delay === undefined ? 0 : _ref4$delay,
        _ref4$duration = _ref4.duration,
        duration = _ref4$duration === undefined ? 0.2 : _ref4$duration;

    classCallCheck(this, SlideDialogAnimator);

    var _this4 = possibleConstructorReturn(this, (SlideDialogAnimator.__proto__ || Object.getPrototypeOf(SlideDialogAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this4.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    return _this4;
  }

  /**
   * @param {Object} dialog
   * @param {Function} callback
   */


  createClass(SlideDialogAnimator, [{
    key: 'show',
    value: function show(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 0 }, { opacity: 1 }), Animit(dialog._dialog, this.def).default(
      // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.
      { transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)' }, { transform: 'translate3d(-50%, -50%, 0)' }).queue(function (done) {
        callback();
        done();
      }));
    }

    /**
     * @param {Object} dialog
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(dialog, callback) {
      callback = callback ? callback : function () {};

      Animit.runAll(Animit(dialog._mask, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(dialog._dialog, this.def).default({ transform: 'translate3d(-50%, -50%, 0)' },
      // FIXME: This should avoid Forced Synchronous Layout. Otherwise, fade animation of mask will be broken.
      { transform: 'translate3d(-50%, ' + (-(this.bodyHeight / 2.0) + 1 - dialog._dialog.clientHeight) + 'px, 0)' }).queue(function (done) {
        callback();
        done();
      }));
    }
  }]);
  return SlideDialogAnimator;
}(DialogAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$6 = {
  '.dialog': 'dialog--*',
  '.dialog-container': 'dialog-container--*',
  '.dialog-mask': 'dialog-mask--*'
};

var _animatorDict$2 = {
  'default': function _default() {
    return platform.isAndroid() ? AndroidDialogAnimator : IOSDialogAnimator;
  },
  'slide': SlideDialogAnimator,
  'none': DialogAnimator
};

/**
 * @element ons-dialog
 * @category dialog
 * @description
 *   [en]
 *     Dialog that is displayed on top of current screen. As opposed to the `<ons-alert-dialog>` element, this component can contain any kind of content.
 *
 *     To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createDialog(template)` utility function and the `<template>` tag.
 *
 *     The dialog is useful for displaying menus, additional information or to ask the user to make a decision.
 *
 *     It will automatically be displayed as Material Design when running on an Android device.
 *   [/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design dialog.[/en]
 *   [ja]マテリアルデザインのダイアログを表示します。[/ja]
 * @codepen zxxaGa
 * @tutorial vanilla/Reference/dialog
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-alert-dialog
 *   [en]`<ons-alert-dialog>` component[/en]
 *   [ja]ons-alert-dialogコンポーネント[/ja]
 * @seealso ons-popover
 *   [en]`<ons-popover>` component[/en]
 *   [ja]ons-popoverコンポーネント[/ja]
 * @seealso ons-modal
 *   [en]`<ons-modal>` component[/en]
 *   [ja]ons-modalコンポーネント[/ja]
 * @example
 * <ons-dialog id="dialog">
 *   <p>This is a dialog!</p>
 * </ons-dialog>
 *
 * <script>
 *   document.getElementById('dialog').show();
 * </script>
 */

var DialogElement = function (_BaseDialogElement) {
  inherits(DialogElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   * [en]Fired just before the dialog is displayed.[/en]
   * [ja]ダイアログが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the dialog from being shown.[/en]
   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   * [en]Fired just after the dialog is displayed.[/en]
   * [ja]ダイアログが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   * [en]Fired just before the dialog is hidden.[/en]
   * [ja]ダイアログが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the dialog from being hidden.[/en]
   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the dialog is hidden.[/en]
   * [ja]ダイアログが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.dialog
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the dialog.[/en]
   *  [ja]ダイアログの表現を指定します。[/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *  [en]If this attribute is set the dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute disabled
   * @description
   *  [en]If this attribute is set the dialog is disabled.[/en]
   *  [ja]この属性がある時、ダイアログはdisabled状態になります。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the dialog. Can be either `"none"` or `"default"`.[/en]
   *  [ja]ダイアログを表示する際のアニメーション名を指定します。"none"もしくは"default"を指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
   */

  /**
   * @attribute mask-color
   * @type {String}
   * @default rgba(0, 0, 0, 0.2)
   * @description
   *  [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
   *  [ja]背景のマスクの色を指定します。"rgba(0, 0, 0, 0.2)"がデフォルト値です。[/ja]
   */

  function DialogElement() {
    classCallCheck(this, DialogElement);

    var _this = possibleConstructorReturn(this, (DialogElement.__proto__ || Object.getPrototypeOf(DialogElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(DialogElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$2,
        baseClass: DialogAnimator,
        baseClassName: 'DialogAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10001;

      /* Expected result:
       *   <ons-dialog>
       *     <div class="dialog-mask"></div>
       *     <div class="dialog">
       *       <div class="dialog-container">...</div>
       *     </div>
       *   </ons-dialog>
       */

      if (!this._dialog) {
        var dialog = document.createElement('div');
        dialog.classList.add('dialog');

        var container = document.createElement('div');
        container.classList.add('dialog-container');
        while (this.firstChild) {
          container.appendChild(this.firstChild);
        }
        dialog.appendChild(container);

        this.appendChild(dialog);
      }

      if (!this._mask) {
        var mask = document.createElement('div');
        mask.classList.add('dialog-mask');
        this.insertBefore(mask, this.firstChild);
      }

      this._dialog.style.zIndex = 20001;
      this._mask.style.zIndex = 20000;

      this.setAttribute('status-bar-fill', '');

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the dialog has been revealed.[/en]
     *   [ja]ダイアログが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *  [en]Show the dialog.[/en]
     *  [ja]ダイアログを開きます。[/ja]
     * @return {Promise} Resolves to the displayed element.
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"slide"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "slide"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the dialog has been hidden.[/en]
     *   [ja]ダイアログが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Hide the dialog.[/en]
     *   [ja]ダイアログを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]Whether the dialog is cancelable or not. A cancelable dialog can be closed by tapping the background or by pressing the back button on Android devices.[/en]
     *   [ja][/ja]
     */

    /**
     * @param {String} name
     * @param {DialogAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$6;
    }
  }, {
    key: '_mask',
    get: function get$$1() {
      return util$1.findChild(this, '.dialog-mask');
    }
  }, {
    key: '_dialog',
    get: function get$$1() {
      return util$1.findChild(this, '.dialog');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof DialogAnimator)) {
        util$1.throwAnimator('Dialog');
      }
      _animatorDict$2[name] = Animator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$2;
    }
  }, {
    key: 'DialogAnimator',
    get: function get$$1() {
      return DialogAnimator;
    }
  }]);
  return DialogElement;
}(BaseDialogElement);

onsElements.Dialog = DialogElement;
customElements.define('ons-dialog', DialogElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$3 = 'fab';

var scheme$7 = {
  '': 'fab--*',
  '.fab__icon': 'fab--*__icon'
};

/**
 * @element ons-fab
 * @category form
 * @description
 *   [en]
 *     The Floating action button is a circular button defined in the [Material Design specification](https://www.google.com/design/spec/components/buttons-floating-action-button.html). They are often used to promote the primary action of the app.
 *
 *     It can be displayed either as an inline element or in one of the corners. Normally it will be positioned in the lower right corner of the screen.
 *   [/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/fab
 * @modifier mini
 *   [en]Makes the `ons-fab` smaller.[/en]
 *   [ja][/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component is a Floating action button that displays a menu when tapped.[/en]
 *   [ja][/ja]
 */

var FabElement = function (_BaseElement) {
  inherits(FabElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the button.[/en]
   *  [ja]ボタンの表現を指定します。[/ja]
   */

  /**
   * @attribute ripple
   * @description
   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute position
   * @type {String}
   * @description
   *  [en]The position of the button. Should be a string like `"bottom right"` or `"top left"`. If this attribute is not defined it will be displayed as an inline element.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if button should be disabled.[/en]
   *   [ja]ボタンを無効化する場合は指定します。[/ja]
   */

  function FabElement() {
    classCallCheck(this, FabElement);

    // The following statements can be executed before contentReady
    // since these do not access the children
    var _this = possibleConstructorReturn(this, (FabElement.__proto__ || Object.getPrototypeOf(FabElement)).call(this));

    _this.hide();
    _this.classList.add(defaultClassName$3);

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(FabElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (!util$1.findChild(this, '.fab__icon')) {
        var content = document.createElement('span');
        content.classList.add('fab__icon');

        util$1.arrayFrom(this.childNodes).forEach(function (element) {
          if (!element.tagName || element.tagName.toLowerCase() !== 'ons-ripple') {
            content.appendChild(element);
          }
        });
        this.appendChild(content);
      }

      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$7);

      this._updatePosition();
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      setImmediate(function () {
        return _this2.show();
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$3, scheme$7);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$7);
          break;
        case 'ripple':
          this._updateRipple();
          break;
        case 'position':
          this._updatePosition();
          break;
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      this.show();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      var _this3 = this;

      setImmediate(function () {
        return _this3.hide();
      });
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util$1.updateRipple(this);
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }

    /**
     * @method show
     * @signature show()
     * @description
     *  [en]Show the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      this.toggle(true);
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *  [en]Hide the floating action button.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      this.toggle(false);
    }

    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle the visibility of the button.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.visible;

      var isBottom = (this.getAttribute('position') || '').indexOf('bottom') >= 0;
      var translate = isBottom ? 'translate3d(0px, -' + (util$1.globals.fabOffset || 0) + 'px, 0px)' : '';

      styler(this, { transform: translate + ' scale(' + Number(action) + ')' });
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'visible',
    get: function get$$1() {
      return this.style.transform.indexOf('scale(0)') === -1 && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'ripple', 'position', 'class'];
    }
  }]);
  return FabElement;
}(BaseElement);

onsElements.Fab = FabElement;
customElements.define('ons-fab', FabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-gesture-detector
 * @category gesture
 * @description
 *   [en]
 *     Component to detect finger gestures within the wrapped element. Following gestures are supported:
 *     - Drag gestures: `drag`, `dragleft`, `dragright`, `dragup`, `dragdown`
 *     - Hold gestures: `hold`, `release`
 *     - Swipe gestures: `swipe`, `swipeleft`, `swiperight`, `swipeup`, `swipedown`
 *     - Tap gestures: `tap`, `doubletap`
 *     - Pinch gestures: `pinch`, `pinchin`, `pinchout`
 *     - Other gestures: `touch`, `transform`, `rotate`
 *   [/en]
 *   [ja]要素内のジェスチャー操作を検知します。詳しくはガイドを参照してください。[/ja]
 * @guide features.html#gesture-detection
 *   [en]Detecting finger gestures[/en]
 *   [ja]ジェスチャー操作の検知[/ja]
 * @example
 * <ons-gesture-detector>
 *   <div id="detect-area" style="width: 100px; height: 100px;">
 *     Swipe Here
 *   </div>
 * </ons-gesture-detector>
 *
 * <script>
 *   document.addEventListener('swipeleft', function(event) {
 *     if (event.target.matches('#detect-area')) {
 *       console.log('Swipe left is detected.');
 *     }
 *   });
 * </script>
 */

var GestureDetectorElement = function (_BaseElement) {
  inherits(GestureDetectorElement, _BaseElement);

  function GestureDetectorElement() {
    classCallCheck(this, GestureDetectorElement);

    var _this = possibleConstructorReturn(this, (GestureDetectorElement.__proto__ || Object.getPrototypeOf(GestureDetectorElement)).call(this));

    _this._gestureDetector = new GestureDetector(_this, { passive: true });
    return _this;
  }

  return GestureDetectorElement;
}(BaseElement);

onsElements.GestureDetector = GestureDetectorElement;
customElements.define('ons-gesture-detector', GestureDetectorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var autoPrefix = 'fa'; // FIXME: To be removed in v3

/**
 * @element ons-icon
 * @category visual
 * @description
 *   [en]
 *     Displays an icon. The following icon suites are available:
 *
 *     * [Font Awesome](https://fortawesome.github.io/Font-Awesome/)
 *     * [Ionicons](http://ionicons.com/)
 *     * [Material Design Iconic Font](http://zavoloklom.github.io/material-design-iconic-font/)
 *   [/en]
 *   [ja][/ja]
 * @codepen xAhvg
 * @tutorial vanilla/Reference/icon
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja][/ja]
 * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
 * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
 * @example
 * <ons-icon
 *   icon="md-car"
 *   size="20px"
 *   style="color: red">
 * </ons-icon>
 *
 * <ons-button>
 *   <ons-icon icon="md-car"></ons-icon>
 *   Car
 * </ons-button>
 */

var IconElement = function (_BaseElement) {
  inherits(IconElement, _BaseElement);

  /**
   * @attribute icon
   * @type {String}
   * @description
   *   [en]
   *     The icon name. `"md-"` prefix for Material Icons, `"fa-"` for Font Awesome and `"ion-"` prefix for Ionicons.
   *
   *     See all available icons on the element description (at the top).
   *
   *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
   *
   *     The code `<ons-icon icon="ion-edit, material:md-edit"></ons-icon>` will display `"md-edit"` for Material Design and `"ion-edit"` as the default icon.
   *
   *     `fa-` prefix is added automatically if none is provided. Check [See also](#seealso) section for more information.
   *   [/en]
   *   [ja][/ja]
   */

  /**
   * @attribute size
   * @type {String}
   * @description
   *   [en]
   *     The sizes of the icon. Valid values are lg, 2x, 3x, 4x, 5x, or in the size in pixels.
   *     Icons can also be styled based on modifier presence. Add comma-separated icons with `"modifierName:"` prefix.
   *
   *     The code:
   *
   *     ```
   *     <ons-icon
   *       icon="ion-edit"
   *       size="32px, material:24px">
   *     </ons-icon>
   *     ```
   *
   *     will render as a `24px` icon if the `"material"` modifier is present and `32px` otherwise.
   *   [/en]
   *   [ja][/ja]
   */

  /**
   * @attribute rotate
   * @type {Number}
   * @description
   *   [en]Number of degrees to rotate the icon. Valid values are 90, 180 and 270.[/en]
   *   [ja]アイコンを回転して表示します。90, 180, 270から指定できます。[/ja]
   */

  /**
   * @attribute fixed-width
   * @type {Boolean}
   * @default false
   * @description
   *  [en]When used in a list, you want the icons to have the same width so that they align vertically by defining this attribute.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute spin
   * @description
   *   [en]Specify whether the icon should be spinning.[/en]
   *   [ja]アイコンを回転するかどうかを指定します。[/ja]
   */

  function IconElement() {
    classCallCheck(this, IconElement);

    var _this = possibleConstructorReturn(this, (IconElement.__proto__ || Object.getPrototypeOf(IconElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(IconElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      this._cleanClassAttribute(name === 'icon' ? last : this.getAttribute('icon'), name === 'modifier' ? last : undefined);
      this._update();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this._update();
    }
  }, {
    key: '_update',
    value: function _update() {
      var _this2 = this;

      var _buildClassAndStyle2 = this._buildClassAndStyle(this._parseAttr('icon'), this._parseAttr('size')),
          classList = _buildClassAndStyle2.classList,
          style = _buildClassAndStyle2.style;

      util$1.extend(this.style, style);

      classList.forEach(function (className) {
        return _this2.classList.add(className);
      });
    }
  }, {
    key: '_parseAttr',
    value: function _parseAttr(attrName) {
      var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getAttribute('modifier') || '';

      var attr = this.getAttribute(attrName) || attrName || '';
      var parts = attr.split(/\s*,\s*/);
      var def = parts[0];
      var md = parts[1];
      md = (md || '').split(/\s*:\s*/);

      return (modifier && RegExp('(^|\\s+)' + md[0] + '($|\\s+)', 'i').test(modifier) ? md[1] : def) || '';
    }

    /**
     * Remove unneeded class value.
     */

  }, {
    key: '_cleanClassAttribute',
    value: function _cleanClassAttribute(lastIcon, lastModifier) {
      var _this3 = this;

      var _prefixIcon2 = this._prefixIcon(this._parseAttr(lastIcon, lastModifier)),
          className = _prefixIcon2.className,
          prefix = _prefixIcon2.prefix;

      var customPrefixRE = className !== prefix ? '|' + prefix + '$|' + prefix + '-' : '|' + className + '$' || '';
      var re = new RegExp('^(fa$|fa-|ion-|zmdi$|zmdi-|ons-icon--' + customPrefixRE + ')');

      util$1.arrayFrom(this.classList).filter(function (className) {
        return re.test(className);
      }).forEach(function (className) {
        return _this3.classList.remove(className);
      });
    }
  }, {
    key: '_prefixIcon',
    value: function _prefixIcon(iconName) {
      var className = autoPrefix + (autoPrefix ? '-' : '') + iconName;
      return { className: className, prefix: className.split('-')[0] };
    }
  }, {
    key: '_buildClassAndStyle',
    value: function _buildClassAndStyle(iconName, size) {
      var classList = ['ons-icon'];
      var style = {};

      // Icon
      if (iconName.indexOf('ion-') === 0) {
        classList.push(iconName);
        classList.push('ons-icon--ion');
      } else if (iconName.indexOf('fa-') === 0) {
        classList.push(iconName);
        classList.push('fa');
      } else if (iconName.indexOf('md-') === 0) {
        classList.push('zmdi');
        classList.push('zmdi-' + iconName.split(/-(.+)?/)[1]);
      } else {
        var _prefixIcon3 = this._prefixIcon(iconName),
            className = _prefixIcon3.className,
            prefix = _prefixIcon3.prefix;

        prefix && classList.push(prefix);
        className && classList.push(className);
      }

      // Size
      if (size.match(/^[1-5]x|lg$/)) {
        classList.push('ons-icon--' + size);
        this.style.removeProperty('font-size');
      } else {
        style.fontSize = size;
      }

      return {
        classList: classList,
        style: style
      };
    }
  }], [{
    key: 'setAutoPrefix',
    value: function setAutoPrefix(prefix) {
      autoPrefix = prefix ? typeof prefix === 'string' && prefix || 'fa' : '';
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return ['icon', 'size', 'modifier', 'class'];
    }
  }]);
  return IconElement;
}(BaseElement);

onsElements.Icon = IconElement;
customElements.define('ons-icon', IconElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var LazyRepeatDelegate = function () {
  function LazyRepeatDelegate(userDelegate) {
    var templateElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    classCallCheck(this, LazyRepeatDelegate);

    if ((typeof userDelegate === 'undefined' ? 'undefined' : _typeof(userDelegate)) !== 'object' || userDelegate === null) {
      util$1.throw('"delegate" parameter must be an object');
    }
    this._userDelegate = userDelegate;

    if (!(templateElement instanceof Element) && templateElement !== null) {
      util$1.throw('"templateElement" parameter must be an instance of Element or null');
    }
    this._templateElement = templateElement;
  }

  createClass(LazyRepeatDelegate, [{
    key: 'hasRenderFunction',


    /**
     * @return {Boolean}
     */
    value: function hasRenderFunction() {
      return this._userDelegate._render instanceof Function;
    }

    /**
     * @return {void}
     */

  }, {
    key: '_render',
    value: function _render() {
      this._userDelegate._render.apply(this._userDelegate, arguments);
    }

    /**
     * @param {Number} index
     * @param {Function} done A function that take item object as parameter.
     */

  }, {
    key: 'loadItemElement',
    value: function loadItemElement(index, done) {
      if (this._userDelegate.loadItemElement instanceof Function) {
        this._userDelegate.loadItemElement(index, done);
      } else {
        var element = this._userDelegate.createItemContent(index, this._templateElement);
        if (!(element instanceof Element)) {
          util$1.throw('"createItemContent" must return an instance of Element');
        }

        done({ element: element });
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'countItems',
    value: function countItems() {
      var count = this._userDelegate.countItems();
      if (typeof count !== 'number') {
        util$1.throw('"countItems" must return a number');
      }
      return count;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     * @param {Element} item.element
     */

  }, {
    key: 'updateItem',
    value: function updateItem(index, item) {
      if (this._userDelegate.updateItemContent instanceof Function) {
        this._userDelegate.updateItemContent(index, item);
      }
    }

    /**
     * @return {Number}
     */

  }, {
    key: 'calculateItemHeight',
    value: function calculateItemHeight(index) {
      if (this._userDelegate.calculateItemHeight instanceof Function) {
        var height = this._userDelegate.calculateItemHeight(index);

        if (typeof height !== 'number') {
          util$1.throw('"calculateItemHeight" must return a number');
        }

        return height;
      }

      return 0;
    }

    /**
     * @param {Number} index
     * @param {Object} item
     */

  }, {
    key: 'destroyItem',
    value: function destroyItem(index, item) {
      if (this._userDelegate.destroyItem instanceof Function) {
        this._userDelegate.destroyItem(index, item);
      }
    }

    /**
     * @return {void}
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      if (this._userDelegate.destroy instanceof Function) {
        this._userDelegate.destroy();
      }

      this._userDelegate = this._templateElement = null;
    }
  }, {
    key: 'itemHeight',
    get: function get$$1() {
      return this._userDelegate.itemHeight;
    }
  }]);
  return LazyRepeatDelegate;
}();

/**
 * This class provide core functions for ons-lazy-repeat.
 */
var LazyRepeatProvider = function () {

  /**
   * @param {Element} wrapperElement
   * @param {LazyRepeatDelegate} delegate
   */
  function LazyRepeatProvider(wrapperElement, delegate) {
    classCallCheck(this, LazyRepeatProvider);

    if (!(delegate instanceof LazyRepeatDelegate)) {
      util$1.throw('"delegate" parameter must be an instance of LazyRepeatDelegate');
    }

    this._wrapperElement = wrapperElement;
    this._delegate = delegate;
    this._insertIndex = this._wrapperElement.children[0] && this._wrapperElement.children[0].tagName === 'ONS-LAZY-REPEAT' ? 1 : 0;

    if (wrapperElement.tagName.toLowerCase() === 'ons-list') {
      wrapperElement.classList.add('lazy-list');
    }

    this._pageContent = this._findPageContentElement(wrapperElement);

    if (!this._pageContent) {
      util$1.throw('LazyRepeat must be descendant of a Page element');
    }

    this.lastScrollTop = this._pageContent.scrollTop;
    this.padding = 0;
    this._topPositions = [0];
    this._renderedItems = {};

    if (!this._delegate.itemHeight && !this._delegate.calculateItemHeight(0)) {
      this._unknownItemHeight = true;
    }

    this._addEventListeners();
    this._onChange();
  }

  createClass(LazyRepeatProvider, [{
    key: '_findPageContentElement',
    value: function _findPageContentElement(wrapperElement) {
      var pageContent = util$1.findParent(wrapperElement, '.page__content');

      if (pageContent) {
        return pageContent;
      }

      var page = util$1.findParent(wrapperElement, 'ons-page');
      if (page) {
        var content = util$1.findChild(page, '.content');
        if (content) {
          return content;
        }
      }

      return null;
    }
  }, {
    key: '_checkItemHeight',
    value: function _checkItemHeight(callback) {
      var _this = this;

      this._delegate.loadItemElement(0, function (item) {
        if (!_this._unknownItemHeight) {
          util$1.throw('Invalid state');
        }

        _this._wrapperElement.appendChild(item.element);

        var done = function done() {
          _this._delegate.destroyItem(0, item);
          item.element && item.element.remove();
          delete _this._unknownItemHeight;
          callback();
        };

        _this._itemHeight = item.element.offsetHeight;

        if (_this._itemHeight > 0) {
          done();
          return;
        }

        // retry to measure offset height
        // dirty fix for angular2 directive
        _this._wrapperElement.style.visibility = 'hidden';
        item.element.style.visibility = 'hidden';

        setImmediate(function () {
          _this._itemHeight = item.element.offsetHeight;
          if (_this._itemHeight == 0) {
            util$1.throw('Invalid state: "itemHeight" must be greater than zero');
          }
          _this._wrapperElement.style.visibility = '';
          done();
        });
      });
    }
  }, {
    key: '_countItems',
    value: function _countItems() {
      return this._delegate.countItems();
    }
  }, {
    key: '_getItemHeight',
    value: function _getItemHeight(i) {
      // Item is rendered
      if (this._renderedItems.hasOwnProperty(i)) {
        if (!this._renderedItems[i].hasOwnProperty('height')) {
          this._renderedItems[i].height = this._renderedItems[i].element.offsetHeight;
        }
        return this._renderedItems[i].height;
      }

      // Item is not rendered, scroll up
      if (this._topPositions[i + 1] && this._topPositions[i]) {
        return this._topPositions[i + 1] - this._topPositions[i];
      }
      // Item is not rendered, scroll down
      return this.staticItemHeight || this._delegate.calculateItemHeight(i);
    }
  }, {
    key: '_calculateRenderedHeight',
    value: function _calculateRenderedHeight() {
      var _this2 = this;

      return Object.keys(this._renderedItems).reduce(function (a, b) {
        return a + _this2._getItemHeight(+b);
      }, 0);
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      this._render();
    }
  }, {
    key: '_lastItemRendered',
    value: function _lastItemRendered() {
      return Math.max.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));
    }
  }, {
    key: '_firstItemRendered',
    value: function _firstItemRendered() {
      return Math.min.apply(Math, toConsumableArray(Object.keys(this._renderedItems)));
    }
  }, {
    key: 'refresh',
    value: function refresh() {
      var forceRender = { forceScrollDown: true };
      var lastItemIndex = Math.min(this._lastItemRendered(), this._countItems() - 1);
      var firstItemIndex = this._firstItemRendered();

      if (util$1.isInteger(lastItemIndex)) {
        forceRender.forceLastIndex = lastItemIndex;
      }

      if (util$1.isInteger(firstItemIndex)) {
        this._wrapperElement.style.height = this._topPositions[firstItemIndex] + this._calculateRenderedHeight() + 'px';
        this.padding = this._topPositions[firstItemIndex];
        forceRender.forceFirstIndex = firstItemIndex;
      }

      this._removeAllElements();
      this._render(forceRender);
      this._wrapperElement.style.height = 'inherit';
    }
  }, {
    key: '_render',
    value: function _render() {
      var _this3 = this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$forceScrollDown = _ref.forceScrollDown,
          forceScrollDown = _ref$forceScrollDown === undefined ? false : _ref$forceScrollDown,
          forceFirstIndex = _ref.forceFirstIndex,
          forceLastIndex = _ref.forceLastIndex;

      if (this._unknownItemHeight) {
        return this._checkItemHeight(this._render.bind(this, arguments[0]));
      }

      var isScrollUp = !forceScrollDown && this.lastScrollTop > this._pageContent.scrollTop;
      this.lastScrollTop = this._pageContent.scrollTop;
      var keep = {};

      var offset = this._wrapperElement.getBoundingClientRect().top;
      var limit = 4 * window.innerHeight - offset;
      var count = this._countItems();

      var start = forceFirstIndex || Math.max(0, this._calculateStartIndex(offset) - 30); // Recalculate for 0 or undefined
      var i = start;

      for (var top = this._topPositions[i]; i < count && top < limit; i++) {
        if (i >= this._topPositions.length) {
          // perf optimization
          this._topPositions.length += 100;
        }

        this._topPositions[i] = top;
        top += this._getItemHeight(i);
      }

      if (this._delegate.hasRenderFunction && this._delegate.hasRenderFunction()) {
        return this._delegate._render(start, i, function () {
          _this3.padding = _this3._topPositions[start];
        });
      }

      if (isScrollUp) {
        for (var j = i - 1; j >= start; j--) {
          keep[j] = true;
          this._renderElement(j, isScrollUp);
        }
      } else {
        var lastIndex = forceLastIndex || Math.max.apply(Math, [i - 1].concat(toConsumableArray(Object.keys(this._renderedItems)))); // Recalculate for 0 or undefined
        for (var _j = start; _j <= lastIndex; _j++) {
          keep[_j] = true;
          this._renderElement(_j, isScrollUp);
        }
      }

      Object.keys(this._renderedItems).forEach(function (key) {
        return keep[key] || _this3._removeElement(key, isScrollUp);
      });
    }

    /**
     * @param {Number} index
     * @param {Boolean} isScrollUp
     */

  }, {
    key: '_renderElement',
    value: function _renderElement(index, isScrollUp) {
      var _this4 = this;

      var item = this._renderedItems[index];
      if (item) {
        this._delegate.updateItem(index, item); // update if it exists
        return;
      }

      this._delegate.loadItemElement(index, function (item) {
        if (isScrollUp) {
          _this4._wrapperElement.insertBefore(item.element, _this4._wrapperElement.children[_this4._insertIndex]);
          _this4.padding = _this4._topPositions[index];
          item.height = _this4._topPositions[index + 1] - _this4._topPositions[index];
        } else {
          _this4._wrapperElement.appendChild(item.element);
        }

        _this4._renderedItems[index] = item;
      });
    }

    /**
     * @param {Number} index
     * @param {Boolean} isScrollUp
     */

  }, {
    key: '_removeElement',
    value: function _removeElement(index) {
      var isScrollUp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      index = +index;
      var item = this._renderedItems[index];
      this._delegate.destroyItem(index, item);

      if (isScrollUp) {
        this._topPositions[index + 1] = undefined;
      } else {
        this.padding = this.padding + this._getItemHeight(index);
      }

      if (item.element.parentElement) {
        item.element.parentElement.removeChild(item.element);
      }

      delete this._renderedItems[index];
    }
  }, {
    key: '_removeAllElements',
    value: function _removeAllElements() {
      var _this5 = this;

      Object.keys(this._renderedItems).forEach(function (key) {
        return _this5._removeElement(key);
      });
    }
  }, {
    key: '_recalculateTopPositions',
    value: function _recalculateTopPositions(start, end) {
      for (var i = start; i <= end; i++) {
        this._topPositions[i + 1] = this._topPositions[i] + this._getItemHeight(i);
      }
    }
  }, {
    key: '_calculateStartIndex',
    value: function _calculateStartIndex(current) {
      var firstItemIndex = this._firstItemRendered();
      var lastItemIndex = this._lastItemRendered();

      // Fix for Safari scroll and Angular 2
      this._recalculateTopPositions(firstItemIndex, lastItemIndex);

      var start = 0;
      var end = this._countItems() - 1;

      // Binary search for index at top of screen so we can speed up rendering.
      for (;;) {
        var middle = Math.floor((start + end) / 2);
        var value = current + this._topPositions[middle];

        if (end < start) {
          return 0;
        } else if (value <= 0 && value + this._getItemHeight(middle) > 0) {
          return middle;
        } else if (isNaN(value) || value >= 0) {
          end = middle - 1;
        } else {
          start = middle + 1;
        }
      }
    }
  }, {
    key: '_debounce',
    value: function _debounce(func, wait, immediate) {
      var timeout = void 0;
      return function () {
        var _this6 = this,
            _arguments = arguments;

        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        if (callNow) {
          func.apply(this, arguments);
        } else {
          timeout = setTimeout(function () {
            timeout = null;
            func.apply(_this6, _arguments);
          }, wait);
        }
      };
    }
  }, {
    key: '_doubleFireOnTouchend',
    value: function _doubleFireOnTouchend() {
      this._render();
      this._debounce(this._render.bind(this), 100);
    }
  }, {
    key: '_addEventListeners',
    value: function _addEventListeners() {
      util$1.bindListeners(this, ['_onChange', '_doubleFireOnTouchend']);

      if (platform.isIOS()) {
        this._boundOnChange = this._debounce(this._boundOnChange, 30);
      }

      this._pageContent.addEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        util$1.addEventListener(this._pageContent, 'touchmove', this._boundOnChange, { capture: true, passive: true });
        this._pageContent.addEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.addEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: '_removeEventListeners',
    value: function _removeEventListeners() {
      this._pageContent.removeEventListener('scroll', this._boundOnChange, true);

      if (platform.isIOS()) {
        util$1.removeEventListener(this._pageContent, 'touchmove', this._boundOnChange, { capture: true, passive: true });
        this._pageContent.removeEventListener('touchend', this._boundDoubleFireOnTouchend, true);
      }

      window.document.removeEventListener('resize', this._boundOnChange, true);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this._removeAllElements();
      this._delegate.destroy();
      this._parentElement = this._delegate = this._renderedItems = null;
      this._removeEventListeners();
    }
  }, {
    key: 'padding',
    get: function get$$1() {
      return parseInt(this._wrapperElement.style.paddingTop, 10);
    },
    set: function set$$1(newValue) {
      this._wrapperElement.style.paddingTop = newValue + 'px';
    }
  }, {
    key: 'staticItemHeight',
    get: function get$$1() {
      return this._delegate.itemHeight || this._itemHeight;
    }
  }]);
  return LazyRepeatProvider;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/**
 * @element ons-lazy-repeat
 * @category list
 * @description
 *   [en]
 *     Using this component a list with millions of items can be rendered without a drop in performance.
 *     It does that by "lazily" loading elements into the DOM when they come into view and
 *     removing items from the DOM when they are not visible.
 *   [/en]
 *   [ja]
 *     このコンポーネント内で描画されるアイテムのDOM要素の読み込みは、画面に見えそうになった時まで自動的に遅延され、
 *     画面から見えなくなった場合にはその要素は動的にアンロードされます。
 *     このコンポーネントを使うことで、パフォーマンスを劣化させること無しに巨大な数の要素を描画できます。
 *   [/ja]
 * @codepen QwrGBm
 * @tutorial vanilla/Reference/lazy-repeat
 * @seealso ons-list
 *   [en]The `<ons-list>` element is used to render a list.[/en]
 *   [ja]`<ons-list>`要素はリストを描画するのに使われます。[/ja]
 * @example
 * <script>
 *   window.addEventListener('load', function() {
 *     var lazyRepeat = document.querySelector('#list');
 *     lazyRepeat.delegate = {
 *      createItemContent: function(i, template) {
 *        var dom = template.cloneNode(true);
 *        dom.innerText = i;
 *
 *        return dom;
 *      },
 *      countItems: function() {
 *        return 10000000;
 *      },
 *      destroyItem: function(index, item) {
 *        console.log('Destroyed item with index: ' + index);
 *      }
 *     };
 *   });
 * </script>
 *
 * <ons-list id="list">
 *   <ons-lazy-repeat>
 *     <ons-list-item></ons-list-item>
 *   </ons-lazy-repeat>
 * </ons-list>
 */

var LazyRepeatElement = function (_BaseElement) {
  inherits(LazyRepeatElement, _BaseElement);

  function LazyRepeatElement() {
    classCallCheck(this, LazyRepeatElement);
    return possibleConstructorReturn(this, (LazyRepeatElement.__proto__ || Object.getPrototypeOf(LazyRepeatElement)).apply(this, arguments));
  }

  createClass(LazyRepeatElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      // not very good idea and also not documented
      if (this.hasAttribute('delegate')) {
        this.delegate = window[this.getAttribute('delegate')];
      }
    }

    /**
     * @property delegate
     * @type {Object}
     * @description
     *  [en]Specify a delegate object to load and unload item elements.[/en]
     *  [ja]要素のロード、アンロードなどの処理を委譲するオブジェクトを指定します。[/ja]
     */

    /**
     * @property delegate.createItemContent
     * @type {Function}
     * @description
     *   [en]
     *     This function should return a `HTMLElement`.
     *
     *     To help rendering the element, the current index and a template is supplied as arguments. The template is the initial content of the `<ons-lazy-repeat>` element.
     *   [/en]
     *   [ja]
     *     この関数は`HTMLElement`を返してください。
     *     要素を生成しやすくするために、現在のアイテムのインデックスとテンプレートが引数に渡されます。
     *     このテンプレートは、`<ons-lazy-repeat>`要素のコンテンツが渡されます。
     *   [/ja]
     */

    /**
     * @property delegate.countItems
     * @type {Function}
     * @description
     *   [en]Should return the number of items in the list.[/en]
     *   [ja]リスト内のアイテム数を返してください。[/ja]
     */

    /**
     * @property delegate.calculateItemHeight
     * @type {Function}
     * @description
     *   [en]
     *     Should return the height of an item. The index is provided as an argument.
     *
     *     This is important when rendering lists where the items have different height.
     *
     *     The function is optional and if it isn't present the height of the first item will be automatically calculated and used for all other items.
     *   [/en]
     *   [ja]
     *     アイテムの高さ(ピクセル)を返してください。アイテムのインデックス値は引数で渡されます。
     *     この関数は、それぞれのアイムが違った高さを持つリストをレンダリングする際に重要です。
     *     この関数はオプショナルです。もしこの関数が無い場合には、
     *     最初のアイテムの高さが他のすべてのアイテムの高さとして利用されます。
     *   [/ja]
     */

    /**
     * @property delegate.destroyItem
     * @type {Function}
     * @description
     *   [en]
     *     This function is used called when an item is removed from the DOM. The index and DOM element is provided as arguments.
     *
     *     The function is optional but may be important in order to avoid memory leaks.
     *   [/en]
     *   [ja]
     *     この関数は、あるアイテムがDOMツリーから除かれた時に呼び出されます。
     *     アイテムのインデックス値とDOM要素が引数として渡されます。
     *     この関数はオプショナルですが、各アイテムの後処理が必要な場合にはメモリーリークを避けるために重要です。
     *   [/ja]
     */

  }, {
    key: 'refresh',


    /**
     * @method refresh
     * @signature refresh()
     * @description
     *   [en]Refresh the list. Use this method when the data has changed.[/en]
     *   [ja]リストを更新します。もしデータが変わった場合にはこのメソッドを使ってください。[/ja]
     */
    value: function refresh() {
      this._lazyRepeatProvider && this._lazyRepeatProvider.refresh();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._lazyRepeatProvider) {
        this._lazyRepeatProvider.destroy();
        this._lazyRepeatProvider = null;
      }
    }
  }, {
    key: 'delegate',
    set: function set$$1(userDelegate) {
      this._lazyRepeatProvider && this._lazyRepeatProvider.destroy();

      if (!this._templateElement && this.children[0]) {
        this._templateElement = this.removeChild(this.children[0]);
      }

      var delegate = new LazyRepeatDelegate(userDelegate, this._templateElement || null);
      this._lazyRepeatProvider = new LazyRepeatProvider(this.parentElement, delegate);
    },
    get: function get$$1() {
      util$1.throw('No delegate getter');
    }
  }]);
  return LazyRepeatElement;
}(BaseElement);

internal$1.LazyRepeatDelegate = LazyRepeatDelegate;
internal$1.LazyRepeatProvider = LazyRepeatProvider;

onsElements.LazyRepeat = LazyRepeatElement;
customElements.define('ons-lazy-repeat', LazyRepeatElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$4 = 'list-header';
var scheme$8 = { '': 'list-header--*' };

/**
 * @element ons-list-header
 * @category list
 * @description
 *   [en]Header element for list items. Must be put inside the `<ons-list>` component.[/en]
 *   [ja]リスト要素に使用するヘッダー用コンポーネント。ons-listと共に使用します。[/ja]
 * @seealso ons-list
 *   [en]The `<ons-list>` component[/en]
 *   [ja]ons-listコンポーネント[/ja]
 * @seealso ons-list-item
 *   [en]The `<ons-list-item>` component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @modifier material
 *   [en]Display a Material Design list header.[/en]
 *   [ja][/ja]
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListHeaderElement = function (_BaseElement) {
  inherits(ListHeaderElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the list header.[/en]
   *   [ja]ヘッダーの表現を指定します。[/ja]
   */

  function ListHeaderElement() {
    classCallCheck(this, ListHeaderElement);

    var _this = possibleConstructorReturn(this, (ListHeaderElement.__proto__ || Object.getPrototypeOf(ListHeaderElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(ListHeaderElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$4);
      ModifierUtil.initModifier(this, scheme$8);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$4, scheme$8);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$8);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ListHeaderElement;
}(BaseElement);

onsElements.ListHeader = ListHeaderElement;
customElements.define('ons-list-header', ListHeaderElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$5 = 'list-title';
var scheme$9 = { '': 'list-title--*' };

/**
 * @element ons-list-title
 * @category list
 * @description
 *   [en]Represents a list title.[/en]
 *   [ja]リストのタイトルを表現します。[/ja]
 * @example
 * <ons-list-title>List Title</ons-list-title>
 * <ons-list>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 * @modifier material
 *   [en]Display a Material Design list title.[/en]
 *   [ja][/ja]
 */

var ListTitleElement = function (_BaseElement) {
  inherits(ListTitleElement, _BaseElement);

  function ListTitleElement() {
    classCallCheck(this, ListTitleElement);

    var _this = possibleConstructorReturn(this, (ListTitleElement.__proto__ || Object.getPrototypeOf(ListTitleElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(ListTitleElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$5);
      ModifierUtil.initModifier(this, scheme$9);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$5, scheme$9);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$9);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ListTitleElement;
}(BaseElement);

onsElements.ListTitle = ListTitleElement;
customElements.define('ons-list-title', ListTitleElement);

/*
Copyright 2013-2018 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var ListItemAnimator = function (_BaseAnimator) {
  inherits(ListItemAnimator, _BaseAnimator);

  function ListItemAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ListItemAnimator);
    return possibleConstructorReturn(this, (ListItemAnimator.__proto__ || Object.getPrototypeOf(ListItemAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  createClass(ListItemAnimator, [{
    key: 'showExpansion',
    value: function showExpansion(listItem, callback) {
      callback();
    }
  }, {
    key: 'hideExpansion',
    value: function hideExpansion(listItem, callback) {
      callback();
    }
  }]);
  return ListItemAnimator;
}(BaseAnimator);

var SlideListItemAnimator = function (_ListItemAnimator) {
  inherits(SlideListItemAnimator, _ListItemAnimator);

  function SlideListItemAnimator() {
    classCallCheck(this, SlideListItemAnimator);
    return possibleConstructorReturn(this, (SlideListItemAnimator.__proto__ || Object.getPrototypeOf(SlideListItemAnimator)).apply(this, arguments));
  }

  createClass(SlideListItemAnimator, [{
    key: 'showExpansion',
    value: function showExpansion(listItem, callback) {
      this._animateExpansion(listItem, true, callback);
    }
  }, {
    key: 'hideExpansion',
    value: function hideExpansion(listItem, callback) {
      this._animateExpansion(listItem, false, callback);
    }
  }, {
    key: '_animateExpansion',
    value: function _animateExpansion(listItem, shouldOpen, callback) {
      var _animit;

      // To animate the opening of the expansion panel correctly, we need to know its
      // height. To calculate this, we set its height to auto, and then get the computed
      // height and padding. Once this is done, we set the height back to its original value.
      var oldHeight = listItem.expandableContent.style.height;
      var oldDisplay = listItem.expandableContent.style.display;
      listItem.expandableContent.style.height = 'auto';
      listItem.expandableContent.style.display = 'block';
      var computedStyle = window.getComputedStyle(listItem.expandableContent);

      var expansionOpenTransition = [{ height: 0, paddingTop: 0, paddingBottom: 0 }, {
        height: computedStyle.height,
        paddingTop: computedStyle.paddingTop,
        paddingBottom: computedStyle.paddingBottom
      }];
      var iconOpenTransition = [{ transform: 'rotate(45deg)' }, { transform: 'rotate(225deg)' }];

      // Now that we have the values we need, reset the height back to its original state
      listItem.expandableContent.style.height = oldHeight;

      (_animit = Animit(listItem.expandableContent, { duration: this.duration, property: 'height padding-top padding-bottom' })).default.apply(_animit, toConsumableArray(shouldOpen ? expansionOpenTransition : expansionOpenTransition.reverse())).play(function () {
        listItem.expandableContent.style.display = oldDisplay;
        callback && callback();
      });

      if (listItem.expandChevron) {
        var _animit2;

        (_animit2 = Animit(listItem.expandChevron, { duration: this.duration, property: 'transform' })).default.apply(_animit2, toConsumableArray(shouldOpen ? iconOpenTransition : iconOpenTransition.reverse())).play();
      }
    }
  }]);
  return SlideListItemAnimator;
}(ListItemAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$6 = 'list-item';
var scheme$10 = {
  '.list-item': 'list-item--*',
  '.list-item__left': 'list-item--*__left',
  '.list-item__center': 'list-item--*__center',
  '.list-item__right': 'list-item--*__right',
  '.list-item__label': 'list-item--*__label',
  '.list-item__title': 'list-item--*__title',
  '.list-item__subtitle': 'list-item--*__subtitle',
  '.list-item__thumbnail': 'list-item--*__thumbnail',
  '.list-item__icon': 'list-item--*__icon'
};

var _animatorDict$3 = {
  'default': SlideListItemAnimator,
  'none': ListItemAnimator
};

/**
 * @element ons-list-item
 * @category list
 * @modifier tappable
 *   [en]Make the list item change appearance when it's tapped. On iOS it is better to use the "tappable" and "tap-background-color" attribute for better behavior when scrolling.[/en]
 *   [ja]タップやクリックした時に効果が表示されるようになります。[/ja]
 * @modifier chevron
 *   [en]Display a chevron at the right end of the list item and make it change appearance when tapped.[/en]
 *   [ja][/ja]
 * @modifier longdivider
 *   [en]Displays a long horizontal divider between items.[/en]
 *   [ja][/ja]
 * @modifier nodivider
 *   [en]Removes the divider between list items.[/en]
 *   [ja][/ja]
 * @modifier material
 *   [en]Display a Material Design list item.[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Component that represents each item in a list. The list item is composed of four parts that are represented with the `left`, `center`, `right` and `expandable-content` classes. These classes can be used to ensure that the content of the list items is properly aligned.
 *
 *     ```
 *     <ons-list-item>
 *       <div class="left">Left</div>
 *       <div class="center">Center</div>
 *       <div class="right">Right</div>
 *       <div class="expandable-content">Expandable content</div>
 *     </ons-list-item>
 *     ```
 *
 *     There are also a number of classes (prefixed with `list-item__*`) that help when putting things like icons and thumbnails into the list items.
 *   [/en]
 *   [ja][/ja]
 * @seealso ons-list
 *   [en]ons-list component[/en]
 *   [ja]ons-listコンポーネント[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-headerコンポーネント[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list-item>
 *   <div class="left">
 *     <ons-icon icon="md-face" class="list-item__icon"></ons-icon>
 *   </div>
 *   <div class="center">
 *     <div class="list-item__title">Title</div>
 *     <div class="list-item__subtitle">Subtitle</div>
 *   </div>
 *   <div class="right">
 *     <ons-switch></ons-switch>
 *   </div>
 * </ons-list-item>
 */

var ListItemElement = function (_BaseElement) {
  inherits(ListItemElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the list item.[/en]
   *   [ja]各要素の表現を指定します。[/ja]
   */

  /**
   * @attribute lock-on-drag
   * @type {String}
   * @description
   *   [en]Prevent vertical scrolling when the user drags horizontally.[/en]
   *   [ja]この属性があると、ユーザーがこの要素を横方向にドラッグしている時に、縦方向のスクロールが起きないようになります。[/ja]
   */

  /**
   * @attribute tappable
   * @type {Boolean}
   * @description
   *   [en]Makes the element react to taps. `prevent-tap` attribute can be added to child elements like buttons or inputs to prevent this effect. `ons-*` elements are ignored by default.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute tap-background-color
   * @type {Color}
   * @description
   *   [en] Changes the background color when tapped. For this to work, the attribute "tappable" needs to be set. The default color is "#d9d9d9". It will display as a ripple effect on Android.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute expandable
   * @type {Boolean}
   * @description
   *   [en]Makes the element able to be expanded to reveal extra content. For this to work, the expandable content must be defined in `div.expandable-content`.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the expandable content. Can be either `"default"` or `"none"`.[/en]
   *  [ja][/ja]
   */

  function ListItemElement() {
    classCallCheck(this, ListItemElement);

    var _this = possibleConstructorReturn(this, (ListItemElement.__proto__ || Object.getPrototypeOf(ListItemElement)).call(this));

    _this._animatorFactory = _this._updateAnimatorFactory();
    _this.toggleExpansion = _this.toggleExpansion.bind(_this);

    // Elements ignored when tapping
    var re = /^ons-(?!col$|row$|if$)/i;
    _this._shouldIgnoreTap = function (e) {
      return e.hasAttribute('prevent-tap') || re.test(e.tagName);
    };

    // show and hide functions for Vue hidable mixin
    _this.show = _this.showExpansion;
    _this.hide = _this.hideExpansion;

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(ListItemElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$6);

      if (this.hasAttribute('expandable')) {
        this.classList.add('list-item--expandable');
      }

      var left = void 0,
          center = void 0,
          right = void 0,
          expandableContent = void 0;

      for (var i = 0; i < this.children.length; i++) {
        var el = this.children[i];

        if (el.classList.contains('left')) {
          el.classList.add('list-item__left');
          left = el;
        } else if (el.classList.contains('center')) {
          center = el;
        } else if (el.classList.contains('right')) {
          el.classList.add('list-item__right');
          right = el;
        } else if (el.classList.contains('expandable-content')) {
          el.classList.add('list-item__expandable-content');
          expandableContent = el;
        }
      }

      if (!right && this.hasAttribute('expandable')) {
        right = document.createElement('div');
        right.classList.add('list-item__right', 'right');

        // We cannot use a pseudo-element for this chevron, as we cannot animate it using
        // JS. So, we make a chevron span instead.
        var chevron = document.createElement('span');
        chevron.classList.add('list-item__expand-chevron');
        right.appendChild(chevron);
      }

      if (!center) {
        center = document.createElement('div');

        if (!left && !right && !expandableContent) {
          while (this.childNodes[0]) {
            center.appendChild(this.childNodes[0]);
          }
        } else {
          for (var _i = this.childNodes.length - 1; _i >= 0; _i--) {
            var _el = this.childNodes[_i];
            if (_el !== left && _el !== right && _el !== expandableContent && _el.tagName !== 'ONS-RIPPLE') {
              center.insertBefore(_el, center.firstChild);
            }
          }
        }

        if (!expandableContent) {
          this.insertBefore(center, right || null);
        }
      }

      center.classList.add('center', 'list-item__center');

      if (expandableContent) {
        // create 'top' div
        // this holds everything except the expandable content
        this._top = document.createElement('div');
        this._top.classList.add('top', 'list-item__top');
        this.appendChild(this._top);

        this._top.appendChild(center);
        if (left) {
          this._top.appendChild(left);
        }
        if (right) {
          this._top.appendChild(right);
        }
      }

      util$1.updateRipple(this);

      ModifierUtil.initModifier(this, scheme$10);
    }

    /**
     * @method showExpansion
     * @signature showExpansion()
     * @description
     *   [en]Show the expandable content if the element is expandable.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'showExpansion',
    value: function showExpansion() {
      var _this2 = this;

      if (this.hasAttribute('expandable') && !this._expanding) {
        this.expanded = true;
        this._expanding = true;

        var animator = this._animatorFactory.newAnimator();
        animator.showExpansion(this, function () {
          _this2.classList.add('expanded');
          _this2._expanding = false;
        });
      }
    }

    /**
     * @method hideExpansion
     * @signature hideExpansion()
     * @description
     *   [en]Hide the expandable content if the element expandable.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'hideExpansion',
    value: function hideExpansion() {
      var _this3 = this;

      if (this.hasAttribute('expandable') && !this._expanding) {
        this.expanded = false;
        this._expanding = true;

        var animator = this._animatorFactory.newAnimator();
        animator.hideExpansion(this, function () {
          _this3.classList.remove('expanded');
          _this3._expanding = false;
        });
      }
    }
  }, {
    key: 'toggleExpansion',
    value: function toggleExpansion() {
      this.classList.contains('expanded') ? this.hideExpansion() : this.showExpansion();
    }
  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$3,
        baseClass: ListItemAnimator,
        baseClassName: 'ListItemAnimator',
        defaultAnimation: this.getAttribute('animation') || 'default'
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$6, scheme$10);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$10);
          break;
        case 'ripple':
          util$1.updateRipple(this);
          break;
        case 'animation':
          this._animatorFactory = this._updateAnimatorFactory();
          break;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._setupListeners(true);
        _this4._originalBackgroundColor = _this4.style.backgroundColor;
        _this4.tapped = false;
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._setupListeners(false);
    }
  }, {
    key: '_setupListeners',
    value: function _setupListeners(add) {
      var action = (add ? 'add' : 'remove') + 'EventListener';
      util$1[action](this, 'touchstart', this._onTouch, { passive: true });
      util$1[action](this, 'touchmove', this._onRelease, { passive: true });
      this[action]('touchcancel', this._onRelease);
      this[action]('touchend', this._onRelease);
      this[action]('touchleave', this._onRelease);
      this[action]('drag', this._onDrag);
      this[action]('mousedown', this._onTouch);
      this[action]('mouseup', this._onRelease);
      this[action]('mouseout', this._onRelease);

      if (this._top) {
        this._top[action]('click', this.toggleExpansion);
      }
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var gesture = event.gesture;
      // Prevent vertical scrolling if the users pans left or right.
      if (this.hasAttribute('lock-on-drag') && ['left', 'right'].indexOf(gesture.direction) > -1) {
        gesture.preventDefault();
      }
    }
  }, {
    key: '_onTouch',
    value: function _onTouch(e) {
      var _this5 = this;

      if (this.tapped || this !== e.target && (this._shouldIgnoreTap(e.target) || util$1.findParent(e.target, this._shouldIgnoreTap, function (p) {
        return p === _this5;
      }))) {
        return; // Ignore tap
      }

      this.tapped = true;
      var touchStyle = { transition: 'background-color 0.0s linear 0.02s, box-shadow 0.0s linear 0.02s' };

      if (this.hasAttribute('tappable')) {
        if (this.style.backgroundColor) {
          this._originalBackgroundColor = this.style.backgroundColor;
        }

        touchStyle.backgroundColor = this.getAttribute('tap-background-color') || '#d9d9d9';
        touchStyle.boxShadow = '0px -1px 0px 0px ' + touchStyle.backgroundColor;
      }

      styler(this, touchStyle);
    }
  }, {
    key: '_onRelease',
    value: function _onRelease() {
      this.tapped = false;
      this.style.backgroundColor = this._originalBackgroundColor || '';
      styler.clear(this, 'transition boxShadow');
    }
  }, {
    key: 'expandableContent',
    get: function get$$1() {
      return this.querySelector('.list-item__expandable-content');
    }
  }, {
    key: 'expandChevron',
    get: function get$$1() {
      return this.querySelector('.list-item__expand-chevron');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class', 'ripple', 'animation'];
    }
  }]);
  return ListItemElement;
}(BaseElement);

onsElements.ListItem = ListItemElement;
customElements.define('ons-list-item', ListItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$7 = 'list';
var scheme$11 = { '': 'list--*' };

/**
 * @element ons-list
 * @category list
 * @modifier inset
 *   [en]Inset list that doesn't cover the whole width of the parent.[/en]
 *   [ja]親要素の画面いっぱいに広がらないリストを表示します。[/ja]
 * @modifier noborder
 *   [en]A list with no borders at the top and bottom.[/en]
 *   [ja]リストの上下のボーダーが無いリストを表示します。[/ja]
 * @description
 *   [en]Component to define a list, and the container for ons-list-item(s).[/en]
 *   [ja]リストを表現するためのコンポーネント。ons-list-itemのコンテナとして使用します。[/ja]
 * @seealso ons-list-item
 *   [en]ons-list-item component[/en]
 *   [ja]ons-list-itemコンポーネント[/ja]
 * @seealso ons-list-header
 *   [en]ons-list-header component[/en]
 *   [ja]ons-list-headerコンポーネント[/ja]
 * @seealso ons-lazy-repeat
 *   [en]ons-lazy-repeat component[/en]
 *   [ja]ons-lazy-repeatコンポーネント[/ja]
 * @codepen yxcCt
 * @tutorial vanilla/Reference/list
 * @example
 * <ons-list>
 *   <ons-list-header>Header Text</ons-list-header>
 *   <ons-list-item>Item</ons-list-item>
 *   <ons-list-item>Item</ons-list-item>
 * </ons-list>
 */

var ListElement = function (_BaseElement) {
  inherits(ListElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the list.[/en]
   *   [ja]リストの表現を指定します。[/ja]
   */

  function ListElement() {
    classCallCheck(this, ListElement);

    var _this = possibleConstructorReturn(this, (ListElement.__proto__ || Object.getPrototypeOf(ListElement)).call(this));

    _this._compile();
    return _this;
  }

  createClass(ListElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$7);
      ModifierUtil.initModifier(this, scheme$11);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$7, scheme$11);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$11);
          break;
      }
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ListElement;
}(BaseElement);

onsElements.List = ListElement;
customElements.define('ons-list', ListElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var INPUT_ATTRIBUTES = ['autocapitalize', 'autocomplete', 'autocorrect', 'autofocus', 'disabled', 'inputmode', 'max', 'maxlength', 'min', 'minlength', 'name', 'pattern', 'placeholder', 'readonly', 'required', 'size', 'step', 'validator', 'value'];

var BaseInputElement = function (_BaseElement) {
  inherits(BaseInputElement, _BaseElement);
  createClass(BaseInputElement, [{
    key: '_update',
    value: function _update() {} // Optionally implemented

  }, {
    key: '_scheme',
    get: function get$$1() {
      util$1.throwMember();
    }
  }, {
    key: '_template',
    get: function get$$1() {
      util$1.throwMember();
    }
  }, {
    key: 'type',
    get: function get$$1() {
      util$1.throwMember();
    }
  }]);

  function BaseInputElement() {
    classCallCheck(this, BaseInputElement);

    var _this = possibleConstructorReturn(this, (BaseInputElement.__proto__ || Object.getPrototypeOf(BaseInputElement)).call(this));

    if (_this.constructor === BaseInputElement) {
      util$1.throwAbstract();
    }

    contentReady(_this, function () {
      return _this._compile();
    });
    _this._boundDelegateEvent = _this._delegateEvent.bind(_this);
    return _this;
  }

  createClass(BaseInputElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this._defaultClassName && this.classList.add(this._defaultClassName);

      if (this.children.length !== 0) {
        return;
      }

      this.appendChild(util$1.createFragment(this._template));

      this._setInputId();

      this._updateBoundAttributes();

      ModifierUtil.initModifier(this, this._scheme);
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this2 = this;

      INPUT_ATTRIBUTES.forEach(function (attr) {
        if (_this2.hasAttribute(attr)) {
          _this2._input.setAttribute(attr, _this2.getAttribute(attr));
        } else {
          _this2._input.removeAttribute(attr);
        }
      });

      this._update();
    }
  }, {
    key: '_delegateEvent',
    value: function _delegateEvent(event) {
      var e = new CustomEvent(event.type, {
        bubbles: false,
        cancelable: true
      });

      return this.dispatchEvent(e);
    }
  }, {
    key: '_setInputId',
    value: function _setInputId() {
      if (this.hasAttribute('input-id')) {
        this._input.id = this.getAttribute('input-id');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._input.addEventListener('focus', _this3._boundDelegateEvent);
        _this3._input.addEventListener('blur', _this3._boundDelegateEvent);
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this4 = this;

      contentReady(this, function () {
        _this4._input.removeEventListener('focus', _this4._boundDelegateEvent);
        _this4._input.removeEventListener('blur', _this4._boundDelegateEvent);
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      switch (name) {
        case 'modifier':
          contentReady(this, function () {
            return ModifierUtil.onModifierChanged(last, current, _this5, _this5._scheme);
          });
          break;
        case 'input-id':
          contentReady(this, function () {
            return _this5._setInputId();
          });
          break;
        case 'class':
          util$1.restoreClass(this, this._defaultClassName, this._scheme);
          break;
      }

      if (INPUT_ATTRIBUTES.indexOf(name) >= 0) {
        contentReady(this, function () {
          return _this5._updateBoundAttributes();
        });
      }
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return '';
    }
  }, {
    key: '_input',
    get: function get$$1() {
      return this.querySelector('input');
    }
  }, {
    key: 'value',
    get: function get$$1() {
      return this._input === null ? this.getAttribute('value') : this._input.value;
    },
    set: function set$$1(val) {
      var _this6 = this;

      contentReady(this, function () {
        if (val instanceof Date) {
          val = val.toISOString().substring(0, 10);
        }
        _this6._input.value = val;
        _this6._update();
      });
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'input-id', 'class'].concat(INPUT_ATTRIBUTES);
    }
  }]);
  return BaseInputElement;
}(BaseElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$12 = {
  '.text-input': 'text-input--*',
  '.text-input__label': 'text-input--*__label'
};

/**
 * @element ons-input
 * @category form
 * @modifier material
 *  [en]Displays a Material Design input.[/en]
 *  [ja][/ja]
 * @modifier underbar
 *  [en]Displays a horizontal line underneath a text input.[/en]
 *  [ja][/ja]
 * @modifier transparent
 *  [en]Displays a transparent input. Works for Material Design.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    An input element. The `type` attribute can be used to change the input type. All text input types are supported.
 *
 *    The component will automatically render as a Material Design input on Android devices.
 *
 *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-input>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/input
 * @seealso ons-checkbox
 *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
 *   [ja][/ja]
 * @seealso ons-radio
 *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-input placeholder="Username" float></ons-input>
 */

var InputElement = function (_BaseInputElement) {
  inherits(InputElement, _BaseInputElement);

  function InputElement() {
    classCallCheck(this, InputElement);

    var _this = possibleConstructorReturn(this, (InputElement.__proto__ || Object.getPrototypeOf(InputElement)).call(this));

    _this._boundOnInput = _this._update.bind(_this);
    _this._boundOnFocusin = _this._update.bind(_this);
    return _this;
  }

  /* Inherited props */

  createClass(InputElement, [{
    key: '_update',
    value: function _update() {
      this._updateLabel();
      this._updateLabelClass();
    }
  }, {
    key: '_updateLabel',


    /* Own props */

    value: function _updateLabel() {
      var label = this.getAttribute('placeholder') || '';

      if (typeof this._helper.textContent !== 'undefined') {
        this._helper.textContent = label;
      } else {
        this._helper.innerText = label;
      }
    }
  }, {
    key: '_updateLabelClass',
    value: function _updateLabelClass() {
      if (this.value === '') {
        this._helper.classList.remove('text-input--material__label--active');
      } else {
        this._helper.classList.add('text-input--material__label--active');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'connectedCallback', this).call(this);

      contentReady(this, function () {
        _this2._input.addEventListener('input', _this2._boundOnInput);
        _this2._input.addEventListener('focusin', _this2._boundOnFocusin);
      });

      var type = this.getAttribute('type');
      if (['checkbox', 'radio'].indexOf(type) >= 0) {
        util$1.warn('Warn: <ons-input type="' + type + '"> is deprecated since v2.4.0. Use <ons-' + type + '> instead.');
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'disconnectedCallback', this).call(this);

      contentReady(this, function () {
        _this3._input.removeEventListener('input', _this3._boundOnInput);
        _this3._input.removeEventListener('focusin', _this3._boundOnFocusin);
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this4 = this;

      switch (name) {
        case 'type':
          contentReady(this, function () {
            return _this4._input.setAttribute('type', _this4.type);
          });
          break;
        default:
          get(InputElement.prototype.__proto__ || Object.getPrototypeOf(InputElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }

    /**
     * @attribute placeholder
     * @type {String}
     * @description
     *   [en]Placeholder text. In Material Design, this placeholder will be a floating label.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute float
     * @description
     *  [en]If this attribute is present, the placeholder will be animated in Material Design.[/en]
     *  [ja]この属性が設定された時、ラベルはアニメーションするようになります。[/ja]
     */

    /**
     * @attribute type
     * @type {String}
     * @description
     *  [en]
     *    Specify the input type. This is the same as the "type" attribute for normal inputs. It expects strict text types such as `text`, `password`, etc. For checkbox, radio button, select or range, please have a look at the corresponding elements.
     *
     *    Please take a look at [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-type) for an exhaustive list of possible values. Depending on the platform and browser version some of these might not work.
     *  [/en]
     *  [ja][/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the input is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$12;
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="text-input">\n      <span class="text-input__label"></span>\n    ';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      var type = this.getAttribute('type');
      return ['checkbox', 'radio'].indexOf(type) < 0 && type || 'text';
    }
  }, {
    key: '_helper',
    get: function get$$1() {
      return this.querySelector('span');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(InputElement.__proto__ || Object.getPrototypeOf(InputElement), 'observedAttributes', this)), ['type']);
    }
  }]);
  return InputElement;
}(BaseInputElement);

onsElements.Input = InputElement;
customElements.define('ons-input', InputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var BaseCheckboxElement = function (_BaseInputElement) {
  inherits(BaseCheckboxElement, _BaseInputElement);

  function BaseCheckboxElement() {
    classCallCheck(this, BaseCheckboxElement);

    var _this = possibleConstructorReturn(this, (BaseCheckboxElement.__proto__ || Object.getPrototypeOf(BaseCheckboxElement)).call(this));

    if (_this.constructor === BaseCheckboxElement) {
      util.throwAbstract();
    }

    contentReady(_this, function () {
      _this.attributeChangedCallback('checked', null, _this.getAttribute('checked'));
    });
    return _this;
  }

  /* Inherited props */

  createClass(BaseCheckboxElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'checked':
          this.checked = current !== null;
          break;
        default:
          get(BaseCheckboxElement.prototype.__proto__ || Object.getPrototypeOf(BaseCheckboxElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <span class="' + this._defaultClassName + '__checkmark"></span>\n    ';
    }

    /* Own props */

  }, {
    key: '_helper',
    get: function get$$1() {
      return this.querySelector('span');
    }
  }, {
    key: 'checked',
    get: function get$$1() {
      return this._input.checked;
    },
    set: function set$$1(val) {
      var _this2 = this;

      contentReady(this, function () {
        _this2._input.checked = val;
      });
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(BaseCheckboxElement.__proto__ || Object.getPrototypeOf(BaseCheckboxElement), 'observedAttributes', this)), ['checked']);
    }
  }]);
  return BaseCheckboxElement;
}(BaseInputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$13 = {
  '.checkbox': 'checkbox--*',
  '.checkbox__input': 'checkbox--*__input',
  '.checkbox__checkmark': 'checkbox--*__checkmark'
};

/**
 * @element ons-checkbox
 * @category form
 * @modifier material
 *  [en]Displays a Material Design checkbox.[/en]
 *  [ja][/ja]
 * @modifier noborder
 *  [en]iOS borderless checkbox.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    A checkbox element. The component will automatically render as a Material Design checkbox on Android devices.
 *
 *    Most attributes that can be used for a normal `<input type="checkbox">` element can also be used on the `<ons-checkbox>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/checkbox
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-radio
 *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
 *   [ja][/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` element is used to display a text input.[/en]
 *   [ja][/ja]
 * @seealso ons-search-input
 *   [en]The `<ons-search-input>` element is used to display a search input.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-checkbox checked></ons-checkbox>
 */

var CheckboxElement = function (_BaseCheckboxElement) {
  inherits(CheckboxElement, _BaseCheckboxElement);

  function CheckboxElement() {
    classCallCheck(this, CheckboxElement);
    return possibleConstructorReturn(this, (CheckboxElement.__proto__ || Object.getPrototypeOf(CheckboxElement)).apply(this, arguments));
  }

  createClass(CheckboxElement, [{
    key: '_scheme',
    get: function get$$1() {
      return scheme$13;
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'checkbox';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'checkbox';
    }

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the checkbox.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]Whether the checkbox is checked or not.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the checkbox is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }]);
  return CheckboxElement;
}(BaseCheckboxElement);

onsElements.Checkbox = CheckboxElement;
customElements.define('ons-checkbox', CheckboxElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$14 = {
  '.radio-button': 'radio-button--*',
  '.radio-button__input': 'radio-button--*__input',
  '.radio-button__checkmark': 'radio-button--*__checkmark'
};

/**
 * @element ons-radio
 * @category form
 * @modifier material
 *  [en]Displays a Material Design radio button.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    A radio button element. The component will automatically render as a Material Design radio button on Android devices.
 *
 *    Most attributes that can be used for a normal `<input type="radio">` element can also be used on the `<ons-radio>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/radio
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @seealso ons-checkbox
 *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` element is used to display a text input.[/en]
 *   [ja][/ja]
 * @seealso ons-search-input
 *   [en]The `<ons-search-input>` element is used to display a search input.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-radio checked></ons-radio>
 */

var RadioElement = function (_BaseCheckboxElement) {
  inherits(RadioElement, _BaseCheckboxElement);

  function RadioElement() {
    classCallCheck(this, RadioElement);
    return possibleConstructorReturn(this, (RadioElement.__proto__ || Object.getPrototypeOf(RadioElement)).apply(this, arguments));
  }

  createClass(RadioElement, [{
    key: '_scheme',
    get: function get$$1() {
      return scheme$14;
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'radio-button';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'radio';
    }

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the radio button.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]Whether the radio button is checked or not.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the radio button is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }]);
  return RadioElement;
}(BaseCheckboxElement);

onsElements.Radio = RadioElement;
customElements.define('ons-radio', RadioElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$15 = {
  '.search-input': 'search-input--*'
};

/**
 * @element ons-search-input
 * @category form
 * @modifier material
 *  [en]Displays a Material Design search input.[/en]
 *  [ja][/ja]
 * @description
 *  [en]
 *    A search input element. The component will automatically render as a Material Design search input on Android devices.
 *
 *    Most attributes that can be used for a normal `<input>` element can also be used on the `<ons-search-input>` element.
 *  [/en]
 *  [ja][/ja]
 * @tutorial vanilla/Reference/search-input
 * @seealso ons-input
 *   [en]The `<ons-input>` element is used to display a text input.[/en]
 *   [ja][/ja]
 * @seealso ons-range
 *   [en]The `<ons-range>` element is used to display a range slider.[/en]
 *   [ja][/ja]
 * @seealso ons-switch
 *   [en]The `<ons-switch>` element is used to display a draggable toggle switch.[/en]
 *   [ja][/ja]
 * @seealso ons-select
 *   [en]The `<ons-select>` element is used to display a select box.[/en]
 *   [ja][/ja]
 * @seealso ons-checkbox
 *   [en]The `<ons-checkbox>` element is used to display a checkbox.[/en]
 *   [ja][/ja]
 * @seealso ons-radio
 *   [en]The `<ons-radio>` element is used to display a radio button.[/en]
 *   [ja][/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-search-input placeholder="Search"></ons-search-input>
 */

var SearchInputElement = function (_BaseInputElement) {
  inherits(SearchInputElement, _BaseInputElement);

  function SearchInputElement() {
    classCallCheck(this, SearchInputElement);
    return possibleConstructorReturn(this, (SearchInputElement.__proto__ || Object.getPrototypeOf(SearchInputElement)).apply(this, arguments));
  }

  createClass(SearchInputElement, [{
    key: '_scheme',
    get: function get$$1() {
      return scheme$15;
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="search-input">\n    ';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'search';
    }

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *  [en]Specify the "id" attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *  [ja][/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the input is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }]);
  return SearchInputElement;
}(BaseInputElement);

onsElements.SearchInput = SearchInputElement;
customElements.define('ons-search-input', SearchInputElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ModalAnimator = function (_BaseAnimator) {
  inherits(ModalAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function ModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ModalAnimator);
    return possibleConstructorReturn(this, (ModalAnimator.__proto__ || Object.getPrototypeOf(ModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(ModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback();
    }
  }]);
  return ModalAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for dialog.
 */

var FadeModalAnimator = function (_ModalAnimator) {
  inherits(FadeModalAnimator, _ModalAnimator);

  function FadeModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, FadeModalAnimator);
    return possibleConstructorReturn(this, (FadeModalAnimator.__proto__ || Object.getPrototypeOf(FadeModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(FadeModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal, this.def).default({ opacity: 0 }, { opacity: 1 }).queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal, this.def).default({ opacity: 1 }, { opacity: 0 }).queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return FadeModalAnimator;
}(ModalAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for modal.
 */

var LiftModalAnimator = function (_ModalAnimator) {
  inherits(LiftModalAnimator, _ModalAnimator);

  function LiftModalAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier( .1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, LiftModalAnimator);
    return possibleConstructorReturn(this, (LiftModalAnimator.__proto__ || Object.getPrototypeOf(LiftModalAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(LiftModalAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal, this.def).default({ transform: 'translate3d(0, 100%, 0)' }, { transform: 'translate3d(0, 0, 0)' }).queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback = callback ? callback : function () {};

      Animit(modal, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, 100%, 0)' }).queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return LiftModalAnimator;
}(ModalAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$16 = {
  '': 'modal--*',
  'modal__content': 'modal--*__content'
};

var defaultClassName$8 = 'modal';

var _animatorDict$4 = {
  'default': ModalAnimator,
  'fade': FadeModalAnimator,
  'lift': LiftModalAnimator,
  'none': ModalAnimator
};

/**
 * @element ons-modal
 * @category dialog
 * @description
 *   [en]
 *     Modal component that masks current screen. Underlying components are not subject to any events while the modal component is shown.
 *
 *     This component can be used to block user input while some operation is running or to show some information to the user.
 *   [/en]
 *   [ja]
 *     画面全体をマスクするモーダル用コンポーネントです。下側にあるコンポーネントは、
 *     モーダルが表示されている間はイベント通知が行われません。
 *   [/ja]
 * @seealso ons-dialog
 *   [en]The `<ons-dialog>` component can be used to create a modal dialog.[/en]
 *   [ja][/ja]
 * @codepen devIg
 * @tutorial vanilla/reference/modal
 * @example
 * <ons-modal id="modal">
 *   Modal content
 * </ons-modal>
 * <script>
 *   var modal = document.getElementById('modal');
 *   modal.show();
 * </script>
 */

var ModalElement = function (_BaseDialogElement) {
  inherits(ModalElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   * [en]Fired just before the modal is displayed.[/en]
   * [ja]モーダルが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the modal from being shown.[/en]
   *   [ja]この関数を実行すると、ダイアログの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   * [en]Fired just after the modal is displayed.[/en]
   * [ja]モーダルが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   * [en]Fired just before the modal is hidden.[/en]
   * [ja]モーダルが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Execute this function to stop the modal from being hidden.[/en]
   *   [ja]この関数を実行すると、ダイアログの非表示がキャンセルされます。[/ja]
   */

  /**
   * @event posthide
   * @description
   * [en]Fired just after the modal is hidden.[/en]
   * [ja]モーダルが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.modal
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the modal. Can be either `"none"`, `"fade"` or `"lift"`.[/en]
   *  [ja]モーダルを表示する際のアニメーション名を指定します。"none"もしくは"fade","lift"を指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
   */

  function ModalElement() {
    classCallCheck(this, ModalElement);

    var _this = possibleConstructorReturn(this, (ModalElement.__proto__ || Object.getPrototypeOf(ModalElement)).call(this));

    _this._defaultDBB = function () {
      return undefined;
    };
    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ModalElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$4,
        baseClass: ModalAnimator,
        baseClassName: 'ModalAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      this.style.display = 'none';
      this.style.zIndex = 10001;
      this.classList.add(defaultClassName$8);

      if (!util$1.findChild(this, '.modal__content')) {
        var content = document.createElement('div');
        content.classList.add('modal__content');

        while (this.childNodes[0]) {
          var node = this.childNodes[0];
          this.removeChild(node);
          content.insertBefore(node, null);
        }

        this.appendChild(content);
      }

      ModifierUtil.initModifier(this, this._scheme);
    }
  }, {
    key: '_toggleStyle',
    value: function _toggleStyle(shouldShow) {
      this.style.display = shouldShow ? 'table' : 'none';
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'connectedCallback', this).call(this);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'disconnectedCallback', this).call(this);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the modal has been revealed.[/en]
     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Show modal.[/en]
     *   [ja]モーダルを表示します。[/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the modal has been revealed.[/en]
     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Toggle modal visibility.[/en]
     *   [ja]モーダルの表示を切り替えます。[/ja]
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"none"` and `"fade"`.[/en]
     *   [ja]アニメーション名を指定します。"none", "fade"のいずれかを指定します。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the modal has been revealed.[/en]
     *   [ja]モーダルが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Hide modal.[/en]
     *   [ja]モーダルを非表示にします。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'class') {
        util$1.restoreClass(this, defaultClassName$8, scheme$16);
      } else {
        get(ModalElement.prototype.__proto__ || Object.getPrototypeOf(ModalElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
      }
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$16;
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ModalAnimator)) {
        util$1.throwAnimator('Modal');
      }
      _animatorDict$4[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(ModalElement.__proto__ || Object.getPrototypeOf(ModalElement), 'observedAttributes', this)), ['class']);
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$4;
    }
  }, {
    key: 'ModalAnimator',
    get: function get$$1() {
      return ModalAnimator;
    }
  }]);
  return ModalElement;
}(BaseDialogElement);

onsElements.Modal = ModalElement;
customElements.define('ons-modal', ModalElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var widthToPx = function widthToPx(width) {
  var _ref = [parseInt(width, 10), /px/.test(width)],
      value = _ref[0],
      px = _ref[1];

  return px ? value : Math.round(document.body.offsetWidth * value / 100);
};

var SwipeReveal = function () {
  function SwipeReveal(params) {
    var _this = this;

    classCallCheck(this, SwipeReveal);

    'element ignoreSwipe isInitialState onDragCallback swipeMax swipeMin swipeMid'.split(/\s+/).forEach(function (key) {
      return _this[key] = params[key];
    });

    this.elementHandler = params.elementHandler || params.element;
    this.getThreshold = params.getThreshold || function () {
      return .5;
    };
    this.getSide = params.getSide || function () {
      return 'left';
    };

    this.handleGesture = this.handleGesture.bind(this);

    this._shouldFixScroll = util$1.globals.actualMobileOS === 'ios';
  }

  createClass(SwipeReveal, [{
    key: 'update',
    value: function update() {
      var swipeable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.element.hasAttribute('swipeable');

      if (!this.gestureDetector) {
        this.gestureDetector = new GestureDetector(this.elementHandler, { dragMinDistance: 1, passive: !this._shouldFixScroll });
      }

      var action = swipeable ? 'on' : 'off';
      this.gestureDetector[action]('drag dragstart dragend', this.handleGesture);
    }
  }, {
    key: 'handleGesture',
    value: function handleGesture(e) {
      if (e.gesture) {
        if (e.type === 'dragstart') {
          this.onDragStart(e);
        } else if (!this._ignoreDrag) {
          e.type === 'dragend' ? this.onDragEnd(e) : this.onDrag(e);
        }
      }
    }
  }, {
    key: 'onDragStart',
    value: function onDragStart(event) {
      var _this2 = this;

      var getDistance = function getDistance() {
        return _this2.getSide() === 'left' ? event.gesture.center.clientX : window.innerWidth - event.gesture.center.clientX;
      };
      this._ignoreDrag = event.consumed || !util$1.isValidGesture(event) || this.ignoreSwipe(event, getDistance());

      if (!this._ignoreDrag) {
        event.consume && event.consume();
        event.consumed = true;

        this._width = widthToPx(this.element.style.width || '100%');
        this._startDistance = this._distance = !(this.isInitialState instanceof Function) || this.isInitialState() ? 0 : this._width;

        util$1.iosPreventScroll(this.gestureDetector);
      }
    }
  }, {
    key: 'onDrag',
    value: function onDrag(event) {
      event.stopPropagation();

      var delta = this.getSide() === 'left' ? event.gesture.deltaX : -event.gesture.deltaX;
      var distance = Math.max(0, Math.min(this._width, this._startDistance + delta));
      if (distance !== this._distance) {
        this._distance = distance;
        this.swipeMid(this._distance, this._width);
      }
    }
  }, {
    key: 'onDragEnd',
    value: function onDragEnd(event) {
      event.stopPropagation();

      var direction = event.gesture.interimDirection;
      var isSwipeMax = this.getSide() !== direction && this._distance > this._width * this.getThreshold();
      isSwipeMax ? this.swipeMax() : this.swipeMin();
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this.gestureDetector && this.gestureDetector.dispose();
      this.gestureDetector = this.element = this.elementHandler = null;
    }
  }]);
  return SwipeReveal;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NavigatorAnimator = function (_BaseAnimator) {
  inherits(NavigatorAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function NavigatorAnimator(options) {
    classCallCheck(this, NavigatorAnimator);

    options = util$1.extend({
      timing: 'linear',
      duration: '0.4',
      delay: '0'
    }, options || {});

    return possibleConstructorReturn(this, (NavigatorAnimator.__proto__ || Object.getPrototypeOf(NavigatorAnimator)).call(this, options));
  }

  createClass(NavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'block',
    value: function block(page) {
      var blocker = util$1.createElement('\n      <div style="position: absolute; background-color: transparent; width: 100%; height: 100%; z-index: 100000"></div>\n    ');
      page.parentNode.appendChild(blocker);
      return function () {
        return blocker.remove();
      };
    }
  }]);
  return NavigatorAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Abstract swipe animator for iOS navigator transition.
 */

var IOSSwipeNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(IOSSwipeNavigatorAnimator, _NavigatorAnimator);
  createClass(IOSSwipeNavigatorAnimator, null, [{
    key: 'swipeable',
    get: function get$$1() {
      return true;
    }
  }]);

  function IOSSwipeNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref$durationRestore = _ref.durationRestore,
        durationRestore = _ref$durationRestore === undefined ? 0.1 : _ref$durationRestore,
        _ref$durationSwipe = _ref.durationSwipe,
        durationSwipe = _ref$durationSwipe === undefined ? 0.15 : _ref$durationSwipe,
        _ref$timingSwipe = _ref.timingSwipe,
        timingSwipe = _ref$timingSwipe === undefined ? 'linear' : _ref$timingSwipe,
        rest = objectWithoutProperties(_ref, ['durationRestore', 'durationSwipe', 'timingSwipe']);
    classCallCheck(this, IOSSwipeNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (IOSSwipeNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSSwipeNavigatorAnimator)).call(this, _extends({}, rest)));

    if (_this.constructor === IOSSwipeNavigatorAnimator) {
      util$1.throwAbstract();
    }

    _this.durationRestore = durationRestore;
    _this.durationSwipe = durationSwipe;
    _this.timingSwipe = timingSwipe;

    _this.optSwipe = { timing: timingSwipe, duration: durationSwipe };
    _this.optRestore = { timing: timingSwipe, duration: durationRestore };

    _this.swipeShadow = util$1.createElement('<div style="position: absolute; height: 100%; width: 12px; right: 100%; top: 0; bottom: 0; z-index: -1;' + 'background: linear-gradient(to right, transparent 0, rgba(0,0,0,.04) 40%, rgba(0,0,0,.12) 80%, rgba(0,0,0,.16) 100%);"></div>');

    _this.isDragStart = true;
    return _this;
  }

  createClass(IOSSwipeNavigatorAnimator, [{
    key: '_decompose',
    value: function _decompose() {
      util$1.throwMember();
    }
  }, {
    key: '_shouldAnimateToolbar',
    value: function _shouldAnimateToolbar() {
      util$1.throwMember();
    }
  }, {
    key: '_calculateDelta',
    value: function _calculateDelta() {
      util$1.throwMember();
    }
  }, {
    key: '_dragStartSetup',
    value: function _dragStartSetup(enterPage, leavePage) {
      this.isDragStart = false;

      // Avoid content clicks
      this.unblock = get(IOSSwipeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSwipeNavigatorAnimator.prototype), 'block', this).call(this, leavePage);

      // Mask
      enterPage.parentElement.insertBefore(this.backgroundMask, enterPage);

      // Decomposition
      this.target = {
        enter: util$1.findToolbarPage(enterPage) || enterPage,
        leave: util$1.findToolbarPage(leavePage) || leavePage
      };
      this.decomp = {
        enter: this._decompose(this.target.enter),
        leave: this._decompose(this.target.leave)
      };

      // Animation values
      this.delta = this._calculateDelta(leavePage, this.decomp.leave);
      this.shouldAnimateToolbar = this._shouldAnimateToolbar(this.target.enter, this.target.leave);

      // Shadow && styles
      if (this.shouldAnimateToolbar) {
        this.swipeShadow.style.top = this.decomp.leave.toolbar.offsetHeight + 'px';
        this.target.leave.appendChild(this.swipeShadow);
        this._saveStyle(this.target.enter, this.target.leave);
      } else {
        leavePage.appendChild(this.swipeShadow);
        this._saveStyle(enterPage, leavePage);
      }
      leavePage.classList.add('overflow-visible');
      this.overflowElement = leavePage;
      this.decomp.leave.content.classList.add('content-swiping');
    }
  }, {
    key: 'translate',
    value: function translate(distance, maxWidth, enterPage, leavePage) {
      this.isSwiping = true;

      if (enterPage.style.display === 'none') {
        enterPage.style.display = '';
      }

      if (this.isDragStart) {
        this.maxWidth = maxWidth;
        this._dragStartSetup(enterPage, leavePage);
      }

      var swipeRatio = (distance - maxWidth) / maxWidth;

      if (this.shouldAnimateToolbar) {

        Animit.runAll(

        /* Enter page */

        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
          transform: 'translate3d(' + swipeRatio * 25 + '%, 0, 0)',
          opacity: 1 + swipeRatio * 10 / 100 // 0.9 -> 1
        }), Animit(this.decomp.enter.toolbarCenter).queue({
          transform: 'translate3d(' + this.delta.title * swipeRatio + 'px, 0, 0)',
          opacity: 1 + swipeRatio // 0 -> 1
        }), Animit(this.decomp.enter.backButtonLabel).queue({
          opacity: 1 + swipeRatio * 10 / 100, // 0.9 -> 1
          transform: 'translate3d(' + this.delta.label * swipeRatio + 'px, 0, 0)'
        }), Animit(this.decomp.enter.other).queue({
          opacity: 1 + swipeRatio // 0 -> 1
        }),

        /* Leave page */

        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background, this.swipeShadow]).queue({
          transform: 'translate3d(' + distance + 'px, 0, 0)'
        }), Animit(this.decomp.leave.toolbar).queue({
          opacity: -1 * swipeRatio // 1 -> 0
        }), Animit(this.decomp.leave.toolbarCenter).queue({
          transform: 'translate3d(' + (1 + swipeRatio) * 125 + '%, 0, 0)'
        }), Animit(this.decomp.leave.backButtonLabel).queue({
          opacity: -1 * swipeRatio, // 1 -> 0
          transform: 'translate3d(' + this.delta.title * (1 + swipeRatio) + 'px, 0, 0)'
        }),

        /* Other */

        Animit(this.swipeShadow).queue({
          opacity: -1 * swipeRatio // 1 -> 0
        }));
      } else {
        Animit.runAll(Animit(leavePage).queue({
          transform: 'translate3d(' + distance + 'px, 0, 0)'
        }), Animit(enterPage).queue({
          transform: 'translate3d(' + swipeRatio * 25 + '%, 0, 0)',
          opacity: 1 + swipeRatio * 10 / 100 // 0.9 -> 1
        }), Animit(this.swipeShadow).queue({
          opacity: -1 * swipeRatio // 1 -> 0
        }));
      }
    }
  }, {
    key: 'restore',
    value: function restore(enterPage, leavePage, callback) {
      var _this2 = this;

      if (this.isDragStart) {
        return;
      }

      if (this.shouldAnimateToolbar) {

        Animit.runAll(

        /* Enter page */

        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
          transform: 'translate3d(-25%, 0, 0)',
          opacity: 0.9
        }, this.optRestore), Animit(this.decomp.enter.toolbarCenter).queue({
          transform: 'translate3d(-' + this.delta.title + 'px, 0, 0)',
          transition: 'opacity ' + this.durationRestore + 's linear, transform ' + this.durationRestore + 's ' + this.timingSwipe,
          opacity: 0
        }), Animit(this.decomp.enter.backButtonLabel).queue({
          transform: 'translate3d(-' + this.delta.label + 'px, 0, 0)'
        }, this.optRestore), Animit(this.decomp.enter.other).queue({
          opacity: 0
        }, this.optRestore),

        /* Leave page */

        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background, this.swipeShadow]).queue({
          transform: 'translate3d(0, 0, 0)'
        }, this.optRestore), Animit(this.decomp.leave.toolbar).queue({
          opacity: 1
        }, this.optRestore), Animit(this.decomp.leave.toolbarCenter).queue({
          transform: 'translate3d(0, 0, 0)'
        }, this.optRestore), Animit(this.decomp.leave.backButtonLabel).queue({
          opacity: 1,
          transform: 'translate3d(0, 0, 0)',
          transition: 'opacity ' + this.durationRestore + 's linear, transform ' + this.durationRestore + 's ' + this.timingSwipe
        }),

        /* Other */

        Animit(this.swipeShadow).queue({
          opacity: 0
        }, this.optRestore).queue(function (done) {
          _this2._reset(_this2.target.enter, _this2.target.leave);
          enterPage.style.display = 'none';
          callback && callback();
          done();
        }));
      } else {
        Animit.runAll(Animit(enterPage).queue({
          transform: 'translate3D(-25%, 0, 0)',
          opacity: 0.9
        }, this.optRestore), Animit(leavePage).queue({
          transform: 'translate3D(0, 0, 0)'
        }, this.optRestore).queue(function (done) {
          _this2._reset(enterPage, leavePage);
          enterPage.style.display = 'none';
          callback && callback();
          done();
        }));
      }
    }
  }, {
    key: 'popSwipe',
    value: function popSwipe(enterPage, leavePage, callback) {
      var _this3 = this;

      if (this.isDragStart) {
        return;
      }

      if (this.shouldAnimateToolbar) {

        Animit.runAll(

        /* Enter page */

        Animit([this.decomp.enter.content, this.decomp.enter.bottomToolbar, this.decomp.enter.background]).queue({
          transform: 'translate3d(0, 0, 0)',
          opacity: 1
        }, this.optSwipe), Animit(this.decomp.enter.toolbarCenter).queue({
          transform: 'translate3d(0, 0, 0)',
          transition: 'opacity ' + this.durationSwipe + 's linear, transform ' + this.durationSwipe + 's ' + this.timingSwipe,
          opacity: 1
        }), Animit(this.decomp.enter.backButtonLabel).queue({
          transform: 'translate3d(0, 0, 0)'
        }, this.optSwipe), Animit(this.decomp.enter.other).queue({
          opacity: 1
        }, this.optSwipe),

        /* Leave page */

        Animit([this.decomp.leave.content, this.decomp.leave.bottomToolbar, this.decomp.leave.background]).queue({
          transform: 'translate3d(100%, 0, 0)'
        }, this.optSwipe), Animit(this.decomp.leave.toolbar).queue({
          opacity: 0
        }, this.optSwipe), Animit(this.decomp.leave.toolbarCenter).queue({
          transform: 'translate3d(125%, 0, 0)'
        }, this.optSwipe), Animit(this.decomp.leave.backButtonLabel).queue({
          opacity: 0,
          transform: 'translate3d(' + this.delta.title + 'px, 0, 0)',
          transition: 'opacity ' + this.durationSwipe + 's linear, transform ' + this.durationSwipe + 's ' + this.timingSwipe
        }),

        /* Other */

        Animit(this.swipeShadow).queue({
          opacity: 0,
          transform: 'translate3d(' + this.maxWidth + 'px, 0, 0)'
        }, this.optSwipe).queue(function (done) {
          _this3._reset(_this3.target.enter, _this3.target.leave);
          callback && callback();
          done();
        }));
      } else {
        Animit.runAll(Animit(enterPage).queue({
          transform: 'translate3D(0, 0, 0)',
          opacity: 1.0
        }, this.optSwipe), Animit(leavePage).queue({
          transform: 'translate3D(100%, 0, 0)'
        }, this.optSwipe).queue(function (done) {
          _this3._reset(enterPage, leavePage);
          callback && callback();
          done();
        }));
      }
    }
  }, {
    key: '_saveStyle',
    value: function _saveStyle() {
      var _this4 = this;

      this._savedStyle = new WeakMap();
      var save = function save(el) {
        return _this4._savedStyle.set(el, el.getAttribute('style'));
      };

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      args.forEach(save);

      Object.keys(this.decomp).forEach(function (p) {
        Object.keys(_this4.decomp[p]).forEach(function (k) {
          (_this4.decomp[p][k] instanceof Array ? _this4.decomp[p][k] : [_this4.decomp[p][k]]).forEach(save);
        });
      });
    }
  }, {
    key: '_restoreStyle',
    value: function _restoreStyle() {
      var _this5 = this;

      var restore = function restore(el) {
        _this5._savedStyle.get(el) === null ? el.removeAttribute('style') : el.setAttribute('style', _this5._savedStyle.get(el));
        _this5._savedStyle.delete(el);
      };

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      args.forEach(restore);

      Object.keys(this.decomp).forEach(function (p) {
        Object.keys(_this5.decomp[p]).forEach(function (k) {
          (_this5.decomp[p][k] instanceof Array ? _this5.decomp[p][k] : [_this5.decomp[p][k]]).forEach(restore);
        });
      });
    }
  }, {
    key: '_reset',
    value: function _reset() {
      this.isSwiping = false;
      this._savedStyle && this._restoreStyle.apply(this, arguments);
      this.unblock && this.unblock();
      this.swipeShadow.remove();
      this.backgroundMask.remove();
      this.overflowElement.classList.remove('overflow-visible');
      this.decomp.leave.content.classList.remove('content-swiping');
      this.decomp = this.target = this.overflowElement = this._savedStyle = null;
      this.isDragStart = true;
    }
  }]);
  return IOSSwipeNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var translate3d = function translate3d() {
  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return 'translate3d(' + x + ', ' + y + ', ' + z + ')';
};

/**
 * Slide animator for navigator transition like iOS's screen slide transition.
 */

var IOSSlideNavigatorAnimator = function (_IOSSwipeNavigatorAni) {
  inherits(IOSSlideNavigatorAnimator, _IOSSwipeNavigatorAni);

  function IOSSlideNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(0.3, .4, 0, .9)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration,
        rest = objectWithoutProperties(_ref, ['timing', 'delay', 'duration']);
    classCallCheck(this, IOSSlideNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (IOSSlideNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator)).call(this, _extends({ timing: timing, delay: delay, duration: duration }, rest)));

    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%;' + 'background-color: black; z-index: 2"></div>');
    return _this;
  }

  createClass(IOSSlideNavigatorAnimator, [{
    key: '_decompose',
    value: function _decompose(page) {
      var toolbar = page._getToolbarElement();
      var left = toolbar._getToolbarLeftItemsElement();
      var right = toolbar._getToolbarRightItemsElement();

      var excludeBackButton = function excludeBackButton(elements) {
        var result = [];

        for (var i = 0; i < elements.length; i++) {
          if (elements[i].nodeName.toLowerCase() !== 'ons-back-button') {
            result.push(elements[i]);
          }
        }

        return result;
      };

      var other = [].concat(left.children.length === 0 ? left : excludeBackButton(left.children)).concat(right.children.length === 0 ? right : excludeBackButton(right.children));

      return {
        toolbarCenter: toolbar._getToolbarCenterItemsElement(),
        backButtonIcon: toolbar._getToolbarBackButtonIconElement(),
        backButtonLabel: toolbar._getToolbarBackButtonLabelElement(),
        other: other,
        content: page._getContentElement(),
        background: page._getBackgroundElement(),
        toolbar: toolbar,
        bottomToolbar: page._getBottomToolbarElement()
      };
    }
  }, {
    key: '_shouldAnimateToolbar',
    value: function _shouldAnimateToolbar(enterPage, leavePage) {
      var toolbars = enterPage._canAnimateToolbar() && leavePage._canAnimateToolbar();

      var enterToolbar = enterPage._getToolbarElement();
      var leaveToolbar = leavePage._getToolbarElement();

      var isStatic = enterToolbar.hasAttribute('static') || leaveToolbar.hasAttribute('static');
      var isMaterial = util$1.hasModifier(enterToolbar, 'material') || util$1.hasModifier(leaveToolbar, 'material');
      var isTransparent = util$1.hasModifier(enterToolbar, 'transparent') || util$1.hasModifier(leaveToolbar, 'transparent');

      return toolbars && !isStatic && !isMaterial && !isTransparent;
    }
  }, {
    key: '_calculateDelta',
    value: function _calculateDelta(element, decomposition) {
      var title = void 0,
          label = void 0;

      var pageRect = element.getBoundingClientRect();
      if (decomposition.backButtonLabel.classList.contains('back-button__label')) {
        var labelRect = decomposition.backButtonLabel.getBoundingClientRect();
        title = Math.round(pageRect.width / 2 - labelRect.width / 2 - labelRect.left);
      } else {
        title = Math.round(pageRect.width / 2 * 0.6);
      }

      if (decomposition.backButtonIcon.classList.contains('back-button__icon')) {
        label = decomposition.backButtonIcon.getBoundingClientRect().right - 2;
      }

      return { title: title, label: label };
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get(IOSSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      contentReady(enterPage, function () {
        var enterPageTarget = util$1.findToolbarPage(enterPage) || enterPage;
        var leavePageTarget = util$1.findToolbarPage(leavePage) || leavePage;
        var enterPageDecomposition = _this2._decompose(enterPageTarget);
        var leavePageDecomposition = _this2._decompose(leavePageTarget);

        var delta = _this2._calculateDelta(leavePage, enterPageDecomposition);

        var shouldAnimateToolbar = _this2._shouldAnimateToolbar(enterPageTarget, leavePageTarget);

        if (shouldAnimateToolbar) {

          Animit.runAll(Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background], _this2.def).default({ transform: translate3d('100%') }, { transform: translate3d() }), Animit(enterPageDecomposition.toolbar, _this2.def).default({ opacity: 0 }, { opacity: 1 }), Animit(enterPageDecomposition.toolbarCenter, _this2.def).default({ transform: translate3d('125%'), opacity: 1 }, { transform: translate3d(), opacity: 1 }), Animit(enterPageDecomposition.backButtonLabel, _this2.def).default({ transform: translate3d(delta.title + 'px'), opacity: 0 }, {
            transform: translate3d(),
            opacity: 1,
            transition: 'opacity ' + _this2.duration + 's linear, transform ' + _this2.duration + 's ' + _this2.timing
          }), Animit(enterPageDecomposition.other, _this2.def).default({ opacity: 0 }, { css: { opacity: 1 }, timing: 'linear' }), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background], _this2.def).default({ transform: translate3d(), opacity: 1 }, { transform: translate3d('-25%'), opacity: 0.9 }).queue(function (done) {
            _this2.backgroundMask.remove();
            unblock();
            callback();
            done();
          }), Animit(leavePageDecomposition.toolbarCenter, _this2.def).default({ transform: translate3d(), opacity: 1 }, {
            transform: translate3d('-' + delta.title + 'px'),
            opacity: 0,
            transition: 'opacity ' + _this2.duration + 's linear, transform ' + _this2.duration + 's ' + _this2.timing
          }), Animit(leavePageDecomposition.backButtonLabel, _this2.def).default({ transform: translate3d(), opacity: 1 }, { transform: translate3d('-' + delta.label + 'px'), opacity: 0 }), Animit(leavePageDecomposition.other, _this2.def).default({ opacity: 1 }, { css: { opacity: 0 }, timing: 'linear' }));
        } else {

          Animit.runAll(Animit(enterPage, _this2.def).default({ transform: translate3d('100%') }, { transform: translate3d() }), Animit(leavePage, _this2.def).default({ transform: translate3d(), opacity: 1 }, { transform: translate3d('-25%'), opacity: .9 }).queue(function (done) {
            _this2.backgroundMask.remove();
            unblock();
            callback();
            done();
          }));
        }
      });
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      if (this.isSwiping) {
        return this.popSwipe(enterPage, leavePage, callback);
      }

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get(IOSSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      var enterPageTarget = util$1.findToolbarPage(enterPage) || enterPage;
      var leavePageTarget = util$1.findToolbarPage(leavePage) || leavePage;
      var enterPageDecomposition = this._decompose(enterPageTarget);
      var leavePageDecomposition = this._decompose(leavePageTarget);

      var delta = this._calculateDelta(leavePage, leavePageDecomposition);

      var shouldAnimateToolbar = this._shouldAnimateToolbar(enterPageTarget, leavePageTarget);

      if (shouldAnimateToolbar) {
        Animit.runAll(Animit([enterPageDecomposition.content, enterPageDecomposition.bottomToolbar, enterPageDecomposition.background], this.def).default({ transform: translate3d('-25%'), opacity: .9 }, { transform: translate3d(), opacity: 1 }), Animit(enterPageDecomposition.toolbarCenter, this.def).default({ transform: translate3d('-' + delta.title + 'px'), opacity: 0 }, {
          transform: translate3d(),
          opacity: 1,
          transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing
        }), Animit(enterPageDecomposition.backButtonLabel, this.def).default({ transform: translate3d('-' + delta.label + 'px') }, { transform: translate3d() }), Animit(enterPageDecomposition.other, this.def).default({ opacity: 0 }, { css: { opacity: 1 }, timing: 'linear' }), Animit([leavePageDecomposition.content, leavePageDecomposition.bottomToolbar, leavePageDecomposition.background], this.def).default({ transform: translate3d() }, { transform: translate3d('100%') }).wait(0).queue(function (done) {
          _this3.backgroundMask.remove();
          unblock();
          callback();
          done();
        }), Animit(leavePageDecomposition.toolbar, this.def).default({ opacity: 1 }, { opacity: 0 }), Animit(leavePageDecomposition.toolbarCenter, this.def).default({ transform: translate3d() }, { transform: translate3d('125%') }), Animit(leavePageDecomposition.backButtonLabel, this.def).default({ transform: translate3d(), opacity: 1 }, {
          transform: translate3d(delta.title + 'px'),
          opacity: 0,
          transition: 'opacity ' + this.duration + 's linear, transform ' + this.duration + 's ' + this.timing
        }));
      } else {
        Animit.runAll(Animit(enterPage, this.def).default({ transform: translate3d('-25%'), opacity: .9 }, { transform: translate3d(), opacity: 1 }), Animit(leavePage, this.def).default({ transform: translate3d() }, { transform: translate3d('100%') }).queue(function (done) {
          _this3.backgroundMask.remove();
          unblock();
          callback();
          done();
        }));
      }
    }
  }]);
  return IOSSlideNavigatorAnimator;
}(IOSSwipeNavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var IOSLiftNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(IOSLiftNavigatorAnimator, _NavigatorAnimator);

  function IOSLiftNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSLiftNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (IOSLiftNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%;' + 'background: linear-gradient(black, white);"></div>');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSLiftNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get(IOSLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage, this.def).default({ transform: 'translate3D(0, 100%, 0)' }, { transform: 'translate3D(0, 0, 0)' }), Animit(leavePage, this.def).default({ transform: 'translate3D(0, 0, 0)', opacity: 1 }, { transform: 'translate3D(0, -10%, 0)', opacity: .9 }).queue(function (done) {
        _this2.backgroundMask.remove();
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get(IOSLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage, this.def).default({ transform: 'translate3D(0, -43px, 0)', opacity: .9 }, { transform: 'translate3D(0, 0, 0)', opacity: 1 }).queue(function (done) {
        _this3.backgroundMask.remove();
        unblock();
        callback();
        done();
      }), Animit(leavePage, this.def).default({ transform: 'translate3D(0, 0, 0)' }, { transform: 'translate3D(0, 100%, 0)' }));
    }
  }]);
  return IOSLiftNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var transform = 'translate3d(0, 0, 0)';

/**
 * Fade-in screen transition.
 */

var IOSFadeNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(IOSFadeNavigatorAnimator, _NavigatorAnimator);

  function IOSFadeNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, IOSFadeNavigatorAnimator);
    return possibleConstructorReturn(this, (IOSFadeNavigatorAnimator.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(IOSFadeNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var unblock = get(IOSFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage, this.def).default({ transform: transform, opacity: 0 }, { transform: transform, opacity: 1 }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var unblock = get(IOSFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(IOSFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(leavePage, this.def).default({ transform: transform, opacity: 1 }, { transform: transform, opacity: 0 }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }
  }]);
  return IOSFadeNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Slide animator for navigator transition.
 */

var MDSlideNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(MDSlideNavigatorAnimator, _NavigatorAnimator);

  function MDSlideNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, MDSlideNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (MDSlideNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.blackMaskOpacity = 0.4;
    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%; z-index: 2;' + 'background-color: black; opacity: 0;"></div>');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDSlideNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentElement.insertBefore(this.backgroundMask, leavePage.nextSibling);

      var unblock = get(MDSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 0 }, { opacity: this.blackMaskOpacity }).queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      }), Animit(enterPage, this.def).default({ transform: 'translate3d(100%, 0, 0)' }, { transform: 'translate3d(0, 0, 0)' }), Animit(leavePage, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(-45%, 0, 0)' }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage.nextSibling);

      var unblock = get(MDSlideNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDSlideNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: this.blackMaskOpacity }, { opacity: 0 }).queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage, this.def).default({ transform: 'translate3d(-45%, 0, 0)', opacity: .9 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }), Animit(leavePage, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(100%, 0, 0)' }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }
  }]);
  return MDSlideNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift screen transition.
 */

var MDLiftNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(MDLiftNavigatorAnimator, _NavigatorAnimator);

  function MDLiftNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0.05 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.4 : _ref$duration;

    classCallCheck(this, MDLiftNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (MDLiftNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.backgroundMask = util$1.createElement('<div style="position: absolute; width: 100%; height: 100%;' + 'background-color: black;"></div>');
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDLiftNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var _this2 = this;

      this.backgroundMask.remove();
      leavePage.parentNode.insertBefore(this.backgroundMask, leavePage);

      var unblock = get(MDLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      var maskClear = Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this2.backgroundMask.remove();
        done();
      });

      Animit.runAll(maskClear, Animit(enterPage, this.def).default({ transform: 'translate3d(0, 100%, 0)' }, { transform: 'translate3d(0, 0, 0)' }), Animit(leavePage, this.def).default({ opacity: 1 }, { opacity: .4 }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} callback
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var _this3 = this;

      this.backgroundMask.remove();
      enterPage.parentNode.insertBefore(this.backgroundMask, enterPage);

      var unblock = get(MDLiftNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDLiftNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(this.backgroundMask).wait(this.delay + this.duration).queue(function (done) {
        _this3.backgroundMask.remove();
        done();
      }), Animit(enterPage, this.def).default({ opacity: .4 }, { opacity: 1 }).queue(function (done) {
        unblock();
        callback();
        done();
      }), Animit(leavePage, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, 100%, 0)' }));
    }
  }]);
  return MDLiftNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fade-in + Lift screen transition.
 */

var MDFadeNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(MDFadeNavigatorAnimator, _NavigatorAnimator);

  function MDFadeNavigatorAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(0.4, 0, 0.2, 1)' : _ref$timing,
        _ref$timingPop = _ref.timingPop,
        timingPop = _ref$timingPop === undefined ? 'cubic-bezier(0.4, 0, 1, 1)' : _ref$timingPop,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, MDFadeNavigatorAnimator);

    var _this = possibleConstructorReturn(this, (MDFadeNavigatorAnimator.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.timingPop = timingPop;
    return _this;
  }

  /**
   * @param {Object} enterPage
   * @param {Object} leavePage
   * @param {Function} callback
   */


  createClass(MDFadeNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      var unblock = get(MDFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(enterPage, this.def).default({ transform: 'translate3D(0, 42px, 0)', opacity: 0 }, { transform: 'translate3D(0, 0, 0)', opacity: 1 }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }

    /**
     * @param {Object} enterPage
     * @param {Object} leavePage
     * @param {Function} done
     */

  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      var unblock = get(MDFadeNavigatorAnimator.prototype.__proto__ || Object.getPrototypeOf(MDFadeNavigatorAnimator.prototype), 'block', this).call(this, enterPage);

      Animit.runAll(Animit(leavePage, this.def).default({ transform: 'translate3D(0, 0, 0)', opacity: 1 }, { css: { transform: 'translate3D(0, 38px, 0)', opacity: 0 }, timing: this.timingPop }).queue(function (done) {
        unblock();
        callback();
        done();
      }));
    }
  }]);
  return MDFadeNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var NoneNavigatorAnimator = function (_NavigatorAnimator) {
  inherits(NoneNavigatorAnimator, _NavigatorAnimator);

  function NoneNavigatorAnimator(options) {
    classCallCheck(this, NoneNavigatorAnimator);
    return possibleConstructorReturn(this, (NoneNavigatorAnimator.__proto__ || Object.getPrototypeOf(NoneNavigatorAnimator)).call(this, options));
  }

  createClass(NoneNavigatorAnimator, [{
    key: 'push',
    value: function push(enterPage, leavePage, callback) {
      callback();
    }
  }, {
    key: 'pop',
    value: function pop(enterPage, leavePage, callback) {
      callback();
    }
  }]);
  return NoneNavigatorAnimator;
}(NavigatorAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$5 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadeNavigatorAnimator : IOSSlideNavigatorAnimator;
  },
  'slide': function slide() {
    return platform.isAndroid() ? MDSlideNavigatorAnimator : IOSSlideNavigatorAnimator;
  },
  'lift': function lift() {
    return platform.isAndroid() ? MDLiftNavigatorAnimator : IOSLiftNavigatorAnimator;
  },
  'fade': function fade() {
    return platform.isAndroid() ? MDFadeNavigatorAnimator : IOSFadeNavigatorAnimator;
  },
  'slide-ios': IOSSlideNavigatorAnimator,
  'slide-md': MDSlideNavigatorAnimator,
  'lift-ios': IOSLiftNavigatorAnimator,
  'lift-md': MDLiftNavigatorAnimator,
  'fade-ios': IOSFadeNavigatorAnimator,
  'fade-md': MDFadeNavigatorAnimator,
  'none': NoneNavigatorAnimator
};

var rewritables = {
  /**
   * @param {Element} navigatorSideElement
   * @param {Function} callback
   */
  ready: function ready(navigatorElement, callback) {
    callback();
  }
};

var verifyPageElement = function verifyPageElement(el) {
  return el.nodeName !== 'ONS-PAGE' && util$1.throw('Only page elements can be children of navigator');
};

/**
 * @element ons-navigator
 * @category navigation
 * @description
 *   [en]
 *     A component that provides page stack management and navigation. Stack navigation is the most common navigation pattern for mobile apps.
 *
 *     When a page is pushed on top of the stack it is displayed with a transition animation. When the user returns to the previous page the top page will be popped from the top of the stack and hidden with an opposite transition animation.
 *   [/en]
 *   [ja][/ja]
 * @codepen yrhtv
 * @tutorial vanilla/Reference/navigator
 * @guide lifecycle.html#events
 *   [en]Overview of page events[/en]
 *   [ja]Overview of page events[/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component is used to display a toolbar on the top of a page.[/en]
 *   [ja][/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component lets the user return to the previous page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-navigator id="navigator">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="center">
 *         Title
 *       </div>
 *     </ons-toolbar>
 *     <p>
 *       <ons-button
 *         onclick="document.getElementById('navigator').pushPage('page.html')">
 *         Push page
 *       </ons-button>
 *     </p>
 *   </ons-page>
 * </ons-navigator>
 *
 * <template id="page.html">
 *   <ons-page>
 *     <ons-toolbar>
 *       <div class="left">
 *         <ons-back-button>Back</ons-back-button>
 *       </div>
 *       <div class="center">
 *         Another page
 *       </div>
 *     </ons-toolbar>
 *   </ons-page>
 * </template>
 */

var NavigatorElement = function (_BaseElement) {
  inherits(NavigatorElement, _BaseElement);
  createClass(NavigatorElement, [{
    key: 'animatorFactory',


    /**
     * @attribute page
     * @initonly
     * @type {String}
     * @description
     *   [en]First page to show when navigator is initialized.[/en]
     *   [ja]ナビゲーターが初期化された時に表示するページを指定します。[/ja]
     */

    /**
     * @attribute swipeable
     * @type {Boolean}
     * @description
     *   [en]Enable iOS "swipe to pop" feature.[/en]
     *   [ja][/ja]
     */

    /**
     * @attribute swipe-target-width
     * @type {String}
     * @default 20px
     * @description
     *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
     *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
     */

    /**
     * @attribute swipe-threshold
     * @type {Number}
     * @default 0.2
     * @description
     *  [en]Specify how much the page needs to be swiped before popping. A value between `0` and `1`.[/en]
     *  [ja][/ja]
     */

    /**
     * @attribute animation
     * @type {String}
     * @default default
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"` depending on the platform.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @attribute animation-options
     * @type {Expression}
     * @description
     *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/en]
     *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`[/ja]
     */

    /**
     * @event prepush
     * @description
     *   [en]Fired just before a page is pushed.[/en]
     *   [ja]pageがpushされる直前に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]現在のpageオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the push.[/en]
     *   [ja]この関数を呼び出すと、push処理がキャンセルされます。[/ja]
     */

    /**
     * @event prepop
     * @description
     *   [en]Fired just before a page is popped.[/en]
     *   [ja]pageがpopされる直前に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.currentPage
     *   [en]Current page object.[/en]
     *   [ja]現在のpageオブジェクト。[/ja]
     * @param {Function} event.cancel
     *   [en]Call this function to cancel the pop.[/en]
     *   [ja]この関数を呼び出すと、pageのpopがキャンセルされます。[/ja]
     */

    /**
     * @event postpush
     * @description
     *   [en]Fired just after a page is pushed.[/en]
     *   [ja]pageがpushされてアニメーションが終了してから発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]pushされたpageオブジェクト。[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]以前のpageオブジェクト。[/ja]
     */

    /**
     * @event postpop
     * @description
     *   [en]Fired just after a page is popped.[/en]
     *   [ja]pageがpopされてアニメーションが終わった後に発火されます。[/ja]
     * @param {Object} event [en]Event object.[/en]
     * @param {Object} event.navigator
     *   [en]Component object.[/en]
     *   [ja]コンポーネントのオブジェクト。[/ja]
     * @param {Object} event.enterPage
     *   [en]Object of the next page.[/en]
     *   [ja]popされて表示されるページのオブジェクト。[/ja]
     * @param {Object} event.leavePage
     *   [en]Object of the previous page.[/en]
     *   [ja]popされて消えるページのオブジェクト。[/ja]
     */

    get: function get$$1() {
      return this._animatorFactory;
    }
  }]);

  function NavigatorElement() {
    classCallCheck(this, NavigatorElement);

    var _this = possibleConstructorReturn(this, (NavigatorElement.__proto__ || Object.getPrototypeOf(NavigatorElement)).call(this));

    _this._isRunning = false;
    _this._initialized = false;
    _this._pageLoader = defaultPageLoader;
    _this._pageMap = new WeakMap();

    _this._updateAnimatorFactory();
    return _this;
  }

  /**
   * @property pageLoader
   * @type {PageLoader}
   * @description
   *   [en]PageLoader instance. It can be overriden to change the way pages are loaded by this element. Useful for lib developers.[/en]
   *   [ja]PageLoaderインスタンスを格納しています。[/ja]
   */


  createClass(NavigatorElement, [{
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en]Specify the page to be loaded during initialization. This value takes precedence over the `page` attribute. Useful for lib developers.[/en]
     *   [ja]初期化時に読み込むページを指定します。`page`属性で指定した値よりも`page`プロパティに指定した値を優先します。[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);

      if (!platform.isAndroid() || this.getAttribute('swipeable') === 'force') {
        var swipeAnimator = void 0;

        this._swipe = new SwipeReveal({
          element: this,
          getThreshold: function getThreshold() {
            return Math.max(0.2, parseFloat(_this2.getAttribute('swipe-threshold')) || 0);
          },

          swipeMax: function swipeMax() {
            _this2._onSwipe && _this2._onSwipe(1, { duration: swipeAnimator.durationSwipe, timing: swipeAnimator.timingSwipe });
            _this2[_this2.swipeMax ? 'swipeMax' : 'popPage']({ animator: swipeAnimator });
            swipeAnimator = null;
          },
          swipeMid: function swipeMid(distance, width) {
            _this2._onSwipe && _this2._onSwipe(distance / width);
            swipeAnimator.translate(distance, width, _this2.topPage.previousElementSibling, _this2.topPage);
          },
          swipeMin: function swipeMin() {
            _this2._onSwipe && _this2._onSwipe(0, { duration: swipeAnimator.durationRestore, timing: swipeAnimator.timingSwipe });
            swipeAnimator.restore(_this2.topPage.previousElementSibling, _this2.topPage);
            swipeAnimator = null;
          },

          ignoreSwipe: function ignoreSwipe(event, distance) {
            // Basic conditions
            if (!_this2._isRunning && _this2.children.length > 1) {

              // Area or directional issues
              var area = parseInt(_this2.getAttribute('swipe-target-width') || 25, 10);
              if (event.gesture.direction === 'right' && area > distance) {

                // Swipes on ons-back-button and its children
                var isBB = function isBB(el) {
                  return (/ons-back-button/i.test(el.tagName)
                  );
                };
                if (!isBB(event.target) && !util$1.findParent(event.target, isBB, function (p) {
                  return (/ons-page/i.test(p.tagName)
                  );
                })) {

                  // Animator is swipeable
                  var animation = (_this2.topPage.pushedOptions || {}).animation || _this2.animatorFactory._animation;
                  var Animator = _animatorDict$5[animation] instanceof Function ? _animatorDict$5[animation].call() : _animatorDict$5[animation];

                  if (typeof Animator !== 'undefined' && Animator.swipeable) {
                    swipeAnimator = new Animator(); // Prepare for the swipe
                    return false;
                  }
                }
              }
            }

            return true; // Ignore swipe
          }
        });

        this.attributeChangedCallback('swipeable');
      }

      if (this._initialized) {
        return;
      }

      this._initialized = true;

      var deferred = util$1.defer();
      this.loaded = deferred.promise;

      rewritables.ready(this, function () {
        var show = !util$1.hasAnyComponentAsParent(_this2);
        var options = { animation: 'none', show: show };

        if (_this2.pages.length === 0 && _this2._getPageTarget()) {
          _this2.pushPage(_this2._getPageTarget(), options).then(function () {
            return deferred.resolve();
          });
        } else if (_this2.pages.length > 0) {
          for (var i = 0; i < _this2.pages.length; i++) {
            verifyPageElement(_this2.pages[i]);
          }

          if (_this2.topPage) {
            contentReady(_this2.topPage, function () {
              return setTimeout(function () {
                deferred.resolve();
                show && _this2.topPage._show();
                _this2._updateLastPageBackButton();
              }, 0);
            });
          }
        } else {
          contentReady(_this2, function () {
            if (_this2.pages.length === 0 && _this2._getPageTarget()) {
              _this2.pushPage(_this2._getPageTarget(), options).then(function () {
                return deferred.resolve();
              });
            } else {
              deferred.resolve();
            }
          });
        }
      });
    }
  }, {
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      this._animatorFactory = new AnimatorFactory({
        animators: _animatorDict$5,
        baseClass: NavigatorAnimator,
        baseClassName: 'NavigatorAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;

      this._swipe && this._swipe.dispose();
      this._swipe = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'animation':
          this._updateAnimatorFactory();
          break;
        case 'swipeable':
          this._swipe && this._swipe.update();
          break;
      }
    }

    /**
     * @method popPage
     * @signature popPage([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @param {Number} [options.times]
     *   [en]Number of pages to be popped. Only one animation will be shown.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the revealed page.[/en]
     *   [ja]明らかにしたページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Pops the current page from the page stack. The previous page will be displayed.[/en]
     *   [ja]現在表示中のページをページスタックから取り除きます。一つ前のページに戻ります。[/ja]
     */

  }, {
    key: 'popPage',
    value: function popPage() {
      var _this3 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _preparePageAndOption = this._preparePageAndOptions(null, options);

      options = _preparePageAndOption.options;


      if (util$1.isInteger(options.times) && options.times > 1) {
        this._removePages(options.times);
      }

      var popUpdate = function popUpdate() {
        return new Promise(function (resolve) {
          _this3._pageLoader.unload(_this3.pages[_this3.pages.length - 1]);
          resolve();
        });
      };

      return this._popPage(options, popUpdate);
    }
  }, {
    key: '_popPage',
    value: function _popPage(options) {
      var _this4 = this;

      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('popPage is already running.');
      }

      if (this.pages.length <= 1) {
        return Promise.reject('ons-navigator\'s page stack is empty.');
      }

      if (this._emitPrePopEvent()) {
        return Promise.reject('Canceled in prepop event.');
      }

      var length = this.pages.length;

      this._isRunning = true;

      this.pages[length - 2].updateBackButton(length - 2 > 0);

      return new Promise(function (resolve) {
        var leavePage = _this4.pages[length - 1];
        var enterPage = _this4.pages[length - 2];

        options = util$1.extend({}, _this4.options || {}, leavePage.pushedOptions || {}, options);

        if (options.data) {
          enterPage.data = util$1.extend({}, enterPage.data || {}, options.data || {});
        }

        var done = function done() {
          update().then(function () {
            _this4._isRunning = false;

            enterPage._show();
            util$1.triggerElementEvent(_this4, 'postpop', { leavePage: leavePage, enterPage: enterPage, navigator: _this4 });

            options.callback && options.callback(enterPage);

            resolve(enterPage);
          });
        };

        leavePage._hide();
        enterPage.style.display = '';

        var animator = options.animator || _this4._animatorFactory.newAnimator(options);
        animator.pop(_this4.pages[length - 2], _this4.pages[length - 1], done);
      }).catch(function () {
        return _this4._isRunning = false;
      });
    }

    /**
     * @method pushPage
     * @signature pushPage(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either a HTML document or a template defined with the `<template>` tag.[/en]
     *   [ja]pageのURLか、もしくは`<template>`で宣言したテンプレートのid属性の値を指定できます。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.page]
     *   [en]Page URL. Only necessary if `page` parameter is null or undefined.[/en]
     *   [ja][/ja]
     * @param {String} [options.pageHTML]
     *   [en]HTML code that will be computed as a new page. Overwrites `page` parameter.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     * @param {Function} [options.callback]
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]pushPage()による画面遷移が終了した時に呼び出される関数オブジェクトを指定します。[/ja]
     * @param {Object} [options.data]
     *   [en]Custom data that will be stored in the new page element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the pushed page.[/en]
     *   [ja]追加したページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Pushes the specified page into the stack.[/en]
     *   [ja]指定したpageを新しいページスタックに追加します。新しいページが表示されます。[/ja]
     */

  }, {
    key: 'pushPage',
    value: function pushPage(page) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption2 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption2.page;
      options = _preparePageAndOption2.options;


      var prepare = function prepare(pageElement) {
        verifyPageElement(pageElement);
        _this5._pageMap.set(pageElement, page);
        pageElement = util$1.extend(pageElement, {
          data: options.data
        });
        pageElement.style.visibility = 'hidden';
      };

      if (options.pageHTML) {
        return this._pushPage(options, function () {
          return new Promise(function (resolve) {
            instantPageLoader.load({ page: options.pageHTML, parent: _this5, params: options.data }, function (pageElement) {
              prepare(pageElement);
              resolve();
            });
          });
        });
      }

      return this._pushPage(options, function () {
        return new Promise(function (resolve) {
          _this5._pageLoader.load({ page: page, parent: _this5, params: options.data }, function (pageElement) {
            prepare(pageElement);
            resolve();
          });
        });
      });
    }
  }, {
    key: '_pushPage',
    value: function _pushPage() {
      var _this6 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
        return Promise.resolve();
      };

      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }

      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      this._isRunning = true;

      var animationOptions = AnimatorFactory.parseAnimationOptionsString(this.getAttribute('animation-options'));
      options = util$1.extend({}, this.options || {}, { animationOptions: animationOptions }, options);

      var animator = this._animatorFactory.newAnimator(options);

      return update().then(function () {
        var pageLength = _this6.pages.length;

        var enterPage = _this6.pages[pageLength - 1];
        var leavePage = options.leavePage || _this6.pages[pageLength - 2];

        verifyPageElement(enterPage);

        enterPage.updateBackButton(pageLength > (options._replacePage ? 2 : 1));

        enterPage.pushedOptions = util$1.extend({}, enterPage.pushedOptions || {}, options || {});
        enterPage.data = util$1.extend({}, enterPage.data || {}, options.data || {});
        enterPage.unload = enterPage.unload || options.unload;

        return new Promise(function (resolve) {
          var done = function done() {
            _this6._isRunning = false;

            options.show !== false && setImmediate(function () {
              return enterPage._show();
            });
            util$1.triggerElementEvent(_this6, 'postpush', { leavePage: leavePage, enterPage: enterPage, navigator: _this6 });

            if (leavePage) {
              leavePage.style.display = 'none';
            }

            options.callback && options.callback(enterPage);

            resolve(enterPage);
          };

          enterPage.style.visibility = '';
          if (leavePage) {
            leavePage._hide();
            animator.push(enterPage, leavePage, done);
          } else {
            done();
          }
        });
      }).catch(function (error) {
        _this6._isRunning = false;
        throw error;
      });
    }

    /**
     * @method replacePage
     * @signature replacePage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new page.[/en]
     *   [ja]新しいページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Replaces the current top page with the specified one. Extends `pushPage()` parameters.[/en]
     *   [ja]現在表示中のページをを指定したページに置き換えます。[/ja]
     */

  }, {
    key: 'replacePage',
    value: function replacePage(page) {
      var _this7 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this.pushPage(page, options).then(function (resolvedValue) {
        if (_this7.pages.length > 1) {
          _this7._pageLoader.unload(_this7.pages[_this7.pages.length - 2]);
        }
        _this7._updateLastPageBackButton();

        return Promise.resolve(resolvedValue);
      });
    }

    /**
     * @method insertPage
     * @signature insertPage(index, page, [options])
     * @param {Number} index
     *   [en]The index where it should be inserted.[/en]
     *   [ja]スタックに挿入する位置のインデックスを指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the inserted page.[/en]
     *   [ja]指定したページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Insert the specified page into the stack with at a position defined by the `index` argument. Extends `pushPage()` parameters.[/en]
     *   [ja]指定したpageをページスタックのindexで指定した位置に追加します。[/ja]
     */

  }, {
    key: 'insertPage',
    value: function insertPage(index, page) {
      var _this8 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      var _preparePageAndOption3 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption3.page;
      options = _preparePageAndOption3.options;

      index = this._normalizeIndex(index);

      if (index >= this.pages.length) {
        return this.pushPage(page, options);
      }

      page = typeof options.pageHTML === 'string' ? options.pageHTML : page;
      var loader = typeof options.pageHTML === 'string' ? instantPageLoader : this._pageLoader;

      return new Promise(function (resolve) {
        loader.load({ page: page, parent: _this8 }, function (pageElement) {
          verifyPageElement(pageElement);
          _this8._pageMap.set(pageElement, page);
          pageElement = util$1.extend(pageElement, {
            data: options.data,
            pushedOptions: options
          });

          options.animationOptions = util$1.extend({}, AnimatorFactory.parseAnimationOptionsString(_this8.getAttribute('animation-options')), options.animationOptions || {});

          pageElement.style.display = 'none';
          _this8.insertBefore(pageElement, _this8.pages[index]);
          _this8.topPage.updateBackButton(true);

          setTimeout(function () {
            pageElement = null;
            resolve(_this8.pages[index]);
          }, 1000 / 60);
        });
      });
    }

    /**
     * @method removePage
     * @signature removePage(index, [options])
     * @param {Number} index
     *   [en]The index where it should be removed.[/en]
     *   [ja]スタックから削除するページのインデックスを指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the revealed page.[/en]
     *   [ja]削除によって表示されたページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Remove the specified page at a position in the stack defined by the `index` argument. Extends `popPage()` parameters.[/en]
     *   [ja]指定したインデックスにあるページを削除します。[/ja]
     */

  }, {
    key: 'removePage',
    value: function removePage(index) {
      var _this9 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      index = this._normalizeIndex(index);

      if (index < this.pages.length - 1) {
        return new Promise(function (resolve) {
          var leavePage = _this9.pages[index];
          var enterPage = _this9.topPage;

          _this9._pageMap.delete(leavePage);
          _this9._pageLoader.unload(leavePage);
          if (_this9.pages.length === 1) {
            // edge case
            _this9.topPage.updateBackButton(false);
          }

          resolve(enterPage);
        });
      } else {
        return this.popPage(options);
      }
    }

    /**
     * @method resetToPage
     * @signature resetToPage(page, [options])
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
     * @param {Boolean} [options.pop]
     *   [en]Performs 'pop' effect if `true` instead of 'push' or none. This also sets `options.animation` value to `default` instead of `none`.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Clears page stack and adds the specified page to the stack. Extends `pushPage()` parameters.[/en]
     *   [ja]ページスタックをリセットし、指定したページを表示します。[/ja]
     */

  }, {
    key: 'resetToPage',
    value: function resetToPage(page) {
      var _this10 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _preparePageAndOption4 = this._preparePageAndOptions(page, options);

      page = _preparePageAndOption4.page;
      options = _preparePageAndOption4.options;


      if (!options.animator && !options.animation && !options.pop) {
        options.animation = 'none';
      }

      if (!options.page && !options.pageHTML && this._getPageTarget()) {
        page = options.page = this._getPageTarget();
      }

      if (options.pop) {
        this._removePages();
        return this.insertPage(0, page, { data: options.data }).then(function () {
          return _this10.popPage(options);
        });
      }

      // Tip: callback runs before resolved promise
      var callback = options.callback;
      options.callback = function (newPage) {
        _this10._removePages();
        newPage.updateBackButton(false);
        callback && callback(newPage);
      };

      return this.pushPage(page, options);
    }

    /**
     * @method bringPageTop
     * @signature bringPageTop(item, [options])
     * @param {String|Number} item
     *   [en]Page URL or index of an existing page in navigator's stack.[/en]
     *   [ja]ページのURLかもしくはons-navigatorのページスタックのインデックス値を指定します。[/ja]
     * @return {Promise}
     *   [en]Promise which resolves to the new top page.[/en]
     *   [ja]新しいトップページを解決するPromiseを返します。[/ja]
     * @description
     *   [en]Brings the given page to the top of the page stack if it already exists or pushes it into the stack if doesn't. Extends `pushPage()` parameters.[/en]
     *   [ja]指定したページをページスタックの一番上に移動します。もし指定したページが無かった場合新しくpushされます。[/ja]
     */

  }, {
    key: 'bringPageTop',
    value: function bringPageTop(item) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (['number', 'string'].indexOf(typeof item === 'undefined' ? 'undefined' : _typeof(item)) === -1) {
        util$1.throw('First argument must be a page name or the index of an existing page. You supplied ' + item);
      }
      var index = typeof item === 'number' ? this._normalizeIndex(item) : this._lastIndexOfPage(item);
      var page = this.pages[index];

      if (index < 0) {
        return this.pushPage(item, options);
      }

      var _preparePageAndOption5 = this._preparePageAndOptions(page, options);

      options = _preparePageAndOption5.options;


      if (index === this.pages.length - 1) {
        return Promise.resolve(page);
      }
      if (!page) {
        util$1.throw('Failed to find item ' + item);
      }
      if (this._isRunning) {
        return Promise.reject('pushPage is already running.');
      }
      if (this._emitPrePushEvent()) {
        return Promise.reject('Canceled in prepush event.');
      }

      page.style.display = '';
      page.style.visibility = 'hidden';
      page.parentNode.appendChild(page);
      return this._pushPage(options);
    }
  }, {
    key: '_preparePageAndOptions',
    value: function _preparePageAndOptions(page) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) != 'object') {
        util$1.throw('options must be an object. You supplied ' + options);
      }

      if ((page === null || page === undefined) && options.page) {
        page = options.page;
      }

      options = util$1.extend({}, this.options || {}, options, { page: page });

      return { page: page, options: options };
    }
  }, {
    key: '_removePages',
    value: function _removePages(times) {
      var pages = this.pages;
      var until = times === undefined ? 0 : pages.length - times;
      until = until < 0 ? 1 : until;

      for (var i = pages.length - 2; i >= until; i--) {
        this._pageMap.delete(pages[i]);
        this._pageLoader.unload(pages[i]);
      }
    }
  }, {
    key: '_updateLastPageBackButton',
    value: function _updateLastPageBackButton() {
      var index = this.pages.length - 1;
      if (index >= 0) {
        this.pages[index].updateBackButton(index > 0);
      }
    }
  }, {
    key: '_normalizeIndex',
    value: function _normalizeIndex(index) {
      return index >= 0 ? index : Math.abs(this.pages.length + index) % this.pages.length;
    }
  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      if (this.pages.length > 1) {
        this.popPage();
      } else {
        event.callParentHandler();
      }
    }
  }, {
    key: '_lastIndexOfPage',
    value: function _lastIndexOfPage(pageName) {
      var index = void 0;
      for (index = this.pages.length - 1; index >= 0; index--) {
        if (!this._pageMap.has(this.pages[index])) {
          util$1.throw('Incorrect state of pageMap');
        }

        if (pageName === this._pageMap.get(this.pages[index])) {
          break;
        }
      }
      return index;
    }
  }, {
    key: '_emitPreEvent',
    value: function _emitPreEvent(name) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var isCanceled = false;

      util$1.triggerElementEvent(this, 'pre' + name, util$1.extend({
        navigator: this,
        currentPage: this.pages[this.pages.length - 1],
        cancel: function cancel() {
          return isCanceled = true;
        }
      }, data));

      return isCanceled;
    }
  }, {
    key: '_emitPrePushEvent',
    value: function _emitPrePushEvent() {
      return this._emitPreEvent('push');
    }
  }, {
    key: '_emitPrePopEvent',
    value: function _emitPrePopEvent() {
      var l = this.pages.length;
      return this._emitPreEvent('pop', {
        leavePage: this.pages[l - 1],
        enterPage: this.pages[l - 2]
      });
    }

    // TODO: 書き直す

  }, {
    key: '_createPageElement',
    value: function _createPageElement(templateHTML) {
      var pageElement = util$1.createElement(internal$1.normalizePageHTML(templateHTML));
      verifyPageElement(pageElement);
      return pageElement;
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_show',
    value: function _show() {
      var _this11 = this;

      this.loaded.then(function () {
        return _this11.topPage && _this11.topPage._show();
      });
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this.topPage && this.topPage._hide();
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      for (var i = this.pages.length - 1; i >= 0; i--) {
        this._pageLoader.unload(this.pages[i]);
      }

      this.remove();
    }

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: 'pageLoader',
    get: function get$$1() {
      return this._pageLoader;
    },
    set: function set$$1(pageLoader) {
      if (!(pageLoader instanceof PageLoader)) {
        util$1.throwPageLoader();
      }
      this._pageLoader = pageLoader;
    }
  }, {
    key: 'page',
    get: function get$$1() {
      return this._page;
    },
    set: function set$$1(page) {
      this._page = page;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }

    /**
     * @property topPage
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Current top page element. Use this method to access options passed by `pushPage()`-like methods.[/en]
     *   [ja]現在のページを取得します。pushPage()やresetToPage()メソッドの引数を取得できます。[/ja]
     */

  }, {
    key: 'topPage',
    get: function get$$1() {
      var last = this.lastElementChild;
      while (last && last.tagName !== 'ONS-PAGE') {
        last = last.previousElementSibling;
      }
      return last;
    }

    /**
     * @property pages
     * @readonly
     * @type {Array}
     * @description
     *   [en]Copy of the navigator's page stack.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pages',
    get: function get$$1() {
      return util$1.arrayFrom(this.children).filter(function (element) {
        return element.tagName === 'ONS-PAGE';
      });
    }

    /**
     * @property onSwipe
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user slides the navigator (swipe-to-pop). It gets a decimal ratio (0-1) and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onSwipe',
    get: function get$$1() {
      return this._onSwipe;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        util$1.throw('"onSwipe" must be a function');
      }
      this._onSwipe = value;
    }

    /**
     * @property options
     * @type {Object}
     * @description
     *   [en]Default options object. Attributes have priority over this property.[/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animation
     * @type {String}
     * @description
     *   [en]
     *     Animation name. Available animations are `"slide"`, `"lift"`, `"fade"` and `"none"`.
     *     These are platform based animations. For fixed animations, add `"-ios"` or `"-md"` suffix to the animation name. E.g. `"lift-ios"`, `"lift-md"`. Defaults values are `"slide-ios"` and `"fade-md"`.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property options.animationOptions
     * @type {String}
     * @description
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}` [/ja]
     */

    /**
     * @property options.callback
     * @type {String}
     * @description
     *   [en]Function that is called when the transition has ended.[/en]
     *   [ja]このメソッドによる画面遷移が終了した際に呼び出される関数オブジェクトを指定します。[/ja]
     */

  }, {
    key: 'options',
    get: function get$$1() {
      return this._options;
    },
    set: function set$$1(object) {
      this._options = object;
    }
  }, {
    key: '_isRunning',
    set: function set$$1(value) {
      this.setAttribute('_is-running', value ? 'true' : 'false');
    },
    get: function get$$1() {
      return JSON.parse(this.getAttribute('_is-running'));
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof NavigatorAnimator)) {
        util$1.throwAnimator('Navigator');
      }

      _animatorDict$5[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return ['animation', 'swipeable'];
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$5;
    }
  }, {
    key: 'NavigatorAnimator',
    get: function get$$1() {
      return NavigatorAnimator;
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['prepush', 'postpush', 'prepop', 'postpop'];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables;
    }
  }]);
  return NavigatorElement;
}(BaseElement);

onsElements.Navigator = NavigatorElement;
customElements.define('ons-navigator', NavigatorElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$10 = 'toolbar';

var scheme$18 = {
  '': 'toolbar--*',
  '.toolbar__left': 'toolbar--*__left',
  '.toolbar__center': 'toolbar--*__center',
  '.toolbar__right': 'toolbar--*__right'
};

/**
 * @element ons-toolbar
 * @category page
 * @modifier material
 *   [en]Material Design toolbar.[/en]
 *   [ja][/ja]
 * @modifier transparent
 *   [en]Transparent toolbar.[/en]
 *   [ja]透明な背景を持つツールバーを表示します。[/ja]
 * @modifier cover-content
 *   [en]Displays the toolbar on top of the page's content. Should be combined with `transparent` modifier.[/en]
 *   [ja][/ja]
 * @modifier noshadow
 *   [en]Toolbar without shadow.[/en]
 *   [ja]ツールバーに影を付けずに表示します。[/ja]
 * @description
 *   [en]
 *     Toolbar component that can be used with navigation.
 *
 *     Left, center and right container can be specified by class names.
 *
 *     This component will automatically displays as a Material Design toolbar when running on Android devices.
 *   [/en]
 *   [ja]ナビゲーションで使用するツールバー用コンポーネントです。クラス名により、左、中央、右のコンテナを指定できます。[/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/toolbar
 * @guide compilation.html#toolbar-compilation [en]Adding a toolbar[/en][ja]ツールバーの追加[/ja]
 * @seealso ons-bottom-toolbar
 *   [en]The `<ons-bottom-toolbar>` displays a toolbar on the bottom of the page.[/en]
 *   [ja]ons-bottom-toolbarコンポーネント[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` component displays a back button inside the toolbar.[/en]
 *   [ja]ons-back-buttonコンポーネント[/ja]
 * @seealso ons-toolbar-button
 *   [en]The `<ons-toolbar-button>` component displays a toolbar button inside the toolbar.[/en]
 *   [ja]ons-toolbar-buttonコンポーネント[/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>
 *         Back
 *       </ons-back-button>
 *     </div>
 *     <div class="center">
 *       Title
 *     </div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 * </ons-page>
 */

var ToolbarElement = function (_BaseElement) {
  inherits(ToolbarElement, _BaseElement);

  /**
   * @attribute inline
   * @initonly
   * @description
   *   [en]Display the toolbar as an inline element.[/en]
   *   [ja]ツールバーをインラインに置きます。スクロール領域内にそのまま表示されます。[/ja]
   */

  /**
   * @attribute static
   * @description
   *   [en]Static toolbars are not animated by `ons-navigator` when pushing or popping pages. This can be useful to improve performance in some situations.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute modifier
   * @description
   *   [en]The appearance of the toolbar.[/en]
   *   [ja]ツールバーの表現を指定します。[/ja]
   */

  function ToolbarElement() {
    classCallCheck(this, ToolbarElement);

    var _this = possibleConstructorReturn(this, (ToolbarElement.__proto__ || Object.getPrototypeOf(ToolbarElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });
    return _this;
  }

  createClass(ToolbarElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$10, scheme$18);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$18);
          break;
      }
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarLeftItemsElement',
    value: function _getToolbarLeftItemsElement() {
      return this.querySelector('.left') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarCenterItemsElement',
    value: function _getToolbarCenterItemsElement() {
      return this.querySelector('.center') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarRightItemsElement',
    value: function _getToolbarRightItemsElement() {
      return this.querySelector('.right') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonLabelElement',
    value: function _getToolbarBackButtonLabelElement() {
      return this.querySelector('ons-back-button .back-button__label') || internal$1.nullElement;
    }

    /**
     * @return {HTMLElement}
     */

  }, {
    key: '_getToolbarBackButtonIconElement',
    value: function _getToolbarBackButtonIconElement() {
      return this.querySelector('ons-back-button .back-button__icon') || internal$1.nullElement;
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$10);
      this._ensureToolbarItemElements();
      ModifierUtil.initModifier(this, scheme$18);
    }
  }, {
    key: '_ensureToolbarItemElements',
    value: function _ensureToolbarItemElements() {
      for (var i = this.childNodes.length - 1; i >= 0; i--) {
        // case of not element
        if (this.childNodes[i].nodeType != 1) {
          this.removeChild(this.childNodes[i]);
        }
      }

      var center = this._ensureToolbarElement('center');
      center.classList.add('toolbar__title');

      if (this.children.length !== 1 || !this.children[0].classList.contains('center')) {
        var left = this._ensureToolbarElement('left');
        var right = this._ensureToolbarElement('right');

        if (this.children[0] !== left || this.children[1] !== center || this.children[2] !== right) {
          this.appendChild(left);
          this.appendChild(center);
          this.appendChild(right);
        }
      }
    }
  }, {
    key: '_ensureToolbarElement',
    value: function _ensureToolbarElement(name) {
      if (util$1.findChild(this, '.toolbar__' + name)) {
        var _element = util$1.findChild(this, '.toolbar__' + name);
        _element.classList.add(name);
        return _element;
      }

      var element = util$1.findChild(this, '.' + name) || util$1.create('.' + name);
      element.classList.add('toolbar__' + name);

      return element;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'];
    }
  }]);
  return ToolbarElement;
}(BaseElement);

onsElements.Toolbar = ToolbarElement;
customElements.define('ons-toolbar', ToolbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$9 = 'page';
var scheme$17 = {
  '': 'page--*',
  '.page__content': 'page--*__content',
  '.page__background': 'page--*__background'
};

/**
 * @element ons-page
 * @category page
 * @modifier material
 *   [en]Material Design style[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     This component defines the root of each page. If the content is large it will become scrollable.
 *
 *     A navigation bar can be added to the top of the page using the `<ons-toolbar>` element.
 *   [/en]
 *   [ja]ページ定義のためのコンポーネントです。このコンポーネントの内容はスクロールが許可されます。[/ja]
 * @tutorial vanilla/Reference/page
 * @guide lifecycle.html#events
 *   [en]Overview of page events[/en]
 *   [ja]Overview of page events[/ja]
 * @guide fundamentals.html#managing-pages
 *   [en]Managing multiple pages[/en]
 *   [ja]複数のページを管理する[/ja]
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-toolbar
 *   [en]Use the `<ons-toolbar>` element to add a navigation bar to the top of the page.[/en]
 *   [ja][/ja]
 * @example
 * <ons-page>
 *   <ons-toolbar>
 *     <div class="left">
 *       <ons-back-button>Back</ons-back-button>
 *     </div>
 *     <div class="center">Title</div>
 *     <div class="right">
 *       <ons-toolbar-button>
 *         <ons-icon icon="md-menu"></ons-icon>
 *       </ons-toolbar-button>
 *     </div>
 *   </ons-toolbar>
 *
 *   <p>Page content</p>
 * </ons-page>
 *
 * @example
 * <script>
 *   myApp.handler = function(done) {
 *     loadMore().then(done);
 *   }
 * </script>
 *
 * <ons-page on-infinite-scroll="myApp.handler">
 *   <ons-toolbar>
 *     <div class="center">List</div>
 *   </ons-toolbar>
 *
 *   <ons-list>
 *     <ons-list-item>#1</ons-list-item>
 *     <ons-list-item>#2</ons-list-item>
 *     <ons-list-item>#3</ons-list-item>
 *     ...
 *   </ons-list>
 * </ons-page>
 */

var PageElement = function (_BaseElement) {
  inherits(PageElement, _BaseElement);

  /**
   * @event init
   * @description
   *   [en]Fired right after the page is attached.[/en]
   *   [ja]ページがアタッチされた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @event show
   * @description
   *   [en]Fired right after the page is shown.[/en]
   *   [ja]ページが表示された後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @event hide
   * @description
   *   [en]Fired right after the page is hidden.[/en]
   *   [ja]ページが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @event destroy
   * @description
   *   [en]Fired right before the page is destroyed.[/en]
   *   [ja]ページが破棄される前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]Specify modifier name to specify custom styles.[/en]
   *   [ja]スタイル定義をカスタマイズするための名前を指定します。[/ja]
   */

  /**
   * @attribute on-infinite-scroll
   * @type {String}
   * @description
   *   [en]Path of the function to be executed on infinite scrolling. Example: `app.loadData`. The function receives a done callback that must be called when it's finished.[/en]
   *   [ja][/ja]
   */

  function PageElement() {
    classCallCheck(this, PageElement);

    var _this = possibleConstructorReturn(this, (PageElement.__proto__ || Object.getPrototypeOf(PageElement)).call(this));

    _this._deriveHooks();

    _this._defaultClassName = defaultClassName$9;
    _this.classList.add(defaultClassName$9);

    _this._initialized = false;

    contentReady(_this, function () {
      _this._compile();

      _this._isShown = false;
      _this._contentElement = _this._getContentElement();
      _this._backgroundElement = _this._getBackgroundElement();
    });
    return _this;
  }

  createClass(PageElement, [{
    key: '_compile',
    value: function _compile() {
      var _this2 = this;

      autoStyle.prepare(this);

      var toolbar = util$1.findChild(this, 'ons-toolbar');

      var background = util$1.findChild(this, '.page__background') || util$1.findChild(this, '.background') || document.createElement('div');
      background.classList.add('page__background');
      this.insertBefore(background, !toolbar && this.firstChild || toolbar && toolbar.nextSibling);

      var content = util$1.findChild(this, '.page__content') || util$1.findChild(this, '.content') || document.createElement('div');
      content.classList.add('page__content');
      if (!content.parentElement) {
        util$1.arrayFrom(this.childNodes).forEach(function (node) {
          if (node.nodeType !== 1 || _this2._elementShouldBeMoved(node)) {
            content.appendChild(node); // Can trigger detached connectedCallbacks
          }
        });
      }

      this._tryToFillStatusBar(content); // Must run before child pages try to fill status bar.
      this.insertBefore(content, background.nextSibling); // Can trigger attached connectedCallbacks

      if ((!toolbar || !util$1.hasModifier(toolbar, 'transparent')) && content.children.length === 1 && util$1.isPageControl(content.children[0])) {
        this._defaultClassName += ' page--wrapper';
        this.attributeChangedCallback('class');
      }

      ModifierUtil.initModifier(this, scheme$17);
    }
  }, {
    key: '_elementShouldBeMoved',
    value: function _elementShouldBeMoved(el) {
      if (el.classList.contains('page__background')) {
        return false;
      }
      var tagName = el.tagName.toLowerCase();
      if (tagName === 'ons-fab') {
        return !el.hasAttribute('position');
      }
      var fixedElements = ['script', 'ons-toolbar', 'ons-bottom-toolbar', 'ons-modal', 'ons-speed-dial', 'ons-dialog', 'ons-alert-dialog', 'ons-popover', 'ons-action-sheet'];
      return el.hasAttribute('inline') || fixedElements.indexOf(tagName) === -1;
    }
  }, {
    key: '_tryToFillStatusBar',
    value: function _tryToFillStatusBar() {
      var _this3 = this;

      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._contentElement;

      internal$1.autoStatusBarFill(function () {
        util$1.toggleAttribute(_this3, 'status-bar-fill', !util$1.findParent(_this3, function (e) {
          return e.hasAttribute('status-bar-fill');
        }) // Not already filled
        && (_this3._canAnimateToolbar(content) || !util$1.findChild(content, util$1.isPageControl)) // Has toolbar or cannot delegate
        );
      });
    }
  }, {
    key: '_canAnimateToolbar',
    value: function _canAnimateToolbar() {
      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._contentElement;

      if (util$1.findChild(this, 'ons-toolbar')) {
        return true;
      }

      return !!util$1.findChild(content, function (el) {
        return util$1.match(el, 'ons-toolbar') && !el.hasAttribute('inline');
      });
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      if (!util$1.isAttached(this)) {
        // Avoid detached calls
        return;
      }

      contentReady(this, function () {
        _this4._tryToFillStatusBar(); // Ensure status bar when the element was compiled before connected

        if (_this4.hasAttribute('on-infinite-scroll')) {
          _this4.attributeChangedCallback('on-infinite-scroll', null, _this4.getAttribute('on-infinite-scroll'));
        }

        if (!_this4._initialized) {
          _this4._initialized = true;

          setImmediate(function () {
            _this4.onInit && _this4.onInit();
            util$1.triggerElementEvent(_this4, 'init');
          });

          if (!util$1.hasAnyComponentAsParent(_this4)) {
            setImmediate(function () {
              return _this4._show();
            });
          }
        }
      });
    }
  }, {
    key: 'updateBackButton',
    value: function updateBackButton(show) {
      if (this.backButton) {
        show ? this.backButton.show() : this.backButton.hide();
      }
    }
  }, {
    key: '_onScroll',
    value: function _onScroll() {
      var _this5 = this;

      var c = this._contentElement,
          overLimit = (c.scrollTop + c.clientHeight) / c.scrollHeight >= this._infiniteScrollLimit;

      if (this._onInfiniteScroll && !this._loadingContent && overLimit) {
        this._loadingContent = true;
        this._onInfiniteScroll(function () {
          return _this5._loadingContent = false;
        });
      }
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_getContentElement',
    value: function _getContentElement() {
      var result = util$1.findChild(this, '.page__content');
      if (result) {
        return result;
      }
      util$1.throw('Fail to get ".page__content" element');
    }
  }, {
    key: '_getBackgroundElement',
    value: function _getBackgroundElement() {
      var result = util$1.findChild(this, '.page__background');
      if (result) {
        return result;
      }
      util$1.throw('Fail to get ".page__background" element');
    }
  }, {
    key: '_getBottomToolbarElement',
    value: function _getBottomToolbarElement() {
      return util$1.findChild(this, 'ons-bottom-toolbar') || internal$1.nullElement;
    }
  }, {
    key: '_getToolbarElement',
    value: function _getToolbarElement() {
      return util$1.findChild(this, 'ons-toolbar') || document.createElement('ons-toolbar');
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this6 = this;

      switch (name) {
        case 'class':
          util$1.restoreClass(this, this._defaultClassName, scheme$17);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$17);
          break;
        case 'on-infinite-scroll':
          if (current === null) {
            this.onInfiniteScroll = null;
          } else {
            this.onInfiniteScroll = function (done) {
              var f = util$1.findFromPath(current);
              _this6.onInfiniteScroll = f;
              f(done);
            };
          }
          break;
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this._isShown && util$1.isAttached(this)) {
        this._isShown = true;
        this.setAttribute('shown', '');
        this.onShow && this.onShow();
        util$1.triggerElementEvent(this, 'show');
        util$1.propagateAction(this, '_show');
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._isShown) {
        this._isShown = false;
        this.removeAttribute('shown');
        this.onHide && this.onHide();
        util$1.triggerElementEvent(this, 'hide');
        util$1.propagateAction(this, '_hide');
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this._hide();

      this.onDestroy && this.onDestroy();
      util$1.triggerElementEvent(this, 'destroy');

      if (this.onDeviceBackButton) {
        this.onDeviceBackButton.destroy();
      }

      util$1.propagateAction(this, '_destroy');

      this.remove();
    }
  }, {
    key: '_deriveHooks',
    value: function _deriveHooks() {
      var _this7 = this;

      this.constructor.events.forEach(function (event) {
        var key = 'on' + event.charAt(0).toUpperCase() + event.slice(1);
        Object.defineProperty(_this7, key, {
          configurable: true,
          enumerable: true,
          get: function get$$1() {
            return _this7['_' + key];
          },
          set: function set$$1(value) {
            if (!(value instanceof Function)) {
              util$1.throw('"' + key + '" hook must be a function');
            }
            _this7['_' + key] = value.bind(_this7);
          }
        });
      });
    }
  }, {
    key: 'name',
    set: function set$$1(str) {
      this.setAttribute('name', str);
    },
    get: function get$$1() {
      return this.getAttribute('name');
    }
  }, {
    key: 'backButton',
    get: function get$$1() {
      return this.querySelector('ons-back-button');
    }

    /**
     * @property onInfiniteScroll
     * @description
     *  [en]Function to be executed when scrolling to the bottom of the page. The function receives a done callback as an argument that must be called when it's finished.[/en]
     *  [ja][/ja]
     */

  }, {
    key: 'onInfiniteScroll',
    set: function set$$1(value) {
      var _this8 = this;

      if (value && !(value instanceof Function)) {
        util$1.throw('"onInfiniteScroll" must be function or null');
      }

      contentReady(this, function () {
        if (!value) {
          _this8._contentElement.removeEventListener('scroll', _this8._boundOnScroll);
        } else if (!_this8._onInfiniteScroll) {
          _this8._infiniteScrollLimit = 0.9;
          _this8._boundOnScroll = _this8._onScroll.bind(_this8);
          setImmediate(function () {
            return _this8._contentElement.addEventListener('scroll', _this8._boundOnScroll);
          });
        }
        _this8._onInfiniteScroll = value;
      });
    },
    get: function get$$1() {
      return this._onInfiniteScroll;
    }
  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }, {
    key: 'scrollTop',
    get: function get$$1() {
      return this._contentElement.scrollTop;
    },
    set: function set$$1(newValue) {
      this._contentElement.scrollTop = newValue;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'on-infinite-scroll', 'class'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['init', 'show', 'hide', 'destroy'];
    }

    /**
     * @property data
     * @type {*}
     * @description
     *   [en]User's custom data passed to `pushPage()`-like methods.[/en]
     *   [ja][/ja]
     */

  }]);
  return PageElement;
}(BaseElement);

onsElements.Page = PageElement;
customElements.define('ons-page', PageElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/
var PopoverAnimator = function (_BaseAnimator) {
  inherits(PopoverAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function PopoverAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .4, 1)' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, PopoverAnimator);
    return possibleConstructorReturn(this, (PopoverAnimator.__proto__ || Object.getPrototypeOf(PopoverAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  createClass(PopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      callback();
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      callback();
    }
  }, {
    key: '_animate',
    value: function _animate(element, _ref2) {
      var from = _ref2.from,
          to = _ref2.to,
          options = _ref2.options,
          callback = _ref2.callback,
          _ref2$restore = _ref2.restore,
          restore = _ref2$restore === undefined ? false : _ref2$restore,
          animation = _ref2.animation;

      options = util$1.extend({}, this.options, options);

      if (animation) {
        from = animation.from;
        to = animation.to;
      }

      animation = Animit(element);
      if (restore) {
        animation = animation.saveStyle();
      }
      animation = animation.queue(from).wait(this.delay).queue({
        css: to,
        duration: this.duration,
        timing: this.timing
      });
      if (restore) {
        animation = animation.restoreStyle();
      }
      if (callback) {
        animation = animation.queue(function (done) {
          callback();
          done();
        });
      }
      return animation;
    }
  }, {
    key: '_animateAll',
    value: function _animateAll(element, animations) {
      var _this2 = this;

      Object.keys(animations).forEach(function (key) {
        return _this2._animate(element[key], animations[key]).play();
      });
    }
  }]);
  return PopoverAnimator;
}(BaseAnimator);

var fade = {
  out: {
    from: { opacity: 1.0 },
    to: { opacity: 0 }
  },
  in: {
    from: { opacity: 0 },
    to: { opacity: 1.0 }
  }
};

var MDFadePopoverAnimator = function (_PopoverAnimator) {
  inherits(MDFadePopoverAnimator, _PopoverAnimator);

  function MDFadePopoverAnimator() {
    classCallCheck(this, MDFadePopoverAnimator);
    return possibleConstructorReturn(this, (MDFadePopoverAnimator.__proto__ || Object.getPrototypeOf(MDFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(MDFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade.in,
        _popover: { animation: fade.in, restore: true, callback: callback }
      });
    }
  }, {
    key: 'hide',
    value: function hide(popover, callback) {
      this._animateAll(popover, {
        _mask: fade.out,
        _popover: { animation: fade.out, restore: true, callback: callback }
      });
    }
  }]);
  return MDFadePopoverAnimator;
}(PopoverAnimator);

var IOSFadePopoverAnimator = function (_MDFadePopoverAnimato) {
  inherits(IOSFadePopoverAnimator, _MDFadePopoverAnimato);

  function IOSFadePopoverAnimator() {
    classCallCheck(this, IOSFadePopoverAnimator);
    return possibleConstructorReturn(this, (IOSFadePopoverAnimator.__proto__ || Object.getPrototypeOf(IOSFadePopoverAnimator)).apply(this, arguments));
  }

  createClass(IOSFadePopoverAnimator, [{
    key: 'show',
    value: function show(popover, callback) {
      this._animateAll(popover, {
        _mask: fade.in,
        _popover: {
          from: {
            transform: 'scale3d(1.3, 1.3, 1.0)',
            opacity: 0
          },
          to: {
            transform: 'scale3d(1.0, 1.0,  1.0)',
            opacity: 1.0
          },
          restore: true,
          callback: callback
        }
      });
    }
  }]);
  return IOSFadePopoverAnimator;
}(MDFadePopoverAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$19 = {
  '.popover': 'popover--*',
  '.popover-mask': 'popover-mask--*',
  '.popover__content': 'popover--*__content',
  '.popover__arrow': 'popover--*__arrow'
};

var _animatorDict$6 = {
  'default': function _default() {
    return platform.isAndroid() ? MDFadePopoverAnimator : IOSFadePopoverAnimator;
  },
  'none': PopoverAnimator,
  'fade-ios': IOSFadePopoverAnimator,
  'fade-md': MDFadePopoverAnimator
};

var positions = {
  up: 'bottom',
  left: 'right',
  down: 'top',
  right: 'left'
};

/**
 * @element ons-popover
 * @category dialog
 * @description
 *  [en]
 *    A component that displays a popover next to an element. The popover can be used to display extra information about a component or a tooltip.
 *
 *    To use the element it can either be attached directly to the `<body>` element or dynamically created from a template using the `ons.createPopover(template)` utility function and the `<template>` tag.
 *
 *    Another common way to use the popover is to display a menu when a button on the screen is tapped. For Material Design, popover looks exactly as a dropdown menu.
 *  [/en]
 *  [ja]ある要素を対象とするポップオーバーを表示するコンポーネントです。[/ja]
 * @codepen ZYYRKo
 * @tutorial vanilla/Reference/popover
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-button onclick="showPopover(this)">
 *   Click me!
 * </ons-button>
 *
 * <ons-popover direction="down" id="popover">
 *   <p>This is a popover!</p>
 * </ons-popover>
 *
 * <script>
 *   var showPopover = function(element) {
 *     var popover = document.getElementById('popover');
 *     popover.show(element);
 *   };
 * </script>
 */

var PopoverElement = function (_BaseDialogElement) {
  inherits(PopoverElement, _BaseDialogElement);

  /**
   * @event preshow
   * @description
   *   [en]Fired just before the popover is displayed.[/en]
   *   [ja]ポップオーバーが表示される直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call this function to stop the popover from being shown.[/en]
   *   [ja]この関数を呼び出すと、ポップオーバーの表示がキャンセルされます。[/ja]
   */

  /**
   * @event postshow
   * @description
   *   [en]Fired just after the popover is displayed.[/en]
   *   [ja]ポップオーバーが表示された直後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event prehide
   * @description
   *   [en]Fired just before the popover is hidden.[/en]
   *   [ja]ポップオーバーが隠れる直前に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call this function to stop the popover from being hidden.[/en]
   *   [ja]この関数を呼び出すと、ポップオーバーが隠れる処理をキャンセルします。[/ja]
   */

  /**
   * @event posthide
   * @description
   *   [en]Fired just after the popover is hidden.[/en]
   *   [ja]ポップオーバーが隠れた後に発火します。[/ja]
   * @param {Object} event [en]Event object.[/en]
   * @param {Object} event.popover
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the popover.[/en]
   *  [ja]ポップオーバーの表現を指定します。[/ja]
   */

  /**
   * @attribute direction
   * @type {String}
   * @description
   *  [en]
   *    A space separated list of directions. If more than one direction is specified,
   *    it will be chosen automatically. Valid directions are `"up"`, `"down"`, `"left"` and `"right"`.
   *  [/en]
   *  [ja]
   *    ポップオーバーを表示する方向を空白区切りで複数指定できます。
   *    指定できる方向は、"up", "down", "left", "right"の4つです。空白区切りで複数指定することもできます。
   *    複数指定された場合、対象とする要素に合わせて指定した値から自動的に選択されます。
   *  [/ja]
   */

  /**
   * @attribute cancelable
   * @description
   *   [en]If this attribute is set the popover can be closed by tapping the background or by pressing the back button.[/en]
   *   [ja]この属性があると、ポップオーバーが表示された時に、背景やバックボタンをタップした時にをポップオーバー閉じます。[/ja]
   */

  /**
   * @attribute cover-target
   * @description
   *   [en]If set the popover will cover the target on the screen.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @description
   *   [en]The animation used when showing an hiding the popover. Can be either `"none"`, `"default"`, `"fade-ios"` or `"fade-md"`.[/en]
   *   [ja]ポップオーバーを表示する際のアニメーション名を指定します。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute mask-color
   * @type {Color}
   * @description
   *   [en]Color of the background mask. Default is `"rgba(0, 0, 0, 0.2)"`.[/en]
   *   [ja]背景のマスクの色を指定します。デフォルトは"rgba(0, 0, 0, 0.2)"です。[/ja]
   */

  function PopoverElement() {
    classCallCheck(this, PopoverElement);

    var _this = possibleConstructorReturn(this, (PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement)).call(this));

    _this._boundOnChange = _this._onChange.bind(_this);

    contentReady(_this, function () {
      _this._compile();
      _this.style.display = 'none';
    });
    return _this;
  }

  createClass(PopoverElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      return new AnimatorFactory({
        animators: _animatorDict$6,
        baseClass: PopoverAnimator,
        baseClassName: 'PopoverAnimator',
        defaultAnimation: this.getAttribute('animation') || 'default'
      });
    }
  }, {
    key: '_toggleStyle',
    value: function _toggleStyle(shouldShow) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (shouldShow) {
        this.style.display = 'block';
        this._currentTarget = options.target;
        this._positionPopover(options.target);
      } else {
        this.style.display = 'none';
        this._clearStyles();
      }
    }
  }, {
    key: '_positionPopover',
    value: function _positionPopover(target) {
      var radius = this._radius,
          contentElement = this._content,
          margin = this._margin;

      var safeAreaLengths = iPhoneXPatch.getSafeAreaLengths();
      var safeAreaRect = iPhoneXPatch.getSafeAreaDOMRect();
      var targetRect = target.getBoundingClientRect();
      var isMD = util$1.hasModifier(this, 'material');
      var cover = isMD && this.hasAttribute('cover-target');
      var parent = util$1.findParent(this, 'ons-page') || document.body;
      var parentDimensions = parent.getBoundingClientRect();
      var maxPositions = {
        top: Math.max(parentDimensions.top, safeAreaRect.top),
        left: Math.max(parentDimensions.left, safeAreaRect.left),
        bottom: Math.min(parentDimensions.bottom, safeAreaRect.bottom),
        right: Math.min(parentDimensions.right, safeAreaRect.right)
      };

      // Distance from each side of the safe area (with margin) to the target element
      var targetDistance = {
        top: targetRect.top - (maxPositions.top + margin),
        left: targetRect.left - (maxPositions.left + margin),
        bottom: maxPositions.bottom - margin - targetRect.bottom,
        right: maxPositions.right - margin - targetRect.right
      };

      // Distance from each side of the safe area (with margin) to the geometric center of the target element
      var targetCenterDistanceFrom = {
        top: targetRect.top + Math.round(targetRect.height / 2) - (maxPositions.top + margin),
        left: targetRect.left + Math.round(targetRect.width / 2) - (maxPositions.left + margin),
        bottom: maxPositions.bottom - margin - targetRect.bottom + Math.round(targetRect.height / 2),
        right: maxPositions.right - margin - targetRect.right + Math.round(targetRect.width / 2)
      };

      var _calculateDirections2 = this._calculateDirections(targetDistance),
          vertical = _calculateDirections2.vertical,
          primaryDirection = _calculateDirections2.primary,
          secondaryDirection = _calculateDirections2.secondary;

      this._currentDirection = primaryDirection;
      util$1.addModifier(this, primaryDirection);

      var sizeName = vertical ? 'width' : 'height';
      // Get .popover__content size
      var contentSize = function (style) {
        return {
          width: parseInt(style.getPropertyValue('width'), 10),
          height: parseInt(style.getPropertyValue('height'), 10)
        };
      }(window.getComputedStyle(contentElement));

      // Setting .popover position.
      var targetAndArrowLength = cover ? 0 : (vertical ? targetRect.height : targetRect.width) + (isMD ? 0 : 14);
      var primaryOffset = Math.max(safeAreaLengths[primaryDirection] + margin, safeAreaLengths[primaryDirection] + margin + targetDistance[primaryDirection] + targetAndArrowLength);
      var secondaryOffset = Math.max(safeAreaLengths[secondaryDirection] + margin, safeAreaLengths[secondaryDirection] + margin + targetCenterDistanceFrom[secondaryDirection] - contentSize[sizeName] / 2);
      this._popover.style[primaryDirection] = primaryOffset + 'px';
      this._popover.style[secondaryDirection] = secondaryOffset + 'px';

      // Setting .popover__arrow position.
      this._arrow.style[secondaryDirection] = Math.max(radius, safeAreaLengths[secondaryDirection] + margin + targetCenterDistanceFrom[secondaryDirection] - secondaryOffset) + 'px';
    }
  }, {
    key: '_calculateDirections',
    value: function _calculateDirections(distance) {
      var options = (this.getAttribute('direction') || 'up down left right').split(/\s+/).map(function (e) {
        return positions[e];
      });
      var primary = options.sort(function (a, b) {
        return distance[a] - distance[b];
      })[0];
      var vertical = 'top' == primary || 'bottom' == primary;
      var secondary = void 0;

      if (vertical) {
        secondary = distance.left < distance.right ? 'left' : 'right';
      } else {
        secondary = distance.top < distance.bottom ? 'top' : 'bottom';
      }

      return { vertical: vertical, primary: primary, secondary: secondary };
    }
  }, {
    key: '_clearStyles',
    value: function _clearStyles() {
      var _this2 = this;

      this._currentDirection = null;
      ['top', 'bottom', 'left', 'right'].forEach(function (e) {
        _this2._arrow.style[e] = _this2._content.style[e] = _this2._popover.style[e] = '';
        util$1.removeModifier(_this2, e);
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange() {
      var _this3 = this;

      setImmediate(function () {
        if (_this3._currentTarget) {
          _this3._positionPopover(_this3._currentTarget);
        }
      });
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      if (this._popover && this._mask) {
        return;
      }

      var hasDefaultContainer = this._popover && this._content;

      if (hasDefaultContainer) {

        if (!this._mask) {
          var mask = document.createElement('div');
          mask.classList.add('popover-mask');
          this.insertBefore(mask, this.firstChild);
        }

        if (!this._arrow) {
          var arrow = document.createElement('div');
          arrow.classList.add('popover__arrow');
          this._popover.appendChild(arrow);
        }
      } else {

        var template = util$1.createFragment('\n        <div class="popover-mask"></div>\n        <div class="popover">\n          <div class="popover__content"></div>\n          <div class="popover__arrow"></div>\n        </div>\n      ');
        var content = template.querySelector('.popover__content');

        while (this.childNodes[0]) {
          content.appendChild(this.childNodes[0]);
        }

        this.appendChild(template);
      }

      // FIXME!
      if (this.hasAttribute('style')) {
        this._popover.setAttribute('style', this.getAttribute('style'));
        this.removeAttribute('style');
      }

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @method show
     * @signature show(target, [options])
     * @param {String|Event|HTMLElement} target
     *   [en]Target element. Can be either a CSS selector, an event object or a DOM element. It can be also provided as 'options.target' instead. [/en]
     *   [ja]ポップオーバーのターゲットとなる要素を指定します。CSSセレクタかeventオブジェクトかDOM要素のいずれかを渡せます。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This function is called after the popover has been revealed.[/en]
     *   [ja]ポップオーバーが表示され終わった後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Open the popover and point it at a target. The target can be either an event, a CSS selector or a DOM element..[/en]
     *   [ja]対象とする要素にポップオーバーを表示します。target引数には、$eventオブジェクトやDOMエレメントやCSSセレクタを渡すことが出来ます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'show',
    value: function show(target) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Copy options and include options.target
      if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && !(target instanceof Event) && !(target instanceof HTMLElement)) {
        options = _extends({}, target);
      } else {
        options = _extends({}, options, { target: target });
      }

      if (typeof options.target === 'string') {
        options.target = document.querySelector(options.target);
      } else if (options.target instanceof Event) {
        options.target = options.target.target;
      }

      if (!(options.target instanceof HTMLElement)) {
        util$1.throw('Invalid target type or undefined');
      }

      return get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'show', this).call(this, options);
    }

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name.  Use one of `"fade-ios"`, `"fade-md"`, `"none"` and `"default"`.[/en]
     *   [ja]アニメーション名を指定します。"fade-ios", "fade-md", "none", "default"のいずれかを指定できます。[/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @param {Function} [options.callback]
     *   [en]This functions is called after the popover has been hidden.[/en]
     *   [ja]ポップオーバーが隠れた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Close the popover.[/en]
     *   [ja]ポップオーバーを閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @property cancelable
     * @type {Boolean}
     * @description
     *   [en]
     *     A boolean value that specifies whether the popover is cancelable or not.
     *
     *     When the popover is cancelable it can be closed by tapping the background or by pressing the back button on Android devices.
     *   [/en]
     *   [ja][/ja]
     */

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'connectedCallback', this).call(this);

      window.addEventListener('resize', this._boundOnChange, false);
      this._margin = this._margin || parseInt(window.getComputedStyle(this).getPropertyValue('top'));
      this._margin = this._margin || 6; // Fix for iframes

      contentReady(this, function () {
        _this4._radius = parseInt(window.getComputedStyle(_this4._content).getPropertyValue('border-top-left-radius'));
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'disconnectedCallback', this).call(this);
      window.removeEventListener('resize', this._boundOnChange, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'direction') {
        return this._boundOnChange();
      } else if (name === 'modifier') {
        this._currentDirection && util$1.addModifier(this, this._currentDirection);
      }
      get(PopoverElement.prototype.__proto__ || Object.getPrototypeOf(PopoverElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
    }

    /**
     * @param {String} name
     * @param {PopoverAnimator} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$19;
    }
  }, {
    key: '_mask',
    get: function get$$1() {
      return util$1.findChild(this, '.popover-mask');
    }
  }, {
    key: '_popover',
    get: function get$$1() {
      return util$1.findChild(this, '.popover');
    }
  }, {
    key: '_content',
    get: function get$$1() {
      return util$1.findChild(this._popover, '.popover__content');
    }
  }, {
    key: '_arrow',
    get: function get$$1() {
      return util$1.findChild(this._popover, '.popover__arrow');
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof PopoverAnimator)) {
        util$1.throwAnimator('Popover');
      }
      _animatorDict$6[name] = Animator;
    }
  }, {
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(PopoverElement.__proto__ || Object.getPrototypeOf(PopoverElement), 'observedAttributes', this)), ['direction']);
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$6;
    }
  }, {
    key: 'PopoverAnimator',
    get: function get$$1() {
      return PopoverAnimator;
    }
  }]);
  return PopoverElement;
}(BaseDialogElement);

onsElements.Popover = PopoverElement;
customElements.define('ons-popover', PopoverElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$20 = {
  '.progress-bar': 'progress-bar--*',
  '.progress-bar__primary': 'progress-bar--*__primary',
  '.progress-bar__secondary': 'progress-bar--*__secondary'
};

var template = util$1.createElement('\n  <div class="progress-bar">\n    <div class="progress-bar__secondary"></div>\n    <div class="progress-bar__primary"></div>\n  </div>\n');

var INDET = 'indeterminate';

/**
 * @element ons-progress-bar
 * @category visual
 * @modifier material
 *   [en]Display a Material Design progress bar.[/en]
 *   [ja]マテリアルデザインのスタイルでプログレスバーを表示します。[/ja]
 * @description
 *   [en]
 *     The component is used to display a linear progress bar. It can either display a progress bar that shows the user how much of a task has been completed. In the case where the percentage is not known it can be used to display an animated progress bar so the user can see that an operation is in progress.
 *   [/en]
 *   [ja][/ja]
 * @codepen zvQbGj
 * @tutorial vanilla/Reference/progress
 * @seealso ons-progress-circular
 *   [en]The `<ons-progress-circular>` component displays a circular progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-bar
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-bar>
 *
 * <ons-progress-bar
 *  indeterminate>
 * </ons-progress-bar>
 */

var ProgressBarElement = function (_BaseElement) {
  inherits(ProgressBarElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]Change the appearance of the progress indicator.[/en]
   *   [ja]プログレスインジケータの見た目を変更します。[/ja]
   */

  /**
   * @attribute value
   * @type {Number}
   * @description
   *   [en]Current progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute secondary-value
   * @type {Number}
   * @description
   *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute indeterminate
   * @description
   *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
   *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
   */

  function ProgressBarElement() {
    classCallCheck(this, ProgressBarElement);

    var _this = possibleConstructorReturn(this, (ProgressBarElement.__proto__ || Object.getPrototypeOf(ProgressBarElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ProgressBarElement, [{
    key: '_compile',
    value: function _compile() {
      if (!this._isCompiled()) {
        this._template = template.cloneNode(true);
      } else {
        this._template = util$1.findChild(this, '.progress-bar');
      }

      this._primary = util$1.findChild(this._template, '.progress-bar__primary');
      this._secondary = util$1.findChild(this._template, '.progress-bar__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      autoStyle.prepare(this);
      ModifierUtil.initModifier(this, scheme$20);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util$1.findChild(this, '.progress-bar')) {
        return false;
      }

      var barElement = util$1.findChild(this, '.progress-bar');

      if (!util$1.findChild(barElement, '.progress-bar__secondary')) {
        return false;
      }

      if (!util$1.findChild(barElement, '.progress-bar__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$20);
        this.hasAttribute(INDET) && this._updateDeterminate();
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === INDET) {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this2 = this;

      contentReady(this, function () {
        return util$1.toggleModifier(_this2, INDET, { force: _this2.hasAttribute(INDET) });
      });
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._primary.style.width = _this3.hasAttribute('value') ? _this3.getAttribute('value') + '%' : '0%';
        _this3._secondary.style.width = _this3.hasAttribute('secondary-value') ? _this3.getAttribute('secondary-value') + '%' : '0%';
      });
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'value',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        util$1.throw('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        util$1.throw('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set$$1(value) {
      if (value) {
        this.setAttribute(INDET, '');
      } else {
        this.removeAttribute(INDET);
      }
    },
    get: function get$$1() {
      return this.hasAttribute(INDET);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'value', 'secondary-value', INDET];
    }
  }]);
  return ProgressBarElement;
}(BaseElement);

onsElements.ProgressBar = ProgressBarElement;
customElements.define('ons-progress-bar', ProgressBarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$21 = {
  '.progress-circular': 'progress-circular--*',
  '.progress-circular__background': 'progress-circular--*__background',
  '.progress-circular__primary': 'progress-circular--*__primary',
  '.progress-circular__secondary': 'progress-circular--*__secondary'
};

var template$1 = util$1.createElement('\n  <svg class="progress-circular">\n    <circle class="progress-circular__background" />\n    <circle class="progress-circular__secondary" cx="50%" cy="50%" r="40%" />\n    <circle class="progress-circular__primary" cx="50%" cy="50%" r="40%" />\n  </svg>\n');

var INDET$1 = 'indeterminate';

/**
 * @element ons-progress-circular
 * @category visual
 * @description
 *   [en]
 *     This component displays a circular progress indicator. It can either be used to show how much of a task has been completed or to show a looping animation to indicate that an operation is currently running.
 *   [/en]
 *   [ja][/ja]
 * @codepen EVzMjR
 * @tutorial vanilla/Reference/progress-circular
 * @seealso ons-progress-bar
 *   [en]The `<ons-progress-bar>` component displays a bar progress indicator.[/en]
 *   [ja][/ja]
 * @example
 * <ons-progress-circular
 *  value="55"
 *  secondary-value="87">
 * </ons-progress-circular>
 *
 * <ons-progress-circular
 *  indeterminate>
 * </ons-progress-circular>
 */

var ProgressCircularElement = function (_BaseElement) {
  inherits(ProgressCircularElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]Change the appearance of the progress indicator.[/en]
   *   [ja]プログレスインジケータの見た目を変更します。[/ja]
   */

  /**
   * @attribute value
   * @type {Number}
   * @description
   *   [en]Current progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute secondary-value
   * @type {Number}
   * @description
   *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
   *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
   */

  /**
   * @attribute indeterminate
   * @description
   *   [en]If this attribute is set, an infinite looping animation will be shown.[/en]
   *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
   */

  function ProgressCircularElement() {
    classCallCheck(this, ProgressCircularElement);

    var _this = possibleConstructorReturn(this, (ProgressCircularElement.__proto__ || Object.getPrototypeOf(ProgressCircularElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ProgressCircularElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$21);
        this.hasAttribute(INDET$1) && this._updateDeterminate();
      } else if (name === 'value' || name === 'secondary-value') {
        this._updateValue();
      } else if (name === INDET$1) {
        this._updateDeterminate();
      }
    }
  }, {
    key: '_updateDeterminate',
    value: function _updateDeterminate() {
      var _this2 = this;

      contentReady(this, function () {
        return util$1.toggleModifier(_this2, INDET$1, { force: _this2.hasAttribute(INDET$1) });
      });
    }
  }, {
    key: '_updateValue',
    value: function _updateValue() {
      var _this3 = this;

      if (this.hasAttribute('value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this3.getAttribute('value') * 251.32 * 0.01);
          _this3._primary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      }
      if (this.hasAttribute('secondary-value')) {
        contentReady(this, function () {
          var per = Math.ceil(_this3.getAttribute('secondary-value') * 251.32 * 0.01);
          _this3._secondary.style.display = null;
          _this3._secondary.style['stroke-dasharray'] = per + '%, 251.32%';
        });
      } else {
        contentReady(this, function () {
          _this3._secondary.style.display = 'none';
        });
      }
    }

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      if (this._isCompiled()) {
        this._template = util$1.findChild(this, '.progress-circular');
      } else {
        this._template = template$1.cloneNode(true);
      }

      this._primary = util$1.findChild(this._template, '.progress-circular__primary');
      this._secondary = util$1.findChild(this._template, '.progress-circular__secondary');

      this._updateDeterminate();
      this._updateValue();

      this.appendChild(this._template);

      autoStyle.prepare(this);
      ModifierUtil.initModifier(this, scheme$21);
    }
  }, {
    key: '_isCompiled',
    value: function _isCompiled() {
      if (!util$1.findChild(this, '.progress-circular')) {
        return false;
      }

      var svg = util$1.findChild(this, '.progress-circular');

      if (!util$1.findChild(svg, '.progress-circular__secondary')) {
        return false;
      }

      if (!util$1.findChild(svg, '.progress-circular__primary')) {
        return false;
      }

      return true;
    }
  }, {
    key: 'value',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        util$1.throw('Invalid value');
      }

      this.setAttribute('value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('value') || '0');
    }

    /**
     * @property secondaryValue
     * @type {Number}
     * @description
     *   [en]Current secondary progress. Should be a value between 0 and 100.[/en]
     *   [ja]現在の２番目の進行状況の値を指定します。0から100の間の値を指定して下さい。[/ja]
     */

  }, {
    key: 'secondaryValue',
    set: function set$$1(value) {
      if (typeof value !== 'number' || value < 0 || value > 100) {
        util$1.throw('Invalid value');
      }

      this.setAttribute('secondary-value', Math.floor(value));
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('secondary-value') || '0');
    }

    /**
     * @property indeterminate
     * @type {Boolean}
     * @description
     *   [en]If this property is `true`, an infinite looping animation will be shown.[/en]
     *   [ja]この属性が設定された場合、ループするアニメーションが表示されます。[/ja]
     */

  }, {
    key: 'indeterminate',
    set: function set$$1(value) {
      if (value) {
        this.setAttribute(INDET$1, '');
      } else {
        this.removeAttribute(INDET$1);
      }
    },
    get: function get$$1() {
      return this.hasAttribute(INDET$1);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'value', 'secondary-value', INDET$1];
    }
  }]);
  return ProgressCircularElement;
}(BaseElement);

onsElements.ProgressCircular = ProgressCircularElement;
customElements.define('ons-progress-circular', ProgressCircularElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var STATE_INITIAL = 'initial';
var STATE_PREACTION = 'preaction';
var STATE_ACTION = 'action';

var throwType = function throwType(el, type) {
  return util$1.throw('"' + el + '" must be ' + type);
};

/**
 * @element ons-pull-hook
 * @category control
 * @description
 *   [en]
 *     Component that adds **Pull to refresh** functionality to an `<ons-page>` element.
 *
 *     It can be used to perform a task when the user pulls down at the top of the page. A common usage is to refresh the data displayed in a page.
 *   [/en]
 *   [ja][/ja]
 * @codepen WbJogM
 * @tutorial vanilla/Reference/pull-hook
 * @example
 * <ons-page>
 *   <ons-pull-hook>
 *     Release to refresh
 *   </ons-pull-hook>
 * </ons-page>
 *
 * <script>
 *   document.querySelector('ons-pull-hook').onAction = function(done) {
 *     setTimeout(done, 1000);
 *   };
 * </script>
 */

var PullHookElement = function (_BaseElement) {
  inherits(PullHookElement, _BaseElement);

  /**
   * @event changestate
   * @description
   *   [en]Fired when the state is changed. The state can be either "initial", "preaction" or "action".[/en]
   *   [ja]コンポーネントの状態が変わった場合に発火します。状態は、"initial", "preaction", "action"のいずれかです。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Object} event.pullHook
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {String} event.state
   *   [en]Current state.[/en]
   *   [ja]現在の状態名を参照できます。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]If this attribute is set the "pull-to-refresh" functionality is disabled.[/en]
   *   [ja]この属性がある時、disabled状態になりアクションが実行されなくなります[/ja]
   */

  /**
   * @attribute height
   * @type {String}
   * @description
   *   [en]Specify the height of the component. When pulled down further than this value it will switch to the "preaction" state. The default value is "64px".[/en]
   *   [ja]コンポーネントの高さを指定します。この高さ以上にpull downすると"preaction"状態に移行します。デフォルトの値は"64px"です。[/ja]
   */

  /**
   * @attribute threshold-height
   * @type {String}
   * @description
   *   [en]Specify the threshold height. The component automatically switches to the "action" state when pulled further than this value. The default value is "96px". A negative value will disable this property. If this value is lower than the height, it will skip "preaction" state.[/en]
   *   [ja]閾値となる高さを指定します。この値で指定した高さよりもpull downすると、このコンポーネントは自動的に"action"状態に移行します。[/ja]
   */

  /**
   * @attribute fixed-content
   * @description
   *   [en]If this attribute is set the content of the page will not move when pulling.[/en]
   *   [ja]この属性がある時、プルフックが引き出されている時にもコンテンツは動きません。[/ja]
   */

  function PullHookElement() {
    classCallCheck(this, PullHookElement);

    var _this = possibleConstructorReturn(this, (PullHookElement.__proto__ || Object.getPrototypeOf(PullHookElement)).call(this));

    _this._shouldFixScroll = util$1.globals.isUIWebView;

    _this._onDrag = _this._onDrag.bind(_this);
    _this._onDragStart = _this._onDragStart.bind(_this);
    _this._onDragEnd = _this._onDragEnd.bind(_this);
    _this._onScroll = _this._onScroll.bind(_this);

    _this._setState(STATE_INITIAL, true);
    _this._hide(); // Fix for transparent toolbar transitions
    return _this;
  }

  createClass(PullHookElement, [{
    key: '_setStyle',
    value: function _setStyle() {
      var height = this.height + 'px';
      styler(this, { height: height, lineHeight: height });
      this.style.display === '' && this._show();
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(event) {
      var element = this._pageElement;

      if (element.scrollTop < 0) {
        element.scrollTop = 0;
      }
    }
  }, {
    key: '_canConsumeGesture',
    value: function _canConsumeGesture(gesture) {
      return gesture.direction === 'up' || gesture.direction === 'down';
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(event) {
      var _this2 = this;

      if (!event.gesture || this.disabled) {
        return;
      }

      var tapY = event.gesture.center.clientY + this._pageElement.scrollTop;
      var maxY = window.innerHeight;
      // Only use drags that start near the pullHook to reduce flickerings
      var draggableAreaRatio = this._shouldFixScroll ? .8 : 1;

      this._ignoreDrag = event.consumed || tapY > maxY * draggableAreaRatio;

      if (!this._ignoreDrag) {
        var consume = event.consume;
        event.consume = function () {
          consume && consume();
          _this2._ignoreDrag = true;
          // This elements resizes .page__content so it is safer
          // to hide it when other components are dragged.
          _this2._hide();
        };

        if (this._canConsumeGesture(event.gesture)) {
          consume && consume();
          event.consumed = true;
          this._show(); // Not enough due to 'dragLockAxis'
        }
      }

      this._startScroll = this._pageElement.scrollTop;
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(event) {
      var _this3 = this;

      if (!event.gesture || this.disabled || this._ignoreDrag || !this._canConsumeGesture(event.gesture)) {
        return;
      }

      // Necessary due to 'dragLockAxis' (25px)
      if (this.style.display === 'none') {
        this._show();
      }

      event.stopPropagation();

      var tapY = event.gesture.center.clientY + this._pageElement.scrollTop;
      var maxY = window.innerHeight;

      // Hack to make it work on Android 4.4 WebView and iOS UIWebView. Scrolls manually
      // near the top of the page so there will be no inertial scroll when scrolling down.
      // Allowing default scrolling will kill all 'touchmove' events.
      if (this._shouldFixScroll) {
        this._pageElement.scrollTop = this._startScroll - event.gesture.deltaY;
        // Allow inertia when scrolling down below 50% of the view to reduce flickerings
        if (event.gesture.interimDirection !== 'up' || tapY <= maxY * .5) {
          event.gesture.preventDefault();
        }
      }

      var scroll = Math.max(event.gesture.deltaY - this._startScroll, 0);
      if (scroll !== this._currentTranslation) {

        var th = this.thresholdHeight;
        if (th > 0 && scroll >= th) {
          event.gesture.stopDetect();
          setImmediate(function () {
            return _this3._finish();
          });
        } else if (scroll >= this.height) {
          this._setState(STATE_PREACTION);
        } else {
          this._setState(STATE_INITIAL);
        }

        this._translateTo(scroll);
      }
    }
  }, {
    key: '_onDragEnd',
    value: function _onDragEnd(event) {
      if (!event.gesture || this.disabled || this._ignoreDrag) {
        return;
      }

      event.stopPropagation();

      if (this._currentTranslation > 0) {
        var scroll = this._currentTranslation;

        if (scroll > this.height) {
          this._finish();
        } else {
          this._translateTo(0, { animate: true });
        }
      }
    }

    /**
     * @property onAction
     * @type {Function}
     * @description
     *   [en]This will be called in the `action` state if it exists. The function will be given a `done` callback as it's first argument.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_finish',
    value: function _finish() {
      var _this4 = this;

      this._setState(STATE_ACTION);
      this._translateTo(this.height, { animate: true });
      var action = this.onAction || function (done) {
        return done();
      };
      action(function () {
        _this4._translateTo(0, { animate: true });
        _this4._setState(STATE_INITIAL);
      });
    }

    /**
     * @property height
     * @type {Number}
     * @description
     *   [en]The height of the pull hook in pixels. The default value is `64px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_setState',
    value: function _setState(state, noEvent) {
      var lastState = this.state;

      this.setAttribute('state', state);

      if (!noEvent && lastState !== this.state) {
        util$1.triggerElementEvent(this, 'changestate', {
          pullHook: this,
          state: state,
          lastState: lastState
        });
      }
    }

    /**
     * @property state
     * @readonly
     * @type {String}
     * @description
     *   [en]Current state of the element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_show',
    value: function _show() {
      var _this5 = this;

      // Run asyncrhonously to avoid conflicts with Animit's style clean
      setImmediate(function () {
        _this5.style.display = '';
        if (_this5._pageElement) {
          _this5._pageElement.style.marginTop = '-' + _this5.height + 'px';
        }
      });
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this.style.display = 'none';
      if (this._pageElement) {
        this._pageElement.style.marginTop = '';
      }
    }

    /**
     * @param {Number} scroll
     * @param {Object} options
     * @param {Function} [options.callback]
     */

  }, {
    key: '_translateTo',
    value: function _translateTo(scroll) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this._currentTranslation == 0 && scroll == 0) {
        return;
      }

      this._currentTranslation = scroll;
      var opt = options.animate ? { duration: .3, timing: 'cubic-bezier(.1, .7, .1, 1)' } : {};
      this._onPull && this._onPull((scroll / this.height).toFixed(2), opt);
      var scrollElement = this.hasAttribute('fixed-content') ? this : this._pageElement;

      Animit(scrollElement).queue({ transform: 'translate3d(0px, ' + scroll + 'px, 0px)' }, opt).play(function () {
        scroll === 0 && styler.clear(scrollElement, 'transition transform');
        options.callback instanceof Function && options.callback();
      });
    }
  }, {
    key: '_disableDragLock',
    value: function _disableDragLock() {
      // e2e tests need it
      this._dragLockDisabled = true;
      this._setupListeners(true);
    }
  }, {
    key: '_setupListeners',
    value: function _setupListeners(add) {
      var _this6 = this;

      var scrollToggle = function scrollToggle(action) {
        return _this6._pageElement[action + 'EventListener']('scroll', _this6._onScroll, false);
      };
      var gdToggle = function gdToggle(action) {
        var passive = { passive: true };
        _this6._gestureDetector[action]('drag', _this6._onDrag, passive);
        _this6._gestureDetector[action]('dragstart', _this6._onDragStart, passive);
        _this6._gestureDetector[action]('dragend', _this6._onDragEnd, passive);
      };

      if (this._gestureDetector) {
        gdToggle('off');
        this._gestureDetector.dispose();
        this._gestureDetector = null;
      }
      scrollToggle('remove');

      if (add) {
        this._gestureDetector = new GestureDetector(this._pageElement, {
          dragMinDistance: 1,
          dragDistanceCorrection: false,
          dragLockToAxis: !this._dragLockDisabled,
          passive: !this._shouldFixScroll
        });

        gdToggle('on');
        scrollToggle('add');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._currentTranslation = 0;
      this._pageElement = this.parentNode;

      this._setupListeners(true);
      this._setStyle();
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._hide();
      this._setupListeners(false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'height' && this._pageElement) {
        this._setStyle();
      }
    }
  }, {
    key: 'onAction',
    get: function get$$1() {
      return this._onAction;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        throwType('onAction', 'function or null');
      }
      this._onAction = value;
    }

    /**
     * @property onPull
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user pulls the element. It gets the pulled distance ratio (scroll / height) and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onPull',
    get: function get$$1() {
      return this._onPull;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        throwType('onPull', 'function or null');
      }
      this._onPull = value;
    }
  }, {
    key: 'height',
    set: function set$$1(value) {
      if (!util$1.isInteger(value)) {
        throwType('height', 'integer');
      }

      this.setAttribute('height', value + 'px');
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('height') || '64', 10);
    }

    /**
     * @property thresholdHeight
     * @type {Number}
     * @description
     *   [en]The thresholdHeight of the pull hook in pixels. The default value is `96px`.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'thresholdHeight',
    set: function set$$1(value) {
      if (!util$1.isInteger(value)) {
        throwType('thresholdHeight', 'integer');
      }

      this.setAttribute('threshold-height', value + 'px');
    },
    get: function get$$1() {
      return parseInt(this.getAttribute('threshold-height') || '96', 10);
    }
  }, {
    key: 'state',
    get: function get$$1() {
      return this.getAttribute('state');
    }

    /**
     * @property pullDistance
     * @readonly
     * @type {Number}
     * @description
     *   [en]The current number of pixels the pull hook has moved.[/en]
     *   [ja]現在のプルフックが引き出された距離をピクセル数。[/ja]
     */

  }, {
    key: 'pullDistance',
    get: function get$$1() {
      return this._currentTranslation;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['height'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['changestate'];
    }
  }]);
  return PullHookElement;
}(BaseElement);

onsElements.PullHook = PullHookElement;
customElements.define('ons-pull-hook', PullHookElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var scheme$22 = {
  '': 'range--*',
  '.range__input': 'range--*__input',
  '.range__focus-ring': 'range--*__focus-ring'
};

var activeClassToken = 'range__input--active';

/**
 * @element ons-range
 * @category form
 * @modifier material
 *   [en]Material Design slider[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Range input component. Used to display a draggable slider.
 *
 *     Works very similar to the `<input type="range">` element.
 *   [/en]
 *   [ja][/ja]
 * @codepen xZQomM
 * @tutorial vanilla/Reference/range
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @seealso ons-input
 *   [en]The `<ons-input>` component is used to display text inputs, radio buttons and checkboxes.[/en]
 *   [ja][/ja]
 * @example
 * <ons-range value="20"></ons-range>
 * <ons-range modifier="material" value="10"></range>
 */

var RangeElement = function (_BaseInputElement) {
  inherits(RangeElement, _BaseInputElement);

  function RangeElement() {
    classCallCheck(this, RangeElement);

    var _this = possibleConstructorReturn(this, (RangeElement.__proto__ || Object.getPrototypeOf(RangeElement)).call(this));

    _this._onMouseDown = _this._onMouseDown.bind(_this);
    _this._onMouseUp = _this._onMouseUp.bind(_this);
    _this._onTouchStart = _this._onTouchStart.bind(_this);
    _this._onTouchEnd = _this._onTouchEnd.bind(_this);
    _this._onInput = _this._update.bind(_this);
    _this._onDragstart = _this._onDragstart.bind(_this);
    _this._onDragend = _this._onDragend.bind(_this);
    return _this;
  }

  createClass(RangeElement, [{
    key: '_compile',
    value: function _compile() {
      get(RangeElement.prototype.__proto__ || Object.getPrototypeOf(RangeElement.prototype), '_compile', this).call(this);
      this._updateDisabled(this.hasAttribute('disabled'));
    }

    /* Inherited props */

  }, {
    key: '_update',
    value: function _update() {
      var input = this._input;
      var focusRing = this._focusRing;

      input.style.backgroundSize = 100 * this._ratio + '% 2px';
      focusRing.value = this.value;

      // NOTE: "_zero" attribute is used for CSS styling.
      if (input.min === '' && input.value === '0' || input.min === input.value) {
        input.setAttribute('_zero', '');
      } else {
        input.removeAttribute('_zero');
      }

      ['min', 'max'].forEach(function (attr) {
        return focusRing[attr] = input[attr];
      });
    }
  }, {
    key: '_onMouseDown',


    /* Own props */

    value: function _onMouseDown(e) {
      var _this2 = this;

      this._input.classList.add(activeClassToken);
      setImmediate(function () {
        return _this2._input.focus();
      });
    }
  }, {
    key: '_onTouchStart',
    value: function _onTouchStart(e) {
      this._onMouseDown();
    }
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp(e) {
      this._input.classList.remove(activeClassToken);
    }
  }, {
    key: '_onTouchEnd',
    value: function _onTouchEnd(e) {
      this._onMouseUp(e);
    }
  }, {
    key: '_onDragstart',
    value: function _onDragstart(e) {
      e.consumed = true;
      e.gesture.stopPropagation();
      this._input.classList.add(activeClassToken);
      this.addEventListener('drag', this._onDrag);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(e) {
      e.stopPropagation();
    }
  }, {
    key: '_onDragend',
    value: function _onDragend(e) {
      this._input.classList.remove(activeClassToken);
      this.removeEventListener('drag', this._onDrag);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'disabled') {
        this._updateDisabled(current);
      }
      get(RangeElement.prototype.__proto__ || Object.getPrototypeOf(RangeElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
    }

    /**
     * @param {boolean} disabled
     */

  }, {
    key: '_updateDisabled',
    value: function _updateDisabled(disabled) {
      if (disabled) {
        this.classList.add('range--disabled');
      } else {
        this.classList.remove('range--disabled');
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._setupListeners(true);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._setupListeners(false);
    }
  }, {
    key: '_setupListeners',
    value: function _setupListeners(add) {
      var action = (add ? 'add' : 'remove') + 'EventListener';
      util$1[action](this, 'touchstart', this._onTouchStart, { passive: true });
      this[action]('mousedown', this._onMouseDown);
      this[action]('mouseup', this._onMouseUp);
      this[action]('touchend', this._onTouchEnd);
      this[action]('dragstart', this._onDragstart);
      this[action]('dragend', this._onDragend);
      this[action]('input', this._onInput);
    }

    /**
     * @attribute disabled
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property value
     * @type {Number}
     * @description
     *   [en]Current value.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$22;
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <input type="range" class="range__focus-ring" tabIndex="-1">\n    ';
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'range';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'range';
    }
  }, {
    key: '_focusRing',
    get: function get$$1() {
      return this.children[1];
    }
  }, {
    key: '_ratio',
    get: function get$$1() {
      // Returns the current ratio.
      var min = this._input.min === '' ? 0 : parseInt(this._input.min);
      var max = this._input.max === '' ? 100 : parseInt(this._input.max);

      return (this.value - min) / (max - min);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['disabled'].concat(toConsumableArray(BaseInputElement.observedAttributes));
    }
  }]);
  return RangeElement;
}(BaseInputElement);

onsElements.Range = RangeElement;
customElements.define('ons-range', RangeElement);

/*
Copyright 2013-2016 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @class AnimatorCSS - implementation of Animator class using css transitions
 */

var AnimatorCSS = function () {
  createClass(AnimatorCSS, [{
    key: 'animate',


    /**
     * @method animate
     * @desc main animation function
     * @param {Element} element
     * @param {Object} finalCSS
     * @param {number} [duration=200] - duration in milliseconds
     * @return {Object} result
     * @return {Function} result.then(callback) - sets a callback to be executed after the animation has stopped
     * @return {Function} result.stop(options) - stops the animation; if options.stopNext is true then it doesn't call the callback
     * @return {Function} result.finish(ms) - finishes the animation in the specified time in milliseconds
     * @return {Function} result.speed(ms) - sets the animation speed so that it finishes as if the original duration was the one specified here
     * @example
     * ````
     *  var result = animator.animate(el, {opacity: 0.5}, 1000);
     *
     *  el.addEventListener('click', function(e){
     *    result.speed(200).then(function(){
     *      console.log('done');
     *    });
     *  }, 300);
     * ````
     */
    value: function animate(el, final) {
      var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;

      var start = new Date().getTime(),
          initial = {},
          stopped = false,
          next = false,
          timeout = false,
          properties = Object.keys(final);

      var updateStyles = function updateStyles() {
        var s = window.getComputedStyle(el);
        properties.forEach(s.getPropertyValue.bind(s));
        s = el.offsetHeight;
      };

      var result = {
        stop: function stop() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          timeout && clearTimeout(timeout);
          var k = Math.min(1, (new Date().getTime() - start) / duration);
          properties.forEach(function (i) {
            el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
          });
          el.style.transitionDuration = '0s';

          if (options.stopNext) {
            next = false;
          } else if (!stopped) {
            stopped = true;
            next && next();
          }
          return result;
        },
        then: function then(cb) {
          next = cb;
          if (stopped) {
            next && next();
          }
          return result;
        },
        speed: function speed(newDuration) {
          if (internal$1.config.animationsDisabled) {
            newDuration = 0;
          }
          if (!stopped) {
            timeout && clearTimeout(timeout);

            var passed = new Date().getTime() - start;
            var k = passed / duration;
            var remaining = newDuration * (1 - k);

            properties.forEach(function (i) {
              el.style[i] = (1 - k) * initial[i] + k * final[i] + (i == 'opacity' ? '' : 'px');
            });

            updateStyles();

            start = el.speedUpTime;
            duration = remaining;

            el.style.transitionDuration = duration / 1000 + 's';

            properties.forEach(function (i) {
              el.style[i] = final[i] + (i == 'opacity' ? '' : 'px');
            });

            timeout = setTimeout(result.stop, remaining);
          }
          return result;
        },
        finish: function finish() {
          var milliseconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;

          var k = (new Date().getTime() - start) / duration;

          result.speed(milliseconds / (1 - k));
          return result;
        }
      };

      if (el.hasAttribute('disabled') || stopped || internal$1.config.animationsDisabled) {
        return result;
      }

      var style = window.getComputedStyle(el);
      properties.forEach(function (e) {
        var v = parseFloat(style.getPropertyValue(e));
        initial[e] = isNaN(v) ? 0 : v;
      });

      if (!stopped) {
        el.style.transitionProperty = properties.join(',');
        el.style.transitionDuration = duration / 1000 + 's';

        properties.forEach(function (e) {
          el.style[e] = final[e] + (e == 'opacity' ? '' : 'px');
        });
      }

      timeout = setTimeout(result.stop, duration);
      this._onStopAnimations(el, result.stop);

      return result;
    }
  }]);

  function AnimatorCSS() {
    classCallCheck(this, AnimatorCSS);

    this._queue = [];
    this._index = 0;
  }

  createClass(AnimatorCSS, [{
    key: '_onStopAnimations',
    value: function _onStopAnimations(el, listener) {
      var queue = this._queue;
      var i = this._index++;
      queue[el] = queue[el] || [];
      queue[el][i] = function (options) {
        delete queue[el][i];
        if (queue[el] && queue[el].length == 0) {
          delete queue[el];
        }
        return listener(options);
      };
    }

    /**
    * @method stopAnimations
    * @desc stops active animations on a specified element
    * @param {Element|Array} element - element or array of elements
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAnimations',
    value: function stopAnimations(el) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (Array.isArray(el)) {
        return el.forEach(function (el) {
          _this.stopAnimations(el, options);
        });
      }

      (this._queue[el] || []).forEach(function (e) {
        e(options || {});
      });
    }

    /**
    * @method stopAll
    * @desc stops all active animations
    * @param {Object} [options={}]
    * @param {Boolean} [options.stopNext] - the callbacks after the animations won't be called if this option is true
    */

  }, {
    key: 'stopAll',
    value: function stopAll() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.stopAnimations(Object.keys(this._queue), options);
    }

    /**
    * @method fade
    * @desc fades the element (short version for animate(el, {opacity: 0}))
    * @param {Element} element
    * @param {number} [duration=200]
    */

  }, {
    key: 'fade',
    value: function fade(el) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;

      return this.animate(el, { opacity: 0 }, duration);
    }
  }]);
  return AnimatorCSS;
}();

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$11 = 'ripple';
var scheme$23 = {
  '': 'ripple--*',
  '.ripple__wave': 'ripple--*__wave',
  '.ripple__background': 'ripple--*__background'
};

/**
 * @element ons-ripple
 * @category visual
 * @description
 *   [en]
 *     Adds a Material Design "ripple" effect to an element. The ripple effect will spread from the position where the user taps.
 *
 *     Some elements such as `<ons-button>` and `<ons-fab>`  support a `ripple` attribute.
 *   [/en]
 *   [ja]マテリアルデザインのリップル効果をDOM要素に追加します。[/ja]
 * @codepen wKQWdZ
 * @tutorial vanilla/Reference/ripple
 * @modifier light-gray
 *   [en]Change the color of effects to light gray.[/en]
 *   [ja]エフェクトの色が明るい灰色になります。[/ja]
 * @guide theming.html#cross-platform-styling-autostyling
 *  [en]Cross platform styling[/en]
 *  [ja]Cross platform styling[/ja]
 * @example
 * <div class="my-div">
 *  <ons-ripple></ons-ripple>
 * </div>
 *
 * @example
 * <ons-button ripple>Click me!</ons-button>
 */

var RippleElement = function (_BaseElement) {
  inherits(RippleElement, _BaseElement);

  /**
   * @attribute color
   * @type {String}
   * @description
   *   [en]Color of the ripple effect.[/en]
   *   [ja]リップルエフェクトの色を指定します。[/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the ripple effect.[/en]
   *   [ja]エフェクトの表現を指定します。[/ja]
   */

  /**
   * @attribute background
   * @type {String}
   * @description
   *   [en]Color of the background.[/en]
   *   [ja]背景の色を設定します。[/ja]
   */

  /**
   * @attribute size
   * @type {String}
   * @description
   *   [en]Sizing of the wave on ripple effect. Set "cover" or "contain". Default is "cover".[/en]
   *   [ja]エフェクトのサイズを指定します。"cover"もしくは"contain"を指定します。デフォルトは"cover"です。[/ja]
   */

  /**
   * @attribute center
   * @type {Boolean}
   * @description
   *   [en]If this attribute presents, change the position of wave effect to center of the target element.[/en]
   *   [ja]この要素を設定すると、エフェクトの位置が要素の真ん中から始まります。[/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]If this attribute is set, the ripple effect will be disabled.[/en]
   *   [ja]この属性が設定された場合、リップルエフェクトは無効になります。[/ja]
   */

  function RippleElement() {
    classCallCheck(this, RippleElement);

    var _this = possibleConstructorReturn(this, (RippleElement.__proto__ || Object.getPrototypeOf(RippleElement)).call(this));

    _this._onTap = _this._onTap.bind(_this);
    _this._onHold = _this._onHold.bind(_this);
    _this._onDragStart = _this._onDragStart.bind(_this);
    _this._onRelease = _this._onRelease.bind(_this);

    contentReady(_this, function () {
      return _this._compile();
    });

    _this._animator = new AnimatorCSS();

    ['color', 'center', 'start-radius', 'background', 'modifier'].forEach(function (e) {
      _this.attributeChangedCallback(e, null, _this.getAttribute(e));
    });
    return _this;
  }

  createClass(RippleElement, [{
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$11);

      this._wave = this.getElementsByClassName('ripple__wave')[0];
      this._background = this.getElementsByClassName('ripple__background')[0];

      if (!(this._background && this._wave)) {
        this._wave = util$1.create('.ripple__wave');
        this._background = util$1.create('.ripple__background');

        this.appendChild(this._wave);
        this.appendChild(this._background);
      }

      ModifierUtil.initModifier(this, scheme$23);
    }
  }, {
    key: '_getEffectSize',
    value: function _getEffectSize() {
      var sizes = ['cover', 'contain'];
      if (this.hasAttribute('size')) {
        var size = this.getAttribute('size');
        if (sizes.indexOf(size) !== -1) {
          return size;
        }
      }

      return 'cover';
    }
  }, {
    key: '_calculateCoords',
    value: function _calculateCoords(e) {
      var x = void 0,
          y = void 0,
          h = void 0,
          w = void 0,
          r = void 0;
      var b = this.getBoundingClientRect();
      var size = this._getEffectSize();
      var error = function error() {
        return util$1.throw('Ripple invalid state');
      };

      if (this._center) {
        x = b.width / 2;
        y = b.height / 2;

        if (size === 'cover') {
          r = Math.sqrt(x * x + y * y);
        } else if (size === 'contain') {
          r = Math.min(x, y);
        } else {
          error();
        }
      } else {
        x = (typeof e.clientX === 'number' ? e.clientX : e.changedTouches[0].clientX) - b.left;
        y = (typeof e.clientY === 'number' ? e.clientY : e.changedTouches[0].clientY) - b.top;
        h = Math.max(y, b.height - y);
        w = Math.max(x, b.width - x);

        if (size === 'cover') {
          r = Math.sqrt(h * h + w * w);
        } else if (size === 'contain') {
          r = Math.min(Math.round(h / 2), Math.round(w / 2));
        } else {
          error();
        }
      }

      return { x: x, y: y, r: r };
    }
  }, {
    key: '_rippleAnimation',
    value: function _rippleAnimation(e) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
      var _animator = this._animator,
          _wave = this._wave,
          _background = this._background,
          _minR = this._minR;

      var _calculateCoords2 = this._calculateCoords(e),
          x = _calculateCoords2.x,
          y = _calculateCoords2.y,
          r = _calculateCoords2.r;

      _animator.stopAll({ stopNext: 1 });
      _animator.animate(_background, { opacity: 1 }, duration);

      util$1.extend(_wave.style, {
        opacity: 1,
        top: y - _minR + 'px',
        left: x - _minR + 'px',
        width: 2 * _minR + 'px',
        height: 2 * _minR + 'px'
      });

      return _animator.animate(_wave, {
        top: y - r,
        left: x - r,
        height: 2 * r,
        width: 2 * r
      }, duration);
    }
  }, {
    key: '_updateParent',
    value: function _updateParent() {
      if (!this._parentUpdated && this.parentNode) {
        var computedStyle = window.getComputedStyle(this.parentNode);
        if (computedStyle.getPropertyValue('position') === 'static') {
          this.parentNode.style.position = 'relative';
        }
        this._parentUpdated = true;
      }
    }
  }, {
    key: '_onTap',
    value: function _onTap(e) {
      var _this2 = this;

      if (!this.disabled && !e.ripple) {
        e.ripple = true;
        this._updateParent();
        this._rippleAnimation(e.gesture.srcEvent).then(function () {
          _this2._animator.fade(_this2._wave);
          _this2._animator.fade(_this2._background);
        });
      }
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled && !e.ripple) {
        e.ripple = true;
        this._updateParent();
        this._holding = this._rippleAnimation(e.gesture.srcEvent, 2000);
        document.addEventListener('release', this._onRelease);
      }
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var _this3 = this;

      if (this._holding && !e.ripple) {
        e.ripple = true;
        this._holding.speed(300).then(function () {
          _this3._animator.stopAll({ stopNext: true });
          _this3._animator.fade(_this3._wave);
          _this3._animator.fade(_this3._background);
        });

        this._holding = false;
      }

      document.removeEventListener('release', this._onRelease);
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this._holding) {
        return this._onRelease(e);
      }
      if (['left', 'right'].indexOf(e.gesture.direction) != -1) {
        this._onTap(e);
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this._parentNode = this.parentNode;

      if (internal$1.config.animationsDisabled) {
        this.disabled = true;
      } else {
        this._parentNode.addEventListener('tap', this._onTap);
        this._parentNode.addEventListener('hold', this._onHold);
        this._parentNode.addEventListener('dragstart', this._onDragStart);
      }
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var pn = this._parentNode || this.parentNode;
      pn.removeEventListener('tap', this._onTap);
      pn.removeEventListener('hold', this._onHold);
      pn.removeEventListener('dragstart', this._onDragStart);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this4 = this;

      switch (name) {

        case 'class':
          util$1.restoreClass(this, defaultClassName$11, scheme$23);
          break;

        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$23);
          break;

        case 'start-radius':
          this._minR = Math.max(0, parseFloat(current) || 0);
          break;

        case 'color':
          if (current) {
            contentReady(this, function () {
              _this4._wave.style.background = current;
              if (!_this4.hasAttribute('background')) {
                _this4._background.style.background = current;
              }
            });
          }
          break;

        case 'background':
          if (current || last) {
            if (current === 'none') {
              contentReady(this, function () {
                _this4._background.setAttribute('disabled', 'disabled');
                _this4._background.style.background = 'transparent';
              });
            } else {
              contentReady(this, function () {
                if (_this4._background.hasAttribute('disabled')) {
                  _this4._background.removeAttribute('disabled');
                }
                _this4._background.style.background = current;
              });
            }
          }
          break;

        case 'center':
          if (name === 'center') {
            this._center = current != null && current != 'false';
          }
          break;

      }
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['start-radius', 'color', 'background', 'center', 'class', 'modifier'];
    }
  }]);
  return RippleElement;
}(BaseElement);

onsElements.Ripple = RippleElement;
customElements.define('ons-ripple', RippleElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-row
 * @category grid
 * @description
 *   [en]Represents a row in the grid system. Use with `<ons-col>` to layout components.[/en]
 *   [ja]グリッドシステムにて行を定義します。ons-colとともに使用し、コンポーネントの配置に使用します。[/ja]
 * @codepen GgujC {wide}
 * @guide theming.html
 *   [en]Layouting guide[/en]
 *   [ja]レイアウト調整[/ja]
 * @seealso ons-col
 *   [en]The `<ons-col>` component is used as children of `<ons-row>`.[/en]
 *   [ja]ons-colコンポーネント[/ja]
 * @note
 *   [en]For Android 4.3 and earlier, and iOS6 and earlier, when using mixed alignment with ons-row and ons-col, they may not be displayed correctly. You can use only one vertical-align.[/en]
 *   [ja]Android 4.3以前、もしくはiOS 6以前のOSの場合、ons-rowとons-colを組み合わせてそれぞれのons-col要素のvertical-align属性の値に別々の値を指定すると、描画が崩れる場合があります。vertical-align属性の値には一つの値だけを指定できます。[/ja]
 * @example
 * <ons-row>
 *   <ons-col width="50px"><ons-icon icon="fa-twitter"></ons-icon></ons-col>
 *   <ons-col>Text</ons-col>
 * </ons-row>
 */

/**
 * @attribute vertical-align
 * @type {String}
 * @description
 *   [en]Short hand attribute for aligning vertically. Valid values are top, bottom, and center.[/en]
 *   [ja]縦に整列するために指定します。top、bottom、centerのいずれかを指定できます。[/ja]
 */

var RowElement = function (_BaseElement) {
  inherits(RowElement, _BaseElement);

  function RowElement() {
    classCallCheck(this, RowElement);
    return possibleConstructorReturn(this, (RowElement.__proto__ || Object.getPrototypeOf(RowElement)).apply(this, arguments));
  }

  return RowElement;
}(BaseElement);

onsElements.Row = RowElement;
customElements.define('ons-row', RowElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$12 = 'segment';
var scheme$24 = {
  '': 'segment--*',
  '.segment__item': 'segment--*__item',
  '.segment__input': 'segment--*__input',
  '.segment__button': 'segment--*__button'
};

var generateId$1 = function () {
  var i = 0;
  return function () {
    return 'ons-segment-gen-' + i++;
  };
}();

/**
 * @element ons-segment
 * @category control
 * @modifier material
 *   [en]Material Design segment[/en]
 *   [ja][/ja]
 * @description
 *   [en]
 *     Segment component. Use this component to have a button bar with automatic styles that switch on click of another button.
 *
 *     Will automatically display as a Material Design segment on Android.
 *   [/en]
 *   [ja][/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/segment
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-segment>
 *   <ons-button>Label 1</ons-button>
 *   <ons-button>Label 2</ons-button>
 *   <ons-button>Label 3</ons-button>
 * </ons-segment>
 */

var SegmentElement = function (_BaseElement) {
  inherits(SegmentElement, _BaseElement);

  /**
   * @event postchange
   * @description
   *   [en]Fires after the active button is changed.[/en]
   *   [ja][/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja][/ja]
   * @param {Number} event.index
   *   [en]Tapped button index.[/en]
   *   [ja][/ja]
   * @param {Object} event.segmentItem
   *   [en]Segment item object.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *  [en]The appearance of the segment.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute tabbar-id
   * @initonly
   * @type {String}
   * @description
   *  [en]ID of the tabbar element to "connect" to the segment. Must be inside the same page.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute active-index
   * @initonly
   * @default 0
   * @type {Number}
   * @description
   *  [en]Index of the first active button, only works if there is no connected tabbar (in which case the active tab sets the active button).[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if segment should be disabled.[/en]
   *   [ja]ボタンを無効化する場合は指定します。[/ja]
   */

  function SegmentElement() {
    classCallCheck(this, SegmentElement);

    var _this = possibleConstructorReturn(this, (SegmentElement.__proto__ || Object.getPrototypeOf(SegmentElement)).call(this));

    _this._segmentId = generateId$1();
    _this._tabbar = null;
    _this._onChange = _this._onChange.bind(_this);
    _this._onTabbarPreChange = _this._onTabbarPreChange.bind(_this);

    contentReady(_this, function () {
      _this._compile();
      setImmediate(function () {
        return _this._lastActiveIndex = _this._tabbar ? _this._tabbar.getActiveTabIndex() : _this.getActiveButtonIndex();
      });
    });
    return _this;
  }

  createClass(SegmentElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$12);

      for (var index = this.children.length - 1; index >= 0; index--) {
        var item = this.children[index];
        item.classList.add('segment__item');

        var input = util$1.findChild(item, '.segment__input') || util$1.create('input.segment__input');
        input.type = 'radio';
        input.value = index;
        input.name = input.name || this._segmentId;
        input.checked = !this.hasAttribute('tabbar-id') && index === (parseInt(this.getAttribute('active-index')) || 0);

        var button = util$1.findChild(item, '.segment__button') || util$1.create('.segment__button');
        if (button.parentElement !== item) {
          while (item.firstChild) {
            button.appendChild(item.firstChild);
          }
        }

        item.appendChild(input);
        item.appendChild(button);
      }

      ModifierUtil.initModifier(this, scheme$24);
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (this.hasAttribute('tabbar-id')) {
        contentReady(this, function () {
          var page = util$1.findParent(_this2, 'ons-page');
          _this2._tabbar = page && page.querySelector('#' + _this2.getAttribute('tabbar-id'));
          if (!_this2._tabbar || _this2._tabbar.tagName !== 'ONS-TABBAR') {
            util$1.throw('No tabbar with id ' + _this2.getAttribute('tabbar-id') + ' was found.');
          }

          _this2._tabbar.setAttribute('hide-tabs', '');
          setImmediate(function () {
            return _this2._setChecked(_this2._tabbar.getActiveTabIndex());
          });

          _this2._tabbar.addEventListener('prechange', _this2._onTabbarPreChange);
        });
      }

      this.addEventListener('change', this._onChange);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        if (_this3._tabbar) {
          _this3._tabbar.removeEventListener('prechange', _this3._onTabbarPreChange);
          _this3._tabbar = null;
        }
      });
      this.removeEventListener('change', this._onChange);
    }
  }, {
    key: '_setChecked',
    value: function _setChecked(index) {
      this.children[index].firstElementChild.checked = true;
    }

    /**
     * @method setActiveButton
     * @signature setActiveButton(index, [options])
     * @param {Number} index
     *   [en]Button index.[/en]
     *   [ja][/ja]
     * @param {Object} [options]
     *   [en]Parameter object, works only if there is a connected tabbar. Supports the same options as `ons-tabbar`'s `setActiveTab` method.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Make button with the specified index active. If there is a connected tabbar it shows the corresponding tab page. In this case animations and their options can be specified by the second parameter.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the selected index or to the new page element if there is a connected tabbar.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setActiveButton',
    value: function setActiveButton(index, options) {
      if (this._tabbar) {
        return this._tabbar.setActiveTab(index, options);
      }

      this._setChecked(index);
      this._postChange(index);
      return Promise.resolve(index);
    }

    /**
     * @method getActiveButtonIndex
     * @signature getActiveButtonIndex()
     * @return {Number}
     *   [en]The index of the currently active button.[/en]
     *   [ja][/ja]
     * @description
     *   [en]Returns button index of current active button. If active button is not found, returns -1.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'getActiveButtonIndex',
    value: function getActiveButtonIndex() {
      for (var i = this.children.length - 1; i >= 0; i--) {
        // Array.findIndex
        if (this.children[i].firstElementChild.checked) {
          return i;
        }
      }
      return -1;
    }
  }, {
    key: '_onChange',
    value: function _onChange(event) {
      event.stopPropagation();
      this._tabbar ? this._tabbar.setActiveTab(this.getActiveButtonIndex(), { reject: false }) : this._postChange(this.getActiveButtonIndex());
    }
  }, {
    key: '_onTabbarPreChange',
    value: function _onTabbarPreChange(event) {
      var _this4 = this;

      setImmediate(function () {
        if (!event.detail.canceled) {
          _this4._setChecked(event.index);
          _this4._postChange(event.index);
        }
      });
    }
  }, {
    key: '_postChange',
    value: function _postChange(index) {
      util$1.triggerElementEvent(this, 'postchange', {
        index: index,
        activeIndex: index,
        lastActiveIndex: this._lastActiveIndex,
        segmentItem: this.children[index]
      });
      this._lastActiveIndex = index;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the segment is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$12, scheme$24);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$24);
          break;
      }
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['class', 'modifier'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['postchange'];
    }
  }]);
  return SegmentElement;
}(BaseElement);

onsElements.Segment = SegmentElement;
customElements.define('ons-segment', SegmentElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$25 = {
  '': 'select-* select--*',
  '.select-input': 'select-input--*'
};

var defaultClassName$13 = 'select';

var INPUT_ATTRIBUTES$1 = ['autofocus', 'disabled', 'form', 'multiple', 'name', 'required', 'size'];

/**
 * @element ons-select
 * @category form
 * @modifier material
 *  [en]Displays a Material Design select input.[/en]
 *  [ja][/ja]
 * @modifier underbar
 *  [en]Displays a horizontal line underneath a select input.[/en]
 *  [ja][/ja]
 * @description
 *   [en]
 *     Select component. If you want to place a select with an ID of `my-id` on a page, use `<ons-select select-id="my-id">`.
 *
 *     The component will automatically display as a Material Design select on Android.
 *
 *     Most attributes that can be used for a normal `<select>` element can also be used on the `<ons-select>` element.
 *   [/en]
 *   [ja]セレクトボックスを表示するコンポーネントです。`select` 要素に使用できる属性の多くが `ons-select` 要素でも利用できます。[/ja]
 * @codepen hLayx
 * @tutorial vanilla/Reference/select
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @guide theming.html#cross-platform-styling-autostyling [en]Information about cross platform styling[/en][ja]Information about cross platform styling[/ja]
 * @example
 * <ons-select>
 *   <option value="1">1</option>
 *   <option value="2">2nd</option>
 *   <option value="3">3rd option</option>
 * </ons-select>
 */

var SelectElement = function (_BaseElement) {
  inherits(SelectElement, _BaseElement);

  /**
   * @attribute autofocus
   * @type {Boolean}
   * @default false
   * @description
   *  [en]Element automatically gains focus on page load.[/en]
   *  [ja]ページロード時にこのセレクトボックスにフォーカスが移るようにします。[/ja]
   */

  /**
   * @attribute disabled
   * @type {Boolean}
   * @default false
   * @description
   *   [en]Specify if select input should be disabled.[/en]
   *   [ja]このセレクトボックスを無効化する場合に指定します。[/ja]
   */

  /**
   * @attribute form
   * @type {String}
   * @description
   *   [en]Associate a select element to an existing form on the page, even if not nested.[/en]
   *   [ja]このセレクトボックスを、指定した `form` 要素に紐付けます。セレクトボックスを `form` 要素の外側に配置する際に使用します。[/ja]
   */

  /**
   * @attribute multiple
   * @type {Boolean}
   * @default false
   * @description
   *  [en]If this attribute is defined, multiple options can be selected at once.[/en]
   *  [ja]選択肢の複数選択を有効にします。[/ja]
   */

  /**
   * @attribute name
   * @type {String}
   * @description
   *   [en]Name the select element, useful for instance if it is part of a form.[/en]
   *   [ja]このセレクトボックスの名前を指定します。通常 `form` 要素と共に使用します。[/ja]
   */

  /**
   * @attribute required
   * @type {Boolean}
   * @description
   *   [en]Make the select input required for submitting the form it is part of.[/en]
   *   [ja]このセレクトボックスを入力必須にする場合に指定します。通常 `form` 要素と共に使用します。[/ja]
   */

  /**
   * @attribute select-id
   * @type {String}
   * @description
   *   [en]ID given to the inner select, useful for dynamic manipulation.[/en]
   *   [ja]このセレクトボックスが内部に持つ select 要素に与える ID を指定します。セレクトボックスの内容を動的に変更する必要がある場合に使用します。[/ja]
   */

  /**
   * @attribute size
   * @type {Number}
   * @default 1
   * @description
   *   [en]How many options are displayed; if there are more than the size then a scroll appears to navigate them.[/en]
   *   [ja]一度に表示する選択肢の個数を指定します。選択肢がこの属性で指定した個数よりも多い場合、スクロールが有効になります。[/ja]
   */

  function SelectElement() {
    classCallCheck(this, SelectElement);

    var _this = possibleConstructorReturn(this, (SelectElement.__proto__ || Object.getPrototypeOf(SelectElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });

    _this._deriveGetters();
    return _this;
  }

  createClass(SelectElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this2 = this;

      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$13, scheme$25);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$25);
          break;
      }

      if (INPUT_ATTRIBUTES$1.indexOf(name) >= 0) {
        contentReady(this, function () {
          return _this2._updateBoundAttributes();
        });
      }
    }
  }, {
    key: '_updateBoundAttributes',
    value: function _updateBoundAttributes() {
      var _this3 = this;

      INPUT_ATTRIBUTES$1.forEach(function (attr) {
        if (_this3.hasAttribute(attr)) {
          _this3._select.setAttribute(attr, _this3.getAttribute(attr));
        } else {
          _this3._select.removeAttribute(attr);
        }
      });
    }

    /**
     * @property length
     * @description
     *   [en]Number of options in the select box.[/en]
     *   [ja]このセレクトボックスに含まれる選択肢の個数を返します。 `select` 要素[/ja]
     */

    /**
     * @property options
     * @description
     *   [en]Several options for handling the select DOM object.[/en]
     *   [ja]このセレクトボックスに含まれる `option` 要素の配列を返します。[/ja]
     */

    /**
     * @property selectedIndex
     * @description
     *   [en]Index of the currently selected option.[/en]
     *   [ja]現在選択されている選択肢のインデックスを返します。[/ja]
     */

    /**
     * @property value
     * @description
     *   [en]Value of the currently selected option.[/en]
     *   [ja]現在選択されている選択肢の値を返します。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.classList.add(defaultClassName$13);
      var sel = this._select || document.createElement('select');
      if (!sel.id && this.hasAttribute('select-id')) {
        sel.id = this.getAttribute('select-id');
      }
      sel.classList.add('select-input');
      if (!this._select) {
        util$1.arrayFrom(this.childNodes).forEach(function (element) {
          return sel.appendChild(element);
        });
        this.appendChild(sel);
      }

      ModifierUtil.initModifier(this, scheme$25);
    }
  }, {
    key: '_deriveGetters',
    value: function _deriveGetters() {
      var _this4 = this;

      ['disabled', 'length', 'multiple', 'name', 'options', 'selectedIndex', 'size', 'value', 'form', 'type'].forEach(function (key) {
        Object.defineProperty(_this4, key, {
          configurable: true,
          enumerable: true,
          get: function get$$1() {
            return _this4._select[key];
          },
          set: ['form', 'type'].indexOf(key) === -1 ? function (value) {
            return contentReady(_this4, function () {
              return _this4._select[key] = value;
            });
          } : undefined
        });
      });
    }
  }, {
    key: 'add',
    value: function add(option) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      this._select.add(option, index);
    }
  }, {
    key: 'remove',
    value: function remove(index) {
      this._select.remove(index);
    }
  }, {
    key: '_select',
    get: function get$$1() {
      return this.querySelector('select');
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'class'].concat(INPUT_ATTRIBUTES$1);
    }
  }]);
  return SelectElement;
}(BaseElement);

onsElements.Select = SelectElement;
customElements.define('ons-select', SelectElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$14 = 'fab fab--mini speed-dial__item';

var scheme$26 = {
  '': 'fab--* speed-dial__item--*'
};

/**
 * @element ons-speed-dial-item
 * @category control
 * @description
 *   [en]
 *     This component displays the child elements of the Material Design Speed dial component.
 *   [/en]
 *   [ja]
 *     Material DesignのSpeed dialの子要素を表現する要素です。
 *   [/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial
 *   [en]The `<ons-speed-dial>` component.[/en]
 *   [ja]ons-speed-dialコンポーネント[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fabコンポーネント[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialItemElement = function (_BaseElement) {
  inherits(SpeedDialItemElement, _BaseElement);

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the component.[/en]
   *   [ja]このコンポーネントの表現を指定します。[/ja]
   */

  /**
   * @attribute ripple
   * @description
   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
   *  [ja][/ja]
   */

  function SpeedDialItemElement() {
    classCallCheck(this, SpeedDialItemElement);

    var _this = possibleConstructorReturn(this, (SpeedDialItemElement.__proto__ || Object.getPrototypeOf(SpeedDialItemElement)).call(this));

    _this._compile();
    _this._boundOnClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(SpeedDialItemElement, [{
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$14, scheme$26);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$26);
          util$1.addModifier(this, 'mini');
          break;
        case 'ripple':
          this._updateRipple();
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      util$1.updateRipple(this);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      e.stopPropagation();
    }
  }, {
    key: '_compile',
    value: function _compile() {
      var _this2 = this;

      autoStyle.prepare(this);

      defaultClassName$14.split(/\s+/).forEach(function (token) {
        return _this2.classList.add(token);
      });

      util$1.addModifier(this, 'mini');
      this._updateRipple();

      ModifierUtil.initModifier(this, scheme$26);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'ripple', 'class'];
    }
  }]);
  return SpeedDialItemElement;
}(BaseElement);

onsElements.SpeedDialItem = SpeedDialItemElement;
customElements.define('ons-speed-dial-item', SpeedDialItemElement);

/*
Copyright 2013-2015 ASIAL CORPORATION
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
   http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

var defaultClassName$15 = 'speed-dial';
var scheme$27 = {
  '': 'speed-dial--*'
};

/**
 * @element ons-speed-dial
 * @category control
 * @description
 *   [en]
 *     Element that displays a Material Design Speed Dialog component. It is useful when there are more than one primary action that can be performed in a page.
 *
 *     The Speed dial looks like a `<ons-fab>` element but will expand a menu when tapped.
 *   [/en]
 *   [ja][/ja]
 * @codepen dYQYLg
 * @tutorial vanilla/Reference/speed-dial
 * @seealso ons-speed-dial-item
 *   [en]The `<ons-speed-dial-item>` represents a menu item.[/en]
 *   [ja]ons-speed-dial-itemコンポーネント[/ja]
 * @seealso ons-fab
 *   [en]ons-fab component[/en]
 *   [ja]ons-fabコンポーネント[/ja]
 * @example
 * <ons-speed-dial position="left bottom">
 *   <ons-fab>
 *     <ons-icon icon="fa-twitter"></ons-icon>
 *   </ons-fab>
 *   <ons-speed-dial-item>A</ons-speed-dial-item>
 *   <ons-speed-dial-item>B</ons-speed-dial-item>
 *   <ons-speed-dial-item>C</ons-speed-dial-item>
 * </ons-speed-dial>
 */

var SpeedDialElement = function (_BaseElement) {
  inherits(SpeedDialElement, _BaseElement);

  /**
   * @event open
   * @description
   *   [en]Fired when the menu items are shown.[/en]
   *   [ja][/ja]
   */

  /**
   * @event close
   * @description
   *   [en]Fired when the menu items are hidden.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the component.[/en]
   *   [ja]このコンポーネントの表現を指定します。[/ja]
   */

  /**
   * @attribute ripple
   * @description
   *  [en]If this attribute is defined, the button will have a ripple effect when tapped.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute position
   * @type {String}
   * @description
   *   [en]
   *     Specify the vertical and horizontal position of the component.
   *     I.e. to display it in the top right corner specify "right top".
   *     Choose from "right", "left", "top" and "bottom".
   *   [/en]
   *   [ja]
   *     この要素を表示する左右と上下の位置を指定します。
   *     例えば、右上に表示する場合には"right top"を指定します。
   *     左右と上下の位置の指定には、rightとleft、topとbottomがそれぞれ指定できます。
   *   [/ja]
   */

  /**
   * @attribute direction
   * @type {String}
   * @description
   *   [en]Specify the direction the items are displayed. Possible values are "up", "down", "left" and "right".[/en]
   *   [ja]
   *     要素が表示する方向を指定します。up, down, left, rightが指定できます。
   *   [/ja]
   */

  /**
   * @attribute disabled
   * @description
   *   [en]Specify if button should be disabled.[/en]
   *   [ja]無効化する場合に指定します。[/ja]
   */

  function SpeedDialElement() {
    classCallCheck(this, SpeedDialElement);

    var _this = possibleConstructorReturn(this, (SpeedDialElement.__proto__ || Object.getPrototypeOf(SpeedDialElement)).call(this));

    contentReady(_this, function () {
      _this._compile();
    });

    _this._itemShown = false;
    _this._boundOnClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(SpeedDialElement, [{
    key: '_compile',
    value: function _compile() {
      this.classList.add(defaultClassName$15);
      autoStyle.prepare(this);
      this._updateRipple();
      ModifierUtil.initModifier(this, scheme$27);

      if (this.hasAttribute('direction')) {
        this._updateDirection(this.getAttribute('direction'));
      } else {
        this._updateDirection('up');
      }

      this._updatePosition();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this2 = this;

      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$15, scheme$27);
          break;
        case 'modifier':
          ModifierUtil.onModifierChanged(last, current, this, scheme$27);
          break;
        case 'ripple':
          contentReady(this, function () {
            return _this2._updateRipple();
          });
          break;
        case 'direction':
          contentReady(this, function () {
            return _this2._updateDirection(current);
          });
          break;
        case 'position':
          contentReady(this, function () {
            return _this2._updatePosition();
          });
          break;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick, false);
    }
  }, {
    key: '_onClick',
    value: function _onClick(e) {
      if (this.onClick) {
        this.onClick.apply(this);
        return Promise.resolve();
      } else if (!this.disabled && this.visible) {
        return this.toggleItems();
      }
    }
  }, {
    key: '_show',
    value: function _show() {
      if (!this.inline) {
        return this.show();
      }
      return Promise.resolve();
    }
  }, {
    key: '_hide',
    value: function _hide() {
      var _this3 = this;

      return new Promise(function (resolve) {
        if (!_this3.inline) {
          setImmediate(function () {
            return _this3.hide().then(resolve);
          });
        } else {
          resolve();
        }
      });
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      if (this._fab) {
        this.hasAttribute('ripple') ? this._fab.setAttribute('ripple', '') : this._fab.removeAttribute('ripple');
      }
    }
  }, {
    key: '_updateDirection',
    value: function _updateDirection(direction) {
      var children = this.items;
      for (var i = 0; i < children.length; i++) {
        styler(children[i], {
          transitionDelay: 25 * i + 'ms',
          bottom: 'auto',
          right: 'auto',
          top: 'auto',
          left: 'auto'
        });
      }
      switch (direction) {
        case 'up':
          for (var _i = 0; _i < children.length; _i++) {
            children[_i].style.bottom = 72 + 56 * _i + 'px';
            children[_i].style.right = '8px';
          }
          break;
        case 'down':
          for (var _i2 = 0; _i2 < children.length; _i2++) {
            children[_i2].style.top = 72 + 56 * _i2 + 'px';
            children[_i2].style.left = '8px';
          }
          break;
        case 'left':
          for (var _i3 = 0; _i3 < children.length; _i3++) {
            children[_i3].style.top = '8px';
            children[_i3].style.right = 72 + 56 * _i3 + 'px';
          }
          break;
        case 'right':
          for (var _i4 = 0; _i4 < children.length; _i4++) {
            children[_i4].style.top = '8px';
            children[_i4].style.left = 72 + 56 * _i4 + 'px';
          }
          break;
        default:
          util$1.throw('Argument must be one of up, down, left or right.');
      }
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var position = this.getAttribute('position');
      this.classList.remove('fab--top__left', 'fab--bottom__right', 'fab--bottom__left', 'fab--top__right', 'fab--top__center', 'fab--bottom__center');
      switch (position) {
        case 'top right':
        case 'right top':
          this.classList.add('fab--top__right');
          break;
        case 'top left':
        case 'left top':
          this.classList.add('fab--top__left');
          break;
        case 'bottom right':
        case 'right bottom':
          this.classList.add('fab--bottom__right');
          break;
        case 'bottom left':
        case 'left bottom':
          this.classList.add('fab--bottom__left');
          break;
        case 'center top':
        case 'top center':
          this.classList.add('fab--top__center');
          break;
        case 'center bottom':
        case 'bottom center':
          this.classList.add('fab--bottom__center');
          break;
        default:
          break;
      }
    }
  }, {
    key: '_getTranslate',
    value: function _getTranslate() {
      var isBottom = (this.getAttribute('position') || '').indexOf('bottom') >= 0;
      var translate = isBottom ? 'translate3d(0px, -' + (util$1.globals.fabOffset || 0) + 'px, 0px) ' : '';
      return translate;
    }

    /**
     * @method show
     * @signature show()
     * @description
     *   [en]Show the speed dial.[/en]
     *   [ja]Speed dialを表示します。[/ja]
     */

  }, {
    key: 'show',
    value: function show() {
      this._fab.show();
      styler(this, { transform: this._getTranslate });
      return Promise.resolve();
    }

    /**
     * @method hide
     * @signature hide()
     * @description
     *   [en]Hide the speed dial.[/en]
     *   [ja]Speed dialを非表示にします。[/ja]
     */

  }, {
    key: 'hide',
    value: function hide() {
      var _this4 = this;

      return this.hideItems().then(function () {
        return _this4._fab.hide();
      });
    }

    /**
     * @method showItems
     * @signature showItems()
     * @description
     *   [en]Show the speed dial items.[/en]
     *   [ja]Speed dialの子要素を表示します。[/ja]
     */

  }, {
    key: 'showItems',
    value: function showItems() {
      if (this.hasAttribute('direction')) {
        this._updateDirection(this.getAttribute('direction'));
      } else {
        this._updateDirection('up');
      }

      var totalDelay = 0;
      if (!this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          var delay = 25 * i;
          totalDelay += delay;
          styler(children[i], {
            transform: 'scale(1)',
            transitionDelay: delay + 'ms'
          });
        }
        totalDelay += 50;

        this._itemShown = true;
        util$1.triggerElementEvent(this, 'open');
      }

      var deferred = util$1.defer();
      setTimeout(deferred.resolve, totalDelay);
      return deferred.promise;
    }

    /**
     * @method hideItems
     * @signature hideItems()
     * @description
     *   [en]Hide the speed dial items.[/en]
     *   [ja]Speed dialの子要素を非表示にします。[/ja]
     */

  }, {
    key: 'hideItems',
    value: function hideItems() {
      var totalDelay = 0;
      if (this._itemShown) {
        var children = this.items;
        for (var i = 0; i < children.length; i++) {
          var delay = 25 * (children.length - i);
          totalDelay += delay;
          styler(children[i], {
            transform: 'scale(0)',
            transitionDelay: delay + 'ms'
          });
        }
        totalDelay += 50;

        this._itemShown = false;
        util$1.triggerElementEvent(this, 'close');
      }

      var deferred = util$1.defer();
      setTimeout(deferred.resolve, totalDelay);
      return deferred.promise;
    }

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

  }, {
    key: 'isOpen',


    /**
     * @method isOpen
     * @signature isOpen()
     * @description
     *   [en]Returns whether the menu is open or not.[/en]
     *   [ja][/ja]
     */
    value: function isOpen() {
      return this._itemShown;
    }

    /**
     * @method toggle
     * @signature toggle()
     * @description
     *   [en]Toggle visibility.[/en]
     *   [ja]Speed dialの表示非表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      return this.visible ? this.hide() : this.show();
    }

    /**
     * @method toggleItems
     * @signature toggleItems()
     * @description
     *   [en]Toggle item visibility.[/en]
     *   [ja]Speed dialの子要素の表示非表示を切り替えます。[/ja]
     */

  }, {
    key: 'toggleItems',
    value: function toggleItems() {
      return this.isOpen() ? this.hideItems() : this.showItems();
    }
  }, {
    key: 'items',
    get: function get$$1() {
      return util$1.arrayFrom(this.querySelectorAll('ons-speed-dial-item'));
    }
  }, {
    key: '_fab',
    get: function get$$1() {
      return util$1.findChild(this, 'ons-fab');
    }
  }, {
    key: 'disabled',
    set: function set$$1(value) {
      if (value) {
        this.hideItems();
      }
      util$1.arrayFrom(this.children).forEach(function (e) {
        util$1.match(e, '.fab') && util$1.toggleAttribute(e, 'disabled', value);
      });

      return util$1.toggleAttribute(this, 'disabled', value);
    },
    get: function get$$1() {
      return this.hasAttribute('disabled');
    }

    /**
     * @property inline
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is inline or not.[/en]
     *   [ja]インライン要素の場合に`true`。[/ja]
     */

  }, {
    key: 'inline',
    get: function get$$1() {
      return this.hasAttribute('inline');
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

  }, {
    key: 'visible',
    get: function get$$1() {
      return this._fab.visible && this.style.display !== 'none';
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['class', 'modifier', 'ripple', 'direction', 'position'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['open', 'close'];
    }
  }]);
  return SpeedDialElement;
}(BaseElement);

onsElements.SpeedDial = SpeedDialElement;
customElements.define('ons-speed-dial', SpeedDialElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var rewritables$1 = {
  /**
   * @param {Element} element
   * @param {Function} callback
   */
  ready: function ready(element, callback) {
    setImmediate(callback);
  }
};

/**
 * @element ons-splitter-content
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-content>` element is used as a child element of `<ons-splitter>`.
 *
 *    It contains the main content of the page while `<ons-splitter-side>` contains the list.
 *  [/en]
 *  [ja]ons-splitter-content要素は、ons-splitter要素の子要素として利用します。[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` component is the parent element.[/en]
 *  [ja]ons-splitterコンポーネント[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-sideコンポーネント[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */

var SplitterContentElement = function (_BaseElement) {
  inherits(SplitterContentElement, _BaseElement);

  /**
   * @attribute page
   * @type {String}
   * @description
   *   [en]
   *     The url of the content page. If this attribute is used the content will be loaded from a `<template>` tag or a remote file.
   *
   *     It is also possible to put `<ons-page>` element as a child of the element.
   *   [/en]
   *   [ja]ons-splitter-content要素に表示するページのURLを指定します。[/ja]
   */

  function SplitterContentElement() {
    classCallCheck(this, SplitterContentElement);

    var _this = possibleConstructorReturn(this, (SplitterContentElement.__proto__ || Object.getPrototypeOf(SplitterContentElement)).call(this));

    _this._page = null;
    _this._pageLoader = defaultPageLoader;

    contentReady(_this, function () {
      rewritables$1.ready(_this, function () {
        var page = _this._getPageTarget();

        if (page) {
          _this.load(page);
        }
      });
    });
    return _this;
  }

  createClass(SplitterContentElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      if (!util$1.match(this.parentNode, 'ons-splitter')) {
        util$1.throw('"ons-splitter-content" must have "ons-splitter" as parent');
      }
    }
  }, {
    key: '_getPageTarget',
    value: function _getPageTarget() {
      return this._page || this.getAttribute('page');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {}
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}

    /**
     * @property page
     * @type {HTMLElement}
     * @description
     *   [en]The page to load in the splitter content.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'load',


    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page, [options]
     *   [en]Page URL. Can be either an HTML document or an `<template>` id.[/en]
     *   [ja]pageのURLか、`<template>`で宣言したテンプレートのid属性の値を指定します。[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in `page` in the content.[/en]
     *   [ja]指定したURLをメインページを読み込みます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new `<ons-page>` element[/en]
     *   [ja]`<ons-page>`要素を解決するPromiseオブジェクトを返します。[/ja]
     */
    value: function load(page) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this2._content || null;

        _this2._pageLoader.load({ page: page, parent: _this2 }, function (pageElement) {
          if (oldContent) {
            _this2._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this2._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      if (this._content) {
        this._content._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._content) {
        this._content._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      if (this._content) {
        this._pageLoader.unload(this._content);
      }
      this.remove();
    }
  }, {
    key: 'page',
    get: function get$$1() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set$$1(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get$$1() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @type {Function}
     * @description
     *   [en]Page element loaded in the splitter content.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get$$1() {
      return this._pageLoader;
    },
    set: function set$$1(loader) {
      if (!(loader instanceof PageLoader)) {
        util$1.throwPageLoader();
      }
      this._pageLoader = loader;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables$1;
    }
  }]);
  return SplitterContentElement;
}(BaseElement);

onsElements.SplitterContent = SplitterContentElement;
customElements.define('ons-splitter-content', SplitterContentElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterMaskElement = function (_BaseElement) {
  inherits(SplitterMaskElement, _BaseElement);

  function SplitterMaskElement() {
    classCallCheck(this, SplitterMaskElement);

    var _this = possibleConstructorReturn(this, (SplitterMaskElement.__proto__ || Object.getPrototypeOf(SplitterMaskElement)).call(this));

    _this._boundOnClick = _this._onClick.bind(_this);
    contentReady(_this, function () {
      if (_this.parentNode._sides.every(function (side) {
        return side.mode === 'split';
      })) {
        _this.setAttribute('style', 'display: none !important');
      }
    });
    return _this;
  }

  createClass(SplitterMaskElement, [{
    key: '_onClick',
    value: function _onClick(event) {
      if (this.onClick instanceof Function) {
        this.onClick();
      } else if (util$1.match(this.parentNode, 'ons-splitter')) {
        this.parentNode._sides.forEach(function (side) {
          return side.close('left').catch(function () {});
        });
      }
      event.stopPropagation();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.addEventListener('click', this._boundOnClick);
      util$1.iosMaskScrollFix(this, true);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._boundOnClick);
      util$1.iosMaskScrollFix(this, false);
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [];
    }
  }]);
  return SplitterMaskElement;
}(BaseElement);

onsElements.SplitterMask = SplitterMaskElement;
customElements.define('ons-splitter-mask', SplitterMaskElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SplitterAnimator$1 = function (_BaseAnimator) {
  inherits(SplitterAnimator, _BaseAnimator);

  function SplitterAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'cubic-bezier(.1, .7, .1, 1)' : _ref$timing,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay;

    classCallCheck(this, SplitterAnimator);
    return possibleConstructorReturn(this, (SplitterAnimator.__proto__ || Object.getPrototypeOf(SplitterAnimator)).call(this, { timing: timing, duration: duration, delay: delay }));
  }

  createClass(SplitterAnimator, [{
    key: 'updateOptions',
    value: function updateOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      util$1.extend(this, {
        timing: this.timing, duration: this.duration, delay: this.delay
      }, options);
    }

    /**
     * @param {Element} sideElement
     */

  }, {
    key: 'activate',
    value: function activate(sideElement) {
      var _this2 = this;

      var splitter = sideElement.parentNode;

      contentReady(splitter, function () {
        _this2._side = sideElement;
        _this2._oppositeSide = splitter.right !== sideElement && splitter.right || splitter.left !== sideElement && splitter.left;
        _this2._content = splitter.content;
        _this2._mask = splitter.mask;
      });
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      this.clearTransition();
      this._mask && this.clearMask();
      this._content = this._side = this._oppositeSide = this._mask = null;
    }
  }, {
    key: 'clearTransition',
    value: function clearTransition() {
      var _this3 = this;

      'side mask content'.split(/\s+/).forEach(function (e) {
        return _this3['_' + e] && styler.clear(_this3['_' + e], 'transform transition');
      });
    }
  }, {
    key: 'clearMask',
    value: function clearMask() {
      // Check if the other side needs the mask before clearing
      if (!this._oppositeSide || this._oppositeSide.mode === 'split' || !this._oppositeSide.isOpen) {
        this._mask.style.opacity = '';
        this._mask.style.display = 'none';
      }
    }

    /**
     * @param {Number} distance
     */

  }, {
    key: 'translate',
    value: function translate(distance) {}

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      done();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      done();
    }
  }, {
    key: 'minus',
    get: function get$$1() {
      return this._side.side === 'right' ? '-' : '';
    }
  }]);
  return SplitterAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var OverlaySplitterAnimator = function (_SplitterAnimator) {
  inherits(OverlaySplitterAnimator, _SplitterAnimator);

  function OverlaySplitterAnimator() {
    classCallCheck(this, OverlaySplitterAnimator);
    return possibleConstructorReturn(this, (OverlaySplitterAnimator.__proto__ || Object.getPrototypeOf(OverlaySplitterAnimator)).apply(this, arguments));
  }

  createClass(OverlaySplitterAnimator, [{
    key: 'translate',
    value: function translate(distance) {
      this._mask.style.display = 'block'; // Avoid content clicks

      Animit(this._side).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0, 0)'
      }).play();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      Animit.runAll(Animit(this._side).wait(this.delay).queue({
        transform: 'translate3d(' + this.minus + '100%, 0, 0)'
      }, this.def).queue(function (callback) {
        callback();
        done && done();
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'block'
      }).queue({
        opacity: '1'
      }, {
        duration: this.duration,
        timing: 'linear'
      }));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {

      Animit.runAll(Animit(this._side).wait(this.delay).queue({
        transform: 'translate3d(0, 0, 0)'
      }, this.def).queue(function (callback) {
        done && done();
        callback();
      }), Animit(this._mask).wait(this.delay).queue({
        opacity: '0'
      }, {
        duration: this.duration,
        timing: 'linear'
      }).queue({
        display: 'none'
      }));
    }
  }]);
  return OverlaySplitterAnimator;
}(SplitterAnimator$1);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var PushSplitterAnimator = function (_SplitterAnimator) {
  inherits(PushSplitterAnimator, _SplitterAnimator);

  function PushSplitterAnimator() {
    classCallCheck(this, PushSplitterAnimator);
    return possibleConstructorReturn(this, (PushSplitterAnimator.__proto__ || Object.getPrototypeOf(PushSplitterAnimator)).apply(this, arguments));
  }

  createClass(PushSplitterAnimator, [{
    key: '_getSlidingElements',
    value: function _getSlidingElements() {
      var slidingElements = [this._side, this._content];
      if (this._oppositeSide && this._oppositeSide.mode === 'split') {
        slidingElements.push(this._oppositeSide);
      }

      return slidingElements;
    }
  }, {
    key: 'translate',
    value: function translate(distance) {
      if (!this._slidingElements) {
        this._slidingElements = this._getSlidingElements();
      }

      this._mask.style.display = 'block'; // Avoid content clicks

      Animit(this._slidingElements).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0, 0)'
      }).play();
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      var _this2 = this;

      var max = this._side.offsetWidth;
      this._slidingElements = this._getSlidingElements();

      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
        transform: 'translate3d(' + (this.minus + max) + 'px, 0, 0)'
      }, this.def).queue(function (callback) {
        _this2._slidingElements = null;
        callback();
        done && done();
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'block'
      }));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      var _this3 = this;

      this._slidingElements = this._getSlidingElements();

      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
        transform: 'translate3d(0, 0, 0)'
      }, this.def).queue(function (callback) {
        _this3._slidingElements = null;
        get(PushSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(PushSplitterAnimator.prototype), 'clearTransition', _this3).call(_this3);
        done && done();
        callback();
      }), Animit(this._mask).wait(this.delay).queue({
        display: 'none'
      }));
    }
  }]);
  return PushSplitterAnimator;
}(SplitterAnimator$1);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var RevealSplitterAnimator = function (_SplitterAnimator) {
  inherits(RevealSplitterAnimator, _SplitterAnimator);

  function RevealSplitterAnimator() {
    classCallCheck(this, RevealSplitterAnimator);
    return possibleConstructorReturn(this, (RevealSplitterAnimator.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator)).apply(this, arguments));
  }

  createClass(RevealSplitterAnimator, [{
    key: '_getSlidingElements',
    value: function _getSlidingElements() {
      var slidingElements = [this._content, this._mask];
      if (this._oppositeSide && this._oppositeSide.mode === 'split') {
        slidingElements.push(this._oppositeSide);
      }

      return slidingElements;
    }
  }, {
    key: 'activate',
    value: function activate(sideElement) {
      get(RevealSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator.prototype), 'activate', this).call(this, sideElement);
      if (sideElement.mode === 'collapse') {
        this._setStyles(sideElement);
      }
    }
  }, {
    key: 'deactivate',
    value: function deactivate() {
      this._side && this._unsetStyles(this._side);
      get(RevealSplitterAnimator.prototype.__proto__ || Object.getPrototypeOf(RevealSplitterAnimator.prototype), 'deactivate', this).call(this);
    }
  }, {
    key: '_setStyles',
    value: function _setStyles(sideElement) {
      styler(sideElement, {
        left: sideElement.side === 'right' ? 'auto' : 0,
        right: sideElement.side === 'right' ? 0 : 'auto',
        zIndex: 0,
        backgroundColor: 'black',
        transform: this._generateBehindPageStyle(0).container.transform,
        display: 'none'
      });

      var splitter = sideElement.parentElement;
      contentReady(splitter, function () {
        return splitter.content && styler(splitter.content, { boxShadow: '0 0 12px 0 rgba(0, 0, 0, 0.2)' });
      });
    }
  }, {
    key: '_unsetStyles',
    value: function _unsetStyles(sideElement) {
      styler.clear(sideElement, 'left right zIndex backgroundColor display');
      if (sideElement._content) {
        sideElement._content.style.opacity = '';
      }

      // Check if the other side needs the common styles
      if (!this._oppositeSide || this._oppositeSide.mode === 'split') {
        sideElement.parentElement.content && styler.clear(sideElement.parentElement.content, 'boxShadow');
      }
    }
  }, {
    key: '_generateBehindPageStyle',
    value: function _generateBehindPageStyle(distance) {
      var max = this.maxWidth;

      var behindDistance = (distance - max) / max * 10;
      behindDistance = isNaN(behindDistance) ? 0 : Math.max(Math.min(behindDistance, 0), -10);

      var behindTransform = 'translate3d(' + (this.minus ? -1 : 1) * behindDistance + '%, 0, 0)';
      var opacity = 1 + behindDistance / 100;

      return {
        content: {
          opacity: opacity
        },
        container: {
          transform: behindTransform
        }
      };
    }
  }, {
    key: 'translate',
    value: function translate(distance) {
      this._side.style.display = '';
      this._side.style.zIndex = 1;
      this.maxWidth = this.maxWidth || this._getMaxWidth();
      var menuStyle = this._generateBehindPageStyle(Math.min(distance, this.maxWidth));

      if (!this._slidingElements) {
        this._slidingElements = this._getSlidingElements();
      }

      this._mask.style.display = 'block'; // Avoid content clicks

      Animit.runAll(Animit(this._slidingElements).queue({
        transform: 'translate3d(' + (this.minus + distance) + 'px, 0, 0)'
      }), Animit(this._side._content).queue(menuStyle.content), Animit(this._side).queue(menuStyle.container));
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'open',
    value: function open(done) {
      var _this2 = this;

      this._side.style.display = '';
      this._side.style.zIndex = 1;
      this.maxWidth = this.maxWidth || this._getMaxWidth();
      var menuStyle = this._generateBehindPageStyle(this.maxWidth);
      this._slidingElements = this._getSlidingElements();

      setTimeout(function () {
        // Fix: Time to update previous translate3d after changing style.display
        Animit.runAll(Animit(_this2._slidingElements).wait(_this2.delay).queue({
          transform: 'translate3d(' + (_this2.minus + _this2.maxWidth) + 'px, 0, 0)'
        }, _this2.def), Animit(_this2._mask).wait(_this2.delay).queue({
          display: 'block'
        }), Animit(_this2._side._content).wait(_this2.delay).queue(menuStyle.content, _this2.def), Animit(_this2._side).wait(_this2.delay).queue(menuStyle.container, _this2.def).queue(function (callback) {
          _this2._slidingElements = null;
          callback();
          done && done();
        }));
      }, 1000 / 60);
    }

    /**
     * @param {Function} done
     */

  }, {
    key: 'close',
    value: function close(done) {
      var _this3 = this;

      var menuStyle = this._generateBehindPageStyle(0);
      this._slidingElements = this._getSlidingElements();

      Animit.runAll(Animit(this._slidingElements).wait(this.delay).queue({
        transform: 'translate3d(0, 0, 0)'
      }, this.def), Animit(this._mask).wait(this.delay).queue({
        display: 'none'
      }), Animit(this._side._content).wait(this.delay).queue(menuStyle.content, this.def), Animit(this._side).wait(this.delay).queue(menuStyle.container, this.def).queue(function (callback) {
        _this3._slidingElements = null;
        _this3._side.style.zIndex = 0;
        _this3._side.style.display = 'none';
        _this3._side._content.style.opacity = '';
        done && done();
        callback();
      }));
    }
  }, {
    key: '_getMaxWidth',
    value: function _getMaxWidth() {
      return this._side.offsetWidth;
    }
  }]);
  return RevealSplitterAnimator;
}(SplitterAnimator$1);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var _animatorDict$7 = {
  default: OverlaySplitterAnimator,
  overlay: OverlaySplitterAnimator,
  push: PushSplitterAnimator,
  reveal: RevealSplitterAnimator
};

/**
 * @element ons-splitter
 * @category menu
 * @description
 *  [en]
 *    A component that enables responsive layout by implementing both a two-column layout and a sliding menu layout.
 *
 *    It can be configured to automatically expand into a column layout on large screens and collapse the menu on smaller screens. When the menu is collapsed the user can open it by swiping.
 *  [/en]
 *  [ja][/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-contentコンポーネント[/ja]
 * @seealso ons-splitter-side
 *  [en]The `<ons-splitter-side>` component contains the menu.[/en]
 *  [ja]ons-splitter-sideコンポーネント[/ja]
 * @example
 * <ons-splitter id="splitter">
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse swipeable>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 *
 * <script>
 *   var splitter = document.getElementById('splitter');
 *   splitter.left.open();
 * </script>
 */

var SplitterElement = function (_BaseElement) {
  inherits(SplitterElement, _BaseElement);
  createClass(SplitterElement, [{
    key: '_getSide',
    value: function _getSide(side) {
      var element = util$1.findChild(this, function (e) {
        return util$1.match(e, 'ons-splitter-side') && e.getAttribute('side') === side;
      });
      return element;
    }

    /**
     * @property left
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Left `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: '_onDeviceBackButton',
    value: function _onDeviceBackButton(event) {
      this._sides.some(function (s) {
        return s.isOpen ? s.close() : false;
      }) || event.callParentHandler();
    }
  }, {
    key: '_onModeChange',
    value: function _onModeChange(e) {
      var _this2 = this;

      if (e.target.parentNode) {
        contentReady(this, function () {
          _this2._layout();
        });
      }
    }
  }, {
    key: '_layout',
    value: function _layout() {
      var _this3 = this;

      this._sides.forEach(function (side) {
        if (_this3.content) {
          _this3.content.style[side.side] = side.mode === 'split' ? side.style.width : 0;
        }
      });
    }
  }, {
    key: 'left',
    get: function get$$1() {
      return this._getSide('left');
    }
    /**
     * @property right
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]Right `<ons-splitter-side>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'right',
    get: function get$$1() {
      return this._getSide('right');
    }

    /**
     * @property side
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]First `<ons-splitter-side>` element regardless the actual side.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'side',
    get: function get$$1() {
      return util$1.findChild(this, 'ons-splitter-side');
    }
  }, {
    key: '_sides',
    get: function get$$1() {
      return [this.left, this.right].filter(function (e) {
        return e;
      });
    }
    /**
     * @property content
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The `<ons-splitter-content>` element.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'content',
    get: function get$$1() {
      return util$1.findChild(this, 'ons-splitter-content');
    }
  }, {
    key: 'topPage',
    get: function get$$1() {
      return this.content._content;
    }
  }, {
    key: 'mask',
    get: function get$$1() {
      return util$1.findChild(this, 'ons-splitter-mask');
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: 'onDeviceBackButton',
    get: function get$$1() {
      return this._backButtonHandler;
    },
    set: function set$$1(callback) {
      if (this._backButtonHandler) {
        this._backButtonHandler.destroy();
      }

      this._backButtonHandler = deviceBackButtonDispatcher.createHandler(this, callback);
    }
  }]);

  function SplitterElement() {
    classCallCheck(this, SplitterElement);

    var _this = possibleConstructorReturn(this, (SplitterElement.__proto__ || Object.getPrototypeOf(SplitterElement)).call(this));

    _this._onModeChange = _this._onModeChange.bind(_this);

    contentReady(_this, function () {
      !_this.mask && _this.appendChild(document.createElement('ons-splitter-mask'));
      _this._layout();
    });
    return _this;
  }

  createClass(SplitterElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      this.onDeviceBackButton = this._onDeviceBackButton.bind(this);
      this.addEventListener('modechange', this._onModeChange, false);
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._backButtonHandler.destroy();
      this._backButtonHandler = null;
      this.removeEventListener('modechange', this._onModeChange, false);
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {}
  }, {
    key: '_show',
    value: function _show() {
      util$1.propagateAction(this, '_show');
    }
  }, {
    key: '_hide',
    value: function _hide() {
      util$1.propagateAction(this, '_hide');
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      util$1.propagateAction(this, '_destroy');
      this.remove();
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator instanceof SplitterAnimator)) {
        util$1.throwAnimator('Splitter');
      }
      _animatorDict$7[name] = Animator;
    }
  }, {
    key: 'SplitterAnimator',
    get: function get$$1() {
      return SplitterAnimator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$7;
    }
  }]);
  return SplitterElement;
}(BaseElement);

onsElements.Splitter = SplitterElement;
customElements.define('ons-splitter', SplitterElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var SPLIT_MODE = 'split';
var COLLAPSE_MODE = 'collapse';
var CLOSED_STATE = 'closed';
var OPEN_STATE = 'open';
var CHANGING_STATE = 'changing';

var rewritables$2 = {
  /**
   * @param {Element} splitterSideElement
   * @param {Function} callback
   */
  ready: function ready(splitterSideElement, callback) {
    setImmediate(callback);
  }
};

var CollapseDetection = function () {
  function CollapseDetection(element, target) {
    classCallCheck(this, CollapseDetection);

    this._element = element;
    this._onChange = this._onChange.bind(this);
    target && this.changeTarget(target);
  }

  createClass(CollapseDetection, [{
    key: 'changeTarget',
    value: function changeTarget(target) {
      this.disable();
      this._target = target;
      if (target) {
        this._orientation = ['portrait', 'landscape'].indexOf(target) !== -1;
        this.activate();
      }
    }
  }, {
    key: '_match',
    value: function _match(value) {
      if (this._orientation) {
        return this._target === (value.isPortrait ? 'portrait' : 'landscape');
      }
      return value.matches;
    }
  }, {
    key: '_onChange',
    value: function _onChange(value) {
      this._element._updateMode(this._match(value) ? COLLAPSE_MODE : SPLIT_MODE);
    }
  }, {
    key: 'activate',
    value: function activate() {
      if (this._orientation) {
        orientation.on('change', this._onChange);
        this._onChange({ isPortrait: orientation.isPortrait() });
      } else {
        this._queryResult = window.matchMedia(this._target);
        this._queryResult.addListener(this._onChange);
        this._onChange(this._queryResult);
      }
    }
  }, {
    key: 'disable',
    value: function disable() {
      if (this._orientation) {
        orientation.off('change', this._onChange);
      } else if (this._queryResult) {
        this._queryResult.removeListener(this._onChange);
        this._queryResult = null;
      }
    }
  }]);
  return CollapseDetection;
}();

/**
 * @element ons-splitter-side
 * @category menu
 * @description
 *  [en]
 *    The `<ons-splitter-side>` element is used as a child element of `<ons-splitter>`.
 *
 *    It will be displayed on either the left or right side of the `<ons-splitter-content>` element.
 *
 *    It supports two modes: collapsed and split. When it's in collapsed mode it will be hidden from view and can be displayed when the user swipes the screen or taps a button. In split mode the element is always shown. It can be configured to automatically switch between the two modes depending on the screen size.
 *  [/en]
 *  [ja]ons-splitter-side要素は、ons-splitter要素の子要素として利用します。[/ja]
 * @codepen rOQOML
 * @tutorial vanilla/Reference/splitter
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-splitter
 *  [en]The `<ons-splitter>` is the parent component.[/en]
 *  [ja]ons-splitterコンポーネント[/ja]
 * @seealso ons-splitter-content
 *  [en]The `<ons-splitter-content>` component contains the main content of the page.[/en]
 *  [ja]ons-splitter-contentコンポーネント[/ja]
 * @example
 * <ons-splitter>
 *   <ons-splitter-content>
 *     ...
 *   </ons-splitter-content>
 *
 *   <ons-splitter-side side="left" width="80%" collapse>
 *     ...
 *   </ons-splitter-side>
 * </ons-splitter>
 */

var SplitterSideElement = function (_BaseElement) {
  inherits(SplitterSideElement, _BaseElement);

  /**
   * @event modechange
   * @description
   *   [en]Fired just after the component's mode changes.[/en]
   *   [ja]この要素のモードが変化した際に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {String} event.mode
   *   [en]Returns the current mode. Can be either `"collapse"` or `"split"`.[/en]
   *   [ja]現在のモードを返します。[/ja]
   */

  /**
   * @event preopen
   * @description
   *   [en]Fired just before the sliding menu is opened.[/en]
   *   [ja]スライディングメニューが開く前に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Function} event.cancel
   *   [en]Call to cancel opening sliding menu.[/en]
   *   [ja]スライディングメニューが開くのをキャンセルします。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event postopen
   * @description
   *   [en]Fired just after the sliding menu is opened.[/en]
   *   [ja]スライディングメニューが開いた後に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @event preclose
   * @description
   *   [en]Fired just before the sliding menu is closed.[/en]
   *   [ja]スライディングメニューが閉じる前に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call to cancel opening sliding-menu.[/en]
   *   [ja]スライディングメニューが閉じるのをキャンセルします。[/ja]
   */

  /**
   * @event postclose
   * @description
   *   [en]Fired just after the sliding menu is closed.[/en]
   *   [ja]スライディングメニューが閉じた後に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクトです。[/ja]
   * @param {Object} event.side
   *   [en]Component object.[/en]
   *   [ja]コンポーネントのオブジェクト。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default  default
   * @description
   *  [en]Specify the animation. Use one of `overlay`, `push`, `reveal` or  `default`.[/en]
   *  [ja]アニメーションを指定します。"overlay", "push", "reveal", "default"のいずれかを指定できます。[/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute open-threshold
   * @type {Number}
   * @default  0.3
   * @description
   *  [en]Specify how much the menu needs to be swiped before opening. A value between `0` and `1`.[/en]
   *  [ja]どのくらいスワイプすればスライディングメニューを開くかどうかの割合を指定します。0から1の間の数値を指定します。スワイプの距離がここで指定した数値掛けるこの要素の幅よりも大きければ、スワイプが終わった時にこの要素を開きます。デフォルトは0.3です。[/ja]
   */

  /**
   * @attribute collapse
   * @type {String}
   * @description
   *   [en]
   *     Specify the collapse behavior. Valid values are `"portrait"`, `"landscape"` or a media query.
   *     The strings `"portrait"` and `"landscape"` means the view will collapse when device is in landscape or portrait orientation.
   *     If the value is a media query, the view will collapse when the media query resolves to `true`.
   *     If the value is not defined, the view always be in `"collapse"` mode.
   *   [/en]
   *   [ja]
   *     左側のページを非表示にする条件を指定します。portrait, landscape、width #pxもしくはメディアクエリの指定が可能です。
   *     portraitもしくはlandscapeを指定すると、デバイスの画面が縦向きもしくは横向きになった時に適用されます。
   *     メディアクエリを指定すると、指定したクエリに適合している場合に適用されます。
   *     値に何も指定しない場合には、常にcollapseモードになります。
   *   [/ja]
   */

  /**
   * @attribute swipe-target-width
   * @type {String}
   * @description
   *   [en]The width of swipeable area calculated from the edge (in pixels). Use this to enable swipe only when the finger touch on the screen edge.[/en]
   *   [ja]スワイプの判定領域をピクセル単位で指定します。画面の端から指定した距離に達するとページが表示されます。[/ja]
   */

  /**
   * @attribute width
   * @type {String}
   * @description
   *   [en]Can be specified in either pixels or as a percentage, e.g. `90%` or `200px`.[/en]
   *   [ja]この要素の横幅を指定します。pxと%での指定が可能です。eg. 90%, 200px[/ja]
   */

  /**
   * @attribute side
   * @type {String}
   * @default left
   * @description
   *   [en]Specify which side of the screen the `<ons-splitter-side>` element is located. Possible values are `"left"` and `"right"`.[/en]
   *   [ja]この要素が左か右かを指定します。指定できる値は"left"か"right"のみです。[/ja]
   */

  /**
   * @attribute mode
   * @type {String}
   * @description
   *   [en]Current mode. Possible values are `"collapse"` or `"split"`. This attribute is read only.[/en]
   *   [ja]現在のモードが設定されます。"collapse"もしくは"split"が指定されます。この属性は読み込み専用です。[/ja]
   */

  /**
   * @attribute page
   * @initonly
   * @type {String}
   * @description
   *   [en]The URL of the menu page.[/en]
   *   [ja]ons-splitter-side要素に表示するページのURLを指定します。[/ja]
   */

  /**
   * @attribute swipeable
   * @type {Boolean}
   * @description
   *   [en]Whether to enable swipe interaction on collapse mode.[/en]
   *   [ja]collapseモード時にスワイプ操作を有効にする場合に指定します。[/ja]
   */

  function SplitterSideElement() {
    classCallCheck(this, SplitterSideElement);

    var _this = possibleConstructorReturn(this, (SplitterSideElement.__proto__ || Object.getPrototypeOf(SplitterSideElement)).call(this));

    _this._page = null;
    _this._state = CLOSED_STATE;
    _this._lock = new DoorLock();
    _this._pageLoader = defaultPageLoader;
    _this._collapseDetection = new CollapseDetection(_this);

    _this._animatorFactory = new AnimatorFactory({
      animators: SplitterElement.animators,
      baseClass: SplitterAnimator$1,
      baseClassName: 'SplitterAnimator',
      defaultAnimation: _this.getAttribute('animation')
    });

    contentReady(_this, function () {
      // These attributes are used early by the parent element
      _this.attributeChangedCallback('width');
      if (!_this.hasAttribute('side')) {
        _this.setAttribute('side', 'left');
      }

      rewritables$2.ready(_this, function () {
        var page = _this._page || _this.getAttribute('page');
        page && _this.load(page);
      });
    });
    return _this;
  }

  createClass(SplitterSideElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (!util$1.match(this.parentNode, 'ons-splitter')) {
        util$1.throw('Parent must be an ons-splitter element');
      }

      this._swipe = new SwipeReveal({
        element: this,
        elementHandler: this.parentElement,
        swipeMax: function swipeMax() {
          _this2._onSwipe && _this2._onSwipe(1, _this2._animationOpt);
          _this2.open();
        },
        swipeMid: function swipeMid(distance, width) {
          _this2._onSwipe && _this2._onSwipe(distance / width);
          _this2._animator.translate(distance);
        },
        swipeMin: function swipeMin() {
          _this2._onSwipe && _this2._onSwipe(0, _this2._animationOpt);
          _this2.close();
        },
        getThreshold: function getThreshold() {
          return Math.max(0, Math.min(1, parseFloat(_this2.getAttribute('open-threshold')) || 0.3));
        },
        getSide: function getSide() {
          return _this2.side;
        },
        isInitialState: function isInitialState() {
          var closed = _this2._state === CLOSED_STATE;
          _this2._state = CHANGING_STATE;
          return closed;
        },
        ignoreSwipe: function ignoreSwipe(event, distance) {
          var isOpen = _this2.isOpen;
          var validDrag = function validDrag(d) {
            return _this2.side === 'left' ? d === 'left' && isOpen || d === 'right' && !isOpen : d === 'left' && !isOpen || d === 'right' && isOpen;
          };

          var area = Math.max(0, parseInt(_this2.getAttribute('swipe-target-width'), 10) || 0);

          return _this2._mode === SPLIT_MODE || _this2._lock.isLocked() || _this2._isOtherSideOpen() || !validDrag(event.gesture.direction) || !isOpen && area !== 0 && distance > area;
        }
      });

      this.attributeChangedCallback('swipeable');

      contentReady(this, function () {
        _this2.constructor.observedAttributes.forEach(function (attr) {
          return _this2.attributeChangedCallback(attr, null, _this2.getAttribute(attr));
        });
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this._swipe && this._swipe.dispose();
      this._animator = this._animationOpt = this._swipe = null;
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      switch (name) {
        case 'swipeable':
          this._swipe && this._swipe.update();
          break;
        case 'width':
          current = this.getAttribute('width'); // Sometimes undefined. CE bug?
          this.style.width = /^\d+(px|%)$/.test(current) ? current : '80%';
          break;
        default:
          this[util$1.camelize('_update-' + name)](current);
      }
    }
  }, {
    key: '_emitEvent',
    value: function _emitEvent(name) {
      if (name.slice(0, 3) !== 'pre') {
        return util$1.triggerElementEvent(this, name, { side: this });
      }
      var isCanceled = false;

      util$1.triggerElementEvent(this, name, {
        side: this,
        cancel: function cancel() {
          return isCanceled = true;
        }
      });

      return isCanceled;
    }
  }, {
    key: '_isOtherSideOpen',
    value: function _isOtherSideOpen() {
      var _this3 = this;

      return !!util$1.findChild(this.parentElement, function (el) {
        return el instanceof _this3.constructor && el !== _this3 && el._mode === COLLAPSE_MODE && el.isOpen;
      });
    }
  }, {
    key: '_updateCollapse',
    value: function _updateCollapse() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('collapse');

      if (value === null || value === 'split') {
        this._collapseDetection.disable();
        return this._updateMode(SPLIT_MODE);
      }
      if (value === '' || value === 'collapse') {
        this._collapseDetection.disable();
        return this._updateMode(COLLAPSE_MODE);
      }

      this._collapseDetection.changeTarget(value);
    }
  }, {
    key: '_updateMode',
    value: function _updateMode(mode) {
      if (mode !== this._mode) {
        this._mode = mode;
        this.setAttribute('mode', mode); // readonly attribute for the users

        if (mode === SPLIT_MODE) {
          this._animator && this._animator.deactivate();
          this._state = CLOSED_STATE;
        } else {
          this._animator && this._animator.activate(this);
          this._state === OPEN_STATE && this._animator.open();
        }

        util$1.triggerElementEvent(this, 'modechange', { side: this, mode: mode });
      }
    }
  }, {
    key: '_updateAnimation',
    value: function _updateAnimation() {
      var animation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation');

      if (this.parentNode) {
        this._animator && this._animator.deactivate();
        this._animator = this._animatorFactory.newAnimator({ animation: animation });
        this._animator.activate(this);
        this._animationOpt = {
          timing: this._animator.duration,
          duration: this._animator.duration
        };
      }
    }
  }, {
    key: '_updateAnimationOptions',
    value: function _updateAnimationOptions() {
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('animation-options');

      this._animator.updateOptions(AnimatorFactory.parseAnimationOptionsString(value));
    }

    /**
     * @property page
     * @type {*}
     * @description
     *   [en]Page location to load in the splitter side.[/en]
     *   [ja]この要素内に表示するページを指定します。[/ja]
     */

  }, {
    key: 'open',


    /**
     * @method open
     * @signature open([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been opened.[/en]
     *   [ja]メニューが開いた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Open menu in collapse mode.[/en]
     *   [ja]collapseモードになっているons-splitter-side要素を開きます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */
    value: function open(options) {
      return this.toggle(options, true);
    }

    /**
     * @method close
     * @signature close([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]This function will be called after the menu has been closed.[/en]
     *   [ja]メニューが閉じた後に呼び出される関数オブジェクトを指定します。[/ja]
     * @description
     *   [en]Close menu in collapse mode.[/en]
     *   [ja]collapseモードになっているons-splitter-side要素を閉じます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'close',
    value: function close(options) {
      return this.toggle(options, false);
    }

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     * @description
     *   [en]Opens if it's closed. Closes if it's open.[/en]
     *   [ja]開けている場合は要素を閉じますそして開けている場合は要素を開きます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the splitter side element or false if not in collapse mode[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      var _this4 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var force = arguments[1];

      var shouldOpen = typeof force === 'boolean' ? force : !this.isOpen;
      var action = shouldOpen ? 'open' : 'close',
          FINAL_STATE = shouldOpen ? OPEN_STATE : CLOSED_STATE;

      if (this._mode === SPLIT_MODE) {
        return Promise.resolve(false);
      }
      if (this._state === FINAL_STATE) {
        return Promise.resolve(this);
      }
      if (this._lock.isLocked()) {
        return Promise.reject('Another splitter-side action is already running.');
      }
      if (shouldOpen && this._isOtherSideOpen()) {
        return Promise.reject('Another menu is already open.');
      }
      if (this._emitEvent('pre' + action)) {
        return Promise.reject('Canceled in pre' + action + ' event.');
      }

      var unlock = this._lock.lock();
      this._state = CHANGING_STATE;

      return new Promise(function (resolve) {
        _this4._animator[action](function () {
          util$1.iosPageScrollFix(shouldOpen);
          _this4._state = FINAL_STATE;
          unlock();
          _this4._emitEvent('post' + action);
          options.callback instanceof Function && options.callback(_this4);
          resolve(_this4);
        });
      });
    }

    /**
     * @method load
     * @signature load(page, [options])
     * @param {String} page
     *   [en]Page URL. Can be either an HTML document or a `<template>`.[/en]
     *   [ja]pageのURLか、`<template>`で宣言したテンプレートのid属性の値を指定します。[/ja]
     * @param {Object} [options]
     * @param {Function} [options.callback]
     * @description
     *   [en]Show the page specified in pageUrl in the right section[/en]
     *   [ja]指定したURLをメインページを読み込みます。[/ja]
     * @return {Promise}
     *   [en]Resolves to the new page element[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'load',
    value: function load(page) {
      var _this5 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._page = page;
      var callback = options.callback || function () {};

      return new Promise(function (resolve) {
        var oldContent = _this5._content || null;

        _this5._pageLoader.load({ page: page, parent: _this5 }, function (pageElement) {
          if (oldContent) {
            _this5._pageLoader.unload(oldContent);
            oldContent = null;
          }

          setImmediate(function () {
            return _this5._show();
          });

          callback(pageElement);
          resolve(pageElement);
        });
      });
    }
  }, {
    key: '_show',
    value: function _show() {
      if (this._content) {
        this._content._show();
      }
    }
  }, {
    key: '_hide',
    value: function _hide() {
      if (this._content) {
        this._content._hide();
      }
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      if (this._content) {
        this._pageLoader.unload(this._content);
      }
      this.remove();
    }
  }, {
    key: 'side',
    get: function get$$1() {
      return this.getAttribute('side') === 'right' ? 'right' : 'left';
    }
  }, {
    key: 'page',
    get: function get$$1() {
      return this._page;
    }

    /**
     * @param {*} page
     */
    ,
    set: function set$$1(page) {
      this._page = page;
    }
  }, {
    key: '_content',
    get: function get$$1() {
      return this.children[0];
    }

    /**
     * @property pageLoader
     * @description
     *   [en][/en]
     *   [ja][/ja]
     */

  }, {
    key: 'pageLoader',
    get: function get$$1() {
      return this._pageLoader;
    },
    set: function set$$1(loader) {
      if (!(loader instanceof PageLoader)) {
        util$1.throwPageLoader();
      }
      this._pageLoader = loader;
    }

    /**
     * @property mode
     * @readonly
     * @type {String}
     * @description
     *   [en]Current mode. Possible values are "split", "collapse", "closed", "open" or "changing".[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'mode',
    get: function get$$1() {
      return this._mode;
    }

    /**
     * @property onSwipe
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user slides the splitter. It gets a decimal ratio (0-1) and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onSwipe',
    get: function get$$1() {
      return this._onSwipe;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        util$1.throw('"onSwipe" must be a function');
      }
      this._onSwipe = value;
    }

    /**
     * @property isOpen
     * @type {Boolean}
     * @readonly
     * @description
     *   [en]This value is `true` when the menu is open.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'isOpen',
    get: function get$$1() {
      return this._mode === COLLAPSE_MODE && this._state !== CLOSED_STATE;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['animation', 'width', 'collapse', 'swipeable', 'animation-options'];
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['preopen', 'postopen', 'preclose', 'postclose', 'modechange'];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables$2;
    }
  }]);
  return SplitterSideElement;
}(BaseElement);

onsElements.SplitterSide = SplitterSideElement;
customElements.define('ons-splitter-side', SplitterSideElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$28 = {
  '': 'switch--*',
  '.switch__input': 'switch--*__input',
  '.switch__handle': 'switch--*__handle',
  '.switch__toggle': 'switch--*__toggle'
};

var locations = {
  ios: [1, 21],
  material: [0, 16]
};

/**
 * @element ons-switch
 * @category form
 * @description
 *   [en]
 *     Switch component. The switch can be toggled both by dragging and tapping.
 *
 *     Will automatically displays a Material Design switch on Android devices.
 *   [/en]
 *   [ja]スイッチを表示するコンポーネントです。[/ja]
 * @modifier material
 *   [en]Material Design switch[/en]
 *   [ja][/ja]
 * @codepen LpXZQQ
 * @tutorial vanilla/Reference/switch
 * @guide theming.html#modifiers [en]More details about the `modifier` attribute[/en][ja]modifier属性の使い方[/ja]
 * @example
 * <ons-switch checked></ons-switch>
 * <ons-switch disabled></ons-switch>
 * <ons-switch modifier="material"></ons-switch>
 */

var SwitchElement = function (_BaseCheckboxElement) {
  inherits(SwitchElement, _BaseCheckboxElement);

  function SwitchElement() {
    classCallCheck(this, SwitchElement);

    var _this = possibleConstructorReturn(this, (SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement)).call(this));

    contentReady(_this, function () {
      _this.attributeChangedCallback('modifier', null, _this.getAttribute('modifier'));
    });

    _this._onChange = _this._onChange.bind(_this);
    _this._onRelease = _this._onRelease.bind(_this);
    _this._lastTimeStamp = 0;
    return _this;
  }

  createClass(SwitchElement, [{
    key: '_getPosition',


    /* Own props */

    value: function _getPosition(e) {
      var l = this._locations;
      return Math.min(l[1], Math.max(l[0], this._startX + e.gesture.deltaX));
    }
  }, {
    key: '_emitChangeEvent',
    value: function _emitChangeEvent() {
      util$1.triggerElementEvent(this, 'change', {
        value: this.checked,
        switch: this,
        isInteractive: true
      });
    }
  }, {
    key: '_onChange',
    value: function _onChange(event) {
      if (event && event.stopPropagation) {
        event.stopPropagation();
      }

      this._emitChangeEvent();
    }
  }, {
    key: '_onClick',
    value: function _onClick(ev) {
      if (ev.target.classList.contains(this.defaultElementClass + '__touch') || ev.timeStamp - this._lastTimeStamp < 50 // Prevent second click triggered by <label>
      ) {
          ev.preventDefault();
        }
      this._lastTimeStamp = ev.timeStamp;
    }
  }, {
    key: '_onHold',
    value: function _onHold(e) {
      if (!this.disabled) {
        ModifierUtil.addModifier(this, 'active');
        document.addEventListener('release', this._onRelease);
      }
    }
  }, {
    key: '_onDragStart',
    value: function _onDragStart(e) {
      if (this.disabled || ['left', 'right'].indexOf(e.gesture.direction) === -1) {
        ModifierUtil.removeModifier(this, 'active');
        return;
      }

      e.consumed = true;

      ModifierUtil.addModifier(this, 'active');
      this._startX = this._locations[this.checked ? 1 : 0]; // - e.gesture.deltaX;

      this.addEventListener('drag', this._onDrag);
      document.addEventListener('release', this._onRelease);
    }
  }, {
    key: '_onDrag',
    value: function _onDrag(e) {
      e.stopPropagation();
      this._handle.style.left = this._getPosition(e) + 'px';
    }
  }, {
    key: '_onRelease',
    value: function _onRelease(e) {
      var l = this._locations;
      var position = this._getPosition(e);
      var previousValue = this.checked;

      this.checked = position >= (l[0] + l[1]) / 2;

      if (this.checked !== previousValue) {
        this._emitChangeEvent();
      }

      this.removeEventListener('drag', this._onDrag);
      document.removeEventListener('release', this._onRelease);

      this._handle.style.left = '';
      ModifierUtil.removeModifier(this, 'active');
    }
  }, {
    key: 'click',
    value: function click() {
      var ev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.disabled) {
        this.checked = !this.checked;
        this._emitChangeEvent();
        this._lastTimeStamp = ev.timeStamp || 0;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      contentReady(this, function () {
        _this2._input.addEventListener('change', _this2._onChange);
      });

      this.addEventListener('dragstart', this._onDragStart);
      this.addEventListener('hold', this._onHold);
      this.addEventListener('tap', this.click);
      this.addEventListener('click', this._onClick);
      this._gestureDetector = new GestureDetector(this, { dragMinDistance: 1, holdTimeout: 251, passive: true });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      var _this3 = this;

      contentReady(this, function () {
        _this3._input.removeEventListener('change', _this3._onChange);
      });

      this.removeEventListener('dragstart', this._onDragStart);
      this.removeEventListener('hold', this._onHold);
      this.removeEventListener('tap', this.click);
      this.removeEventListener('click', this._onClick);
      if (this._gestureDetector) {
        this._gestureDetector.dispose();
      }
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        var md = (current || '').indexOf('material') !== -1;
        this._locations = locations[md ? 'material' : 'ios'];
      }

      get(SwitchElement.prototype.__proto__ || Object.getPrototypeOf(SwitchElement.prototype), 'attributeChangedCallback', this).call(this, name, last, current);
    }

    /**
     * @event change
     * @description
     *   [en]Fired when the switch is toggled.[/en]
     *   [ja]ON/OFFが変わった時に発火します。[/ja]
     * @param {Object} event
     *   [en]Event object.[/en]
     *   [ja]イベントオブジェクト。[/ja]
     * @param {Object} event.switch
     *   [en]Switch object.[/en]
     *   [ja]イベントが発火したSwitchオブジェクトを返します。[/ja]
     * @param {Boolean} event.value
     *   [en]Current value.[/en]
     *   [ja]現在の値を返します。[/ja]
     * @param {Boolean} event.isInteractive
     *   [en]True if the change was triggered by the user clicking on the switch.[/en]
     *   [ja]タップやクリックなどのユーザの操作によって変わった場合にはtrueを返します。[/ja]
     */

    /**
     * @attribute modifier
     * @type {String}
     * @description
     *  [en]The appearance of the switch.[/en]
     *  [ja]スイッチの表現を指定します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Whether the switch is be disabled.[/en]
     *   [ja]スイッチを無効の状態にする場合に指定します。[/ja]
     */

    /**
     * @attribute checked
     * @description
     *   [en]Whether the switch is checked.[/en]
     *   [ja]スイッチがONの状態にするときに指定します。[/ja]
     */

    /**
     * @attribute input-id
     * @type {String}
     * @description
     *   [en]Specify the `id` attribute of the inner `<input>` element. This is useful when using `<label for="...">` elements.[/en]
     *   [ja][/ja]
     */

    /**
     * @property checked
     * @type {Boolean}
     * @description
     *   [en]This value is `true` if the switch is checked.[/en]
     *   [ja]スイッチがONの場合に`true`。[/ja]
     */

    /**
     * @property value
     * @type {String}
     * @description
     *   [en]The current value of the input.[/en]
     *   [ja][/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    /**
     * @property checkbox
     * @readonly
     * @type {HTMLElement}
     * @description
     *   [en]The underlying checkbox element.[/en]
     *   [ja]コンポーネント内部のcheckbox要素になります。[/ja]
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$28;
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'switch';
    }
  }, {
    key: '_template',
    get: function get$$1() {
      return '\n      <input type="' + this.type + '" class="' + this._defaultClassName + '__input">\n      <div class="' + this._defaultClassName + '__toggle">\n        <div class="' + this._defaultClassName + '__handle">\n          <div class="' + this._defaultClassName + '__touch"></div>\n        </div>\n      </div>\n    ';
    }
  }, {
    key: 'type',
    get: function get$$1() {
      return 'checkbox';
    }
  }, {
    key: '_handle',
    get: function get$$1() {
      return this.querySelector('.' + this._defaultClassName + '__handle');
    }
  }, {
    key: 'checkbox',
    get: function get$$1() {
      return this._input;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return [].concat(toConsumableArray(get(SwitchElement.__proto__ || Object.getPrototypeOf(SwitchElement), 'observedAttributes', this)), ['modifier']);
    }
  }]);
  return SwitchElement;
}(BaseCheckboxElement);

onsElements.Switch = SwitchElement;
customElements.define('ons-switch', SwitchElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$30 = {
  '.tabbar__content': 'tabbar--*__content',
  '.tabbar__border': 'tabbar--*__border',
  '.tabbar': 'tabbar--*'
};

var rewritables$3 = {
  /**
   * @param {Element} tabbarElement
   * @param {Function} callback
   */
  ready: function ready(tabbarElement, callback) {
    callback();
  }
};

var lerp = function lerp(x0, x1, t) {
  return (1 - t) * x0 + t * x1;
};

/**
 * @element ons-tabbar
 * @category tabbar
 * @description
 *   [en]A component to display a tab bar on the bottom of a page. Used with `<ons-tab>` to manage pages using tabs.[/en]
 *   [ja]タブバーをページ下部に表示するためのコンポーネントです。ons-tabと組み合わせて使うことで、ページを管理できます。[/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @modifier material
 *   [en]A tabbar in Material Design.[/en]
 *   [ja][/ja]
 * @modifier autogrow
 *   [en]Tabs automatically grow depending on their content instead of having a fixed width.[/en]
 *   [ja][/ja]
 * @modifier top-border
 *   [en]Shows a static border-bottom in tabs for iOS top tabbars.[/en]
 *   [ja][/ja]
 * @guide fundamentals.html#managing-pages
 *  [en]Managing multiple pages.[/en]
 *  [ja]複数のページを管理する[/ja]
 * @seealso ons-tab
 *   [en]The `<ons-tab>` component.[/en]
 *   [ja]ons-tabコンポーネント[/ja]
 * @seealso ons-page
 *   [en]The `<ons-page>` component.[/en]
 *   [ja]ons-pageコンポーネント[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <template id="home.html">
 *   ...
 * </template>
 *
 * <template id="settings.html">
 *   ...
 * </template>
 */

var TabbarElement = function (_BaseElement) {
  inherits(TabbarElement, _BaseElement);

  /**
   * @event prechange
   * @description
   *   [en]Fires just before the tab is changed.[/en]
   *   [ja]アクティブなタブが変わる前に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Number} event.index
   *   [en]Current index.[/en]
   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
   * @param {Object} event.tabItem
   *   [en]Tab item object.[/en]
   *   [ja]tabItemオブジェクト。[/ja]
   * @param {Function} event.cancel
   *   [en]Call this function to cancel the change event.[/en]
   *   [ja]この関数を呼び出すと、アクティブなタブの変更がキャンセルされます。[/ja]
   */

  /**
   * @event postchange
   * @description
   *   [en]Fires just after the tab is changed.[/en]
   *   [ja]アクティブなタブが変わった後に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Number} event.index
   *   [en]Current index.[/en]
   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
   * @param {Object} event.tabItem
   *   [en]Tab item object.[/en]
   *   [ja]tabItemオブジェクト。[/ja]
   */

  /**
   * @event reactive
   * @description
   *   [en]Fires if the already open tab is tapped again.[/en]
   *   [ja]すでにアクティブになっているタブがもう一度タップやクリックされた場合に発火します。[/ja]
   * @param {Object} event
   *   [en]Event object.[/en]
   *   [ja]イベントオブジェクト。[/ja]
   * @param {Number} event.index
   *   [en]Current index.[/en]
   *   [ja]現在アクティブになっているons-tabのインデックスを返します。[/ja]
   * @param {Object} event.tabItem
   *   [en]Tab item object.[/en]
   *   [ja]tabItemオブジェクト。[/ja]
   */

  /**
   * @attribute animation
   * @type {String}
   * @default none
   * @description
   *   [en]If this attribute is set to `"none"` the transitions will not be animated.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. {duration: 0.2, delay: 1, timing: 'ease-in'}[/ja]
   */

  /**
   * @attribute position
   * @initonly
   * @type {String}
   * @default bottom
   * @description
   *   [en]Tabbar's position. Available values are `"bottom"` and `"top"`. Use `"auto"` to choose position depending on platform (bottom for iOS flat design, top for Material Design).[/en]
   *   [ja]タブバーの位置を指定します。"bottom"もしくは"top"を選択できます。デフォルトは"bottom"です。[/ja]
   */

  /**
   * @attribute swipeable
   * @description
   *   [en]If this attribute is set the tab bar can be scrolled by drag or swipe.[/en]
   *   [ja]この属性がある時、タブバーをスワイプやドラッグで移動できるようになります。[/ja]
   */

  /**
   * @attribute ignore-edge-width
   * @type {Number}
   * @default 20
   * @description
   *   [en]Distance in pixels from both edges. Swiping on these areas will prioritize parent components such as `ons-splitter` or `ons-navigator`.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute hide-tabs
   * @description
   *   [en]Whether to hide the tabs.[/en]
   *   [ja]タブを非表示にする場合に指定します。[/ja]
   */

  /**
   * @attribute tab-border
   * @description
   *   [en]If this attribute is set the tabs show a dynamic bottom border. Only works for iOS flat design since the border is always visible in Material Design.[/en]
   *   [ja][/ja]
   */

  /**
   * @attribute modifier
   * @type {String}
   * @description
   *   [en]The appearance of the tabbar.[/en]
   *   [ja]タブバーの表現を指定します。[/ja]
   */

  function TabbarElement() {
    classCallCheck(this, TabbarElement);

    var _this = possibleConstructorReturn(this, (TabbarElement.__proto__ || Object.getPrototypeOf(TabbarElement)).call(this));

    contentReady(_this, function () {
      return _this._compile();
    });
    _this._loadInactive = util$1.defer(); // Improves #2324
    return _this;
  }

  createClass(TabbarElement, [{
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this2 = this;

      if (!this._swiper) {
        this._swiper = new Swiper({
          getElement: function getElement() {
            return _this2._contentElement;
          },
          getInitialIndex: function getInitialIndex() {
            return _this2.getAttribute('activeIndex') || _this2.getAttribute('active-index');
          },
          getAutoScrollRatio: this._getAutoScrollRatio.bind(this),
          getBubbleWidth: function getBubbleWidth() {
            return parseInt(_this2.getAttribute('ignore-edge-width') || 25, 10);
          },
          isAutoScrollable: function isAutoScrollable() {
            return true;
          },
          preChangeHook: this._onPreChange.bind(this),
          postChangeHook: this._onPostChange.bind(this),
          refreshHook: this._onRefresh.bind(this),
          scrollHook: this._onScroll.bind(this)
        });

        contentReady(this, function () {
          _this2._tabbarBorder = util$1.findChild(_this2._tabbarElement, '.tabbar__border');
          _this2._swiper.init({ swipeable: _this2.hasAttribute('swipeable') });
        });
      }

      contentReady(this, function () {
        _this2._updatePosition();

        if (!util$1.findParent(_this2, 'ons-page', function (p) {
          return p === document.body;
        })) {
          _this2._show(); // This tabbar is the top component
        }
      });
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      if (this._swiper && this._swiper.initialized) {
        this._swiper.dispose();
        this._swiper = null;
        this._tabbarBorder = null;
        this._tabsRect = null;
      }
    }
  }, {
    key: '_normalizeEvent',
    value: function _normalizeEvent(event) {
      return _extends({}, event, { index: event.activeIndex, tabItem: this.tabs[event.activeIndex] });
    }
  }, {
    key: '_onPostChange',
    value: function _onPostChange(event) {
      event = this._normalizeEvent(event);
      util$1.triggerElementEvent(this, 'postchange', event);
      var page = event.tabItem.pageElement;
      page && page._show();
    }
  }, {
    key: '_onPreChange',
    value: function _onPreChange(event) {
      event = this._normalizeEvent(event);
      event.cancel = function () {
        return event.canceled = true;
      };

      util$1.triggerElementEvent(this, 'prechange', event);

      if (!event.canceled) {
        var _event = event,
            activeIndex = _event.activeIndex,
            lastActiveIndex = _event.lastActiveIndex;

        var tabs = this.tabs;

        tabs[activeIndex].setActive(true);
        if (lastActiveIndex >= 0) {
          var prevTab = tabs[lastActiveIndex];
          prevTab.setActive(false);
          prevTab.pageElement && prevTab.pageElement._hide();
        }
      }

      return event.canceled;
    }
  }, {
    key: '_onScroll',
    value: function _onScroll(index) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this._tabbarBorder) {
        this._tabbarBorder.style.transition = 'all ' + (options.duration || 0) + 's ' + (options.timing || '');

        if (this._autogrow && this._tabsRect.length > 0) {
          var a = Math.floor(index),
              b = Math.ceil(index),
              r = index % 1;
          this._tabbarBorder.style.width = lerp(this._tabsRect[a].width, this._tabsRect[b].width, r) + 'px';
          this._tabbarBorder.style.transform = 'translate3d(' + lerp(this._tabsRect[a].left, this._tabsRect[b].left, r) + 'px, 0, 0)';
        } else {
          this._tabbarBorder.style.transform = 'translate3d(' + index * 100 + '%, 0, 0)';
        }
      }

      this._onSwipe && this._onSwipe(index, options);
    }
  }, {
    key: '_onRefresh',
    value: function _onRefresh() {
      this._autogrow = util$1.hasModifier(this, 'autogrow');
      this._tabsRect = this.tabs.map(function (tab) {
        return tab.getBoundingClientRect();
      });
      if (this._tabbarBorder) {
        this._tabbarBorder.style.display = this.hasAttribute('tab-border') || util$1.hasModifier(this, 'material') ? 'block' : 'none';
        var index = this.getActiveTabIndex();
        if (this._tabsRect.length > 0 && index >= 0) {
          this._tabbarBorder.style.width = this._tabsRect[index].width + 'px';
        }
      }
    }
  }, {
    key: '_getAutoScrollRatio',
    value: function _getAutoScrollRatio(matches, velocity, size) {
      var ratio = .6; // Base ratio
      var modifier = size / 300 * (matches ? -1 : 1); // Based on screen size
      return Math.min(1, Math.max(0, ratio + velocity * modifier));
    }
  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      var content = this._contentElement || util$1.create('.tabbar__content');
      content.classList.add('ons-tabbar__content');
      var tabbar = this._tabbarElement || util$1.create('.tabbar');
      tabbar.classList.add('ons-tabbar__footer');

      if (!tabbar.parentNode) {
        while (this.firstChild) {
          tabbar.appendChild(this.firstChild);
        }
      }

      var activeIndex = Number(this.getAttribute('activeIndex')); // 0 by default
      if (tabbar.children.length > activeIndex && !util$1.findChild(tabbar, '[active]')) {
        tabbar.children[activeIndex].setAttribute('active', '');
      }

      this._tabbarBorder = util$1.findChild(tabbar, '.tabbar__border') || util$1.create('.tabbar__border');
      tabbar.appendChild(this._tabbarBorder);
      tabbar.classList.add('ons-swiper-tabbar'); // Hides material border

      !content.children[0] && content.appendChild(document.createElement('div'));
      !content.children[1] && content.appendChild(document.createElement('div'));
      content.appendChild = content.appendChild.bind(content.children[0]);
      content.insertBefore = content.insertBefore.bind(content.children[0]);

      this.appendChild(content);
      this.appendChild(tabbar); // Triggers ons-tab connectedCallback

      ModifierUtil.initModifier(this, scheme$30);
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition() {
      var _this3 = this;

      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getAttribute('position');

      var top = this._top = position === 'top' || position === 'auto' && util$1.hasModifier(this, 'material');
      var action = top ? util$1.addModifier : util$1.removeModifier;

      action(this, 'top');

      var page = util$1.findParent(this, 'ons-page');
      if (page) {
        contentReady(page, function () {
          var p = 0;
          if (page.children[0] && util$1.match(page.children[0], 'ons-toolbar')) {
            action(page.children[0], 'noshadow');
            p = 1; // Visual fix for some devices
          }

          var content = page._getContentElement();
          var cs = window.getComputedStyle(page._getContentElement(), null);

          _this3.style.top = top ? parseInt(cs.getPropertyValue('padding-top'), 10) - p + 'px' : '';

          // Refresh content top - Fix for iOS 8
          content.style.top = cs.top;
          content.style.top = '';
        });
      }

      internal$1.autoStatusBarFill(function () {
        var filled = util$1.findParent(_this3, function (e) {
          return e.hasAttribute('status-bar-fill');
        });
        util$1.toggleAttribute(_this3, 'status-bar-fill', top && !filled);
      });
    }
  }, {
    key: 'setActiveTab',


    /**
     * @method setActiveTab
     * @signature setActiveTab(index, [options])
     * @param {Number} index
     *   [en]Tab index.[/en]
     *   [ja]タブのインデックスを指定します。[/ja]
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {Function} [options.callback]
     *   [en]Function that runs when the new page has loaded.[/en]
     *   [ja][/ja]
     * @param {String} [options.animation]
     *   [en]If this option is "none", the transition won't slide.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show specified tab page. Animations and their options can be specified by the second parameter.[/en]
     *   [ja]指定したインデックスのタブを表示します。アニメーションなどのオプションを指定できます。[/ja]
     * @return {Promise}
     *   [en]A promise that resolves to the new page element.[/en]
     *   [ja][/ja]
     */
    value: function setActiveTab(nextIndex) {
      var _this4 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var prevIndex = this.getActiveTabIndex();
      var prevTab = this.tabs[prevIndex],
          nextTab = this.tabs[nextIndex];

      if (!nextTab) {
        return Promise.reject('Specified index does not match any tab.');
      }

      if (nextIndex === prevIndex) {
        util$1.triggerElementEvent(this, 'reactive', { index: nextIndex, activeIndex: nextIndex, tabItem: nextTab });
        return Promise.resolve(nextTab.pageElement);
      }

      // FIXME: nextTab.loaded is broken in Zone.js promises (Angular2)
      var nextPage = nextTab.pageElement;
      return (nextPage ? Promise.resolve(nextPage) : nextTab.loaded).then(function (nextPage) {
        return _this4._swiper.setActiveIndex(nextIndex, _extends({
          reject: true
        }, options, {
          animation: prevTab && nextPage ? options.animation || _this4.getAttribute('animation') : 'none',
          animationOptions: util$1.extend({ duration: .3, timing: 'cubic-bezier(.4, .7, .5, 1)' }, _this4.hasAttribute('animation-options') ? util$1.animationOptionsParse(_this4.getAttribute('animation-options')) : {}, options.animationOptions || {})
        })).then(function () {
          options.callback instanceof Function && options.callback(nextPage);
          return nextPage;
        });
      });
    }

    /**
     * @method setTabbarVisibility
     * @signature setTabbarVisibility(visible)
     * @param {Boolean} visible
     * @description
     *   [en]Used to hide or show the tab bar.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'setTabbarVisibility',
    value: function setTabbarVisibility(visible) {
      var _this5 = this;

      contentReady(this, function () {
        _this5._contentElement.style[_this5._top ? 'top' : 'bottom'] = visible ? '' : '0px';
        _this5._tabbarElement.style.display = visible ? '' : 'none';
        visible && _this5._onRefresh();
      });
    }
  }, {
    key: 'show',
    value: function show() {
      this.setTabbarVisibility(true);
    }
  }, {
    key: 'hide',
    value: function hide() {
      this.setTabbarVisibility(false);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the tabbar is visible or not.[/en]
     *   [ja]タブバーが見える場合に`true`。[/ja]
     */

  }, {
    key: 'getActiveTabIndex',


    /**
     * @method getActiveTabIndex
     * @signature getActiveTabIndex()
     * @return {Number}
     *   [en]The index of the currently active tab.[/en]
     *   [ja]現在アクティブになっているタブのインデックスを返します。[/ja]
     * @description
     *   [en]Returns tab index on current active tab. If active tab is not found, returns -1.[/en]
     *   [ja]現在アクティブになっているタブのインデックスを返します。現在アクティブなタブがない場合には-1を返します。[/ja]
     */
    value: function getActiveTabIndex() {
      var tabs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.tabs;

      for (var i = 0; i < tabs.length; i++) {
        if (tabs[i] && tabs[i].tagName === 'ONS-TAB' && tabs[i].isActive()) {
          return i;
        }
      }
      return -1;
    }
  }, {
    key: '_show',
    value: function _show() {
      var _this6 = this;

      this._swiper.show();

      setImmediate(function () {
        var tabs = _this6.tabs;
        var activeIndex = _this6.getActiveTabIndex(tabs);
        _this6._loadInactive.resolve();
        if (tabs.length > 0 && activeIndex >= 0) {
          tabs[activeIndex].loaded.then(function (el) {
            return el && setImmediate(function () {
              return el._show();
            });
          });
        }
      });
    }
  }, {
    key: '_hide',
    value: function _hide() {
      this._swiper.hide();
      var topPage = this.topPage;
      topPage && topPage._hide();
    }
  }, {
    key: '_destroy',
    value: function _destroy() {
      this.tabs.forEach(function (tab) {
        return tab.remove();
      });
      this.remove();
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      if (name === 'modifier') {
        ModifierUtil.onModifierChanged(last, current, this, scheme$30);
        var isTop = function isTop(m) {
          return (/(^|\s+)top($|\s+)/i.test(m)
          );
        };
        isTop(last) !== isTop(current) && this._updatePosition();
      } else if (name === 'position') {
        util$1.isAttached(this) && this._updatePosition();
      } else if (name === 'swipeable') {
        this._swiper && this._swiper.updateSwipeable(this.hasAttribute('swipeable'));
      } else if (name === 'hide-tabs') {
        this.setTabbarVisibility(!this.hasAttribute('hide-tabs') || current === 'false');
      }
    }
  }, {
    key: '_tabbarElement',
    get: function get$$1() {
      return util$1.findChild(this, '.tabbar');
    }
  }, {
    key: '_contentElement',
    get: function get$$1() {
      return util$1.findChild(this, '.tabbar__content');
    }
  }, {
    key: '_targetElement',
    get: function get$$1() {
      var content = this._contentElement;
      return content && content.children[0] || null;
    }
  }, {
    key: 'topPage',
    get: function get$$1() {
      var tabs = this.tabs,
          index = this.getActiveTabIndex();
      return tabs[index] ? tabs[index].pageElement || this.pages[0] || null : null;
    }
  }, {
    key: 'pages',
    get: function get$$1() {
      return util$1.arrayFrom(this._targetElement.children);
    }
  }, {
    key: 'tabs',
    get: function get$$1() {
      return Array.prototype.filter.call(this._tabbarElement.children, function (e) {
        return e.tagName === 'ONS-TAB';
      });
    }
  }, {
    key: 'visible',
    get: function get$$1() {
      return this._tabbarElement.style.display !== 'none';
    }

    /**
     * @property swipeable
     * @type {Boolean}
     * @description
     *   [en]Enable swipe interaction.[/en]
     *   [ja]swipeableであればtrueを返します。[/ja]
     */

  }, {
    key: 'swipeable',
    get: function get$$1() {
      return this.hasAttribute('swipeable');
    },
    set: function set$$1(value) {
      return util$1.toggleAttribute(this, 'swipeable', value);
    }

    /**
     * @property onSwipe
     * @type {Function}
     * @description
     *   [en]Hook called whenever the user slides the tabbar. It gets a decimal index and an animationOptions object as arguments.[/en]
     *   [ja][/ja]
     */

  }, {
    key: 'onSwipe',
    get: function get$$1() {
      return this._onSwipe;
    },
    set: function set$$1(value) {
      if (value && !(value instanceof Function)) {
        util$1.throw('"onSwipe" must be a function');
      }
      this._onSwipe = value;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'position', 'swipeable', 'tab-border', 'hide-tabs'];
    }
  }, {
    key: 'rewritables',
    get: function get$$1() {
      return rewritables$3;
    }
  }, {
    key: 'events',
    get: function get$$1() {
      return ['prechange', 'postchange', 'reactive'];
    }
  }]);
  return TabbarElement;
}(BaseElement);

onsElements.Tabbar = TabbarElement;
customElements.define('ons-tabbar', TabbarElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var defaultClassName$16 = 'tabbar__item';

var scheme$29 = {
  '': 'tabbar--*__item',
  '.tabbar__button': 'tabbar--*__button'
};

/**
 * @element ons-tab
 * @category tabbar
 * @description
 *   [en]Represents a tab inside tab bar. Each `<ons-tab>` represents a page.[/en]
 *   [ja]
 *     タブバーに配置される各アイテムのコンポーネントです。それぞれのons-tabはページを表します。
 *     ons-tab要素の中には、タブに表示されるコンテンツを直接記述することが出来ます。
 *   [/ja]
 * @codepen pGuDL
 * @tutorial vanilla/Reference/tabbar
 * @guide fundamentals.html#managing-pages
 *   [en]Managing multiple pages.[/en]
 *   [ja]複数のページを管理する[/ja]]
 * @guide appsize.html#removing-icon-packs [en]Removing icon packs.[/en][ja][/ja]
 * @guide faq.html#how-can-i-use-custom-icon-packs [en]Adding custom icon packs.[/en][ja][/ja]
 * @seealso ons-tabbar
 *   [en]ons-tabbar component[/en]
 *   [ja]ons-tabbarコンポーネント[/ja]
 * @seealso ons-page
 *   [en]ons-page component[/en]
 *   [ja]ons-pageコンポーネント[/ja]
 * @seealso ons-icon
 *   [en]ons-icon component[/en]
 *   [ja]ons-iconコンポーネント[/ja]
 * @example
 * <ons-tabbar>
 *   <ons-tab
 *     page="home.html"
 *     label="Home"
 *     active>
 *   </ons-tab>
 *   <ons-tab
 *     page="settings.html"
 *     label="Settings"
 *     active>
 *   </ons-tab>
 * </ons-tabbar>
 *
 * <template id="home.html">
 *   ...
 * </template>
 *
 * <template id="settings.html">
 *   ...
 * </template>

 */

var TabElement = function (_BaseElement) {
  inherits(TabElement, _BaseElement);

  /**
   * @attribute page
   * @initonly
   * @type {String}
   * @description
   *   [en]The page that is displayed when the tab is tapped.[/en]
   *   [ja]ons-tabが参照するページへのURLを指定します。[/ja]
   */

  /**
   * @attribute icon
   * @type {String}
   * @description
   *   [en]
   *     The icon name for the tab. Can specify the same icon name as `<ons-icon>`. Check [See also](#seealso) section for more information.
   *   [/en]
   *   [ja]
   *     アイコン名を指定します。ons-iconと同じアイコン名を指定できます。
   *     個別にアイコンをカスタマイズする場合は、background-imageなどのCSSスタイルを用いて指定できます。
   *   [/ja]
   */

  /**
   * @attribute active-icon
   * @type {String}
   * @description
   *   [en]The name of the icon when the tab is active.[/en]
   *   [ja]アクティブの際のアイコン名を指定します。[/ja]
   */

  /**
   * @attribute label
   * @type {String}
   * @description
   *   [en]The label of the tab item.[/en]
   *   [ja]アイコン下に表示されるラベルを指定します。[/ja]
   */

  /**
   * @attribute badge
   * @type {String}
   * @description
   *   [en]Display a notification badge on top of the tab.[/en]
   *   [ja]バッジに表示する内容を指定します。[/ja]
   */

  /**
   * @attribute active
   * @description
   *   [en]This attribute should be set to the tab that is active by default.[/en]
   *   [ja][/ja]
   */

  function TabElement() {
    classCallCheck(this, TabElement);

    var _this = possibleConstructorReturn(this, (TabElement.__proto__ || Object.getPrototypeOf(TabElement)).call(this));

    if (['label', 'icon', 'badge'].some(_this.hasAttribute.bind(_this))) {
      _this._compile();
    } else {
      contentReady(_this, function () {
        return _this._compile();
      });
    }

    _this._pageLoader = defaultPageLoader;
    _this._onClick = _this._onClick.bind(_this);
    return _this;
  }

  createClass(TabElement, [{
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);
      this.classList.add(defaultClassName$16);

      if (this._button) {
        return;
      }

      var button = util$1.create('button.tabbar__button');
      while (this.childNodes[0]) {
        button.appendChild(this.childNodes[0]);
      }

      var input = util$1.create('input', { display: 'none' });
      input.type = 'radio';

      this.appendChild(input);
      this.appendChild(button);

      this._updateButtonContent();
      ModifierUtil.initModifier(this, scheme$29);
      this._updateRipple();
    }
  }, {
    key: '_updateRipple',
    value: function _updateRipple() {
      this._button && util$1.updateRipple(this._button, this.hasAttribute('ripple'));
    }
  }, {
    key: '_updateButtonContent',
    value: function _updateButtonContent() {
      var _this2 = this;

      var button = this._button;

      var iconWrapper = this._icon;
      if (this.hasAttribute('icon')) {
        iconWrapper = iconWrapper || util$1.createElement('<div class="tabbar__icon"><ons-icon></ons-icon></div>');
        var icon = iconWrapper.children[0];
        var fix = function (last) {
          return function () {
            return icon.attributeChangedCallback('icon', last, _this2.getAttribute('icon'));
          };
        }(icon.getAttribute('icon'));
        icon.setAttribute('icon', this.getAttribute('icon'));
        iconWrapper.parentElement !== button && button.insertBefore(iconWrapper, button.firstChild);

        // dirty fix for https://github.com/OnsenUI/OnsenUI/issues/1654
        icon.attributeChangedCallback instanceof Function ? fix() : setImmediate(function () {
          return icon.attributeChangedCallback instanceof Function && fix();
        });
      } else {
        iconWrapper && iconWrapper.remove();
      }

      ['label', 'badge'].forEach(function (attr, index) {
        var prop = _this2.querySelector('.tabbar__' + attr);
        if (_this2.hasAttribute(attr)) {
          prop = prop || util$1.create('.tabbar__' + attr + (attr === 'badge' ? ' notification' : ''));
          prop.textContent = _this2.getAttribute(attr);
          prop.parentElement !== button && button.appendChild(prop);
        } else {
          prop && prop.remove();
        }
      });
    }
  }, {
    key: '_onClick',
    value: function _onClick() {
      if (this.onClick instanceof Function) {
        this.onClick();
      } else {
        this._tabbar.setActiveTab(this.index, { reject: false });
      }
    }
  }, {
    key: 'setActive',
    value: function setActive() {
      var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this._input.checked = active;
      this.classList.toggle('active', active);
      util$1.toggleAttribute(this, 'active', active);

      if (this.hasAttribute('icon') && this.hasAttribute('active-icon')) {
        this._icon.children[0].setAttribute('icon', this.getAttribute(active ? 'active-icon' : 'icon'));
      }
    }
  }, {
    key: '_loadPageElement',
    value: function _loadPageElement(parent, page) {
      var _this3 = this;

      this._hasLoaded = true;

      return new Promise(function (resolve) {
        _this3._pageLoader.load({ parent: parent, page: page }, function (pageElement) {
          parent.replaceChild(pageElement, parent.children[_this3.index]); // Ensure position
          _this3._loadedPage = pageElement;
          resolve(pageElement);
        });
      });
    }
  }, {
    key: 'isActive',


    /**
     * @return {Boolean}
     */
    value: function isActive() {
      return this.classList.contains('active');
    }
  }, {
    key: 'disconnectedCallback',
    value: function disconnectedCallback() {
      this.removeEventListener('click', this._onClick, false);
      if (this._loadedPage) {
        this._pageLoader.unload(this._loadedPage);
        this._loadedPage = null;
        this._hasLoaded = false;
        this.loaded = null;
      }
    }
  }, {
    key: 'connectedCallback',
    value: function connectedCallback() {
      var _this4 = this;

      this.addEventListener('click', this._onClick, false);

      if (!util$1.isAttached(this) || this.loaded) {
        return; // ons-tabbar compilation may trigger this
      }

      var deferred = util$1.defer();
      this.loaded = deferred.promise;

      contentReady(this, function () {
        var index = _this4.index;
        var tabbar = _this4._tabbar;
        if (!tabbar) {
          util$1.throw('Tab elements must be children of Tabbar');
        }

        if (tabbar.hasAttribute('modifier')) {
          util$1.addModifier(_this4, tabbar.getAttribute('modifier'));
        }

        if (!_this4._hasLoaded) {
          if (_this4.hasAttribute('active')) {
            _this4.setActive(true);
            tabbar.setAttribute('activeIndex', index);
          }

          if (index === tabbar.tabs.length - 1) {
            tabbar._onRefresh();
            setImmediate(function () {
              return tabbar._onRefresh();
            });
          }

          TabbarElement.rewritables.ready(tabbar, function () {
            var pageTarget = _this4.page || _this4.getAttribute('page');
            if (!_this4.pageElement && pageTarget) {
              var parentTarget = tabbar._targetElement;
              var dummyPage = util$1.create('div', { height: '100%', width: '100%', visibility: 'hidden' });
              parentTarget.insertBefore(dummyPage, parentTarget.children[index]); // Ensure position

              var load = function load() {
                return _this4._loadPageElement(parentTarget, pageTarget).then(deferred.resolve);
              };
              return _this4.isActive() ? load() : tabbar._loadInactive.promise.then(load);
            }

            return deferred.resolve(_this4.pageElement);
          });
        }
      });
    }
  }, {
    key: 'attributeChangedCallback',
    value: function attributeChangedCallback(name, last, current) {
      var _this5 = this;

      switch (name) {
        case 'class':
          util$1.restoreClass(this, defaultClassName$16, scheme$29);
          break;
        case 'modifier':
          contentReady(this, function () {
            return ModifierUtil.onModifierChanged(last, current, _this5, scheme$29);
          });
          break;
        case 'ripple':
          contentReady(this, function () {
            return _this5._updateRipple();
          });
          break;
        case 'icon':
        case 'label':
        case 'badge':
          contentReady(this, function () {
            return _this5._updateButtonContent();
          });
          break;
        case 'page':
          this.page = current || '';
          break;
      }
    }
  }, {
    key: 'pageLoader',
    set: function set$$1(loader) {
      if (!(loader instanceof PageLoader)) {
        util$1.throwPageLoader();
      }
      this._pageLoader = loader;
    },
    get: function get$$1() {
      return this._pageLoader;
    }
  }, {
    key: '_input',
    get: function get$$1() {
      return util$1.findChild(this, 'input');
    }
  }, {
    key: '_button',
    get: function get$$1() {
      return util$1.findChild(this, '.tabbar__button');
    }
  }, {
    key: '_icon',
    get: function get$$1() {
      return this.querySelector('.tabbar__icon');
    }
  }, {
    key: '_tabbar',
    get: function get$$1() {
      return util$1.findParent(this, 'ons-tabbar');
    }
  }, {
    key: 'index',
    get: function get$$1() {
      return Array.prototype.indexOf.call(this.parentElement.children, this);
    }
  }, {
    key: 'pageElement',
    get: function get$$1() {
      // It has been loaded by ons-tab
      if (this._loadedPage) {
        return this._loadedPage;
      }
      // Manually attached to DOM, 1 per tab
      var tabbar = this._tabbar;
      if (tabbar.pages.length === tabbar.tabs.length) {
        return tabbar.pages[this.index];
      }
      // Loaded in another way
      return null;
    }
  }], [{
    key: 'observedAttributes',
    get: function get$$1() {
      return ['modifier', 'ripple', 'icon', 'label', 'page', 'badge', 'class'];
    }
  }]);
  return TabElement;
}(BaseElement);

onsElements.Tab = TabElement;
customElements.define('ons-tab', TabElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var ToastAnimator = function (_BaseAnimator) {
  inherits(ToastAnimator, _BaseAnimator);

  /**
   * @param {Object} options
   * @param {String} options.timing
   * @param {Number} options.duration
   * @param {Number} options.delay
   */
  function ToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.2 : _ref$duration;

    classCallCheck(this, ToastAnimator);
    return possibleConstructorReturn(this, (ToastAnimator.__proto__ || Object.getPrototypeOf(ToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} modal
   * @param {Function} callback
   */


  createClass(ToastAnimator, [{
    key: 'show',
    value: function show(modal, callback) {
      callback();
    }

    /**
     * @param {HTMLElement} modal
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(modal, callback) {
      callback();
    }
  }]);
  return ToastAnimator;
}(BaseAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * iOS style animator for dialog.
 */

var FadeToastAnimator = function (_ToastAnimator) {
  inherits(FadeToastAnimator, _ToastAnimator);

  function FadeToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'linear' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.3 : _ref$duration;

    classCallCheck(this, FadeToastAnimator);
    return possibleConstructorReturn(this, (FadeToastAnimator.__proto__ || Object.getPrototypeOf(FadeToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(FadeToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      callback = callback ? callback : function () {};

      Animit(toast, this.def).default({ opacity: 0 }, { opacity: 1 }).queue(function (done) {
        callback();
        done();
      }).play();
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      callback = callback ? callback : function () {};

      Animit(toast, this.def).default({ opacity: 1 }, { opacity: 0 }).queue(function (done) {
        callback();
        done();
      }).play();
    }
  }]);
  return FadeToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Ascend Toast Animator.
 */

var AscendToastAnimator = function (_ToastAnimator) {
  inherits(AscendToastAnimator, _ToastAnimator);

  function AscendToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.25 : _ref$duration;

    classCallCheck(this, AscendToastAnimator);

    var _this = possibleConstructorReturn(this, (AscendToastAnimator.__proto__ || Object.getPrototypeOf(AscendToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.messageDelay = _this.duration * 0.4 + _this.delay; // Delay message opacity change
    if (platform.isAndroid()) {
      _this.ascension = 48; // Toasts are always 1 line
    } else {
      if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
        _this.ascension = 98; // 64 + 34
      } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
        _this.ascension = 85; // 64 + 21
      } else {
        _this.ascension = 64;
      }
    }
    return _this;
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(AscendToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      toast = toast._toast;
      util$1.globals.fabOffset = this.ascension;

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, ' + this.ascension + 'px, 0)' }, { transform: 'translate3d(0, 0, 0)' }).queue(function (done) {
        callback && callback();
        done();
      }), Animit(this._getFabs()).wait(this.delay).queue({ transform: 'translate3d(0, -' + this.ascension + 'px, 0) scale(1)' }, this.def), Animit(util$1.arrayFrom(toast.children), this.def).default({ opacity: 0 }, { opacity: 1 }));
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      toast = toast._toast;
      util$1.globals.fabOffset = 0;

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, 0, 0)' }, { transform: 'translate3d(0, ' + this.ascension + 'px, 0)' }).queue(function (done) {
        callback && callback();
        done();
      }), Animit(this._getFabs(), this.def).wait(this.delay).queue({ transform: 'translate3d(0, 0, 0) scale(1)' }, this.def), Animit(util$1.arrayFrom(toast.children), this.def).default({ opacity: 1 }, { opacity: 0 }));
    }
  }, {
    key: '_getFabs',
    value: function _getFabs() {
      return util$1.arrayFrom(document.querySelectorAll('ons-fab[position~=bottom], ons-speed-dial[position~=bottom]')).filter(function (fab) {
        return fab.visible;
      });
    }
  }]);
  return AscendToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Lift-fade Toast Animator
 */

var LiftToastAnimator = function (_ToastAnimator) {
  inherits(LiftToastAnimator, _ToastAnimator);

  function LiftToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.35 : _ref$duration;

    classCallCheck(this, LiftToastAnimator);

    var _this = possibleConstructorReturn(this, (LiftToastAnimator.__proto__ || Object.getPrototypeOf(LiftToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    _this.bodyHeight = document.body.clientHeight; // avoid Forced Synchronous Layout
    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
      _this.liftAmount = 'calc(100% + 34px)';
    } else if (iPhoneXPatch.isIPhoneXLandscapePatchActive()) {
      _this.liftAmount = 'calc(100% + 21px)';
    } else {
      _this.liftAmount = '100%';
    }
    return _this;
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(LiftToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      toast = toast._toast;

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, ' + this.liftAmount + ', 0)', opacity: 0 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }).queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      toast = toast._toast;

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 1 }, { transform: 'translate3d(0, ' + this.liftAmount + ', 0)', opacity: 0 }).queue(function (done) {
        callback && callback();
        done();
      }));
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition(toast) {
      if (parseInt(toast.style.top, 10) === 0) {
        toast.style.top = toast.style.bottom = '';
      }
    }
  }]);
  return LiftToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Fall-fade Toast Animator
 */

var FallToastAnimator = function (_ToastAnimator) {
  inherits(FallToastAnimator, _ToastAnimator);

  function FallToastAnimator() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$timing = _ref.timing,
        timing = _ref$timing === undefined ? 'ease' : _ref$timing,
        _ref$delay = _ref.delay,
        delay = _ref$delay === undefined ? 0 : _ref$delay,
        _ref$duration = _ref.duration,
        duration = _ref$duration === undefined ? 0.35 : _ref$duration;

    classCallCheck(this, FallToastAnimator);

    var _this = possibleConstructorReturn(this, (FallToastAnimator.__proto__ || Object.getPrototypeOf(FallToastAnimator)).call(this, { timing: timing, delay: delay, duration: duration }));

    if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
      _this.fallAmount = 'calc(-100% - 44px)';
    } else {
      _this.fallAmount = '-100%';
    }
    return _this;
  }

  /**
   * @param {HTMLElement} toast
   * @param {Function} callback
   */


  createClass(FallToastAnimator, [{
    key: 'show',
    value: function show(toast, callback) {
      toast = toast._toast;
      this._updatePosition(toast);

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, ' + this.fallAmount + ', 0)', opacity: 0 }, { transform: 'translate3d(0, 0, 0)', opacity: 1 }).queue(function (done) {
        callback && callback();
        done();
      }));
    }

    /**
     * @param {HTMLElement} toast
     * @param {Function} callback
     */

  }, {
    key: 'hide',
    value: function hide(toast, callback) {
      var _this2 = this;

      toast = toast._toast;
      this._updatePosition(toast);

      Animit.runAll(Animit(toast, this.def).default({ transform: 'translate3d(0, 0, 0)', opacity: 1 }, { transform: 'translate3d(0, ' + this.fallAmount + ', 0)', opacity: 0 }).queue(function (done) {
        _this2._updatePosition(toast, true);
        callback && callback();
        done();
      }));
    }
  }, {
    key: '_updatePosition',
    value: function _updatePosition(toast, cleanUp) {
      var correctTop = void 0;
      if (iPhoneXPatch.isIPhoneXPortraitPatchActive()) {
        correctTop = '44px';
      } else {
        correctTop = '0';
      }

      if (toast.style.top !== correctTop) {
        toast.style.top = correctTop;
        toast.style.bottom = 'initial';
      }
    }
  }]);
  return FallToastAnimator;
}(ToastAnimator);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

var scheme$31 = {
  '.toast': 'toast--*',
  '.toast__message': 'toast--*__message',
  '.toast__button': 'toast--*__button'
};

var defaultClassName$17 = 'toast';

var _animatorDict$8 = {
  'default': platform.isAndroid() ? AscendToastAnimator : LiftToastAnimator,
  'fade': FadeToastAnimator,
  'ascend': AscendToastAnimator,
  'lift': LiftToastAnimator,
  'fall': FallToastAnimator,
  'none': ToastAnimator
};

/**
 * @element ons-toast
 * @category dialog
 * @description
 *   [en]
 *     The Toast or Snackbar component is useful for displaying dismissable information or simple actions at (normally) the bottom of the page.
 *
 *     This component does not block user input, allowing the app to continue its flow. For simple toasts, consider `ons.notification.toast` instead.
 *   [/en]
 *   [ja][/ja]
 * @tutorial vanilla/Reference/toast
 * @seealso ons-alert-dialog
 *   [en]The `<ons-alert-dialog>` component is preferred for displaying undismissable information.[/en]
 *   [ja][/ja]
 */

var ToastElement = function (_BaseDialogElement) {
  inherits(ToastElement, _BaseDialogElement);

  /**
   * @attribute animation
   * @type {String}
   * @default default
   * @description
   *  [en]The animation used when showing and hiding the toast. Can be either `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
   *  [ja][/ja]
   */

  /**
   * @attribute animation-options
   * @type {Expression}
   * @description
   *  [en]Specify the animation's duration, timing and delay with an object literal. E.g. `{duration: 0.2, delay: 1, timing: 'ease-in'}`.[/en]
   *  [ja]アニメーション時のduration, timing, delayをオブジェクトリテラルで指定します。e.g. <code>{duration: 0.2, delay: 1, timing: 'ease-in'}</code>[/ja]
   */

  function ToastElement() {
    classCallCheck(this, ToastElement);

    var _this = possibleConstructorReturn(this, (ToastElement.__proto__ || Object.getPrototypeOf(ToastElement)).call(this));

    _this._defaultDBB = function (e) {
      return e.callParentHandler();
    };
    contentReady(_this, function () {
      return _this._compile();
    });
    return _this;
  }

  createClass(ToastElement, [{
    key: '_updateAnimatorFactory',
    value: function _updateAnimatorFactory() {
      // Reset position style
      this._toast && (this._toast.style.top = this._toast.style.bottom = '');

      return new AnimatorFactory({
        animators: _animatorDict$8,
        baseClass: ToastAnimator,
        baseClassName: 'ToastAnimator',
        defaultAnimation: this.getAttribute('animation')
      });
    }

    /**
     * @property onDeviceBackButton
     * @type {Object}
     * @description
     *   [en]Back-button handler.[/en]
     *   [ja]バックボタンハンドラ。[/ja]
     */

  }, {
    key: '_compile',
    value: function _compile() {
      autoStyle.prepare(this);

      this.style.display = 'none';
      this.style.zIndex = 10000; // Lower than dialogs

      var messageClassName = 'toast__message';
      var buttonClassName = 'toast__button';

      var toast = util$1.findChild(this, '.' + defaultClassName$17);
      if (!toast) {
        toast = document.createElement('div');
        toast.classList.add(defaultClassName$17);
        while (this.childNodes[0]) {
          toast.appendChild(this.childNodes[0]);
        }
      }

      var button = util$1.findChild(toast, '.' + buttonClassName);
      if (!button) {
        button = util$1.findChild(toast, function (e) {
          return util$1.match(e, '.button') || util$1.match(e, 'button');
        });
        if (button) {
          button.classList.remove('button');
          button.classList.add(buttonClassName);
          toast.appendChild(button);
        }
      }

      if (!util$1.findChild(toast, '.' + messageClassName)) {
        var message = util$1.findChild(toast, '.message');
        if (!message) {
          message = document.createElement('div');
          for (var i = toast.childNodes.length - 1; i >= 0; i--) {
            if (toast.childNodes[i] !== button) {
              message.insertBefore(toast.childNodes[i], message.firstChild);
            }
          }
        }
        message.classList.add(messageClassName);

        toast.insertBefore(message, toast.firstChild);
      }

      if (toast.parentNode !== this) {
        this.appendChild(toast);
      }

      ModifierUtil.initModifier(this, this._scheme);
    }

    /**
     * @property visible
     * @readonly
     * @type {Boolean}
     * @description
     *   [en]Whether the element is visible or not.[/en]
     *   [ja]要素が見える場合に`true`。[/ja]
     */

    /**
     * @method show
     * @signature show([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Show the element.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the displayed element[/en]
     *   [ja][/ja]
     */

    /**
     * @method toggle
     * @signature toggle([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Toggle toast visibility.[/en]
     *   [ja][/ja]
     */

    /**
     * @method hide
     * @signature hide([options])
     * @param {Object} [options]
     *   [en]Parameter object.[/en]
     *   [ja]オプションを指定するオブジェクト。[/ja]
     * @param {String} [options.animation]
     *   [en]Animation name. Available animations are `"default"`, `"ascend"` (Android), `"lift"` (iOS), `"fall"`, `"fade"` or `"none"`.[/en]
     *   [ja][/ja]
     * @param {String} [options.animationOptions]
     *   [en]Specify the animation's duration, delay and timing. E.g. `{duration: 0.2, delay: 0.4, timing: 'ease-in'}`.[/en]
     *   [ja]アニメーション時のduration, delay, timingを指定します。e.g. {duration: 0.2, delay: 0.4, timing: 'ease-in'}[/ja]
     * @description
     *   [en]Hide toast.[/en]
     *   [ja][/ja]
     * @return {Promise}
     *   [en]Resolves to the hidden element[/en]
     *   [ja][/ja]
     */

    /**
     * @param {String} name
     * @param {Function} Animator
     */

  }, {
    key: '_scheme',
    get: function get$$1() {
      return scheme$31;
    }
  }, {
    key: '_toast',
    get: function get$$1() {
      return util$1.findChild(this, '.' + defaultClassName$17);
    }
  }], [{
    key: 'registerAnimator',
    value: function registerAnimator(name, Animator) {
      if (!(Animator.prototype instanceof ToastAnimator)) {
        util$1.throw('"Animator" param must inherit OnsToastElement.ToastAnimator');
      }
      _animatorDict$8[name] = Animator;
    }
  }, {
    key: 'animators',
    get: function get$$1() {
      return _animatorDict$8;
    }
  }, {
    key: 'ToastAnimator',
    get: function get$$1() {
      return ToastAnimator;
    }
  }]);
  return ToastElement;
}(BaseDialogElement);

onsElements.Toast = ToastElement;
customElements.define('ons-toast', ToastElement);

/*
Copyright 2013-2015 ASIAL CORPORATION

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * @element ons-toolbar-button
 * @category page
 * @modifier material
 *   [en]Material Design toolbar button.[/en]
 *   [ja][/ja]
 * @modifier outline
 *   [en]A button with an outline.[/en]
 *   [ja]アウトラインをもったボタンを表示します。[/ja]
 * @description
 *   [en]Button component for ons-toolbar and ons-bottom-toolbar.[/en]
 *   [ja]ons-toolbarあるいはons-bottom-toolbarに設置できるボタン用コンポーネントです。[/ja]
 * @codepen aHmGL
 * @tutorial vanilla/Reference/page
 * @guide compilation.html#toolbar-compilation
 *   [en]Adding a toolbar[/en]
 *   [ja]ツールバーの追加[/ja]
 * @seealso ons-toolbar
 *   [en]The `<ons-toolbar>` component displays a navigation bar at the top of a page.[/en]
 *   [ja]ons-toolbarコンポーネント[/ja]
 * @seealso ons-back-button
 *   [en]The `<ons-back-button>` displays a back button in the navigation bar.[/en]
 *   [ja]ons-back-buttonコンポーネント[/ja]
 * @example
 * <ons-toolbar>
 *   <div class="left">
 *     <ons-toolbar-button>
 *       Button
 *     </ons-toolbar-button>
 *   </div>
 *   <div class="center">
 *     Title
 *   </div>
 *   <div class="right">
 *     <ons-toolbar-button>
 *       <ons-icon icon="ion-navicon" size="28px"></ons-icon>
 *     </ons-toolbar-button>
 *   </div>
 * </ons-toolbar>
 */

var ToolbarButtonElement = function (_BaseButtonElement) {
  inherits(ToolbarButtonElement, _BaseButtonElement);

  function ToolbarButtonElement() {
    classCallCheck(this, ToolbarButtonElement);
    return possibleConstructorReturn(this, (ToolbarButtonElement.__proto__ || Object.getPrototypeOf(ToolbarButtonElement)).apply(this, arguments));
  }

  createClass(ToolbarButtonElement, [{
    key: '_scheme',


    /**
     * @attribute modifier
     * @type {String}
     * @description
     *   [en]The appearance of the button.[/en]
     *   [ja]ボタンの表現を指定します。[/ja]
     */

    /**
     * @attribute icon
     * @type {String}
     * @description
     *  [en]Creates an `ons-icon` component with this string.[/en]
     *  [ja]`ons-icon`コンポーネントを悪性します。[/ja]
     */

    /**
     * @attribute disabled
     * @description
     *   [en]Specify if button should be disabled.[/en]
     *   [ja]ボタンを無効化する場合は指定してください。[/ja]
     */

    /**
     * @property disabled
     * @type {Boolean}
     * @description
     *   [en]Whether the element is disabled or not.[/en]
     *   [ja]無効化されている場合に`true`。[/ja]
     */

    get: function get$$1() {
      return { '': 'toolbar-button--*' };
    }
  }, {
    key: '_defaultClassName',
    get: function get$$1() {
      return 'toolbar-button';
    }
  }, {
    key: '_rippleOpt',
    get: function get$$1() {
      return [this, undefined, { center: '', 'size': 'contain', 'background': 'transparent' }];
    }
  }]);
  return ToolbarButtonElement;
}(BaseButtonElement);

onsElements.ToolbarButton = ToolbarButtonElement;
customElements.define('ons-toolbar-button', ToolbarButtonElement);

// Add and register Custom Elements
setup$1(ons$1); // Setup initial listeners
window._superSecretOns = ons$1;

return ons$1;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib25zZW51aS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vY29yZS9zcmMvb25zL2VsZW1lbnRzLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL3N0eWxlci5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9wbGF0Zm9ybS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL2ludGVybmFsLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnkuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYXV0b3N0eWxlLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvZGV2aWNlLWJhY2stYnV0dG9uLWRpc3BhdGNoZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL3V0aWwuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYW5pbWl0LmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2dlc3R1cmUtZGV0ZWN0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvY29udGVudC1yZWFkeS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9pbnRlcm5hbC90b2FzdC1xdWV1ZS5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9ub3RpZmljYXRpb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvYWN0aW9uLXNoZWV0LmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL21pY3JvZXZlbnQuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvb3JpZW50YXRpb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvbW9kaWZpZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvc29mdHdhcmUta2V5Ym9hcmQuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvZG9vcmxvY2suanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvcGFnZS1sb2FkZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW5kZXguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvZmFzdGNsaWNrL2xpYi9mYXN0Y2xpY2suanMiLCIuLi8uLi9jb3JlL3NyYy9wb2x5ZmlsbHMvcG9seWZpbGwtc3dpdGNoZXMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mb3Itb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi1zdHJvbmcuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2xsZWN0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc2V0LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvbGxlY3Rpb24tdG8tanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnNldC50by1qc29uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zZXQub2YuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc2V0LmZyb20uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9zZXQuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5tYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5tYXAudG8tanNvbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3Lm1hcC5mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vbWFwLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jcmVhdGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29sbGVjdGlvbi13ZWFrLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYud2Vhay1tYXAuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy53ZWFrLW1hcC5vZi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi93ZWFrLW1hcC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NyZWF0ZS1wcm9wZXJ0eS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9mbi9hcnJheS9mcm9tLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvVXRpbGl0aWVzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvQ3VzdG9tRWxlbWVudFN0YXRlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9EZWZlcnJlZC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0N1c3RvbUVsZW1lbnRSZWdpc3RyeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL05hdGl2ZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL0FscmVhZHlDb25zdHJ1Y3RlZE1hcmtlci5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL0hUTUxFbGVtZW50LmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvSW50ZXJmYWNlL1BhcmVudE5vZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9Eb2N1bWVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL05vZGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG9uc2VudWkvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9JbnRlcmZhY2UvQ2hpbGROb2RlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BvbnNlbnVpL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvRWxlbWVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9Ab25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL2N1c3RvbS1lbGVtZW50cy5qcyIsIi4uLy4uL2NvcmUvc3JjL3BvbHlmaWxscy9NdXRhdGlvbk9ic2VydmVyQDAuNy4yMi9NdXRhdGlvbk9ic2VydmVyLmpzIiwiLi4vLi4vY29yZS9zcmMvcG9seWZpbGxzL3NldEltbWVkaWF0ZUAxLjAuMittb2Qvc2V0SW1tZWRpYXRlLmpzIiwiLi4vLi4vY29yZS9zcmMvcG9seWZpbGxzL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvdmVuZG9yL3ZpZXdwb3J0LmpzIiwiLi4vLi4vY29yZS9zcmMvc2V0dXAuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtZWxlbWVudC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10ZW1wbGF0ZS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1pZi5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9iYXNlLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvb25zL2lwaG9uZXgtcGF0Y2guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYWN0aW9uLXNoZWV0L2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvYmFzZS9iYXNlLWRpYWxvZy5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1hY3Rpb24tc2hlZXQvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWFjdGlvbi1zaGVldC1idXR0b24uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtYWxlcnQtZGlhbG9nL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1hbGVydC1kaWFsb2ctYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWJhY2stYnV0dG9uLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWJ1dHRvbi5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1jYXJkLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWNhcm91c2VsLWl0ZW0uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvc3dpcGVyLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWNhcm91c2VsLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWNvbC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1kaWFsb2cvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtZGlhbG9nL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWZhYi5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1nZXN0dXJlLWRldGVjdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWljb24uanMiLCIuLi8uLi9jb3JlL3NyYy9vbnMvaW50ZXJuYWwvbGF6eS1yZXBlYXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGlzdC1oZWFkZXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGlzdC10aXRsZS5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1saXN0LWl0ZW0vYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbGlzdC1pdGVtL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLWxpc3QuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtaW5wdXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtaW5wdXQuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9iYXNlL2Jhc2UtY2hlY2tib3guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtY2hlY2tib3guanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcmFkaW8uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc2VhcmNoLWlucHV0LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW1vZGFsL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW1vZGFsL2ZhZGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbW9kYWwvbGlmdC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1tb2RhbC9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL29ucy9pbnRlcm5hbC9zd2lwZS1yZXZlYWwuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW5hdmlnYXRvci9pb3Mtc3dpcGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1zbGlkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW9zLWxpZnQtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtbmF2aWdhdG9yL2lvcy1mYWRlLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLW5hdmlnYXRvci9tZC1zbGlkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtbGlmdC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvbWQtZmFkZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3Ivbm9uZS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3IvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9vbGJhci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1wYWdlLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXBvcG92ZXIvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcG9wb3Zlci9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1wcm9ncmVzcy1iYXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXIuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcHVsbC1ob29rLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXJhbmdlLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXJpcHBsZS9hbmltYXRvci1jc3MuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtcmlwcGxlL2luZGV4LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXJvdy5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zZWdtZW50LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNlbGVjdC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGVlZC1kaWFsLWl0ZW0uanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci1jb250ZW50LmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyLW1hc2suanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXIvYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtc3BsaXR0ZXIvb3ZlcmxheS1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci9wdXNoLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXNwbGl0dGVyL3JldmVhbC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy1zcGxpdHRlci1zaWRlLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXN3aXRjaC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10YWJiYXIvaW5kZXguanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdGFiLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2FuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2ZhZGUtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9hc3QvYXNjZW5kLWFuaW1hdG9yLmpzIiwiLi4vLi4vY29yZS9zcmMvZWxlbWVudHMvb25zLXRvYXN0L2xpZnQtYW5pbWF0b3IuanMiLCIuLi8uLi9jb3JlL3NyYy9lbGVtZW50cy9vbnMtdG9hc3QvZmFsbC1hbmltYXRvci5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10b2FzdC9pbmRleC5qcyIsIi4uLy4uL2NvcmUvc3JjL2VsZW1lbnRzL29ucy10b29sYmFyLWJ1dHRvbi5qcyIsIi4uLy4uL2NvcmUvc3JjL2luZGV4LnVtZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7IH07XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5cbi8qKlxuICogQWRkIHZlbmRvciBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuY29uc3QgcHJlZml4ID0gKGZ1bmN0aW9uKCkge1xuICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICcnKTtcbiAgY29uc3QgcHJlZml4ID0gKEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgIC5jYWxsKHN0eWxlcylcbiAgICAuam9pbignJylcbiAgICAubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLykgfHwgKHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVxuICApWzFdO1xuXG4gIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuICctJyArIHByZWZpeCArICctJyArIHV0aWwuaHlwaGVuYXRlKG5hbWUpO1xuICB9O1xufSkoKTtcblxuXG4vKipcbiAqIE1pbmltYWwgdXRpbGl0eSBsaWJyYXJ5IGZvciBtYW5pcHVsYXRpbmcgZWxlbWVudCdzIHN0eWxlLlxuICogU2V0IGVsZW1lbnQncyBzdHlsZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZXNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmNvbnN0IHN0eWxlciA9IGZ1bmN0aW9uKGVsZW1lbnQsIHN0eWxlKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChrZXkgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgICAgZWxlbWVudC5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeChrZXkpIGluIGVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJlZml4KGtleSldID0gc3R5bGVba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXRpbC53YXJuKCdObyBzdWNoIHN0eWxlIHByb3BlcnR5OiAnICsga2V5KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc3R5bGVzIFNwYWNlLXNlcGFyYXRlZCBDU1MgcHJvcGVydGllcyB0byByZW1vdmVcbiAqL1xuc3R5bGVyLmNsZWFyID0gZnVuY3Rpb24oZWxlbWVudCwgc3R5bGVzID0gJycpIHtcbiAgY29uc3QgY2xlYXJsaXN0ID0gc3R5bGVzLnNwbGl0KC9cXHMrLykucmVkdWNlKChyLCBzKSA9PiByLmNvbmNhdChbdXRpbC5oeXBoZW5hdGUocyksIHByZWZpeChzKV0pLCBbXSksXG4gICAga2V5cyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSBlbGVtZW50LnN0eWxlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qga2V5ID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICBpZiAoY2xlYXJsaXN0Lmxlbmd0aCA9PT0gMCB8fCBjbGVhcmxpc3Quc29tZShzID0+IGtleS5pbmRleE9mKHMpID09PSAwKSkge1xuICAgICAga2V5cy5wdXNoKGtleSk7IC8vIFN0b3JlIHRoZSBrZXkgdG8gZml4IFNhZmFyaSBzdHlsZSBpbmRleGVzXG4gICAgfVxuICB9XG5cbiAga2V5cy5mb3JFYWNoKGtleSA9PiBlbGVtZW50LnN0eWxlW2tleV0gPSAnJyk7XG4gIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpID09PSAnJyAmJiBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlcjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbi8vIFNhdmUgSFRNTEVsZW1lbnQgb2JqZWN0IGJlZm9yZSBDdXN0b20gRWxlbWVudHMgcG9seWZpbGwgcGF0Y2ggZ2xvYmFsIEhUTUxFbGVtZW50LlxuY29uc3QgTmF0aXZlSFRNTEVsZW1lbnQgPSB3aW5kb3cuSFRNTEVsZW1lbnQ7XG5cbi8qKlxuICogQG9iamVjdCBvbnMucGxhdGZvcm1cbiAqIEBjYXRlZ29yeSB1dGlsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyB0byBkZXRlY3QgY3VycmVudCBwbGF0Zm9ybS5bL2VuXVxuICogICBbamFd54++5Zyo5a6f6KGM44GV44KM44Gm44GE44KL44OX44Op44OD44OI44OV44Kp44O844Og44KS5qSc55+l44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqL1xuY2xhc3MgUGxhdGZvcm0ge1xuXG4gIC8qKlxuICAgKiBBbGwgZWxlbWVudHMgd2lsbCBiZSByZW5kZXJlZCBhcyBpZiB0aGUgYXBwIHdhcyBydW5uaW5nIG9uIHRoaXMgcGxhdGZvcm0uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9zZWxlY3RlZFBsYXRmb3JtID0gbnVsbDtcbiAgICB0aGlzLl9pZ25vcmVQbGF0Zm9ybVNlbGVjdCA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2VsZWN0XG4gICAqIEBzaWduYXR1cmUgc2VsZWN0KHBsYXRmb3JtKVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHBsYXRmb3JtIE5hbWUgb2YgdGhlIHBsYXRmb3JtLlxuICAgKiAgIFtlbl1Qb3NzaWJsZSB2YWx1ZXMgYXJlOiBcIm9wZXJhXCIsIFwiZmlyZWZveFwiLCBcInNhZmFyaVwiLCBcImNocm9tZVwiLCBcImllXCIsIFwiYW5kcm9pZFwiLCBcImJsYWNrYmVycnlcIiwgXCJpb3NcIiBvciBcIndwXCIuWy9lbl1cbiAgICogICBbamFdXCJvcGVyYVwiLCBcImZpcmVmb3hcIiwgXCJzYWZhcmlcIiwgXCJjaHJvbWVcIiwgXCJpZVwiLCBcImFuZHJvaWRcIiwgXCJibGFja2JlcnJ5XCIsIFwiaW9zXCIsIFwid3BcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TZXRzIHRoZSBwbGF0Zm9ybSB1c2VkIHRvIHJlbmRlciB0aGUgZWxlbWVudHMuIFVzZWZ1bCBmb3IgdGVzdGluZy5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgpLmj4/nlLvjgZnjgovjgZ/jgoHjgavliKnnlKjjgZnjgovjg5fjg6njg4Pjg4jjg5Xjgqnjg7zjg6DlkI3jgpLoqK3lrprjgZfjgb7jgZnjgILjg4bjgrnjg4jjgavkvr/liKnjgafjgZnjgIJbL2phXVxuICAgKi9cbiAgc2VsZWN0KHBsYXRmb3JtKSB7XG4gICAgaWYgKHR5cGVvZiBwbGF0Zm9ybSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGVkUGxhdGZvcm0gPSBwbGF0Zm9ybS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5faWdub3JlUGxhdGZvcm1TZWxlY3QgPyBudWxsIDogdGhpcy5fc2VsZWN0ZWRQbGF0Zm9ybTtcbiAgfVxuXG4gIF9ydW5PbkFjdHVhbFBsYXRmb3JtKGZuKSB7XG4gICAgdGhpcy5faWdub3JlUGxhdGZvcm1TZWxlY3QgPSB0cnVlO1xuICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgdGhpcy5faWdub3JlUGxhdGZvcm1TZWxlY3QgPSBmYWxzZTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gR2VuZXJhbFxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNXZWJWaWV3XG4gICAqIEBzaWduYXR1cmUgaXNXZWJWaWV3KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBDb3Jkb3ZhLlsvZW5dXG4gICAqICAgW2phXUNvcmRvdmHlhoXjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNXZWJWaWV3KCkge1xuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAndW5pbml0aWFsaXplZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaXNXZWJWaWV3KCkgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBkb20gY29udGVudHMgbG9hZGVkLicpO1xuICAgIH1cblxuICAgIHJldHVybiAhISh3aW5kb3cuY29yZG92YSB8fCB3aW5kb3cucGhvbmVnYXAgfHwgd2luZG93LlBob25lR2FwKTtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBpT1MgZGV2aWNlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJUGhvbmVcbiAgICogQHNpZ25hdHVyZSBpc0lQaG9uZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGhvbmUuWy9lbl1cbiAgICogICBbamFdaVBob25l5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBob25lKCkge1xuICAgIHJldHVybiAvaVBob25lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSVBob25lWFxuICAgKiBAc2lnbmF0dXJlIGlzSVBob25lWCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGhvbmUgWC5bL2VuXVxuICAgKiAgIFtqYV1pUGhvbmUgWOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lQaG9uZVgoKSB7XG4gICAgLy8gaVBob25lIDggYW5kIGlQaG9uZSBYIGhhdmUgYSBzYW1lIHVzZXIgYWdlbnQuIFdlIGNhbm5vdCBhdm9pZCB1c2luZyB3aW5kb3cuc2NyZWVuLlxuICAgIC8vIFRoaXMgd29ya3Mgd2VsbCBib3RoIGluIGlPUyBTYWZhcmkgYW5kIChVSXxXSylXZWJWaWV3IG9mIGlQaG9uZSBYLlxuICAgIHJldHVybiB0aGlzLmlzSVBob25lKCkgJiZcbiAgICAgICh3aW5kb3cuc2NyZWVuLndpZHRoID09PSAzNzUgJiYgd2luZG93LnNjcmVlbi5oZWlnaHQgPT09IDgxMlxuICAgIHx8IHdpbmRvdy5zY3JlZW4ud2lkdGggPT09IDgxMiAmJiB3aW5kb3cuc2NyZWVuLmhlaWdodCA9PT0gMzc1KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSVBhZFxuICAgKiBAc2lnbmF0dXJlIGlzSVBhZCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBpUGFkLlsvZW5dXG4gICAqICAgW2phXWlQYWTkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJUGFkKCkge1xuICAgIHJldHVybiAvaVBhZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzSVBvZCgpIHtcbiAgICByZXR1cm4gL2lQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGlPUyB2ZXJzaW9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1NcbiAgICogQHNpZ25hdHVyZSBpc0lPUygpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIE9TIGlzIGlPUy5bL2VuXVxuICAgKiAgIFtqYV1pT1PkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJT1MoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ2lvcyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuIC9pT1MvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNJT1M3YWJvdmVcbiAgICogQHNpZ25hdHVyZSBpc0lPUzdhYm92ZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGlPUyB2ZXJzaW9uIGlzIDcgb3IgYWJvdmUuWy9lbl1cbiAgICogICBbamFdaU9TN+S7peS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lPUzdhYm92ZSgpIHtcbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gKC9pT1MvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSkgJiYgKHBhcnNlSW50KGRldmljZS52ZXJzaW9uLnNwbGl0KCcuJylbMF0pID49IDcpKTtcbiAgICB9IGVsc2UgaWYoL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBjb25zdCB2ZXIgPSAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvXFxiWzAtOV0rX1swLTldKyg/Ol9bMC05XSspP1xcYi8pIHx8IFsnJ10pWzBdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgICAgIHJldHVybiAocGFyc2VJbnQodmVyLnNwbGl0KCcuJylbMF0pID49IDcpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gaU9TIGJyb3dzZXJzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQG1ldGhvZCBpc0lPU1NhZmFyaVxuICAgKiBAc2lnbmF0dXJlIGlzSU9TU2FmYXJpKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBpT1MgU2FmYXJpLlsvZW5dXG4gICAqICAgW2phXWlPUyBTYWZhcmnjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNJT1NTYWZhcmkoKSB7XG4gICAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcjtcbiAgICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgICByZXR1cm4gISEodGhpcy5pc0lPUygpICYmIHVhLmluZGV4T2YoJ1NhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdWZXJzaW9uJykgIT09IC0xICYmICFuYXZpZ2F0b3Iuc3RhbmRhbG9uZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1dLV2ViVmlld1xuICAgKiBAc2lnbmF0dXJlIGlzV0tXZWJWaWV3KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBXS1dlYlZpZXcuWy9lbl1cbiAgICogICBbamFdV0tXZWJWaWV344Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzV0tXZWJWaWV3KCkge1xuICAgIGNvbnN0IGx0ZTkgPSAvY29uc3RydWN0b3IvaS50ZXN0KE5hdGl2ZUhUTUxFbGVtZW50KTtcbiAgICByZXR1cm4gISEodGhpcy5pc0lPUygpICYmIHdpbmRvdy53ZWJraXQgJiYgd2luZG93LndlYmtpdC5tZXNzYWdlSGFuZGxlcnMgJiYgd2luZG93LmluZGV4ZWREQiAmJiAhbHRlOSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc1VJV2ViVmlld1xuICAgKiBAc2lnbmF0dXJlIGlzVUlXZWJWaWV3KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciBhcHAgaXMgcnVubmluZyBpbiBVSVdlYlZpZXcuWy9lbl1cbiAgICogICBbamFdVUlXZWJWaWV344Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzVUlXZWJWaWV3KCkge1xuICAgIHJldHVybiAhISh0aGlzLmlzSU9TKCkgJiYgIXRoaXMuaXNJT1NTYWZhcmkoKSAmJiAhdGhpcy5pc1dLV2ViVmlldygpKTtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBBbmRyb2lkIGRldmljZXNcbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQW5kcm9pZFBob25lXG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkUGhvbmUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQW5kcm9pZCBwaG9uZS5bL2VuXVxuICAgKiAgIFtqYV1BbmRyb2lk5pC65biv5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQW5kcm9pZFBob25lKCkge1xuICAgIHJldHVybiAvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgL01vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc0FuZHJvaWRUYWJsZXRcbiAgICogQHNpZ25hdHVyZSBpc0FuZHJvaWRUYWJsZXQoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBkZXZpY2UgaXMgQW5kcm9pZCB0YWJsZXQuWy9lbl1cbiAgICogICBbamFdQW5kcm9pZOOCv+ODluODrOODg+ODiOS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0FuZHJvaWRUYWJsZXQoKSB7XG4gICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhL01vYmlsZS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQW5kcm9pZCB2ZXJzaW9uc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNBbmRyb2lkXG4gICAqIEBzaWduYXR1cmUgaXNBbmRyb2lkKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgT1MgaXMgQW5kcm9pZC5bL2VuXVxuICAgKiAgIFtqYV1BbmRyb2lk5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzQW5kcm9pZCgpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnYW5kcm9pZCc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkZXZpY2UgPT09ICdvYmplY3QnICYmICEvYnJvd3Nlci9pLnRlc3QoZGV2aWNlLnBsYXRmb3JtKSkge1xuICAgICAgcmV0dXJuIC9BbmRyb2lkL2kudGVzdChkZXZpY2UucGxhdGZvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gL0FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBPdGhlciBkZXZpY2VzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzV1AoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ3dwJztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL1dpbjMyTlR8V2luQ0UvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvV2luZG93cyBQaG9uZXxJRU1vYmlsZXxXUERlc2t0b3AvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQmxhY2tCZXJyeVxuICAgKiBAc2lnbmF0dXJlIGlzQmxhY2tCZXJyeSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGRldmljZSBpcyBCbGFja0JlcnJ5LlsvZW5dXG4gICAqICAgW2phXUJsYWNrQmVycnnkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNCbGFja0JlcnJ5KCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdibGFja2JlcnJ5JztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcgJiYgIS9icm93c2VyL2kudGVzdChkZXZpY2UucGxhdGZvcm0pKSB7XG4gICAgICByZXR1cm4gL0JsYWNrQmVycnkvaS50ZXN0KGRldmljZS5wbGF0Zm9ybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvQmxhY2tCZXJyeXxSSU0gVGFibGV0IE9TfEJCMTAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBPdGhlciBicm93c2Vyc1xuICAvLy0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNPcGVyYVxuICAgKiBAc2lnbmF0dXJlIGlzT3BlcmEoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIE9wZXJhLlsvZW5dXG4gICAqICAgW2phXU9wZXJh5LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzT3BlcmEoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ29wZXJhJztcbiAgICB9XG5cbiAgICByZXR1cm4gKCEhd2luZG93Lm9wZXJhIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignIE9QUi8nKSA+PSAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzRmlyZWZveFxuICAgKiBAc2lnbmF0dXJlIGlzRmlyZWZveCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZXR1cm5zIHdoZXRoZXIgdGhlIGJyb3dzZXIgaXMgRmlyZWZveC5bL2VuXVxuICAgKiAgIFtqYV1GaXJlZm945LiK44Gn5a6f6KGM44GV44KM44Gm44GE44KL44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzRmlyZWZveCgpIHtcbiAgICBpZiAodGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpID09PSAnZmlyZWZveCc7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzU2FmYXJpXG4gICAqIEBzaWduYXR1cmUgaXNTYWZhcmkoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIFNhZmFyaS5bL2VuXVxuICAgKiAgIFtqYV1TYWZhcmnkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNTYWZhcmkoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ3NhZmFyaSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93LkhUTUxFbGVtZW50KS5pbmRleE9mKCdDb25zdHJ1Y3RvcicpID4gMCkgfHwgKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNhZmFyaVJlbW90ZU5vdGlmaWNhdGlvbl0nIH0pKCF3aW5kb3dbJ3NhZmFyaSddIHx8IHNhZmFyaS5wdXNoTm90aWZpY2F0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzQ2hyb21lXG4gICAqIEBzaWduYXR1cmUgaXNDaHJvbWUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBicm93c2VyIGlzIENocm9tZS5bL2VuXVxuICAgKiAgIFtqYV1DaHJvbWXkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNDaHJvbWUoKSB7XG4gICAgaWYgKHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFNlbGVjdGVkUGxhdGZvcm0oKSA9PT0gJ2Nocm9tZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICghIXdpbmRvdy5jaHJvbWUgJiYgISghIXdpbmRvdy5vcGVyYSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBPUFIvJykgPj0gMCkgJiYgIShuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJyBFZGdlLycpID49IDApKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGlzSUVcbiAgICogQHNpZ25hdHVyZSBpc0lFKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3Jlci5bL2VuXVxuICAgKiAgIFtqYV1JbnRlcm5ldCBFeHBsb3JlcuS4iuOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0lFKCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdpZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaXNFZGdlXG4gICAqIEBzaWduYXR1cmUgaXNFZGdlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgYnJvd3NlciBpcyBFZGdlLlsvZW5dXG4gICAqICAgW2phXUVkZ2XkuIrjgaflrp/ooYzjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNFZGdlKCkge1xuICAgIGlmICh0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRTZWxlY3RlZFBsYXRmb3JtKCkgPT09ICdlZGdlJztcbiAgICB9XG5cbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcgRWRnZS8nKSA+PSAwO1xuICB9XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG4gIC8vLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQHJldHVybiB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0TW9iaWxlT1MoKSB7XG4gICAgaWYgKHRoaXMuaXNBbmRyb2lkKCkpIHtcbiAgICAgIHJldHVybiAnYW5kcm9pZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJT1MoKSkge1xuICAgICAgcmV0dXJuICdpb3MnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLmlzV1AoKSkge1xuICAgICAgcmV0dXJuICd3cCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIGdldElPU0RldmljZSgpIHtcbiAgICBpZiAodGhpcy5pc0lQaG9uZSgpKSB7XG4gICAgICByZXR1cm4gJ2lwaG9uZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJUGFkKCkpIHtcbiAgICAgIHJldHVybiAnaXBhZCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuaXNJUG9kKCkpIHtcbiAgICAgIHJldHVybiAnaXBvZCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuICduYSc7XG4gICAgfVxuICB9XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgbmV3IFBsYXRmb3JtKCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBlcnJvciA9IG1lc3NhZ2UgPT4gdXRpbC50aHJvdyhgSW4gUGFnZUF0dHJpYnV0ZUV4cHJlc3Npb246ICR7bWVzc2FnZX1gKTtcblxuY29uc3QgcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24gPSB7XG4gIF92YXJpYWJsZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGVcbiAgICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHZhbHVlIFZhbHVlIG9mIHRoZSB2YXJpYWJsZS4gQ2FuIGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiBtdXN0IHJldHVybiBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBvdmVyd3JpdGUgSWYgdGhpcyB2YWx1ZSBpcyBmYWxzZSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gd2hlbiB0cnlpbmcgdG8gZGVmaW5lIGEgdmFyaWFibGUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXG4gICAqL1xuICBkZWZpbmVWYXJpYWJsZTogZnVuY3Rpb24obmFtZSwgdmFsdWUsIG92ZXJ3cml0ZT1mYWxzZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdWYXJpYWJsZSBuYW1lIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdWYXJpYWJsZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGhpcy5fdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpICYmICFvdmVyd3JpdGUpIHtcbiAgICAgIGVycm9yKGBcIiR7bmFtZX1cIiBpcyBhbHJlYWR5IGRlZmluZWRgKTtcbiAgICB9XG4gICAgdGhpcy5fdmFyaWFibGVzW25hbWVdID0gdmFsdWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHZhcmlhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSB2YXJpYWJsZS5cbiAgICogQHJldHVybiB7U3RyaW5nfEZ1bmN0aW9ufG51bGx9XG4gICAqL1xuICBnZXRWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICghdGhpcy5fdmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzW25hbWVdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB2YXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgdmFyYWlibGUuXG4gICAqL1xuICByZW1vdmVWYXJpYWJsZTogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLl92YXJpYWJsZXNbbmFtZV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhbGwgdmFyaWFibGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBnZXRBbGxWYXJpYWJsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXM7XG4gIH0sXG4gIF9wYXJzZVBhcnQ6IGZ1bmN0aW9uKHBhcnQpIHtcbiAgICBsZXQgYyxcbiAgICAgIGluSW50ZXJwb2xhdGlvbiA9IGZhbHNlLFxuICAgICAgY3VycmVudEluZGV4ID0gMDtcblxuICAgIGNvbnN0IHRva2VucyA9IFtdO1xuXG4gICAgaWYgKHBhcnQubGVuZ3RoID09PSAwKSB7XG4gICAgICBlcnJvcignVW5hYmxlIHRvIHBhcnNlIGVtcHR5IHN0cmluZycpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydC5sZW5ndGg7IGkrKykge1xuICAgICAgYyA9IHBhcnQuY2hhckF0KGkpO1xuXG4gICAgICBpZiAoYyA9PT0gJyQnICYmIHBhcnQuY2hhckF0KGkgKyAxKSA9PT0gJ3snKSB7XG4gICAgICAgIGlmIChpbkludGVycG9sYXRpb24pIHtcbiAgICAgICAgICBlcnJvcignTmVzdGVkIGludGVycG9sYXRpb24gbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG9rZW4gPSBwYXJ0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIGkpO1xuICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEluZGV4ID0gaTtcbiAgICAgICAgaW5JbnRlcnBvbGF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGMgPT09ICd9Jykge1xuICAgICAgICBpZiAoIWluSW50ZXJwb2xhdGlvbikge1xuICAgICAgICAgIGVycm9yKCd9IG11c3QgYmUgcHJlY2VlZGVkIGJ5ICR7Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpO1xuICAgICAgICBpZiAodG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHBhcnQuc3Vic3RyaW5nKGN1cnJlbnRJbmRleCwgaSArIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGkgKyAxO1xuICAgICAgICBpbkludGVycG9sYXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5JbnRlcnBvbGF0aW9uKSB7XG4gICAgICBlcnJvcignVW50ZXJtaW5hdGVkIGludGVycG9sYXRpb24nKTtcbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaChwYXJ0LnN1YnN0cmluZyhjdXJyZW50SW5kZXgsIHBhcnQubGVuZ3RoKSk7XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9LFxuICBfcmVwbGFjZVRva2VuOiBmdW5jdGlvbih0b2tlbikge1xuICAgIGNvbnN0IHJlID0gL15cXCR7KC4qPyl9JC8sXG4gICAgICBtYXRjaCA9IHRva2VuLm1hdGNoKHJlKTtcblxuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3QgbmFtZSA9IG1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGNvbnN0IHZhcmlhYmxlID0gdGhpcy5nZXRWYXJpYWJsZShuYW1lKTtcblxuICAgICAgaWYgKHZhcmlhYmxlID09PSBudWxsKSB7XG4gICAgICAgIGVycm9yKGBWYXJpYWJsZSBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHZhcmlhYmxlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFyaWFibGU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcnYgPSB2YXJpYWJsZSgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgcnYgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3IoJ011c3QgcmV0dXJuIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcnY7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cbiAgfSxcbiAgX3JlcGxhY2VUb2tlbnM6IGZ1bmN0aW9uKHRva2Vucykge1xuICAgIHJldHVybiB0b2tlbnMubWFwKHRoaXMuX3JlcGxhY2VUb2tlbi5iaW5kKHRoaXMpKTtcbiAgfSxcbiAgX3BhcnNlRXhwcmVzc2lvbjogZnVuY3Rpb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uLnNwbGl0KCcsJylcbiAgICAgIC5tYXAoXG4gICAgICAgIGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICByZXR1cm4gcGFydC50cmltKCk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICAgIC5tYXAodGhpcy5fcGFyc2VQYXJ0LmJpbmQodGhpcykpXG4gICAgICAubWFwKHRoaXMuX3JlcGxhY2VUb2tlbnMuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAoKHBhcnQpID0+IHBhcnQuam9pbignJykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBhbiBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXhwcmVzc2lvbiBBbiBwYWdlIGF0dHJpYnV0ZSBleHByZXNzaW9uLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGV2YWx1YXRlOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgfVxufTtcblxuLy8gRGVmaW5lIGRlZmF1bHQgdmFyaWFibGVzLlxucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ21vYmlsZU9TJywgcGxhdGZvcm0uZ2V0TW9iaWxlT1MoKSk7XG5wYWdlQXR0cmlidXRlRXhwcmVzc2lvbi5kZWZpbmVWYXJpYWJsZSgnaU9TRGV2aWNlJywgcGxhdGZvcm0uZ2V0SU9TRGV2aWNlKCkpO1xucGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZGVmaW5lVmFyaWFibGUoJ3J1bnRpbWUnLCAoKSA9PiB7XG4gIHJldHVybiBwbGF0Zm9ybS5pc1dlYlZpZXcoKSA/ICdjb3Jkb3ZhJyA6ICdicm93c2VyJztcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL3BsYXRmb3JtJztcbmltcG9ydCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiBmcm9tICcuLi9wYWdlLWF0dHJpYnV0ZS1leHByZXNzaW9uJztcblxuY29uc3QgaW50ZXJuYWwgPSB7fTtcblxuaW50ZXJuYWwuY29uZmlnID0ge1xuICBhdXRvU3RhdHVzQmFyRmlsbDogdHJ1ZSxcbiAgYW5pbWF0aW9uc0Rpc2FibGVkOiBmYWxzZSxcbiAgd2FybmluZ3NEaXNhYmxlZDogZmFsc2Vcbn07XG5cbmludGVybmFsLm51bGxFbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4vKipcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsID0gKCkgPT4ge1xuICByZXR1cm4gISFpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MID0gaHRtbCA9PiAoJycgKyBodG1sKS50cmltKCk7XG5cbmludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xuICBpZiAod2luZG93LmRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCB3aW5kb3cuZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAndW5pbml0aWFsaXplZCcpIHtcbiAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkQ2FsbGJhY2spO1xuICAgIH07XG4gICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkQ2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gIH1cbn07XG5cbmludGVybmFsLmF1dG9TdGF0dXNCYXJGaWxsID0gYWN0aW9uID0+IHtcbiAgY29uc3Qgb25SZWFkeSA9ICgpID0+IHtcbiAgICBpZiAoaW50ZXJuYWwuc2hvdWxkRmlsbFN0YXR1c0JhcigpKSB7XG4gICAgICBhY3Rpb24oKTtcbiAgICB9XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlcmVhZHknLCBvblJlYWR5KTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRldmljZSA9PT0gJ29iamVjdCcpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIG9uUmVhZHkpO1xuICB9IGVsc2UgaWYgKFsnY29tcGxldGUnLCAnaW50ZXJhY3RpdmUnXS5pbmRleE9mKGRvY3VtZW50LnJlYWR5U3RhdGUpID09PSAtMSkge1xuICAgIGludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkKG9uUmVhZHkpO1xuICB9IGVsc2Uge1xuICAgIG9uUmVhZHkoKTtcbiAgfVxufTtcblxuaW50ZXJuYWwuc2hvdWxkRmlsbFN0YXR1c0JhciA9ICgpID0+IGludGVybmFsLmlzRW5hYmxlZEF1dG9TdGF0dXNCYXJGaWxsKCkgJiZcbiAgKHBsYXRmb3JtLmlzV2ViVmlldygpICYmIHBsYXRmb3JtLmlzSU9TN2Fib3ZlKCkgJiYgIXBsYXRmb3JtLmlzSVBob25lWCgpIHx8IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcignLm9ucy1zdGF0dXMtYmFyLW1vY2suaW9zJykpO1xuXG5pbnRlcm5hbC50ZW1wbGF0ZVN0b3JlID0ge1xuICBfc3RvcmFnZToge30sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7U3RyaW5nL251bGx9IHRlbXBsYXRlXG4gICAqL1xuICBnZXQoa2V5KSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRlbXBsYXRlU3RvcmUuX3N0b3JhZ2Vba2V5XSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVxuICAgKi9cbiAgc2V0KGtleSwgdGVtcGxhdGUpIHtcbiAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLl9zdG9yYWdlW2tleV0gPSB0ZW1wbGF0ZTtcbiAgfVxufTtcblxud2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ190ZW1wbGF0ZWxvYWRlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgaWYgKGUudGFyZ2V0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGVtcGxhdGUnKSB7XG4gICAgaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5zZXQoZS50ZW1wbGF0ZUlkLCBlLnRlbXBsYXRlKTtcbiAgfVxufSwgZmFsc2UpO1xuXG5pbnRlcm5hbC53YWl0RE9NQ29udGVudExvYWRlZChmdW5jdGlvbigpIHtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC9vbnMtdGVtcGxhdGVcIl0nKTtcbiAgcmVnaXN0ZXIoJ3NjcmlwdFt0eXBlPVwidGV4dC90ZW1wbGF0ZVwiXScpO1xuICByZWdpc3Rlcignc2NyaXB0W3R5cGU9XCJ0ZXh0L25nLXRlbXBsYXRlXCJdJyk7XG4gIHJlZ2lzdGVyKCd0ZW1wbGF0ZScpO1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyKHF1ZXJ5KSB7XG4gICAgY29uc3QgdGVtcGxhdGVzID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcGxhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldCh0ZW1wbGF0ZXNbaV0uZ2V0QXR0cmlidXRlKCdpZCcpLCB0ZW1wbGF0ZXNbaV0udGV4dENvbnRlbnQgfHwgdGVtcGxhdGVzW2ldLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbmludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jID0gZnVuY3Rpb24ocGFnZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkKCgpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlID0gaW50ZXJuYWwudGVtcGxhdGVTdG9yZS5nZXQocGFnZSk7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgaWYgKGNhY2hlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGNhY2hlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGh0bWwgPSB0eXBlb2YgY2FjaGUgPT09ICdzdHJpbmcnID8gY2FjaGUgOiBjYWNoZVsxXTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoaW50ZXJuYWwubm9ybWFsaXplUGFnZUhUTUwoaHRtbCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2NhbCA9IHdpbmRvdy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYWdlKTtcbiAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICBjb25zdCBodG1sID0gbG9jYWwudGV4dENvbnRlbnQgfHwgbG9jYWwuY29udGVudDtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHBhZ2UsIHRydWUpO1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCBodG1sID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gNDAwICYmIHhoci5zdGF0dXMgPCA2MDApIHtcbiAgICAgICAgICByZWplY3QoaHRtbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUmVmcmVzaCBzY3JpcHQgdGFnc1xuICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdXRpbC5jcmVhdGVGcmFnbWVudChodG1sKTtcbiAgICAgICAgICB1dGlsLmFycmF5RnJvbShmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKSkuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNjcmlwdC50eXBlID0gZWwudHlwZSB8fCAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgICAgIHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShlbC50ZXh0IHx8IGVsLnRleHRDb250ZW50IHx8IGVsLmlubmVySFRNTCkpO1xuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoc2NyaXB0LCBlbCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpbnRlcm5hbC50ZW1wbGF0ZVN0b3JlLnNldChwYWdlLCBmcmFnbWVudCk7XG4gICAgICAgICAgcmVzb2x2ZShmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB1dGlsLnRocm93KGBQYWdlIHRlbXBsYXRlIG5vdCBmb3VuZDogJHtwYWdlfWApO1xuICAgICAgfTtcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKi9cbmludGVybmFsLmdldFBhZ2VIVE1MQXN5bmMgPSBmdW5jdGlvbihwYWdlKSB7XG4gIGNvbnN0IHBhZ2VzID0gcGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24uZXZhbHVhdGUocGFnZSk7XG5cbiAgY29uc3QgZ2V0UGFnZSA9IChwYWdlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdNdXN0IHNwZWNpZnkgYSBwYWdlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbC5nZXRUZW1wbGF0ZUhUTUxBc3luYyhwYWdlKVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgIGlmIChwYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFBhZ2UocGFnZXMuc2hpZnQoKSk7XG4gICAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gZ2V0UGFnZShwYWdlcy5zaGlmdCgpKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRvckZhY3Rvcnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cy5hbmltYXRvcnMgVGhlIGRpY3Rpb25hcnkgZm9yIGFuaW1hdG9yIGNsYXNzZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5iYXNlQ2xhc3MgVGhlIGJhc2UgY2xhc3Mgb2YgYW5pbWF0b3JzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0cy5iYXNlQ2xhc3NOYW1lXSBUaGUgbmFtZSBvZiB0aGUgYmFzZSBjbGFzcyBvZiBhbmltYXRvcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmRlZmF1bHRBbmltYXRpb25dIFRoZSBkZWZhdWx0IGFuaW1hdGlvbiBuYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9uc10gVGhlIGRlZmF1bHQgYW5pbWF0aW9uIG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLl9hbmltYXRvcnMgPSBvcHRzLmFuaW1hdG9ycztcbiAgICB0aGlzLl9iYXNlQ2xhc3MgPSBvcHRzLmJhc2VDbGFzcztcbiAgICB0aGlzLl9iYXNlQ2xhc3NOYW1lID0gb3B0cy5iYXNlQ2xhc3NOYW1lIHx8IG9wdHMuYmFzZUNsYXNzLm5hbWU7XG4gICAgdGhpcy5fYW5pbWF0aW9uID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uIHx8ICdkZWZhdWx0JztcbiAgICB0aGlzLl9hbmltYXRpb25PcHRpb25zID0gb3B0cy5kZWZhdWx0QW5pbWF0aW9uT3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghdGhpcy5fYW5pbWF0b3JzW3RoaXMuX2FuaW1hdGlvbl0pIHtcbiAgICAgIHV0aWwudGhyb3coJ05vIHN1Y2ggYW5pbWF0aW9uOiAnICsgdGhpcy5fYW5pbWF0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGpzb25TdHJpbmdcbiAgICogQHJldHVybiB7T2JqZWN0L251bGx9XG4gICAqL1xuICBzdGF0aWMgcGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKGpzb25TdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBqc29uU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB1dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZShqc29uU3RyaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdvYmplY3QnICYmIHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignXCJhbmltYXRpb24tb3B0aW9uc1wiIGF0dHJpYnV0ZSBtdXN0IGJlIGEgSlNPTiBvYmplY3Qgc3RyaW5nOiAnICsganNvblN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdcImFuaW1hdGlvbi1vcHRpb25zXCIgYXR0cmlidXRlIG11c3QgYmUgYSBKU09OIG9iamVjdCBzdHJpbmc6ICcgKyBqc29uU3RyaW5nKTtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIHNldEFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2FuaW1hdGlvbk9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dIFRoZSBhbmltYXRpb24gbmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc10gVGhlIGFuaW1hdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0QW5pbWF0b3IgVGhlIGRlZmF1bHQgYW5pbWF0b3IgaW5zdGFuY2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBhbmltYXRvciBpbnN0YW5jZVxuICAgKi9cbiAgbmV3QW5pbWF0b3Iob3B0aW9ucyA9IHt9LCBkZWZhdWx0QW5pbWF0b3IpIHtcblxuICAgIGxldCBhbmltYXRvciA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gaW5zdGFuY2VvZiB0aGlzLl9iYXNlQ2xhc3MpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmFuaW1hdGlvbjtcbiAgICB9XG5cbiAgICBsZXQgQW5pbWF0b3IgPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFuaW1hdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIEFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JzW29wdGlvbnMuYW5pbWF0aW9uXTtcbiAgICB9XG5cbiAgICBpZiAoIUFuaW1hdG9yICYmIGRlZmF1bHRBbmltYXRvcikge1xuICAgICAgYW5pbWF0b3IgPSBkZWZhdWx0QW5pbWF0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIEFuaW1hdG9yID0gQW5pbWF0b3IgfHwgdGhpcy5fYW5pbWF0b3JzW3RoaXMuX2FuaW1hdGlvbl07XG5cbiAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSB1dGlsLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbk9wdGlvbnMsXG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fSxcbiAgICAgICAgaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA/IHtkdXJhdGlvbjogMCwgZGVsYXk6IDB9IDoge31cbiAgICAgICk7XG5cbiAgICAgIGFuaW1hdG9yID0gbmV3IEFuaW1hdG9yKGFuaW1hdGlvbk9wdHMpO1xuXG4gICAgICBpZiAodHlwZW9mIGFuaW1hdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFuaW1hdG9yID0gbmV3IGFuaW1hdG9yKGFuaW1hdGlvbk9wdHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIShhbmltYXRvciBpbnN0YW5jZW9mIHRoaXMuX2Jhc2VDbGFzcykpIHtcbiAgICAgIHV0aWwudGhyb3coYFwiYW5pbWF0b3JcIiBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgJHt0aGlzLl9iYXNlQ2xhc3NOYW1lfWApO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc1BsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0nO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcblxubGV0IGF1dG9TdHlsZUVuYWJsZWQgPSB0cnVlO1xuXG4vLyBNb2RpZmllcnNcbmNvbnN0IG1vZGlmaWVyc01hcCA9IHtcbiAgJ3F1aWV0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ2xpZ2h0JzogJ21hdGVyaWFsLS1mbGF0JyxcbiAgJ291dGxpbmUnOiAnbWF0ZXJpYWwtLWZsYXQnLFxuICAnY3RhJzogJycsXG4gICdsYXJnZS0tcXVpZXQnOiAnbWF0ZXJpYWwtLWZsYXQgbGFyZ2UnLFxuICAnbGFyZ2UtLWN0YSc6ICdsYXJnZScsXG4gICdub2JvcmRlcic6ICcnLFxuICAndGFwcGFibGUnOiAnJ1xufTtcblxuY29uc3QgcGxhdGZvcm1zID0ge307XG5cbnBsYXRmb3Jtcy5hbmRyb2lkID0gZWxlbWVudCA9PiB7XG5cbiAgY29uc3QgZWxlbWVudE5hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAoIXV0aWwuaGFzTW9kaWZpZXIoZWxlbWVudCwgJ21hdGVyaWFsJykpIHtcbiAgICBjb25zdCBvbGRNb2RpZmllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpIHx8ICcnO1xuXG4gICAgY29uc3QgbmV3TW9kaWZpZXIgPSBvbGRNb2RpZmllci50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZSA9PiBtb2RpZmllcnNNYXAuaGFzT3duUHJvcGVydHkoZSkgPyBtb2RpZmllcnNNYXBbZV0gOiBlKTtcbiAgICBuZXdNb2RpZmllci51bnNoaWZ0KCdtYXRlcmlhbCcpO1xuXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbmV3TW9kaWZpZXIuam9pbignICcpLnRyaW0oKSk7XG4gIH1cblxuICBjb25zdCBlbGVtZW50cyA9IFtcbiAgICAnb25zLWFsZXJ0LWRpYWxvZy1idXR0b24nLFxuICAgICdvbnMtdG9vbGJhci1idXR0b24nLFxuICAgICdvbnMtYmFjay1idXR0b24nLFxuICAgICdvbnMtYnV0dG9uJyxcbiAgICAnb25zLWxpc3QtaXRlbScsXG4gICAgJ29ucy1mYWInLFxuICAgICdvbnMtc3BlZWQtZGlhbCcsXG4gICAgJ29ucy1zcGVlZC1kaWFsLWl0ZW0nLFxuICAgICdvbnMtdGFiJ1xuICBdO1xuXG5cbiAgLy8gRWZmZWN0c1xuICBpZiAoZWxlbWVudHMuaW5kZXhPZihlbGVtZW50TmFtZSkgIT09IC0xXG4gICAgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdyaXBwbGUnKVxuICAgICYmICFlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ29ucy1yaXBwbGUnKSkge1xuXG4gICAgaWYgKGVsZW1lbnROYW1lID09PSAnb25zLWxpc3QtaXRlbScpIHtcbiAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFwcGFibGUnKSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFwcGFibGUnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JpcHBsZScsICcnKTtcbiAgICB9XG4gIH1cbn07XG5cbnBsYXRmb3Jtcy5pb3MgPSBlbGVtZW50ID0+IHtcblxuIC8vIE1vZGlmaWVyc1xuIGlmICh1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdtYXRlcmlhbCcpKSB7XG4gICBpZiAodXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCAnbWF0ZXJpYWwtLWZsYXQnKSkge1xuICAgICB1dGlsLmFkZE1vZGlmaWVyKGVsZW1lbnQsICh1dGlsLnJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsICdsYXJnZScpKSA/ICdsYXJnZS0tcXVpZXQnIDogJ3F1aWV0Jyk7XG4gICB9XG5cbiAgIGlmICghZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XG4gICB9XG4gfVxuXG4gLy8gRWZmZWN0c1xuIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgncmlwcGxlJykpIHtcbiAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ29ucy1saXN0LWl0ZW0nKSB7XG4gICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YXBwYWJsZScsICcnKTtcbiAgIH1cblxuICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuIH1cbn07XG5cbmNvbnN0IHVubG9ja2VkID0ge1xuICBhbmRyb2lkOiB0cnVlXG59O1xuXG5jb25zdCBnZXRQbGF0Zm9ybSA9IChlbGVtZW50LCBmb3JjZSkgPT4ge1xuICBpZiAoYXV0b1N0eWxlRW5hYmxlZCAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGUtYXV0by1zdHlsaW5nJykpIHtcbiAgICBjb25zdCBtb2JpbGVPUyA9IG9uc1BsYXRmb3JtLmdldE1vYmlsZU9TKCk7XG4gICAgaWYgKHBsYXRmb3Jtcy5oYXNPd25Qcm9wZXJ0eShtb2JpbGVPUykgJiYgKHVubG9ja2VkLmhhc093blByb3BlcnR5KG1vYmlsZU9TKSB8fCBmb3JjZSkpIHtcbiAgICAgIHJldHVybiBtb2JpbGVPUztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBwcmVwYXJlID0gKGVsZW1lbnQsIGZvcmNlKSA9PiB7XG4gIGNvbnN0IHAgPSBnZXRQbGF0Zm9ybShlbGVtZW50LCBmb3JjZSk7XG4gIHAgJiYgcGxhdGZvcm1zW3BdKGVsZW1lbnQpO1xufTtcblxuY29uc3QgbWFwTW9kaWZpZXIgPSAobW9kaWZpZXIsIGVsZW1lbnQsIGZvcmNlKSA9PiB7XG4gIGlmIChnZXRQbGF0Zm9ybShlbGVtZW50LCBmb3JjZSkpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIuc3BsaXQoL1xccysvKS5tYXAobSA9PiBtb2RpZmllcnNNYXAuaGFzT3duUHJvcGVydHkobSkgPyBtb2RpZmllcnNNYXBbbV0gOiBtKS5qb2luKCcgJyk7XG4gIH1cbiAgcmV0dXJuIG1vZGlmaWVyO1xufTtcblxuY29uc3QgcmVzdG9yZU1vZGlmaWVyID0gZWxlbWVudCA9PiB7XG4gIGlmIChnZXRQbGF0Zm9ybShlbGVtZW50KSA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgY29uc3QgbW9kaWZpZXIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJztcbiAgICBsZXQgbmV3TW9kaWZpZXIgPSBtYXBNb2RpZmllcihtb2RpZmllciwgZWxlbWVudCk7XG5cbiAgICBpZiAoIS8oXnxcXHMrKW1hdGVyaWFsKCR8XFxzKykvaS50ZXN0KG1vZGlmaWVyKSkge1xuICAgICAgbmV3TW9kaWZpZXIgPSAnbWF0ZXJpYWwgJyArIG5ld01vZGlmaWVyO1xuICAgIH1cblxuICAgIGlmIChuZXdNb2RpZmllciAhPT0gbW9kaWZpZXIpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIG5ld01vZGlmaWVyLnRyaW0oKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc0VuYWJsZWQ6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQsXG4gIGVuYWJsZTogKCkgPT4gYXV0b1N0eWxlRW5hYmxlZCA9IHRydWUsXG4gIGRpc2FibGU6ICgpID0+IGF1dG9TdHlsZUVuYWJsZWQgPSBmYWxzZSxcbiAgcHJlcGFyZSxcbiAgbWFwTW9kaWZpZXIsXG4gIGdldFBsYXRmb3JtLFxuICByZXN0b3JlTW9kaWZpZXJcbn07XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsLmpzJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vYXV0b3N0eWxlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kaWZpZXJVdGlsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjdXJyZW50XG4gICAqL1xuICBzdGF0aWMgZGlmZihsYXN0LCBjdXJyZW50KSB7XG4gICAgbGFzdCA9IG1ha2VEaWN0KCgnJyArIGxhc3QpLnRyaW0oKSk7XG4gICAgY3VycmVudCA9IG1ha2VEaWN0KCgnJyArIGN1cnJlbnQpLnRyaW0oKSk7XG5cbiAgICBjb25zdCByZW1vdmVkID0gT2JqZWN0LmtleXMobGFzdCkucmVkdWNlKChyZXN1bHQsIHRva2VuKSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRbdG9rZW5dKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgYWRkZWQgPSBPYmplY3Qua2V5cyhjdXJyZW50KS5yZWR1Y2UoKHJlc3VsdCwgdG9rZW4pID0+IHtcbiAgICAgIGlmICghbGFzdFt0b2tlbl0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4ge2FkZGVkLCByZW1vdmVkfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VEaWN0KG1vZGlmaWVyKSB7XG4gICAgICBjb25zdCBkaWN0ID0ge307XG4gICAgICBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpLmZvckVhY2godG9rZW4gPT4gZGljdFt0b2tlbl0gPSB0b2tlbik7XG4gICAgICByZXR1cm4gZGljdDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtBcnJheX0gZGlmZi5yZW1vdmVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYuYWRkZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNsYXNzTGlzdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGVtcGxhdGVcbiAgICovXG4gIHN0YXRpYyBhcHBseURpZmZUb0NsYXNzTGlzdChkaWZmLCBjbGFzc0xpc3QsIHRlbXBsYXRlKSB7XG4gICAgZGlmZi5hZGRlZFxuICAgICAgLm1hcChtb2RpZmllciA9PiB0ZW1wbGF0ZS5yZXBsYWNlKC9cXCovZywgbW9kaWZpZXIpKVxuICAgICAgLmZvckVhY2goa2xhc3MgPT4ga2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGsgPT4gY2xhc3NMaXN0LmFkZChrKSkpO1xuXG4gICAgZGlmZi5yZW1vdmVkXG4gICAgICAubWFwKG1vZGlmaWVyID0+IHRlbXBsYXRlLnJlcGxhY2UoL1xcKi9nLCBtb2RpZmllcikpXG4gICAgICAuZm9yRWFjaChrbGFzcyA9PiBrbGFzcy5zcGxpdCgvXFxzKy8pLmZvckVhY2goayA9PiBjbGFzc0xpc3QucmVtb3ZlKGspKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpZmZcbiAgICogQHBhcmFtIHtBcnJheX0gZGlmZi5yZW1vdmVkXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRpZmYuYWRkZWRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgYXBwbHlEaWZmVG9FbGVtZW50KGRpZmYsIGVsZW1lbnQsIHNjaGVtZSkge1xuICAgIE9iamVjdC5rZXlzKHNjaGVtZSkuZm9yRWFjaChzZWxlY3RvciA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRFbGVtZW50cyA9ICFzZWxlY3RvciB8fCB1dGlsLm1hdGNoKGVsZW1lbnQsIHNlbGVjdG9yKVxuICAgICAgICA/IFtlbGVtZW50XVxuICAgICAgICA6IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChcbiAgICAgICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciksXG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0+ICF1dGlsLmZpbmRQYXJlbnQodGFyZ2V0RWxlbWVudCwgZWxlbWVudC50YWdOYW1lLCBwYXJlbnQgPT4gcGFyZW50ID09PSBlbGVtZW50KVxuICAgICAgICAgICk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0RWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvQ2xhc3NMaXN0KGRpZmYsIHRhcmdldEVsZW1lbnRzW2ldLmNsYXNzTGlzdCwgc2NoZW1lW3NlbGVjdG9yXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxhc3RcbiAgICogQHBhcmFtIHtTdHJpbmd9IGN1cnJlbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gICAqL1xuICBzdGF0aWMgb25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudChNb2RpZmllclV0aWwuZGlmZihsYXN0LCBjdXJyZW50KSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgICBhdXRvU3R5bGUucmVzdG9yZU1vZGlmaWVyKGVsZW1lbnQpO1xuICB9XG5cbiAgc3RhdGljIHJlZnJlc2goZWxlbWVudCwgc2NoZW1lKSB7XG4gICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudChNb2RpZmllclV0aWwuZGlmZignJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJycpLCBlbGVtZW50LCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtZVxuICAgKi9cbiAgc3RhdGljIGluaXRNb2RpZmllcihlbGVtZW50LCBzY2hlbWUpIHtcbiAgICBjb25zdCBtb2RpZmllciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpO1xuICAgIGlmICh0eXBlb2YgbW9kaWZpZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmFwcGx5RGlmZlRvRWxlbWVudCh7XG4gICAgICByZW1vdmVkOiBbXSxcbiAgICAgIGFkZGVkOiBNb2RpZmllclV0aWwuc3BsaXQobW9kaWZpZXIpXG4gICAgfSwgZWxlbWVudCwgc2NoZW1lKTtcbiAgfVxuXG4gIHN0YXRpYyBzcGxpdChtb2RpZmllcikge1xuICAgIGlmICh0eXBlb2YgbW9kaWZpZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGlmaWVyLnRyaW0oKS5zcGxpdCgvICsvKS5maWx0ZXIodG9rZW4gPT4gdG9rZW4gIT09ICcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgbW9kaWZpZXIgdG9rZW4gdG8gYW4gZWxlbWVudC5cbiAgICovXG4gIHN0YXRpYyBhZGRNb2RpZmllcihlbGVtZW50LCBtb2RpZmllclRva2VuKSB7XG4gICAgaWYgKCFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgbW9kaWZpZXJUb2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRva2VucyA9IE1vZGlmaWVyVXRpbC5zcGxpdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XG4gICAgICBpZiAodG9rZW5zLmluZGV4T2YobW9kaWZpZXJUb2tlbikgPT0gLTEpIHtcbiAgICAgICAgdG9rZW5zLnB1c2gobW9kaWZpZXJUb2tlbik7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdtb2RpZmllcicsIHRva2Vucy5qb2luKCcgJykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbW9kaWZpZXIgdG9rZW4gZnJvbSBhbiBlbGVtZW50LlxuICAgKi9cbiAgc3RhdGljIHJlbW92ZU1vZGlmaWVyKGVsZW1lbnQsIG1vZGlmaWVyVG9rZW4pIHtcbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21vZGlmaWVyJykpIHtcbiAgICAgIGNvbnN0IHRva2VucyA9IE1vZGlmaWVyVXRpbC5zcGxpdChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSk7XG4gICAgICBjb25zdCBpbmRleCA9IHRva2Vucy5pbmRleE9mKG1vZGlmaWVyVG9rZW4pO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0b2tlbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJywgdG9rZW5zLmpvaW4oJyAnKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0nO1xuXG5jb25zdCB1dGlsID0ge1xuICBfcmVhZHk6IGZhbHNlLFxuXG4gIF9kb21Db250ZW50TG9hZGVkOiBmYWxzZSxcblxuICBfb25ET01Db250ZW50TG9hZGVkOiAoKSA9PiB7XG4gICAgdXRpbC5fZG9tQ29udGVudExvYWRlZCA9IHRydWU7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNXZWJWaWV3KCkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsICgpID0+IHtcbiAgICAgICAgdXRpbC5fcmVhZHkgPSB0cnVlO1xuICAgICAgfSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dGlsLl9yZWFkeSA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGFkZEJhY2tCdXR0b25MaXN0ZW5lcjogZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoIXRoaXMuX2RvbUNvbnRlbnRMb2FkZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIGFmdGVyIERPTUNvbnRlbnRMb2FkZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVhZHkpIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZXJlYWR5JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdiYWNrYnV0dG9uJywgZm4sIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICByZW1vdmVCYWNrQnV0dG9uTGlzdGVuZXI6IGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKCF0aGlzLl9kb21Db250ZW50TG9hZGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBhZnRlciBET01Db250ZW50TG9hZGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmFja2J1dHRvbicsIGZuLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5pZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJyB8fFxuICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkZWQnIHx8XG4gICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJykge1xuICB1dGlsLl9vbkRPTUNvbnRlbnRMb2FkZWQoKTtcbn0gZWxzZSB7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4gdXRpbC5fb25ET01Db250ZW50TG9hZGVkKCksIGZhbHNlKTtcbn1cblxuY29uc3QgSGFuZGxlclJlcG9zaXRvcnkgPSB7XG4gIF9zdG9yZToge30sXG5cbiAgX2dlbklkOiAoKCkgPT4ge1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gKCkgPT4gaSsrO1xuICB9KSgpLFxuXG4gIHNldDogZnVuY3Rpb24oZWxlbWVudCwgaGFuZGxlcikge1xuICAgIGlmIChlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCkge1xuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gZWxlbWVudC5kYXRhc2V0LmRldmljZUJhY2tCdXR0b25IYW5kbGVySWQgPSBIYW5kbGVyUmVwb3NpdG9yeS5fZ2VuSWQoKTtcbiAgICB0aGlzLl9zdG9yZVtpZF0gPSBoYW5kbGVyO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N0b3JlW2VsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkXTtcbiAgICAgIGRlbGV0ZSBlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZDtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50LmRhdGFzZXQuZGV2aWNlQmFja0J1dHRvbkhhbmRsZXJJZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkO1xuXG4gICAgaWYgKCF0aGlzLl9zdG9yZVtpZF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdG9yZVtpZF07XG4gIH0sXG5cbiAgaGFzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50LmRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IGVsZW1lbnQuZGF0YXNldC5kZXZpY2VCYWNrQnV0dG9uSGFuZGxlcklkO1xuXG4gICAgcmV0dXJuICEhdGhpcy5fc3RvcmVbaWRdO1xuICB9XG59O1xuXG5jbGFzcyBEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2JvdW5kQ2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuICB9XG5cblxuICAvKipcbiAgICogRW5hYmxlIHRvIGhhbmRsZSAnYmFja2J1dHRvbicgZXZlbnRzLlxuICAgKi9cbiAgZW5hYmxlKCkge1xuICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICB1dGlsLmFkZEJhY2tCdXR0b25MaXN0ZW5lcih0aGlzLl9ib3VuZENhbGxiYWNrKTtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc2FibGUgdG8gaGFuZGxlICdiYWNrYnV0dG9uJyBldmVudHMuXG4gICAqL1xuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLl9pc0VuYWJsZWQpIHtcbiAgICAgIHV0aWwucmVtb3ZlQmFja0J1dHRvbkxpc3RlbmVyKHRoaXMuX2JvdW5kQ2FsbGJhY2spO1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmUgYSAnYmFja2J1dHRvbicgZXZlbnQgbWFudWFsbHkuXG4gICAqL1xuICBmaXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50KCkge1xuICAgIGNvbnN0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KCdiYWNrYnV0dG9uJywgdHJ1ZSwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICBfY2FsbGJhY2soKSB7XG4gICAgdGhpcy5fZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBjcmVhdGVIYW5kbGVyKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCEoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoIShjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlciA9IHtcbiAgICAgIF9jYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBfZWxlbWVudDogZWxlbWVudCxcblxuICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEhhbmRsZXJSZXBvc2l0b3J5LnJlbW92ZShlbGVtZW50KTtcbiAgICAgIH0sXG5cbiAgICAgIHNldExpc3RlbmVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgfSxcblxuICAgICAgZW5hYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgSGFuZGxlclJlcG9zaXRvcnkuc2V0KGVsZW1lbnQsIHRoaXMpO1xuICAgICAgfSxcblxuICAgICAgaXNFbmFibGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEhhbmRsZXJSZXBvc2l0b3J5LmdldChlbGVtZW50KSA9PT0gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBIYW5kbGVyUmVwb3NpdG9yeS5yZW1vdmUoZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGhhbmRsZXIuZW5hYmxlKCk7XG5cbiAgICByZXR1cm4gaGFuZGxlcjtcbiAgfVxuXG4gIF9kaXNwYXRjaERldmljZUJhY2tCdXR0b25FdmVudCgpIHtcbiAgICBjb25zdCB0cmVlID0gdGhpcy5fY2FwdHVyZVRyZWUoKTtcblxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9maW5kSGFuZGxlckxlYWZFbGVtZW50KHRyZWUpO1xuXG4gICAgbGV0IGhhbmRsZXIgPSBIYW5kbGVyUmVwb3NpdG9yeS5nZXQoZWxlbWVudCk7XG4gICAgaGFuZGxlci5fY2FsbGJhY2soY3JlYXRlRXZlbnQoZWxlbWVudCkpO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRXZlbnQoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX2VsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIGNhbGxQYXJlbnRIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgaGFuZGxlciA9IEhhbmRsZXJSZXBvc2l0b3J5LmdldChwYXJlbnQpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuX2NhbGxiYWNrKGNyZWF0ZUV2ZW50KHBhcmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBfY2FwdHVyZVRyZWUoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRyZWUoZG9jdW1lbnQuYm9keSk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUcmVlKGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHRyZWUgPSB7XG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgIGNoaWxkcmVuOiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnJheU9mKGVsZW1lbnQuY2hpbGRyZW4pLm1hcChmdW5jdGlvbihjaGlsZEVsZW1lbnQpIHtcblxuICAgICAgICAgIGlmIChjaGlsZEVsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnIHx8IGNoaWxkRWxlbWVudC5faXNTaG93biA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hpbGRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJiAhSGFuZGxlclJlcG9zaXRvcnkuaGFzKGNoaWxkRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVUcmVlKGNoaWxkRWxlbWVudCk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCAmJiAhSGFuZGxlclJlcG9zaXRvcnkuaGFzKHJlc3VsdC5lbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbcmVzdWx0XTtcbiAgICAgICAgfSkpXG4gICAgICB9O1xuXG4gICAgICBpZiAoIUhhbmRsZXJSZXBvc2l0b3J5Lmhhcyh0cmVlLmVsZW1lbnQpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5jaGlsZHJlbi5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgY29uc3Qgc3ViVHJlZSA9IHRyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgaWYgKEhhbmRsZXJSZXBvc2l0b3J5LmhhcyhzdWJUcmVlLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ViVHJlZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXJyYXlPZih0YXJnZXQpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2godGFyZ2V0W2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmVlXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgX2ZpbmRIYW5kbGVyTGVhZkVsZW1lbnQodHJlZSkge1xuICAgIHJldHVybiBmaW5kKHRyZWUpO1xuXG4gICAgZnVuY3Rpb24gZmluZChub2RlKSB7XG4gICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBmaW5kKG5vZGUuY2hpbGRyZW5bMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGROb2RlKSB7XG4gICAgICAgIHJldHVybiBjaGlsZE5vZGUuZWxlbWVudDtcbiAgICAgIH0pLnJlZHVjZShmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgICBpZiAoIWxlZnQpIHtcbiAgICAgICAgICByZXR1cm4gcmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsZWZ0WiA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGxlZnQsICcnKS56SW5kZXgsIDEwKTtcbiAgICAgICAgY29uc3QgcmlnaHRaID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUocmlnaHQsICcnKS56SW5kZXgsIDEwKTtcblxuICAgICAgICBpZiAoIWlzTmFOKGxlZnRaKSAmJiAhaXNOYU4ocmlnaHRaKSkge1xuICAgICAgICAgIHJldHVybiBsZWZ0WiA+IHJpZ2h0WiA/IGxlZnQgOiByaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwdHVyaW5nIGJhY2tidXR0b24taGFuZGxlciBpcyBmYWlsdXJlLicpO1xuICAgICAgfSwgbnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBEZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlcigpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi9tb2RpZmllci11dGlsJztcbmltcG9ydCBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciBmcm9tICcuL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcblxuaW50ZXJuYWwuQW5pbWF0b3JGYWN0b3J5ID0gQW5pbWF0b3JGYWN0b3J5O1xuaW50ZXJuYWwuTW9kaWZpZXJVdGlsID0gTW9kaWZpZXJVdGlsO1xuaW50ZXJuYWwuZGJiRGlzcGF0Y2hlciA9IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyO1xuXG5leHBvcnQgZGVmYXVsdCBpbnRlcm5hbDtcblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzdGFydHNXaXRoID0gKHMsIGMpID0+IHMuc3Vic3RyKDAsIGMubGVuZ3RoKSA9PT0gYztcbmNvbnN0IGVuZHNXaXRoID0gKHMsIGMpID0+IHMuc3Vic3RyKHMubGVuZ3RoIC0gYy5sZW5ndGgsIGMubGVuZ3RoKSA9PT0gYztcbmNvbnN0IHVud3JhcCA9IHMgPT4gcy5zbGljZSgxLCAtMSk7XG5jb25zdCBpc09iamVjdFN0cmluZyA9IHMgPT4gc3RhcnRzV2l0aChzLCAneycpICYmIGVuZHNXaXRoKHMsICd9Jyk7XG5jb25zdCBpc0FycmF5U3RyaW5nID0gcyA9PiBzdGFydHNXaXRoKHMsICdbJykgJiYgZW5kc1dpdGgocywgJ10nKTtcbmNvbnN0IGlzUXVvdGVkU3RyaW5nID0gcyA9PiAoc3RhcnRzV2l0aChzLCAnXFwnJykgJiYgZW5kc1dpdGgocywgJ1xcJycpKSB8fCAoc3RhcnRzV2l0aChzLCAnXCInKSAmJiBlbmRzV2l0aChzLCAnXCInKSk7XG5cbmNvbnN0IGVycm9yID0gKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSA9PiB7XG4gIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB0b2tlbiBcXCcnICsgdG9rZW4gKyAnXFwnIGF0IHBvc2l0aW9uICcgKyAob3JpZ2luYWxTdHJpbmcubGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCAtIDEpICsgJyBpbiBzdHJpbmc6IFxcJycgKyBvcmlnaW5hbFN0cmluZyArICdcXCcnKTtcbn07XG5cbmNvbnN0IHByb2Nlc3NUb2tlbiA9ICh0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZykgPT4ge1xuICBpZiAodG9rZW4gPT09ICd0cnVlJyB8fCB0b2tlbiA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiB0b2tlbiA9PT0gJ3RydWUnO1xuICB9IGVsc2UgaWYgKGlzUXVvdGVkU3RyaW5nKHRva2VuKSkge1xuICAgIHJldHVybiB1bndyYXAodG9rZW4pO1xuICB9IGVsc2UgaWYgKCFpc05hTih0b2tlbikpIHtcbiAgICByZXR1cm4gKyh0b2tlbik7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3RTdHJpbmcodG9rZW4pKSB7XG4gICAgcmV0dXJuIHBhcnNlT2JqZWN0KHVud3JhcCh0b2tlbikpO1xuICB9IGVsc2UgaWYgKGlzQXJyYXlTdHJpbmcodG9rZW4pKSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkodW53cmFwKHRva2VuKSk7XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IodG9rZW4sIHN0cmluZywgb3JpZ2luYWxTdHJpbmcpO1xuICB9XG59O1xuXG5jb25zdCBuZXh0VG9rZW4gPSAoc3RyaW5nKSA9PiB7XG4gIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG4gIGxldCBsaW1pdCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgaWYgKHN0cmluZ1swXSA9PT0gJzonIHx8IHN0cmluZ1swXSA9PT0gJywnKSB7XG5cbiAgICBsaW1pdCA9IDE7XG5cbiAgfSBlbHNlIGlmIChzdHJpbmdbMF0gPT09ICd7JyB8fCBzdHJpbmdbMF0gPT09ICdbJykge1xuXG4gICAgY29uc3QgYyA9IHN0cmluZy5jaGFyQ29kZUF0KDApO1xuICAgIGxldCBuZXN0ZWRPYmplY3QgPSAxO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IGMpIHtcbiAgICAgICAgbmVzdGVkT2JqZWN0Kys7XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09PSBjICsgMikge1xuICAgICAgICBuZXN0ZWRPYmplY3QtLTtcbiAgICAgICAgaWYgKG5lc3RlZE9iamVjdCA9PT0gMCkge1xuICAgICAgICAgIGxpbWl0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIGlmIChzdHJpbmdbMF0gPT09ICdcXCcnIHx8IHN0cmluZ1swXSA9PT0gJ1wiJykge1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzdHJpbmdbaV0gPT09IHN0cmluZ1swXSkge1xuICAgICAgICBsaW1pdCA9IGkgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIHtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoWycgJywgJywnLCAnOiddLmluZGV4T2Yoc3RyaW5nW2ldKSAhPT0gLTEpIHtcbiAgICAgICAgbGltaXQgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBzdHJpbmcuc2xpY2UoMCwgbGltaXQpO1xufTtcblxuY29uc3QgcGFyc2VPYmplY3QgPSAoc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGlzVmFsaWRLZXkgPSBrZXkgPT4gL15bQS1aXyRdW0EtWjAtOV8kXSokL2kudGVzdChrZXkpO1xuXG4gIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG4gIGNvbnN0IG9yaWdpbmFsU3RyaW5nID0gc3RyaW5nO1xuICBjb25zdCBvYmplY3QgPSB7fTtcbiAgbGV0IHJlYWRpbmdLZXkgPSB0cnVlLCBrZXksIHByZXZpb3VzVG9rZW4sIHRva2VuO1xuXG4gIHdoaWxlKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgcHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgIHRva2VuID0gbmV4dFRva2VuKHN0cmluZyk7XG4gICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHRva2VuLmxlbmd0aCwgc3RyaW5nLmxlbmd0aCkudHJpbSgpO1xuXG4gICAgaWYgKCh0b2tlbiA9PT0gJzonICYmICghcmVhZGluZ0tleSB8fCAhcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKVxuICAgICAgIHx8ICh0b2tlbiA9PT0gJywnICYmIHJlYWRpbmdLZXkpXG4gICAgICAgfHwgKHRva2VuICE9PSAnOicgJiYgdG9rZW4gIT09ICcsJyAmJiAocHJldmlvdXNUb2tlbiAmJiBwcmV2aW91c1Rva2VuICE9PSAnLCcgJiYgcHJldmlvdXNUb2tlbiAhPT0gJzonKSkpIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnOicgJiYgcmVhZGluZ0tleSAmJiBwcmV2aW91c1Rva2VuKSB7XG4gICAgICBwcmV2aW91c1Rva2VuID0gaXNRdW90ZWRTdHJpbmcocHJldmlvdXNUb2tlbikgPyB1bndyYXAocHJldmlvdXNUb2tlbikgOiBwcmV2aW91c1Rva2VuO1xuICAgICAgaWYgKGlzVmFsaWRLZXkocHJldmlvdXNUb2tlbikpIHtcbiAgICAgICAga2V5ID0gcHJldmlvdXNUb2tlbjtcbiAgICAgICAgcmVhZGluZ0tleSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGtleSB0b2tlbiBcXCcnICsgcHJldmlvdXNUb2tlbiArICdcXCcgYXQgcG9zaXRpb24gMCBpbiBzdHJpbmc6IFxcJycgKyBvcmlnaW5hbFN0cmluZyArICdcXCcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnLCcgJiYgIXJlYWRpbmdLZXkgJiYgcHJldmlvdXNUb2tlbikge1xuICAgICAgb2JqZWN0W2tleV0gPSBwcm9jZXNzVG9rZW4ocHJldmlvdXNUb2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgICByZWFkaW5nS2V5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9rZW4pIHtcbiAgICBvYmplY3Rba2V5XSA9IHByb2Nlc3NUb2tlbih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufTtcblxuY29uc3QgcGFyc2VBcnJheSA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcbiAgY29uc3Qgb3JpZ2luYWxTdHJpbmcgPSBzdHJpbmc7XG4gIGNvbnN0IGFycmF5ID0gW107XG4gIGxldCBwcmV2aW91c1Rva2VuLCB0b2tlbjtcblxuICB3aGlsZShzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIHByZXZpb3VzVG9rZW4gPSB0b2tlbjtcbiAgICB0b2tlbiA9IG5leHRUb2tlbihzdHJpbmcpO1xuICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSh0b2tlbi5sZW5ndGgsIHN0cmluZy5sZW5ndGgpLnRyaW0oKTtcblxuICAgIGlmICh0b2tlbiA9PT0gJywnICYmICghcHJldmlvdXNUb2tlbiB8fCBwcmV2aW91c1Rva2VuID09PSAnLCcpKSB7XG4gICAgICBlcnJvcih0b2tlbiwgc3RyaW5nLCBvcmlnaW5hbFN0cmluZyk7XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gJywnKSB7XG4gICAgICBhcnJheS5wdXNoKHByb2Nlc3NUb2tlbihwcmV2aW91c1Rva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRva2VuKSB7XG4gICAgaWYgKHRva2VuICE9PSAnLCcpIHtcbiAgICAgIGFycmF5LnB1c2gocHJvY2Vzc1Rva2VuKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKHRva2VuLCBzdHJpbmcsIG9yaWdpbmFsU3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5jb25zdCBwYXJzZSA9IChzdHJpbmcpID0+IHtcbiAgc3RyaW5nID0gc3RyaW5nLnRyaW0oKTtcblxuICBpZiAoaXNPYmplY3RTdHJpbmcoc3RyaW5nKSkge1xuICAgIHJldHVybiBwYXJzZU9iamVjdCh1bndyYXAoc3RyaW5nKSk7XG4gIH0gZWxzZSBpZiAoaXNBcnJheVN0cmluZyhzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXkodW53cmFwKHN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgc3RyaW5nIG11c3QgYmUgb2JqZWN0IG9yIGFycmF5IGxpa2U6ICcgKyBzdHJpbmcpO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuL2VsZW1lbnRzJztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi9zdHlsZXInO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4vaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgYW5pbWF0aW9uT3B0aW9uc1BhcnNlIGZyb20gJy4vYW5pbWF0aW9uLW9wdGlvbnMtcGFyc2VyJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtJztcblxuY29uc3QgdXRpbCA9IHt9O1xuY29uc3QgZXJyb3JQcmVmaXggPSAnW09uc2VuIFVJXSc7XG5cbnV0aWwuZ2xvYmFscyA9IHtcbiAgZmFiT2Zmc2V0OiAwLFxuICBlcnJvclByZWZpeCxcbiAgc3VwcG9ydHNQYXNzaXZlOiBmYWxzZVxufTtcblxucGxhdGZvcm0uX3J1bk9uQWN0dWFsUGxhdGZvcm0oKCkgPT4ge1xuICB1dGlsLmdsb2JhbHMuYWN0dWFsTW9iaWxlT1MgPSBwbGF0Zm9ybS5nZXRNb2JpbGVPUygpO1xuICB1dGlsLmdsb2JhbHMuaXNVSVdlYlZpZXcgPSBwbGF0Zm9ybS5pc1VJV2ViVmlldygpO1xuICB1dGlsLmdsb2JhbHMuaXNXS1dlYlZpZXcgPSBwbGF0Zm9ybS5pc1dLV2ViVmlldygpO1xufSk7XG5cbnRyeSB7XG4gIGNvbnN0IG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgIGdldCgpIHsgdXRpbC5nbG9iYWxzLnN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7IH1cbiAgfSk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbn0gY2F0Y2ggKGUpIHsgbnVsbDsgfVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgVGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBFdmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIEV2ZW50IGhhbmRsZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XSBFdmVudCBvcHRpb25zIChwYXNzaXZlLCBjYXB0dXJlLi4uKVxuICogQHBhcmFtIHtCb29sZWFufSBbaXNHRF0gSWYgY29tZXMgZnJvbSBHZXN0dXJlRGV0ZWN0b3IuIEp1c3QgZm9yIHRlc3RpbmcuXG4gKi9cbnV0aWwuYWRkRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgaGFuZGxlciwgb3B0LCBpc0dEKSA9PiB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXRpbC5nbG9iYWxzLnN1cHBvcnRzUGFzc2l2ZSA/IG9wdCA6IChvcHQgfHwge30pLmNhcHR1cmUpO1xufTtcbnV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgaGFuZGxlciwgb3B0LCBpc0dEKSA9PiB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXRpbC5nbG9iYWxzLnN1cHBvcnRzUGFzc2l2ZSA/IG9wdCA6IChvcHQgfHwge30pLmNhcHR1cmUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcXVlcnkgZG90IGNsYXNzIG5hbWUgb3Igbm9kZSBuYW1lIG9yIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xudXRpbC5wcmVwYXJlUXVlcnkgPSAocXVlcnkpID0+IHtcbiAgcmV0dXJuIHF1ZXJ5IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBxdWVyeSA6IChlbGVtZW50KSA9PiB1dGlsLm1hdGNoKGVsZW1lbnQsIHF1ZXJ5KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlXG4gKiBAcGFyYW0ge1N0cmluZy9GdW5jdGlvbn0gcyBDU1MgU2VsZWN0b3IuXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG51dGlsLm1hdGNoID0gKGUsIHMpID0+IChlLm1hdGNoZXMgfHwgZS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZS5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZS5tc01hdGNoZXNTZWxlY3RvcikuY2FsbChlLCBzKTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50L251bGx9XG4gKi9cbnV0aWwuZmluZENoaWxkID0gKGVsZW1lbnQsIHF1ZXJ5KSA9PiB7XG4gIGNvbnN0IG1hdGNoID0gdXRpbC5wcmVwYXJlUXVlcnkocXVlcnkpO1xuXG4gIC8vIENhdXRpb246IGBlbGVtZW50LmNoaWxkcmVuYCBpcyBgdW5kZWZpbmVkYCBpbiBzb21lIGVudmlyb25tZW50cyBpZiBgZWxlbWVudGAgaXMgYHN2Z2BcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkgeyAvLyBwcm9jZXNzIG9ubHkgZWxlbWVudCBub2Rlc1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtYXRjaChub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nL0Z1bmN0aW9ufSBxdWVyeSBkb3QgY2xhc3MgbmFtZSBvciBub2RlIG5hbWUgb3IgbWF0Y2hlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50L251bGx9XG4gKi9cbnV0aWwuZmluZFBhcmVudCA9IChlbGVtZW50LCBxdWVyeSwgdW50aWwpID0+IHtcbiAgY29uc3QgbWF0Y2ggPSB1dGlsLnByZXBhcmVRdWVyeShxdWVyeSk7XG5cbiAgbGV0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgZm9yICg7Oykge1xuICAgIGlmICghcGFyZW50IHx8IHBhcmVudCA9PT0gZG9jdW1lbnQgfHwgcGFyZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCB8fCAodW50aWwgJiYgdW50aWwocGFyZW50KSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAobWF0Y2gocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG51dGlsLmlzQXR0YWNoZWQgPSBlbGVtZW50ID0+IGRvY3VtZW50LmJvZHkuY29udGFpbnMoZWxlbWVudCk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG51dGlsLmhhc0FueUNvbXBvbmVudEFzUGFyZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgd2hpbGUgKGVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkubWF0Y2goLyhvbnMtbmF2aWdhdG9yfG9ucy10YWJiYXJ8b25zLW1vZGFsKS8pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNQYWdlQ29udHJvbCA9IGVsZW1lbnQgPT4gZWxlbWVudC5ub2RlTmFtZS5tYXRjaCgvXm9ucy0obmF2aWdhdG9yfHNwbGl0dGVyfHRhYmJhcnxwYWdlKSQvaSk7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uIHRvIHByb3BhZ2F0ZVxuICovXG51dGlsLnByb3BhZ2F0ZUFjdGlvbiA9IChlbGVtZW50LCBhY3Rpb24pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcbiAgICBpZiAoY2hpbGRbYWN0aW9uXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBjaGlsZFthY3Rpb25dKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKGNoaWxkLCBhY3Rpb24pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIC0gc3RyaW5nIHRvIGJlIGNhbWVsaXplZFxuICogQHJldHVybiB7U3RyaW5nfSBDYW1lbGl6ZWQgc3RyaW5nXG4gKi9cbnV0aWwuY2FtZWxpemUgPSBzdHJpbmcgPT4gc3RyaW5nLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvLShbYS16XSkvZywgKG0sIGwpID0+IGwudG9VcHBlckNhc2UoKSk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIHN0cmluZyB0byBiZSBoeXBoZW5hdGVkXG4gKiBAcmV0dXJuIHtTdHJpbmd9IEh5cGhlbmF0ZWQgc3RyaW5nXG4gKi9cbnV0aWwuaHlwaGVuYXRlID0gc3RyaW5nID0+IHN0cmluZy5yZXBsYWNlKC8oW2EtekEtWl0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciAtIHRhZyBhbmQgY2xhc3Mgb25seVxuICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9XG4gKi9cbnV0aWwuY3JlYXRlID0gKHNlbGVjdG9yID0gJycsIHN0eWxlID0ge30pID0+IHtcbiAgY29uc3QgY2xhc3NMaXN0ID0gc2VsZWN0b3Iuc3BsaXQoJy4nKTtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY2xhc3NMaXN0LnNoaWZ0KCkgfHwgJ2RpdicpO1xuXG4gIGlmIChjbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc0xpc3Quam9pbignICcpO1xuICB9XG5cbiAgc3R5bGVyKGVsZW1lbnQsIHN0eWxlKTtcblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbnV0aWwuY3JlYXRlRWxlbWVudCA9IChodG1sKSA9PiB7XG4gIGNvbnN0IHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICBpZiAoaHRtbCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmltcG9ydE5vZGUoaHRtbCwgdHJ1ZSkpO1xuICB9IGVsc2Uge1xuICAgIHdyYXBwZXIuaW5uZXJIVE1MID0gaHRtbC50cmltKCk7XG4gIH1cblxuICBpZiAod3JhcHBlci5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgdXRpbC50aHJvdygnSFRNTCB0ZW1wbGF0ZSBtdXN0IGNvbnRhaW4gYSBzaW5nbGUgcm9vdCBlbGVtZW50JylcbiAgfVxuXG4gIGNvbnN0IGVsZW1lbnQgPSB3cmFwcGVyLmNoaWxkcmVuWzBdO1xuICB3cmFwcGVyLmNoaWxkcmVuWzBdLnJlbW92ZSgpO1xuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxGcmFnbWVudH1cbiAqL1xudXRpbC5jcmVhdGVGcmFnbWVudCA9IChodG1sKSA9PiB7XG4gIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgdGVtcGxhdGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgcmV0dXJuIGRvY3VtZW50LmltcG9ydE5vZGUodGVtcGxhdGUuY29udGVudCwgdHJ1ZSk7XG59O1xuXG4vKlxuICogQHBhcmFtIHtPYmplY3R9IGRzdCBEZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gc3JjIFNvdXJjZSBvYmplY3QocykuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZWZlcmVuY2UgdG8gYGRzdGAuXG4gKi9cbnV0aWwuZXh0ZW5kID0gKGRzdCwgLi4uYXJncykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJnc1tpXSkge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGFyZ3NbaV0pO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbal07XG4gICAgICAgIGRzdFtrZXldID0gYXJnc1tpXVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkc3Q7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcnJheUxpa2VcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG51dGlsLmFycmF5RnJvbSA9IChhcnJheUxpa2UpID0+IHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShhcnJheUxpa2UpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30ganNvblN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IFtmYWlsU2FmZV1cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xudXRpbC5wYXJzZUpTT05PYmplY3RTYWZlbHkgPSAoanNvblN0cmluZywgZmFpbFNhZmUgPSB7fSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UoJycgKyBqc29uU3RyaW5nKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhaWxTYWZlO1xuICB9XG4gIHJldHVybiBmYWlsU2FmZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBwYXRoIHN1Y2ggYXMgJ215QXBwLmNvbnRyb2xsZXJzLmRhdGEubG9hZERhdGEnXG4gKiBAcmV0dXJuIHtBbnl9IC0gd2hhdGV2ZXIgaXMgbG9jYXRlZCBhdCB0aGF0IHBhdGhcbiAqL1xudXRpbC5maW5kRnJvbVBhdGggPSAocGF0aCkgPT4ge1xuICBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICB2YXIgZWwgPSB3aW5kb3csIGtleTtcbiAgd2hpbGUgKGtleSA9IHBhdGguc2hpZnQoKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgZWwgPSBlbFtrZXldO1xuICB9XG4gIHJldHVybiBlbDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gUGFnZSBvciBwYWdlLWNvbnRhaW5lciB0aGF0IGltcGxlbWVudHMgJ3RvcFBhZ2UnXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudHxudWxsfSAtIFZpc2libGUgcGFnZSBlbGVtZW50IG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICovXG51dGlsLmdldFRvcFBhZ2UgPSBjb250YWluZXIgPT4gY29udGFpbmVyICYmIChjb250YWluZXIudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLXBhZ2UnID8gY29udGFpbmVyIDogY29udGFpbmVyLnRvcFBhZ2UpIHx8IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gRWxlbWVudCB3aGVyZSB0aGUgc2VhcmNoIGJlZ2luc1xuICogQHJldHVybiB7SFRNTEVsZW1lbnR8bnVsbH0gLSBQYWdlIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgdmlzaWJsZSB0b29sYmFyIG9yIG51bGwuXG4gKi9cbnV0aWwuZmluZFRvb2xiYXJQYWdlID0gY29udGFpbmVyID0+IHtcbiAgY29uc3QgcGFnZSA9IHV0aWwuZ2V0VG9wUGFnZShjb250YWluZXIpO1xuXG4gIGlmIChwYWdlKSB7XG4gICAgaWYgKHBhZ2UuX2NhbkFuaW1hdGVUb29sYmFyKCkpIHtcbiAgICAgIHJldHVybiBwYWdlO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZS5fY29udGVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5leHRQYWdlID0gdXRpbC5nZXRUb3BQYWdlKHBhZ2UuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldKTtcbiAgICAgIGlmIChuZXh0UGFnZSAmJiAhL29ucy10YWJiYXIvaS50ZXN0KHBhZ2UuX2NvbnRlbnRFbGVtZW50LmNoaWxkcmVuW2ldLnRhZ05hbWUpKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmZpbmRUb29sYmFyUGFnZShuZXh0UGFnZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICogQHBhcmFtIHtPYmplY3R9IFtkZXRhaWxdXG4gKiBAcmV0dXJuIHtDdXN0b21FdmVudH1cbiAqL1xudXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50ID0gKHRhcmdldCwgZXZlbnROYW1lLCBkZXRhaWwgPSB7fSkgPT4ge1xuXG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwge1xuICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICBkZXRhaWw6IGRldGFpbFxuICB9KTtcblxuICBPYmplY3Qua2V5cyhkZXRhaWwpLmZvckVhY2goa2V5ID0+IHtcbiAgICBldmVudFtrZXldID0gZGV0YWlsW2tleV07XG4gIH0pO1xuXG4gIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICByZXR1cm4gZXZlbnQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJOYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG51dGlsLmhhc01vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lKSA9PiB7XG4gIGlmICghdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBSZWdFeHAoYChefFxcXFxzKykke21vZGlmaWVyTmFtZX0oJHxcXFxccyspYCwgJ2knKS50ZXN0KHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYXV0b1N0eWxlIE1hcHMgdGhlIG1vZGlmaWVyTmFtZSB0byB0aGUgY29ycmVzcG9uZGluZyBzdHlsZWQgbW9kaWZpZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5mb3JjZUF1dG9TdHlsZSBJZ25vcmVzIHBsYXRmb3JtIGxpbWl0YXRpb24uXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGl0IHdhcyBhZGRlZCBvciBub3QuXG4gKi9cbnV0aWwuYWRkTW9kaWZpZXIgPSAodGFyZ2V0LCBtb2RpZmllck5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAob3B0aW9ucy5hdXRvU3R5bGUpIHtcbiAgICBtb2RpZmllck5hbWUgPSBhdXRvU3R5bGUubWFwTW9kaWZpZXIobW9kaWZpZXJOYW1lLCB0YXJnZXQsIG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUpO1xuICB9XG5cbiAgaWYgKHV0aWwuaGFzTW9kaWZpZXIodGFyZ2V0LCBtb2RpZmllck5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCAoKHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykgfHwgJycpICsgJyAnICsgbW9kaWZpZXJOYW1lKS50cmltKCkpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBtb2RpZmllck5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmF1dG9TdHlsZSBNYXBzIHRoZSBtb2RpZmllck5hbWUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgc3R5bGVkIG1vZGlmaWVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUgSWdub3JlcyBwbGF0Zm9ybSBsaW1pdGF0aW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBpdCB3YXMgZm91bmQgb3Igbm90LlxuICovXG51dGlsLnJlbW92ZU1vZGlmaWVyID0gKHRhcmdldCwgbW9kaWZpZXJOYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKG9wdGlvbnMuYXV0b1N0eWxlKSB7XG4gICAgbW9kaWZpZXJOYW1lID0gYXV0b1N0eWxlLm1hcE1vZGlmaWVyKG1vZGlmaWVyTmFtZSwgdGFyZ2V0LCBvcHRpb25zLmZvcmNlQXV0b1N0eWxlKTtcbiAgfVxuXG4gIGlmICghdGFyZ2V0LmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAhdXRpbC5oYXNNb2RpZmllcih0YXJnZXQsIG1vZGlmaWVyTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBuZXdNb2RpZmllcnMgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpLnNwbGl0KC9cXHMrLykuZmlsdGVyKG0gPT4gbSAmJiBtICE9PSBtb2RpZmllck5hbWUpO1xuICBuZXdNb2RpZmllcnMubGVuZ3RoID8gdGFyZ2V0LnNldEF0dHJpYnV0ZSgnbW9kaWZpZXInLCBuZXdNb2RpZmllcnMuam9pbignICcpKSA6IHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoJ21vZGlmaWVyJyk7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyTmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLmZvcmNlIEZvcmNlcyBtb2RpZmllciB0byBiZSBhZGRlZCBvciByZW1vdmVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuYXV0b1N0eWxlIE1hcHMgdGhlIG1vZGlmaWVyTmFtZSB0byB0aGUgY29ycmVzcG9uZGluZyBzdHlsZWQgbW9kaWZpZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMuZm9yY2VBdXRvU3R5bGUgSWdub3JlcyBwbGF0Zm9ybSBsaW1pdGF0aW9uLlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBpdCB3YXMgZm91bmQgb3Igbm90LlxuICovXG51dGlsLnRvZ2dsZU1vZGlmaWVyID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFyZ3MubGVuZ3RoID4gMiA/IGFyZ3NbMl0gOiB7fTtcbiAgY29uc3QgZm9yY2UgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucyA6IG9wdGlvbnMuZm9yY2U7XG5cbiAgY29uc3QgdG9nZ2xlID0gdHlwZW9mIGZvcmNlID09PSAnYm9vbGVhbicgPyBmb3JjZSA6ICF1dGlsLmhhc01vZGlmaWVyKC4uLmFyZ3MpO1xuICB0b2dnbGUgPyB1dGlsLmFkZE1vZGlmaWVyKC4uLmFyZ3MpIDogdXRpbC5yZW1vdmVNb2RpZmllciguLi5hcmdzKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVmYXVsdENsYXNzXG4gKiBAcGFyYW0ge09iamVjdH0gc2NoZW1lXG4gKi9cbnV0aWwucmVzdG9yZUNsYXNzID0gKGVsLCBkZWZhdWx0Q2xhc3MsIHNjaGVtZSkgPT4ge1xuICBkZWZhdWx0Q2xhc3Muc3BsaXQoL1xccysvKS5mb3JFYWNoKGMgPT4gYyAhPT0gJycgJiYgIWVsLmNsYXNzTGlzdC5jb250YWlucyhjKSAmJiBlbC5jbGFzc0xpc3QuYWRkKGMpKTtcbiAgZWwuaGFzQXR0cmlidXRlKCdtb2RpZmllcicpICYmIE1vZGlmaWVyVXRpbC5yZWZyZXNoKGVsLCBzY2hlbWUpO1xufVxuXG4vLyBUT0RPOiBGSVhcbnV0aWwudXBkYXRlUGFyZW50UG9zaXRpb24gPSAoZWwpID0+IHtcbiAgaWYgKCFlbC5fcGFyZW50VXBkYXRlZCAmJiBlbC5wYXJlbnRFbGVtZW50KSB7XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsLnBhcmVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICBlbC5wYXJlbnRFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICB9XG4gICAgZWwuX3BhcmVudFVwZGF0ZWQgPSB0cnVlO1xuICB9XG59O1xuXG51dGlsLnRvZ2dsZUF0dHJpYnV0ZSA9IChlbGVtZW50LCBuYW1lLCB2YWx1ZSkgPT4ge1xuICBpZiAodmFsdWUpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyA/ICcnIDogdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG59O1xuXG51dGlsLmJpbmRMaXN0ZW5lcnMgPSAoZWxlbWVudCwgbGlzdGVuZXJOYW1lcykgPT4ge1xuICBsaXN0ZW5lck5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgY29uc3QgYm91bmROYW1lID0gbmFtZS5yZXBsYWNlKC9eX1thLXpdLywgJ19ib3VuZCcgKyBuYW1lWzFdLnRvVXBwZXJDYXNlKCkpO1xuICAgIGVsZW1lbnRbYm91bmROYW1lXSA9IGVsZW1lbnRbYm91bmROYW1lXSB8fCBlbGVtZW50W25hbWVdLmJpbmQoZWxlbWVudCk7XG4gIH0pO1xufTtcblxudXRpbC5lYWNoID0gKG9iaiwgZikgPT4gT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGtleSA9PiBmKGtleSwgb2JqW2tleV0pKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1JpcHBsZVxuICogQHBhcmFtIHtPYmplY3R9IGF0dHJzXG4gKi9cbnV0aWwudXBkYXRlUmlwcGxlID0gKHRhcmdldCwgaGFzUmlwcGxlLCBhdHRycyA9IHt9KSA9PiB7XG4gIGlmIChoYXNSaXBwbGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGhhc1JpcHBsZSA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpO1xuICB9XG5cbiAgY29uc3QgcmlwcGxlRWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRhcmdldCwgJ29ucy1yaXBwbGUnKTtcblxuICBpZiAoaGFzUmlwcGxlKSB7XG4gICAgaWYgKCFyaXBwbGVFbGVtZW50KSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb25zLXJpcHBsZScpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goa2V5ID0+IGVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSkpO1xuICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShlbGVtZW50LCB0YXJnZXQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJpcHBsZUVsZW1lbnQpIHtcbiAgICByaXBwbGVFbGVtZW50LnJlbW92ZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG51dGlsLmFuaW1hdGlvbk9wdGlvbnNQYXJzZSA9IGFuaW1hdGlvbk9wdGlvbnNQYXJzZTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gKHZhbHVlKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgaXNGaW5pdGUodmFsdWUpICYmXG4gICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3R9IERlZmVycmVkIHByb21pc2UuXG4gKi9cbnV0aWwuZGVmZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGRlZmVycmVkID0ge307XG4gIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgZGVmZXJyZWQucmVqZWN0ID0gcmVqZWN0O1xuICB9KTtcbiAgcmV0dXJuIGRlZmVycmVkO1xufTtcblxuLyoqXG4gKiBTaG93IHdhcm5pbmdzIHdoZW4gdGhleSBhcmUgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGFyZ3VtZW50cyB0byBjb25zb2xlLndhcm5cbiAqL1xudXRpbC53YXJuID0gKC4uLmFyZ3MpID0+IHtcbiAgaWYgKCFpbnRlcm5hbC5jb25maWcud2FybmluZ3NEaXNhYmxlZCkge1xuICAgIGNvbnNvbGUud2FybihlcnJvclByZWZpeCwgLi4uYXJncyk7XG4gIH1cbn07XG5cbnV0aWwudGhyb3cgPSAobWVzc2FnZSkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JQcmVmaXh9ICR7bWVzc2FnZX1gKTtcbn07XG5cbnV0aWwudGhyb3dBYnN0cmFjdCA9ICgpID0+IHV0aWwudGhyb3coJ0Nhbm5vdCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcycpO1xudXRpbC50aHJvd01lbWJlciA9ICgpID0+IHV0aWwudGhyb3coJ0NsYXNzIG1lbWJlciBtdXN0IGJlIGltcGxlbWVudGVkJyk7XG51dGlsLnRocm93UGFnZUxvYWRlciA9ICgpID0+IHV0aWwudGhyb3coJ0ZpcnN0IHBhcmFtZXRlciBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgUGFnZUxvYWRlcicpO1xudXRpbC50aHJvd0FuaW1hdG9yID0gKGVsKSA9PiB1dGlsLnRocm93KGBcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0ICR7ZWx9QW5pbWF0b3JgKTtcblxuXG5jb25zdCBwcmV2ZW50ID0gZSA9PiBlLmNhbmNlbGFibGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4vKipcbiAqIFByZXZlbnQgc2Nyb2xsaW5nIHdoaWxlIGRyYWdpbmcgaG9yaXpvbnRhbGx5IG9uIGlPUy5cbiAqXG4gKiBAcGFyYW0ge2dkfSBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2VcbiAqL1xudXRpbC5pb3NQcmV2ZW50U2Nyb2xsID0gZ2QgPT4ge1xuICBpZiAodXRpbC5nbG9iYWxzLmFjdHVhbE1vYmlsZU9TID09PSAnaW9zJykge1xuICAgIGNvbnN0IGNsZWFuID0gKGUpID0+IHtcbiAgICAgIGdkLm9mZigndG91Y2htb3ZlJywgcHJldmVudCk7XG4gICAgICBnZC5vZmYoJ2RyYWdlbmQnLCBjbGVhbik7XG4gICAgfTtcblxuICAgIGdkLm9uKCd0b3VjaG1vdmUnLCBwcmV2ZW50KTtcbiAgICBnZC5vbignZHJhZ2VuZCcsIGNsZWFuKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcmV2ZW50cyBzY3JvbGwgaW4gdW5kZXJseWluZyBwYWdlcyBvbiBpT1MuIFNlZSAjMjIyMCAjMjI3NCAjMTk0OVxuICpcbiAqIEBwYXJhbSB7ZWx9IEhUTUxFbGVtZW50IHRoYXQgcHJldmVudHMgdGhlIGV2ZW50c1xuICogQHBhcmFtIHthZGR9IEJvb2xlYW4gQWRkIG9yIHJlbW92ZSBldmVudCBsaXN0ZW5lcnNcbiAqL1xudXRpbC5pb3NQYWdlU2Nyb2xsRml4ID0gKGFkZCkgPT4geyAvLyBGdWxsIGZpeCAtIE1heSBjYXVzZSBpc3N1ZXMgd2l0aCBVSVdlYlZpZXcncyBtb21lbnR1bSBzY3JvbGxcbiAgaWYgKHV0aWwuZ2xvYmFscy5hY3R1YWxNb2JpbGVPUyA9PT0gJ2lvcycpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC50b2dnbGUoJ29ucy1pb3Mtc2Nyb2xsJywgYWRkKTsgLy8gQWxsb3dzIGN1c3RvbSBhbmQgbG9jYWxpemVkIGZpeGVzICgjMjI3NClcbiAgICBpZiAoIXV0aWwuZ2xvYmFscy5pc1VJV2ViVmlldyB8fCBpbnRlcm5hbC5jb25maWcuZm9yY2VVSVdlYlZpZXdTY3JvbGxGaXgpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnRvZ2dsZSgnb25zLWlvcy1zY3JvbGwtZml4JywgYWRkKTtcbiAgICB9XG4gIH1cbn07XG51dGlsLmlvc01hc2tTY3JvbGxGaXggPSAoZWwsIGFkZCkgPT4geyAvLyBIYWxmIGZpeCAtIG9ubHkgcHJldmVudHMgc2Nyb2xsIG9uIG1hc2tzXG4gIGlmICh1dGlsLmdsb2JhbHMuaXNVSVdlYlZpZXcpIHtcbiAgICBjb25zdCBhY3Rpb24gPSAoYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnRXZlbnRMaXN0ZW5lcic7XG4gICAgZWxbYWN0aW9uXSgndG91Y2htb3ZlJywgcHJldmVudCwgZmFsc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIERpc3RhbmNlIGFuZCBkZWx0YVRpbWUgZmlsdGVyIHNvbWUgd2VpcmQgZHJhZ3N0YXJ0IGV2ZW50cyB0aGF0IGFyZSBub3QgZmlyZWQgaW1tZWRpYXRlbHkuXG4gKlxuICogQHBhcmFtIHtldmVudH1cbiAqL1xudXRpbC5pc1ZhbGlkR2VzdHVyZSA9IGV2ZW50ID0+IGV2ZW50Lmdlc3R1cmUgIT09IHVuZGVmaW5lZCAmJiAoZXZlbnQuZ2VzdHVyZS5kaXN0YW5jZSA8PSAxNSB8fCBldmVudC5nZXN0dXJlLmRlbHRhVGltZSA8PSAxMDApO1xuXG51dGlsLmNoZWNrTWlzc2luZ0ltcG9ydCA9ICguLi5lbGVtZW50TmFtZXMpID0+IHtcbiAgZWxlbWVudE5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgaWYgKCFvbnNFbGVtZW50c1tuYW1lXSkge1xuICAgICAgdXRpbC50aHJvdyhgT25zJHtuYW1lfSBpcyByZXF1aXJlZCBidXQgd2FzIG5vdCBpbXBvcnRlZCAoQ3VzdG9tIEVsZW1lbnRzKWApO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHV0aWw7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5cbi8qKlxuICogTWluaW1hbCBhbmltYXRpb24gbGlicmFyeSBmb3IgbWFuYWdpbmcgY3NzIHRyYW5zaXRpb24gb24gbW9iaWxlIGJyb3dzZXJzLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBUSU1FT1VUX1JBVElPID0gMS40O1xuXG52YXIgdXRpbCA9IHtcbn07XG5cbi8vIGNhcGl0YWxpemUgc3RyaW5nXG51dGlsLmNhcGl0YWxpemUgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtcy5wcm9wZXJ0eVxuICogQHBhcmFtIHtGbG9hdH0gcGFyYW1zLmR1cmF0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zLnRpbWluZ1xuICovXG51dGlsLmJ1aWxkVHJhbnNpdGlvblZhbHVlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHBhcmFtcy5wcm9wZXJ0eSA9IHBhcmFtcy5wcm9wZXJ0eSB8fCAnYWxsJztcbiAgcGFyYW1zLmR1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uIHx8IDAuNDtcbiAgcGFyYW1zLnRpbWluZyA9IHBhcmFtcy50aW1pbmcgfHwgJ2xpbmVhcic7XG5cbiAgdmFyIHByb3BzID0gcGFyYW1zLnByb3BlcnR5LnNwbGl0KC8gKy8pO1xuXG4gIHJldHVybiBwcm9wcy5tYXAoZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBwcm9wICsgJyAnICsgcGFyYW1zLmR1cmF0aW9uICsgJ3MgJyArIHBhcmFtcy50aW1pbmc7XG4gIH0pLmpvaW4oJywgJyk7XG59O1xuXG4vKipcbiAqIEFkZCBhbiBldmVudCBoYW5kbGVyIG9uIFwidHJhbnNpdGlvbmVuZFwiIGV2ZW50LlxuICovXG51dGlsLm9uY2VPblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgfVxuXG4gIHZhciBmbiA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdXRpbC5fdHJhbnNpdGlvbkVuZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50TmFtZSkge1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIGZhbHNlKTtcbiAgICB9KTtcbiAgfTtcblxuICB1dGlsLl90cmFuc2l0aW9uRW5kRXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4sIGZhbHNlKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlbW92ZUxpc3RlbmVycztcbn07XG5cbnV0aWwuX3RyYW5zaXRpb25FbmRFdmVudHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgaWYgKCdvbnRyYW5zaXRpb25lbmQnIGluIHdpbmRvdykge1xuICAgIHJldHVybiBbJ3RyYW5zaXRpb25lbmQnXTtcbiAgfVxuXG4gIGlmICgnb253ZWJraXR0cmFuc2l0aW9uZW5kJyBpbiB3aW5kb3cpIHtcbiAgICByZXR1cm4gWyd3ZWJraXRUcmFuc2l0aW9uRW5kJ107XG4gIH1cblxuICBpZiAodXRpbC52ZW5kb3JQcmVmaXggPT09ICd3ZWJraXQnIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbycgfHwgdXRpbC52ZW5kb3JQcmVmaXggPT09ICdtb3onIHx8IHV0aWwudmVuZG9yUHJlZml4ID09PSAnbXMnKSB7XG4gICAgcmV0dXJuIFt1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRW5kJywgJ3RyYW5zaXRpb25lbmQnXTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn0pKCk7XG5cbnV0aWwuX2Nzc1Byb3BlcnR5RGljdCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJycpO1xuICB2YXIgZGljdCA9IHt9O1xuICB2YXIgYSA9ICdBJy5jaGFyQ29kZUF0KDApO1xuICB2YXIgeiA9ICd6Jy5jaGFyQ29kZUF0KDApO1xuXG4gIHZhciB1cHBlciA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gcy5zdWJzdHIoMSkudG9VcHBlckNhc2UoKTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgdmFyIGtleSA9IHN0eWxlc1tpXVxuICAgIC5yZXBsYWNlKC9eWy1dKy8sICcnKVxuICAgIC5yZXBsYWNlKC9bLV1bYS16XS9nLCB1cHBlcilcbiAgICAucmVwbGFjZSgvXm1vei8sICdNb3onKTtcblxuICAgIGlmIChhIDw9IGtleS5jaGFyQ29kZUF0KDApICYmIHogPj0ga2V5LmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgIGlmIChrZXkgIT09ICdjc3NUZXh0JyAmJiBrZXkgIT09ICdwYXJlbnRUZXh0Jykge1xuICAgICAgICBkaWN0W2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaWN0O1xufSkoKTtcblxudXRpbC5oYXNDc3NQcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgaW4gdXRpbC5fY3NzUHJvcGVydHlEaWN0O1xufTtcblxuLyoqXG4gKiBWZW5kb3IgcHJlZml4IGZvciBjc3MgcHJvcGVydHkuXG4gKi9cbnV0aWwudmVuZG9yUHJlZml4ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJyksXG4gICAgcHJlID0gKEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgLmNhbGwoc3R5bGVzKVxuICAgICAgLmpvaW4oJycpXG4gICAgICAubWF0Y2goLy0obW96fHdlYmtpdHxtcyktLykgfHwgKHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVxuICAgIClbMV07XG4gICAgcmV0dXJuIHByZTtcbn0pKCk7XG5cbnV0aWwuZm9yY2VMYXlvdXRBdE9uY2UgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spIHtcbiAgdGhpcy5iYXRjaEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIC8vIGZvcmNlIGxheW91dFxuICAgICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgfSk7XG4gICAgY2FsbGJhY2soKTtcbiAgfSk7XG59O1xuXG51dGlsLmJhdGNoSW1tZWRpYXRlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgY2FsbGJhY2tzID0gW107XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbmNyZWF0ZUNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgY2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIH07XG59KSgpO1xuXG51dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcblxuICB2YXIgcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJhZihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbmNyZWF0ZUNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICAgICAgY2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvbmNyZWF0ZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIH07XG59KSgpO1xuXG51dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh1dGlsLmhhc0Nzc1Byb3BlcnR5KCd0cmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgIHJldHVybiAndHJhbnNpdGlvbic7XG4gIH1cblxuICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eSh1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgIHJldHVybiB1dGlsLnZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uJztcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZScpO1xufSkoKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xudmFyIEFuaW1pdCA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRlZmF1bHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBbmltaXQpKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltaXQoZWxlbWVudCwgZGVmYXVsdHMpO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHRoaXMuZWxlbWVudHMgPSBbZWxlbWVudF07XG4gIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVsZW1lbnQpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnQ7XG5cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gYXJyYXkgb3IgYW4gaW5zdGFuY2Ugb2YgSFRNTEVsZW1lbnQuJyk7XG4gIH1cblxuICB0aGlzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIHRoaXMudHJhbnNpdGlvblF1ZXVlID0gW107XG4gIHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdCA9IFtdO1xufTtcblxuQW5pbWl0LnByb3RvdHlwZSA9IHtcblxuICAvKipcbiAgICogQHByb3BlcnR5IHtBcnJheX1cbiAgICovXG4gIHRyYW5zaXRpb25RdWV1ZTogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkge0FycmF5fVxuICAgKi9cbiAgZWxlbWVudHM6IHVuZGVmaW5lZCxcblxuICAvKipcbiAgICogQHByb3BlcnR5IHtPYmplY3R9XG4gICAqL1xuICBkZWZhdWx0czogdW5kZWZpbmVkLFxuXG4gIC8qKlxuICAgKiBTdGFydCBhbmltYXRpb24gc2VxdWVuY2Ugd2l0aCBwYXNzZWQgYW5pbWF0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBsYXk6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuc3RhcnRBbmltYXRpb24oKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb3N0IG9mIHRoZSBhbmltYXRpb25zIGZvbGxvdyB0aGlzIGRlZmF1bHQgcHJvY2Vzcy5cbiAgICpcbiAgICogQHBhcmFtIHtmcm9tfSBjc3Mgb3Igb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBjc3NcbiAgICogQHBhcmFtIHt0b30gY3NzIG9yIG9wdGlvbnMgb2JqZWN0IGNvbnRhaW5pbmcgY3NzXG4gICAqIEBwYXJhbSB7ZGVsYXl9IGRlbGF5IHRvIHdhaXRcbiAgICovXG4gIGRlZmF1bHQ6IGZ1bmN0aW9uKGZyb20sIHRvLCBkZWxheSkge1xuICAgIGZ1bmN0aW9uIHN0ZXAocGFyYW1zLCBkdXJhdGlvbiwgdGltaW5nKSB7XG4gICAgICBpZiAocGFyYW1zLmR1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZHVyYXRpb24gPSBwYXJhbXMuZHVyYXRpb247XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLnRpbWluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRpbWluZyA9IHBhcmFtcy50aW1pbmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNzczogcGFyYW1zLmNzcyB8fCBwYXJhbXMsXG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgdGltaW5nOiB0aW1pbmdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2F2ZVN0eWxlKClcbiAgICAgIC5xdWV1ZShzdGVwKGZyb20sIDAsIHRoaXMuZGVmYXVsdHMudGltaW5nKSlcbiAgICAgIC53YWl0KGRlbGF5ID09PSB1bmRlZmluZWQgPyB0aGlzLmRlZmF1bHRzLmRlbGF5IDogZGVsYXkpXG4gICAgICAucXVldWUoc3RlcCh0bywgdGhpcy5kZWZhdWx0cy5kdXJhdGlvbiwgdGhpcy5kZWZhdWx0cy50aW1pbmcpKVxuICAgICAgLnJlc3RvcmVTdHlsZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBRdWV1ZSB0cmFuc2l0aW9uIGFuaW1hdGlvbnMgb3Igb3RoZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2NvbG9yOiAncmVkJ30pXG4gICAqIGUuZy4gYW5pbWl0KGVsdCkucXVldWUoe2NvbG9yOiAncmVkJ30sIHtkdXJhdGlvbjogMC40fSlcbiAgICogZS5nLiBhbmltaXQoZWx0KS5xdWV1ZSh7Y3NzOiB7Y29sb3I6ICdyZWQnfSwgZHVyYXRpb246IDAuMn0pXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fEFuaW1pdC5UcmFuc2l0aW9ufEZ1bmN0aW9ufSB0cmFuc2l0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIHF1ZXVlOiBmdW5jdGlvbih0cmFuc2l0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy50cmFuc2l0aW9uUXVldWU7XG5cbiAgICBpZiAodHJhbnNpdGlvbiAmJiBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zLmNzcyA9IHRyYW5zaXRpb247XG4gICAgICB0cmFuc2l0aW9uID0gbmV3IEFuaW1pdC5UcmFuc2l0aW9uKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICghKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCB0cmFuc2l0aW9uIGluc3RhbmNlb2YgQW5pbWl0LlRyYW5zaXRpb24pKSB7XG4gICAgICBpZiAodHJhbnNpdGlvbi5jc3MpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IG5ldyBBbmltaXQuVHJhbnNpdGlvbih0cmFuc2l0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zaXRpb24gPSBuZXcgQW5pbWl0LlRyYW5zaXRpb24oe1xuICAgICAgICAgIGNzczogdHJhbnNpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICBxdWV1ZS5wdXNoKHRyYW5zaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEFuaW1pdC5UcmFuc2l0aW9uKSB7XG4gICAgICBxdWV1ZS5wdXNoKHRyYW5zaXRpb24uYnVpbGQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUXVldWUgdHJhbnNpdGlvbiBhbmltYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0Zsb2F0fSBzZWNvbmRzXG4gICAqL1xuICB3YWl0OiBmdW5jdGlvbihzZWNvbmRzKSB7XG4gICAgaWYgKHNlY29uZHMgPiAwKSB7XG4gICAgICB0aGlzLnRyYW5zaXRpb25RdWV1ZS5wdXNoKGZ1bmN0aW9uKGRvbmUpIHtcbiAgICAgICAgc2V0VGltZW91dChkb25lLCAxMDAwICogc2Vjb25kcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzYXZlU3R5bGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNzcyA9IHRoaXMubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF0gPSB7fTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuc3R5bGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjc3NbZWxlbWVudC5zdHlsZVtpXV0gPSBlbGVtZW50LnN0eWxlW2VsZW1lbnQuc3R5bGVbaV1dO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgZG9uZSgpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogUmVzdG9yZSBlbGVtZW50J3Mgc3R5bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtGbG9hdH0gW29wdGlvbnMuZHVyYXRpb25dXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aW1pbmddXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50cmFuc2l0aW9uXVxuICAgKi9cbiAgcmVzdG9yZVN0eWxlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbiAmJiAhb3B0aW9ucy5kdXJhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm9wdGlvbnMuZHVyYXRpb25cIiBpcyByZXF1aXJlZCB3aGVuIFwib3B0aW9ucy50cmFuc2l0aW9uXCIgaXMgZW5hYmxlZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNpdGlvbk5hbWUgPSB1dGlsLnRyYW5zaXRpb25Qcm9wZXJ0eU5hbWU7XG5cbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uIHx8IChvcHRpb25zLmR1cmF0aW9uICYmIG9wdGlvbnMuZHVyYXRpb24gPiAwKSkge1xuICAgICAgdmFyIHRyYW5zaXRpb25WYWx1ZSA9IG9wdGlvbnMudHJhbnNpdGlvbiB8fCAoJ2FsbCAnICsgb3B0aW9ucy5kdXJhdGlvbiArICdzICcgKyAob3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcicpKTtcblxuICAgICAgdGhpcy50cmFuc2l0aW9uUXVldWUucHVzaChmdW5jdGlvbihkb25lKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgIHZhciB0aW1lb3V0SWQ7XG5cbiAgICAgICAgdmFyIGNsZWFyVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSAnJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBhZGQgXCJ0cmFuc2l0aW9uZW5kXCIgZXZlbnQgaGFuZGxlclxuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gdXRpbC5vbmNlT25UcmFuc2l0aW9uRW5kKGVsZW1lbnRzWzBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICBjbGVhclRyYW5zaXRpb24oKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZvciBmYWlsIHNhZmUuXG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgY2xlYXJUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9LCBvcHRpb25zLmR1cmF0aW9uICogMTAwMCAqIFRJTUVPVVRfUkFUSU8pO1xuXG4gICAgICAgIC8vIHRyYW5zaXRpb24gYW5kIHN0eWxlIHNldHRpbmdzXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcblxuICAgICAgICAgIHZhciBjc3MgPSBzZWxmLmxhc3RTdHlsZUF0dHJpYnV0ZURpY3RbaW5kZXhdO1xuXG4gICAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzdG9yZVN0eWxlKCk6IFRoZSBzdHlsZSBpcyBub3Qgc2F2ZWQuIEludm9rZSBzYXZlU3R5bGUoKSBiZWZvcmUuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHZhciBuYW1lO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50LnN0eWxlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBuYW1lID0gZWxlbWVudC5zdHlsZVtpXTtcbiAgICAgICAgICAgIGlmIChjc3NbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjc3NbbmFtZV0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50LnN0eWxlW3RyYW5zaXRpb25OYW1lXSA9IHRyYW5zaXRpb25WYWx1ZTtcblxuICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IHRyYW5zaXRpb25OYW1lKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IGNzc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSB0cmFuc2l0aW9uVmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNpdGlvblF1ZXVlLnB1c2goZnVuY3Rpb24oZG9uZSkge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgLy8gQ2xlYXIgdHJhbnNpdGlvbiBhbmltYXRpb24gc2V0dGluZ3MuXG4gICAgICBzZWxmLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZVt0cmFuc2l0aW9uTmFtZV0gPSAnbm9uZSc7XG5cbiAgICAgICAgdmFyIGNzcyA9IHNlbGYubGFzdFN0eWxlQXR0cmlidXRlRGljdFtpbmRleF07XG5cbiAgICAgICAgaWYgKCFjc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jlc3RvcmVTdHlsZSgpOiBUaGUgc3R5bGUgaXMgbm90IHNhdmVkLiBJbnZva2Ugc2F2ZVN0eWxlKCkgYmVmb3JlLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5sYXN0U3R5bGVBdHRyaWJ1dGVEaWN0W2luZGV4XSA9IHVuZGVmaW5lZDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbmFtZSA9ICcnOyBpIDwgZWxlbWVudC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5hbWUgPSBlbGVtZW50LnN0eWxlW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY3NzW2VsZW1lbnQuc3R5bGVbaV1dID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IGNzc1trZXldO1xuICAgICAgICB9KTtcblxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdGFydCBhbmltYXRpb24gc2VxdWVuY2UuXG4gICAqL1xuICBzdGFydEFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZGVxdWV1ZVRyYW5zaXRpb24oKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9kZXF1ZXVlVHJhbnNpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25RdWV1ZS5zaGlmdCgpO1xuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50IHRyYW5zaXRpb24gZXhpc3RzLicpO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50VHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHZhciBkb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLl9jdXJyZW50VHJhbnNpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2VsZi5fZGVxdWV1ZVRyYW5zaXRpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgdHdpY2UuJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICB0cmFuc2l0aW9uLmNhbGwodGhpcywgZG9uZSk7XG4gICAgfVxuICB9XG5cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBbmltaXR9IGFyZ3VtZW50c1xuICovXG5BbmltaXQucnVuQWxsID0gZnVuY3Rpb24oLyogYXJndW1lbnRzLi4uICovKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJndW1lbnRzW2ldLnBsYXkoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0Zsb2F0fSBbb3B0aW9ucy5kdXJhdGlvbl1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcm9wZXJ0eV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aW1pbmddXG4gKi9cbkFuaW1pdC5UcmFuc2l0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm9wdGlvbnMuZHVyYXRpb24gPSB0aGlzLm9wdGlvbnMuZHVyYXRpb24gfHwgMDtcbiAgdGhpcy5vcHRpb25zLnRpbWluZyA9IHRoaXMub3B0aW9ucy50aW1pbmcgfHwgJ2xpbmVhcic7XG4gIHRoaXMub3B0aW9ucy5jc3MgPSB0aGlzLm9wdGlvbnMuY3NzIHx8IHt9O1xuICB0aGlzLm9wdGlvbnMucHJvcGVydHkgPSB0aGlzLm9wdGlvbnMucHJvcGVydHkgfHwgJ2FsbCc7XG59O1xuXG5BbmltaXQuVHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuICBidWlsZDogZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmNzcykubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuY3NzIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cblxuICAgIHZhciBjc3MgPSBjcmVhdGVBY3R1YWxDc3NQcm9wcyh0aGlzLm9wdGlvbnMuY3NzKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZHVyYXRpb24gPiAwKSB7XG4gICAgICB2YXIgdHJhbnNpdGlvblZhbHVlID0gdXRpbC5idWlsZFRyYW5zaXRpb25WYWx1ZSh0aGlzLm9wdGlvbnMpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBzZWxmLm9wdGlvbnMuZHVyYXRpb24gKiAxMDAwICogVElNRU9VVF9SQVRJTztcbiAgICAgICAgdmFyIHRpbWVvdXRJZDtcblxuICAgICAgICB2YXIgcmVtb3ZlTGlzdGVuZXJzID0gdXRpbC5vbmNlT25UcmFuc2l0aW9uRW5kKGVsZW1lbnRzWzBdLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lXSA9IHRyYW5zaXRpb25WYWx1ZTtcblxuICAgICAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW25hbWVdID0gY3NzW25hbWVdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmR1cmF0aW9uIDw9IDApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGVbdXRpbC50cmFuc2l0aW9uUHJvcGVydHlOYW1lXSA9ICcnO1xuXG4gICAgICAgICAgT2JqZWN0LmtleXMoY3NzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSBjc3NbbmFtZV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdXRpbC5mb3JjZUxheW91dEF0T25jZShlbGVtZW50cywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB1dGlsLmJhdGNoQW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWwuYmF0Y2hBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlQWN0dWFsQ3NzUHJvcHMoY3NzKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgIE9iamVjdC5rZXlzKGNzcykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGNzc1tuYW1lXTtcblxuICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmVmaXhlZCA9IHV0aWwudmVuZG9yUHJlZml4ICsgdXRpbC5jYXBpdGFsaXplKG5hbWUpO1xuICAgICAgICBpZiAodXRpbC5oYXNDc3NQcm9wZXJ0eShwcmVmaXhlZCkpIHtcbiAgICAgICAgICByZXN1bHRbcHJlZml4ZWRdID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W3ByZWZpeGVkXSA9IHZhbHVlO1xuICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQW5pbWl0O1xuXG4iLCIvKlxuICogR2VzdHVyZSBkZXRlY3RvciBsaWJyYXJ5IHRoYXQgZm9ya2VkIGZyb20gZ2l0aHViLmNvbS9FaWdodE1lZGlhL2hhbW1lci5qcy5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbnZhciBFdmVudCwgVXRpbHMsIERldGVjdGlvbiwgUG9pbnRlckV2ZW50O1xuXG4vKipcbiAqIEBvYmplY3Qgb25zLkdlc3R1cmVEZXRlY3RvclxuICogQGNhdGVnb3J5IGdlc3R1cmVcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dVXRpbGl0eSBjbGFzcyBmb3IgZ2VzdHVyZSBkZXRlY3Rpb24uWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+OCkuaknOefpeOBmeOCi+OBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+OCr+ODqeOCueOBp+OBmeOAglsvamFdXG4gKi9cblxuLyoqXG4gKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gKiBAc2lnbmF0dXJlIGNvbnN0cnVjdG9yKGVsZW1lbnRbLCBvcHRpb25zXSlcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1DcmVhdGUgYSBuZXcgR2VzdHVyZURldGVjdG9yIGluc3RhbmNlLlsvZW5dXG4gKiAgW2phXUdlc3R1cmVEZXRlY3RvcuOBruOCpOODs+OCueOCv+ODs+OCueOCkueUn+aIkOOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gKiAgIFtqYV3jgrjjgqfjgrnjg4Hjg6PjgpLmpJznn6XjgZnjgotET03opoHntKDjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dT3B0aW9ucyBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcmV0dXJuIHtvbnMuR2VzdHVyZURldGVjdG9yLkluc3RhbmNlfVxuICovXG52YXIgR2VzdHVyZURldGVjdG9yID0gZnVuY3Rpb24gR2VzdHVyZURldGVjdG9yKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2UoZWxlbWVudCwgb3B0aW9ucyB8fCB7fSk7XG59O1xuXG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5ncy5cbiAqIG1vcmUgc2V0dGluZ3MgYXJlIGRlZmluZWQgcGVyIGdlc3R1cmUgYXQgYC9nZXN0dXJlc2AuIEVhY2ggZ2VzdHVyZSBjYW4gYmUgZGlzYWJsZWQvZW5hYmxlZFxuICogYnkgc2V0dGluZyBpdCdzIG5hbWUgKGxpa2UgYHN3aXBlYCkgdG8gZmFsc2UuXG4gKiBZb3UgY2FuIHNldCB0aGUgZGVmYXVsdHMgZm9yIGFsbCBpbnN0YW5jZXMgYnkgY2hhbmdpbmcgdGhpcyBvYmplY3QgYmVmb3JlIGNyZWF0aW5nIGFuIGluc3RhbmNlLlxuICogQGV4YW1wbGVcbiAqIGBgYGBcbiAqICBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMuZHJhZyA9IGZhbHNlO1xuICogIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5iZWhhdmlvci50b3VjaEFjdGlvbiA9ICdwYW4teSc7XG4gKiAgZGVsZXRlIEdlc3R1cmVEZXRlY3Rvci5kZWZhdWx0cy5iZWhhdmlvci51c2VyU2VsZWN0O1xuICogYGBgYFxuICogQHByb3BlcnR5IGRlZmF1bHRzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMgPSB7XG4gIGJlaGF2aW9yOiB7XG4gICAgLy8gdXNlclNlbGVjdDogJ25vbmUnLCAvLyBBbHNvIGRpc2FibGVzIHNlbGVjdGlvbiBpbiBgaW5wdXRgIGNoaWxkcmVuXG4gICAgdG91Y2hBY3Rpb246ICdwYW4teScsXG4gICAgdG91Y2hDYWxsb3V0OiAnbm9uZScsXG4gICAgY29udGVudFpvb21pbmc6ICdub25lJyxcbiAgICB1c2VyRHJhZzogJ25vbmUnLFxuICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgfVxufTtcblxuLyoqXG4gKiBHZXN0dXJlRGV0ZWN0b3IgZG9jdW1lbnQgd2hlcmUgdGhlIGJhc2UgZXZlbnRzIGFyZSBhZGRlZCBhdFxuICogQHByb3BlcnR5IERPQ1VNRU5UXG4gKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gKiBAZGVmYXVsdCB3aW5kb3cuZG9jdW1lbnRcbiAqL1xuR2VzdHVyZURldGVjdG9yLkRPQ1VNRU5UID0gZG9jdW1lbnQ7XG5cbi8qKlxuICogZGV0ZWN0IHN1cHBvcnQgZm9yIHBvaW50ZXIgZXZlbnRzXG4gKiBAcHJvcGVydHkgSEFTX1BPSU5URVJFVkVOVFNcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5HZXN0dXJlRGV0ZWN0b3IuSEFTX1BPSU5URVJFVkVOVFMgPSBuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQ7XG5cbi8qKlxuICogZGV0ZWN0IHN1cHBvcnQgZm9yIHRvdWNoIGV2ZW50c1xuICogQHByb3BlcnR5IEhBU19UT1VDSEVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5IQVNfVE9VQ0hFVkVOVFMgPSAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KTtcblxuLyoqXG4gKiBkZXRlY3QgbW9iaWxlIGJyb3dzZXJzXG4gKiBAcHJvcGVydHkgSVNfTU9CSUxFXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuR2VzdHVyZURldGVjdG9yLklTX01PQklMRSA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWR8c2lsay9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogZGV0ZWN0IGlmIHdlIHdhbnQgdG8gc3VwcG9ydCBtb3VzZWV2ZW50cyBhdCBhbGxcbiAqIEBwcm9wZXJ0eSBOT19NT1VTRUVWRU5UU1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5OT19NT1VTRUVWRU5UUyA9IChHZXN0dXJlRGV0ZWN0b3IuSEFTX1RPVUNIRVZFTlRTICYmIEdlc3R1cmVEZXRlY3Rvci5JU19NT0JJTEUpIHx8IEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUztcblxuLyoqXG4gKiBpbnRlcnZhbCBpbiB3aGljaCBHZXN0dXJlRGV0ZWN0b3IgcmVjYWxjdWxhdGVzIGN1cnJlbnQgdmVsb2NpdHkvZGlyZWN0aW9uL2FuZ2xlIGluIG1zXG4gKiBAcHJvcGVydHkgQ0FMQ1VMQVRFX0lOVEVSVkFMXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGRlZmF1bHQgMjVcbiAqL1xuR2VzdHVyZURldGVjdG9yLkNBTENVTEFURV9JTlRFUlZBTCA9IDI1O1xuXG4vKipcbiAqIGV2ZW50dHlwZXMgcGVyIHRvdWNoZXZlbnQgKHN0YXJ0LCBtb3ZlLCBlbmQpIGFyZSBmaWxsZWQgYnkgYEV2ZW50LmRldGVybWluZUV2ZW50VHlwZXNgIG9uIGBzZXR1cGBcbiAqIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIERPTSBldmVudCBuYW1lcyBwZXIgdHlwZSAoYEVWRU5UX1NUQVJUYCwgYEVWRU5UX01PVkVgLCBgRVZFTlRfRU5EYClcbiAqIEBwcm9wZXJ0eSBFVkVOVF9UWVBFU1xuICogQHByaXZhdGVcbiAqIEB3cml0ZU9uY2VcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBFVkVOVF9UWVBFUyA9IHt9O1xuXG4vKipcbiAqIGRpcmVjdGlvbiBzdHJpbmdzLCBmb3Igc2FmZSBjb21wYXJpc29uc1xuICogQHByb3BlcnR5IERJUkVDVElPTl9ET1dOfExFRlR8VVB8UklHSFRcbiAqIEBmaW5hbFxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZWZhdWx0ICdkb3duJyAnbGVmdCcgJ3VwJyAncmlnaHQnXG4gKi9cbnZhciBESVJFQ1RJT05fRE9XTiA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fRE9XTiA9ICdkb3duJztcbnZhciBESVJFQ1RJT05fTEVGVCA9IEdlc3R1cmVEZXRlY3Rvci5ESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcbnZhciBESVJFQ1RJT05fVVAgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX1VQID0gJ3VwJztcbnZhciBESVJFQ1RJT05fUklHSFQgPSBHZXN0dXJlRGV0ZWN0b3IuRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcblxuLyoqXG4gKiBwb2ludGVydHlwZSBzdHJpbmdzLCBmb3Igc2FmZSBjb21wYXJpc29uc1xuICogQHByb3BlcnR5IFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnbW91c2UnICd0b3VjaCcgJ3BlbidcbiAqL1xudmFyIFBPSU5URVJfTU9VU0UgPSBHZXN0dXJlRGV0ZWN0b3IuUE9JTlRFUl9NT1VTRSA9ICdtb3VzZSc7XG52YXIgUE9JTlRFUl9UT1VDSCA9IEdlc3R1cmVEZXRlY3Rvci5QT0lOVEVSX1RPVUNIID0gJ3RvdWNoJztcbnZhciBQT0lOVEVSX1BFTiA9IEdlc3R1cmVEZXRlY3Rvci5QT0lOVEVSX1BFTiA9ICdwZW4nO1xuXG4vKipcbiAqIGV2ZW50dHlwZXNcbiAqIEBwcm9wZXJ0eSBFVkVOVF9TVEFSVHxNT1ZFfEVORHxSRUxFQVNFfFRPVUNIXG4gKiBAZmluYWxcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVmYXVsdCAnc3RhcnQnICdjaGFuZ2UnICdtb3ZlJyAnZW5kJyAncmVsZWFzZScgJ3RvdWNoJ1xuICovXG52YXIgRVZFTlRfU1RBUlQgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfU1RBUlQgPSAnc3RhcnQnO1xudmFyIEVWRU5UX01PVkUgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfTU9WRSA9ICdtb3ZlJztcbnZhciBFVkVOVF9FTkQgPSBHZXN0dXJlRGV0ZWN0b3IuRVZFTlRfRU5EID0gJ2VuZCc7XG52YXIgRVZFTlRfUkVMRUFTRSA9IEdlc3R1cmVEZXRlY3Rvci5FVkVOVF9SRUxFQVNFID0gJ3JlbGVhc2UnO1xudmFyIEVWRU5UX1RPVUNIID0gR2VzdHVyZURldGVjdG9yLkVWRU5UX1RPVUNIID0gJ3RvdWNoJztcblxuLyoqXG4gKiBpZiB0aGUgd2luZG93IGV2ZW50cyBhcmUgc2V0Li4uXG4gKiBAcHJvcGVydHkgUkVBRFlcbiAqIEB3cml0ZU9uY2VcbiAqIEB0eXBlIHtCb29sZWFufVxuICogQGRlZmF1bHQgZmFsc2VcbiAqL1xuR2VzdHVyZURldGVjdG9yLlJFQURZID0gZmFsc2U7XG5cbi8qKlxuICogcGx1Z2lucyBuYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSBwbHVnaW5zXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5HZXN0dXJlRGV0ZWN0b3IucGx1Z2lucyA9IEdlc3R1cmVEZXRlY3Rvci5wbHVnaW5zIHx8IHt9O1xuXG4vKipcbiAqIGdlc3R1cmVzIG5hbWVzcGFjZVxuICogc2VlIGAvZ2VzdHVyZXNgIGZvciB0aGUgZGVmaW5pdGlvbnNcbiAqIEBwcm9wZXJ0eSBnZXN0dXJlc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzID0gR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIHx8IHt9O1xuXG4vKipcbiAqIHNldHVwIGV2ZW50cyB0byBkZXRlY3QgZ2VzdHVyZXMgb24gdGhlIGRvY3VtZW50XG4gKiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGNyZWF0aW5nIGFuIG5ldyBpbnN0YW5jZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXAob3B0cykge1xuICBpZihHZXN0dXJlRGV0ZWN0b3IuUkVBRFkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBmaW5kIHdoYXQgZXZlbnR0eXBlcyB3ZSBhZGQgbGlzdGVuZXJzIHRvXG4gIEV2ZW50LmRldGVybWluZUV2ZW50VHlwZXMoKTtcblxuICAvLyBSZWdpc3RlciBhbGwgZ2VzdHVyZXMgaW5zaWRlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlc1xuICBVdGlscy5lYWNoKEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcywgZnVuY3Rpb24oZ2VzdHVyZSkge1xuICAgIERldGVjdGlvbi5yZWdpc3RlcihnZXN0dXJlKTtcbiAgfSk7XG5cbiAgLy8gQWRkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnRcbiAgRXZlbnQub25Ub3VjaChHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQsIEVWRU5UX01PVkUsIERldGVjdGlvbi5kZXRlY3QsIG9wdHMpO1xuICBFdmVudC5vblRvdWNoKEdlc3R1cmVEZXRlY3Rvci5ET0NVTUVOVCwgRVZFTlRfRU5ELCBEZXRlY3Rpb24uZGV0ZWN0LCBvcHRzKTtcblxuICAvLyBHZXN0dXJlRGV0ZWN0b3IgaXMgcmVhZHkuLi4hXG4gIEdlc3R1cmVEZXRlY3Rvci5SRUFEWSA9IHRydWU7XG59XG5cbi8qKlxuICogQG1vZHVsZSBHZXN0dXJlRGV0ZWN0b3JcbiAqXG4gKiBAY2xhc3MgVXRpbHNcbiAqIEBzdGF0aWNcbiAqL1xuVXRpbHMgPSBHZXN0dXJlRGV0ZWN0b3IudXRpbHMgPSB7XG4gIC8qKlxuICAgKiBleHRlbmQgbWV0aG9kLCBjb3VsZCBhbHNvIGJlIHVzZWQgZm9yIGNsb25pbmcgd2hlbiBgZGVzdGAgaXMgYW4gZW1wdHkgb2JqZWN0LlxuICAgKiBjaGFuZ2VzIHRoZSBkZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gc3JjXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21lcmdlPWZhbHNlXSAgZG8gYSBtZXJnZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGRlc3RcbiAgICovXG4gIGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkgJiYgKGRlc3Rba2V5XSA9PT0gdW5kZWZpbmVkIHx8ICFtZXJnZSkpIHtcbiAgICAgICAgZGVzdFtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgYWRkRXZlbnRMaXN0ZW5lciB3cmFwcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9wdCkge1xuICAgIHV0aWwuYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvcHQsIHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgcmVtb3ZlRXZlbnRMaXN0ZW5lciB3cmFwcGVyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb3B0KSB7XG4gICAgdXRpbC5yZW1vdmVFdmVudExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9wdCwgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZvckVhY2ggb3ZlciBhcnJheXMgYW5kIG9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9ialxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICAgKiBAcGFyYW0ge2FueX0gaXRlcmF0b3IuaXRlbVxuICAgKiBAcGFyYW0ge051bWJlcn0gaXRlcmF0b3IuaW5kZXhcbiAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IGl0ZXJhdG9yLm9iaiB0aGUgc291cmNlIG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgIGluIHRoZSBpdGVyYXRvclxuICAgKi9cbiAgZWFjaDogZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGksIGxlbjtcblxuICAgIC8vIG5hdGl2ZSBmb3JFYWNoIG9uIGFycmF5c1xuICAgIGlmKCdmb3JFYWNoJyBpbiBvYmopIHtcbiAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIC8vIGFycmF5c1xuICAgIH0gZWxzZSBpZihvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvcihpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gb2JqZWN0c1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IoaSBpbiBvYmopIHtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGkpICYmXG4gICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHRoZSBzdHJpbmcgdXNpbmcgaW5kZXhPZlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBpblN0cjogZnVuY3Rpb24gaW5TdHIoc3JjLCBmaW5kKSB7XG4gICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpID4gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGZpbmQgaWYgYSBhcnJheSBjb250YWlucyB0aGUgb2JqZWN0IHVzaW5nIGluZGV4T2Ygb3IgYSBzaW1wbGUgcG9seWZpbGxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICAgKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICAgKi9cbiAgaW5BcnJheTogZnVuY3Rpb24gaW5BcnJheShzcmMsIGZpbmQsIGRlZXApIHtcbiAgICBpZiAoZGVlcCkge1xuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gc3JjLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7IC8vIEFycmF5LmZpbmRJbmRleFxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZmluZCkuZXZlcnkoZnVuY3Rpb24oa2V5KSB7IHJldHVybiBzcmNbaV1ba2V5XSA9PT0gZmluZFtrZXldOyB9KSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYoc3JjLmluZGV4T2YpIHtcbiAgICAgIHJldHVybiBzcmMuaW5kZXhPZihmaW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gc3JjLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmKHNyY1tpXSA9PT0gZmluZCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0IChgYXJndW1lbnRzYCwgYHRvdWNobGlzdGApIHRvIGFuIGFycmF5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gICAqL1xuICBoYXNQYXJlbnQ6IGZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZShub2RlKSB7XG4gICAgICBpZihub2RlID09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSB0b3VjaGVzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHRvdWNoZXNcbiAgICogQHJldHVybiB7T2JqZWN0fSBjZW50ZXIgY29udGFpbnMgYHBhZ2VYYCwgYHBhZ2VZYCwgYGNsaWVudFhgIGFuZCBgY2xpZW50WWAgcHJvcGVydGllc1xuICAgKi9cbiAgZ2V0Q2VudGVyOiBmdW5jdGlvbiBnZXRDZW50ZXIodG91Y2hlcykge1xuICAgIHZhciBwYWdlWCA9IFtdLFxuICAgICAgICBwYWdlWSA9IFtdLFxuICAgICAgICBjbGllbnRYID0gW10sXG4gICAgICAgIGNsaWVudFkgPSBbXSxcbiAgICAgICAgbWluID0gTWF0aC5taW4sXG4gICAgICAgIG1heCA9IE1hdGgubWF4O1xuXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICBpZih0b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZVg6IHRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICAgIHBhZ2VZOiB0b3VjaGVzWzBdLnBhZ2VZLFxuICAgICAgICBjbGllbnRYOiB0b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6IHRvdWNoZXNbMF0uY2xpZW50WVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBVdGlscy5lYWNoKHRvdWNoZXMsIGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICBwYWdlWC5wdXNoKHRvdWNoLnBhZ2VYKTtcbiAgICAgIHBhZ2VZLnB1c2godG91Y2gucGFnZVkpO1xuICAgICAgY2xpZW50WC5wdXNoKHRvdWNoLmNsaWVudFgpO1xuICAgICAgY2xpZW50WS5wdXNoKHRvdWNoLmNsaWVudFkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VYOiAobWluLmFwcGx5KE1hdGgsIHBhZ2VYKSArIG1heC5hcHBseShNYXRoLCBwYWdlWCkpIC8gMixcbiAgICAgIHBhZ2VZOiAobWluLmFwcGx5KE1hdGgsIHBhZ2VZKSArIG1heC5hcHBseShNYXRoLCBwYWdlWSkpIC8gMixcbiAgICAgIGNsaWVudFg6IChtaW4uYXBwbHkoTWF0aCwgY2xpZW50WCkgKyBtYXguYXBwbHkoTWF0aCwgY2xpZW50WCkpIC8gMixcbiAgICAgIGNsaWVudFk6IChtaW4uYXBwbHkoTWF0aCwgY2xpZW50WSkgKyBtYXguYXBwbHkoTWF0aCwgY2xpZW50WSkpIC8gMlxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgdmVsb2NpdHkgYmV0d2VlbiB0d28gcG9pbnRzLiB1bml0IGlzIGluIHB4IHBlciBtcy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICogQHJldHVybiB7T2JqZWN0fSB2ZWxvY2l0eSBgeGAgYW5kIGB5YFxuICAgKi9cbiAgZ2V0VmVsb2NpdHk6IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5hYnMoZGVsdGFYIC8gZGVsdGFUaW1lKSB8fCAwLFxuICAgICAgeTogTWF0aC5hYnMoZGVsdGFZIC8gZGVsdGFUaW1lKSB8fCAwXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAgICovXG4gIGdldEFuZ2xlOiBmdW5jdGlvbiBnZXRBbmdsZSh0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gdG91Y2gyLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WCxcbiAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICByZXR1cm4gTWF0aC5hdGFuMih5LCB4KSAqIDE4MCAvIE1hdGguUEk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGRvIGEgc21hbGwgY29tcGFyaXNvbiB0byBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byB0b3VjaGVzLlxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gZGlyZWN0aW9uIG1hdGNoZXMgYERJUkVDVElPTl9MRUZUfFJJR0hUfFVQfERPV05gXG4gICAqL1xuICBnZXREaXJlY3Rpb246IGZ1bmN0aW9uIGdldERpcmVjdGlvbih0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gTWF0aC5hYnModG91Y2gxLmNsaWVudFggLSB0b3VjaDIuY2xpZW50WCksXG4gICAgICAgIHkgPSBNYXRoLmFicyh0b3VjaDEuY2xpZW50WSAtIHRvdWNoMi5jbGllbnRZKTtcblxuICAgIGlmKHggPj0geSkge1xuICAgICAgcmV0dXJuIHRvdWNoMS5jbGllbnRYIC0gdG91Y2gyLmNsaWVudFggPiAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB0b3VjaDEuY2xpZW50WSAtIHRvdWNoMi5jbGllbnRZID4gMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHRvdWNoZXNcbiAgICogQHBhcmFtIHtUb3VjaH10b3VjaDFcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2gyXG4gICAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2VcbiAgICovXG4gIGdldERpc3RhbmNlOiBmdW5jdGlvbiBnZXREaXN0YW5jZSh0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gdG91Y2gyLmNsaWVudFggLSB0b3VjaDEuY2xpZW50WCxcbiAgICAgICAgeSA9IHRvdWNoMi5jbGllbnRZIC0gdG91Y2gxLmNsaWVudFk7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCh4ICogeCkgKyAoeSAqIHkpKTtcbiAgfSxcblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gdG91Y2hMaXN0c1xuICAgKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAgICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgdG91Y2hlc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHNjYWxlXG4gICAqL1xuICBnZXRTY2FsZTogZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnMuLi5cbiAgICBpZihzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdKSAvIHRoaXMuZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byB0b3VjaExpc3RzXG4gICAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHBhcmFtIHtBcnJheX0gZW5kIGFycmF5IG9mIHRvdWNoZXNcbiAgICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICAgKi9cbiAgZ2V0Um90YXRpb246IGZ1bmN0aW9uIGdldFJvdGF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAvLyBuZWVkIHR3byBmaW5nZXJzXG4gICAgaWYoc3RhcnQubGVuZ3RoID49IDIgJiYgZW5kLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBbmdsZShlbmRbMV0sIGVuZFswXSkgLSB0aGlzLmdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIG91dCBpZiB0aGUgZGlyZWN0aW9uIGlzIHZlcnRpY2FsICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uIG1hdGNoZXMgYERJUkVDVElPTl9VUHxET1dOYFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBpc192ZXJ0aWNhbFxuICAgKi9cbiAgaXNWZXJ0aWNhbDogZnVuY3Rpb24gaXNWZXJ0aWNhbChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uID09IERJUkVDVElPTl9VUCB8fCBkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV047XG4gIH0sXG5cbiAgLyoqXG4gICAqIHNldCBjc3MgcHJvcGVydGllcyB3aXRoIHRoZWlyIHByZWZpeGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RvZ2dsZT10cnVlXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgc2V0UHJlZml4ZWRDc3M6IGZ1bmN0aW9uIHNldFByZWZpeGVkQ3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlLCB0b2dnbGUpIHtcbiAgICB2YXIgcHJlZml4ZXMgPSBbJycsICdXZWJraXQnLCAnTW96JywgJ08nLCAnbXMnXTtcbiAgICBwcm9wID0gVXRpbHMudG9DYW1lbENhc2UocHJvcCk7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcHJvcDtcbiAgICAgIC8vIHByZWZpeGVzXG4gICAgICBpZihwcmVmaXhlc1tpXSkge1xuICAgICAgICBwID0gcHJlZml4ZXNbaV0gKyBwLnNsaWNlKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBwLnNsaWNlKDEpO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZXN0IHRoZSBzdHlsZVxuICAgICAgaWYocCBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGVbcF0gPSAodG9nZ2xlID09PSBudWxsIHx8IHRvZ2dsZSkgJiYgdmFsdWUgfHwgJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogdG9nZ2xlIGJyb3dzZXIgZGVmYXVsdCBiZWhhdmlvciBieSBzZXR0aW5nIGNzcyBwcm9wZXJ0aWVzLlxuICAgKiBgdXNlclNlbGVjdD0nbm9uZSdgIGFsc28gc2V0cyBgZWxlbWVudC5vbnNlbGVjdHN0YXJ0YCB0byBmYWxzZVxuICAgKiBgdXNlckRyYWc9J25vbmUnYCBhbHNvIHNldHMgYGVsZW1lbnQub25kcmFnc3RhcnRgIHRvIGZhbHNlXG4gICAqXG4gICAqIEBwYXJhbSB7SHRtbEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3RvZ2dsZT10cnVlXVxuICAgKi9cbiAgdG9nZ2xlQmVoYXZpb3I6IGZ1bmN0aW9uIHRvZ2dsZUJlaGF2aW9yKGVsZW1lbnQsIHByb3BzLCB0b2dnbGUpIHtcbiAgICBpZighcHJvcHMgfHwgIWVsZW1lbnQgfHwgIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgdGhlIGNzcyBwcm9wZXJ0aWVzXG4gICAgVXRpbHMuZWFjaChwcm9wcywgZnVuY3Rpb24odmFsdWUsIHByb3ApIHtcbiAgICAgIFV0aWxzLnNldFByZWZpeGVkQ3NzKGVsZW1lbnQsIHByb3AsIHZhbHVlLCB0b2dnbGUpO1xuICAgIH0pO1xuXG4gICAgdmFyIGZhbHNlRm4gPSB0b2dnbGUgJiYgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIC8vIGFsc28gdGhlIGRpc2FibGUgb25zZWxlY3RzdGFydFxuICAgIGlmKHByb3BzLnVzZXJTZWxlY3QgPT0gJ25vbmUnKSB7XG4gICAgICBlbGVtZW50Lm9uc2VsZWN0c3RhcnQgPSBmYWxzZUZuO1xuICAgIH1cbiAgICAvLyBhbmQgZGlzYWJsZSBvbmRyYWdzdGFydFxuICAgIGlmKHByb3BzLnVzZXJEcmFnID09ICdub25lJykge1xuICAgICAgZWxlbWVudC5vbmRyYWdzdGFydCA9IGZhbHNlRm47XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IGEgc3RyaW5nIHdpdGggdW5kZXJzY29yZXMgdG8gY2FtZWxDYXNlXG4gICAqIHNvIHByZXZlbnRfZGVmYXVsdCBiZWNvbWVzIHByZXZlbnREZWZhdWx0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICogQHJldHVybiB7U3RyaW5nfSBjYW1lbENhc2VTdHJcbiAgICovXG4gIHRvQ2FtZWxDYXNlOiBmdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1tfLV0oW2Etel0pL2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBzWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICovXG4vKipcbiAqIEBjbGFzcyBFdmVudFxuICogQHN0YXRpY1xuICovXG5FdmVudCA9IEdlc3R1cmVEZXRlY3Rvci5ldmVudCA9IHtcbiAgLyoqXG4gICAqIHdoZW4gdG91Y2ggZXZlbnRzIGhhdmUgYmVlbiBmaXJlZCwgdGhpcyBpcyB0cnVlXG4gICAqIHRoaXMgaXMgdXNlZCB0byBzdG9wIG1vdXNlIGV2ZW50c1xuICAgKiBAcHJvcGVydHkgcHJldmVudF9tb3VzZWV2ZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIHByZXZlbnRNb3VzZUV2ZW50czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIGlmIEVWRU5UX1NUQVJUIGhhcyBiZWVuIGZpcmVkXG4gICAqIEBwcm9wZXJ0eSBzdGFydGVkXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc3RhcnRlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIHdoZW4gdGhlIG1vdXNlIGlzIGhvbGQgZG93biwgdGhpcyBpcyB0cnVlXG4gICAqIEBwcm9wZXJ0eSBzaG91bGRfZGV0ZWN0XG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgc2hvdWxkRGV0ZWN0OiBmYWxzZSxcblxuICAvKipcbiAgICogc2ltcGxlIGV2ZW50IGJpbmRlciB3aXRoIGEgaG9vayBhbmQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgdHlwZXNcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaG9va11cbiAgICogQHBhcmFtIHtPYmplY3R9IGhvb2sudHlwZVxuICAgKi9cbiAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9wdCwgaG9vaykge1xuICAgIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBVdGlscy5vbihlbGVtZW50LCB0eXBlLCBoYW5kbGVyLCBvcHQpO1xuICAgICAgaG9vayAmJiBob29rKHR5cGUpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBzaW1wbGUgZXZlbnQgdW5iaW5kZXIgd2l0aCBhIGhvb2sgYW5kIHN1cHBvcnQgZm9yIG11bHRpcGxlIHR5cGVzXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdF1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hvb2tdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBob29rLnR5cGVcbiAgICovXG4gIG9mZjogZnVuY3Rpb24gb2ZmKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9wdCwgaG9vaykge1xuICAgIHZhciB0eXBlcyA9IHR5cGUuc3BsaXQoJyAnKTtcbiAgICBVdGlscy5lYWNoKHR5cGVzLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBVdGlscy5vZmYoZWxlbWVudCwgdHlwZSwgaGFuZGxlciwgb3B0KTtcbiAgICAgIGhvb2sgJiYgaG9vayh0eXBlKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogdGhlIGNvcmUgdG91Y2ggZXZlbnQgaGFuZGxlci5cbiAgICogdGhpcyBmaW5kcyBvdXQgaWYgd2Ugc2hvdWxkIHRvIGRldGVjdCBnZXN0dXJlc1xuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgbWF0Y2hlcyBgRVZFTlRfU1RBUlR8TU9WRXxFTkRgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiBvblRvdWNoSGFuZGxlciB7RnVuY3Rpb259IHRoZSBjb3JlIGV2ZW50IGhhbmRsZXJcbiAgICovXG4gIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goZWxlbWVudCwgZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgb25Ub3VjaEhhbmRsZXIgPSBmdW5jdGlvbiBvblRvdWNoSGFuZGxlcihldikge1xuICAgICAgdmFyIHNyY1R5cGUgPSBldi50eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgaXNQb2ludGVyID0gR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTLFxuICAgICAgICAgIGlzTW91c2UgPSBVdGlscy5pblN0cihzcmNUeXBlLCAnbW91c2UnKSxcbiAgICAgICAgICB0cmlnZ2VyVHlwZTtcblxuICAgICAgLy8gaWYgd2UgYXJlIGluIGEgbW91c2VldmVudCwgYnV0IHRoZXJlIGhhcyBiZWVuIGEgdG91Y2hldmVudCB0cmlnZ2VyZWQgaW4gdGhpcyBzZXNzaW9uXG4gICAgICAvLyB3ZSB3YW50IHRvIGRvIG5vdGhpbmcuIHNpbXBseSBicmVhayBvdXQgb2YgdGhlIGV2ZW50LlxuICAgICAgaWYoaXNNb3VzZSAmJiBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cykge1xuICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gbW91c2VidXR0b24gbXVzdCBiZSBkb3duXG4gICAgICB9IGVsc2UgaWYoaXNNb3VzZSAmJiBldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICAgIHNlbGYucHJldmVudE1vdXNlRXZlbnRzID0gZmFsc2U7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gKGV2LmJ1dHRvbnMgPT09IDEgfHwgUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShQT0lOVEVSX1RPVUNILCBldikpO1xuICAgICAgICAvLyBqdXN0IGEgdmFsaWQgc3RhcnQgZXZlbnQsIGJ1dCBubyBtb3VzZVxuICAgICAgfSBlbHNlIGlmKCFpc01vdXNlICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9TVEFSVCkge1xuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgIHNlbGYuc2hvdWxkRGV0ZWN0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyIGV2ZW50IGJlZm9yZSBlbnRlcmluZyB0aGUgZGV0ZWN0aW9uXG4gICAgICBpZihpc1BvaW50ZXIgJiYgZXZlbnRUeXBlICE9IEVWRU5UX0VORCkge1xuICAgICAgICBQb2ludGVyRXZlbnQudXBkYXRlUG9pbnRlcihldmVudFR5cGUsIGV2KTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgYXJlIGluIGEgdG91Y2gvZG93biBzdGF0ZSwgc28gYWxsb3dlZCBkZXRlY3Rpb24gb2YgZ2VzdHVyZXNcbiAgICAgIGlmKHNlbGYuc2hvdWxkRGV0ZWN0KSB7XG4gICAgICAgIHRyaWdnZXJUeXBlID0gc2VsZi5kb0RldGVjdC5jYWxsKHNlbGYsIGV2LCBldmVudFR5cGUsIGVsZW1lbnQsIGhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyAuLi5hbmQgd2UgYXJlIGRvbmUgd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAvLyBzbyByZXNldCBldmVyeXRoaW5nIHRvIHN0YXJ0IGVhY2ggZGV0ZWN0aW9uIHRvdGFsbHkgZnJlc2hcbiAgICAgIGlmKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgICBzZWxmLnByZXZlbnRNb3VzZUV2ZW50cyA9IGZhbHNlO1xuICAgICAgICBzZWxmLnNob3VsZERldGVjdCA9IGZhbHNlO1xuICAgICAgICBQb2ludGVyRXZlbnQucmVzZXQoKTtcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwb2ludGVyZXZlbnQgb2JqZWN0IGFmdGVyIHRoZSBkZXRlY3Rpb25cbiAgICAgIH1cblxuICAgICAgaWYoaXNQb2ludGVyICYmIGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgICAgUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMub24oZWxlbWVudCwgRVZFTlRfVFlQRVNbZXZlbnRUeXBlXSwgb25Ub3VjaEhhbmRsZXIsIG9wdCk7XG4gICAgcmV0dXJuIG9uVG91Y2hIYW5kbGVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiB0aGUgY29yZSBkZXRlY3Rpb24gbWV0aG9kXG4gICAqIHRoaXMgZmluZHMgb3V0IHdoYXQgR2VzdHVyZURldGVjdG9yLXRvdWNoLWV2ZW50cyB0byB0cmlnZ2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlIG1hdGNoZXMgYEVWRU5UX1NUQVJUfE1PVkV8RU5EYFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybiB7U3RyaW5nfSB0cmlnZ2VyVHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICovXG4gIGRvRGV0ZWN0OiBmdW5jdGlvbiBkb0RldGVjdChldiwgZXZlbnRUeXBlLCBlbGVtZW50LCBoYW5kbGVyKSB7XG4gICAgdmFyIHRvdWNoTGlzdCA9IHRoaXMuZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpO1xuICAgIHZhciB0b3VjaExpc3RMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoO1xuICAgIHZhciB0cmlnZ2VyVHlwZSA9IGV2ZW50VHlwZTtcbiAgICB2YXIgdHJpZ2dlckNoYW5nZSA9IHRvdWNoTGlzdC50cmlnZ2VyOyAvLyB1c2VkIGJ5IGZha2VNdWx0aXRvdWNoIHBsdWdpblxuICAgIHZhciBjaGFuZ2VkTGVuZ3RoID0gdG91Y2hMaXN0TGVuZ3RoO1xuXG4gICAgLy8gYXQgZWFjaCB0b3VjaHN0YXJ0LWxpa2UgZXZlbnQgd2Ugd2FudCBhbHNvIHdhbnQgdG8gdHJpZ2dlciBhIFRPVUNIIGV2ZW50Li4uXG4gICAgaWYoZXZlbnRUeXBlID09IEVWRU5UX1NUQVJUKSB7XG4gICAgICB0cmlnZ2VyQ2hhbmdlID0gRVZFTlRfVE9VQ0g7XG4gICAgICAvLyAuLi50aGUgc2FtZSBmb3IgYSB0b3VjaGVuZC1saWtlIGV2ZW50XG4gICAgfSBlbHNlIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRyaWdnZXJDaGFuZ2UgPSBFVkVOVF9SRUxFQVNFO1xuXG4gICAgICAvLyBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IHRvdWNoZXMgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgIGNoYW5nZWRMZW5ndGggPSB0b3VjaExpc3QubGVuZ3RoIC0gKChldi5jaGFuZ2VkVG91Y2hlcykgPyBldi5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggOiAxKTtcbiAgICB9XG5cbiAgICAvLyBhZnRlciB0aGVyZSBhcmUgc3RpbGwgdG91Y2hlcyBvbiB0aGUgc2NyZWVuLFxuICAgIC8vIHdlIGp1c3Qgd2FudCB0byB0cmlnZ2VyIGEgTU9WRSBldmVudC4gc28gY2hhbmdlIHRoZSBTVEFSVCBvciBFTkQgdG8gYSBNT1ZFXG4gICAgLy8gYnV0IG9ubHkgYWZ0ZXIgZGV0ZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHRoZSBmaXJzdCB0aW1lIHdlIGFjdHVhbGx5IHdhbnQgYSBTVEFSVFxuICAgIGlmKGNoYW5nZWRMZW5ndGggPiAwICYmIHRoaXMuc3RhcnRlZCkge1xuICAgICAgdHJpZ2dlclR5cGUgPSBFVkVOVF9NT1ZFO1xuICAgIH1cblxuICAgIC8vIGRldGVjdGlvbiBoYXMgYmVlbiBzdGFydGVkLCB3ZSBrZWVwIHRyYWNrIG9mIHRoaXMsIHNlZSBhYm92ZVxuICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG5cbiAgICAvLyBnZW5lcmF0ZSBzb21lIGV2ZW50IGRhdGEsIHNvbWUgYmFzaWMgaW5mb3JtYXRpb25cbiAgICB2YXIgZXZEYXRhID0gdGhpcy5jb2xsZWN0RXZlbnREYXRhKGVsZW1lbnQsIHRyaWdnZXJUeXBlLCB0b3VjaExpc3QsIGV2KTtcblxuICAgIC8vIHRyaWdnZXIgdGhlIHRyaWdnZXJUeXBlIGV2ZW50IGJlZm9yZSB0aGUgY2hhbmdlIChUT1VDSCwgUkVMRUFTRSkgZXZlbnRzXG4gICAgLy8gYnV0IHRoZSBFTkQgZXZlbnQgc2hvdWxkIGJlIGF0IGxhc3RcbiAgICBpZihldmVudFR5cGUgIT0gRVZFTlRfRU5EKSB7XG4gICAgICBoYW5kbGVyLmNhbGwoRGV0ZWN0aW9uLCBldkRhdGEpO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgYSBjaGFuZ2UgKFRPVUNILCBSRUxFQVNFKSBldmVudCwgdGhpcyBtZWFucyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3VjaGVzIGNoYW5nZWRcbiAgICBpZih0cmlnZ2VyQ2hhbmdlKSB7XG4gICAgICBldkRhdGEuY2hhbmdlZExlbmd0aCA9IGNoYW5nZWRMZW5ndGg7XG4gICAgICBldkRhdGEuZXZlbnRUeXBlID0gdHJpZ2dlckNoYW5nZTtcblxuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcblxuICAgICAgZXZEYXRhLmV2ZW50VHlwZSA9IHRyaWdnZXJUeXBlO1xuICAgICAgZGVsZXRlIGV2RGF0YS5jaGFuZ2VkTGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIHRyaWdnZXIgdGhlIEVORCBldmVudFxuICAgIGlmKHRyaWdnZXJUeXBlID09IEVWRU5UX0VORCkge1xuICAgICAgaGFuZGxlci5jYWxsKERldGVjdGlvbiwgZXZEYXRhKTtcblxuICAgICAgLy8gLi4uYW5kIHdlIGFyZSBkb25lIHdpdGggdGhlIGRldGVjdGlvblxuICAgICAgLy8gc28gcmVzZXQgZXZlcnl0aGluZyB0byBzdGFydCBlYWNoIGRldGVjdGlvbiB0b3RhbGx5IGZyZXNoXG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJpZ2dlclR5cGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHdlIGhhdmUgZGlmZmVyZW50IGV2ZW50cyBmb3IgZWFjaCBkZXZpY2UvYnJvd3NlclxuICAgKiBkZXRlcm1pbmUgd2hhdCB3ZSBuZWVkIGFuZCBzZXQgdGhlbSBpbiB0aGUgRVZFTlRfVFlQRVMgY29uc3RhbnRcbiAgICogdGhlIGBvblRvdWNoYCBtZXRob2QgaXMgYmluZCB0byB0aGVzZSBwcm9wZXJ0aWVzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGV2ZW50c1xuICAgKi9cbiAgZGV0ZXJtaW5lRXZlbnRUeXBlczogZnVuY3Rpb24gZGV0ZXJtaW5lRXZlbnRUeXBlcygpIHtcbiAgICB2YXIgdHlwZXM7XG4gICAgaWYoR2VzdHVyZURldGVjdG9yLkhBU19QT0lOVEVSRVZFTlRTKSB7XG4gICAgICBpZih3aW5kb3cuUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIHR5cGVzID0gW1xuICAgICAgICAgICdwb2ludGVyZG93bicsXG4gICAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcbiAgICAgICAgICAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgbG9zdHBvaW50ZXJjYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZXMgPSBbXG4gICAgICAgICAgJ01TUG9pbnRlckRvd24nLFxuICAgICAgICAgICdNU1BvaW50ZXJNb3ZlJyxcbiAgICAgICAgICAnTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsIE1TTG9zdFBvaW50ZXJDYXB0dXJlJ1xuICAgICAgICBdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZihHZXN0dXJlRGV0ZWN0b3IuTk9fTU9VU0VFVkVOVFMpIHtcbiAgICAgIHR5cGVzID0gW1xuICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICd0b3VjaG1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwnXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlcyA9IFtcbiAgICAgICAgJ3RvdWNoc3RhcnQgbW91c2Vkb3duJyxcbiAgICAgICAgJ3RvdWNobW92ZSBtb3VzZW1vdmUnLFxuICAgICAgICAndG91Y2hlbmQgdG91Y2hjYW5jZWwgbW91c2V1cCdcbiAgICAgIF07XG4gICAgfVxuXG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfU1RBUlRdID0gdHlwZXNbMF07XG4gICAgRVZFTlRfVFlQRVNbRVZFTlRfTU9WRV0gPSB0eXBlc1sxXTtcbiAgICBFVkVOVF9UWVBFU1tFVkVOVF9FTkRdID0gdHlwZXNbMl07XG4gICAgcmV0dXJuIEVWRU5UX1RZUEVTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjcmVhdGUgdG91Y2hMaXN0IGRlcGVuZGluZyBvbiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGVcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNoZXNcbiAgICovXG4gIGdldFRvdWNoTGlzdDogZnVuY3Rpb24gZ2V0VG91Y2hMaXN0KGV2LCBldmVudFR5cGUpIHtcbiAgICAvLyBnZXQgdGhlIGZha2UgcG9pbnRlckV2ZW50IHRvdWNobGlzdFxuICAgIGlmKEdlc3R1cmVEZXRlY3Rvci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgcmV0dXJuIFBvaW50ZXJFdmVudC5nZXRUb3VjaExpc3QoKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHRvdWNobGlzdFxuICAgIGlmKGV2LnRvdWNoZXMpIHtcbiAgICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9NT1ZFKSB7XG4gICAgICAgIHJldHVybiBldi50b3VjaGVzO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgIHZhciBjb25jYXQgPSBbXS5jb25jYXQoVXRpbHMudG9BcnJheShldi50b3VjaGVzKSwgVXRpbHMudG9BcnJheShldi5jaGFuZ2VkVG91Y2hlcykpO1xuICAgICAgdmFyIHRvdWNoTGlzdCA9IFtdO1xuXG4gICAgICBVdGlscy5lYWNoKGNvbmNhdCwgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgaWYoVXRpbHMuaW5BcnJheShpZGVudGlmaWVycywgdG91Y2guaWRlbnRpZmllcikgPT09IC0xKSB7XG4gICAgICAgICAgdG91Y2hMaXN0LnB1c2godG91Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGlkZW50aWZpZXJzLnB1c2godG91Y2guaWRlbnRpZmllcik7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRvdWNoTGlzdDtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGZha2UgdG91Y2hMaXN0IGZyb20gbW91c2UgcG9zaXRpb25cbiAgICBldi5pZGVudGlmaWVyID0gMTtcbiAgICByZXR1cm4gW2V2XTtcbiAgfSxcblxuICAvKipcbiAgICogY29sbGVjdCBiYXNpYyBldmVudCBkYXRhXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtBcnJheX0gdG91Y2hlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICogQHJldHVybiB7T2JqZWN0fSBldlxuICAgKi9cbiAgY29sbGVjdEV2ZW50RGF0YTogZnVuY3Rpb24gY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCBldmVudFR5cGUsIHRvdWNoZXMsIGV2KSB7XG4gICAgLy8gZmluZCBvdXQgcG9pbnRlclR5cGVcbiAgICB2YXIgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1RPVUNIO1xuICAgIGlmKFV0aWxzLmluU3RyKGV2LnR5cGUsICdtb3VzZScpIHx8IFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9NT1VTRSwgZXYpKSB7XG4gICAgICBwb2ludGVyVHlwZSA9IFBPSU5URVJfTU9VU0U7XG4gICAgfSBlbHNlIGlmKFBvaW50ZXJFdmVudC5tYXRjaFR5cGUoUE9JTlRFUl9QRU4sIGV2KSkge1xuICAgICAgcG9pbnRlclR5cGUgPSBQT0lOVEVSX1BFTjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyOiBVdGlscy5nZXRDZW50ZXIodG91Y2hlcyksXG4gICAgICB0aW1lU3RhbXA6IERhdGUubm93KCksXG4gICAgICB0YXJnZXQ6IGV2LnRhcmdldCxcbiAgICAgIHRvdWNoZXM6IHRvdWNoZXMsXG4gICAgICBldmVudFR5cGU6IGV2ZW50VHlwZSxcbiAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcbiAgICAgIHNyY0V2ZW50OiBldixcblxuICAgICAgLyoqXG4gICAgICAgKiBwcmV2ZW50IHRoZSBicm93c2VyIGRlZmF1bHQgYWN0aW9uc1xuICAgICAgICogbW9zdGx5IHVzZWQgdG8gZGlzYWJsZSBzY3JvbGxpbmcgb2YgdGhlIGJyb3dzZXJcbiAgICAgICAqL1xuICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3JjRXZlbnQgPSB0aGlzLnNyY0V2ZW50O1xuICAgICAgICBzcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uICYmIHNyY0V2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24oKTtcbiAgICAgICAgc3JjRXZlbnQucHJldmVudERlZmF1bHQgJiYgc3JjRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogc3RvcCBidWJibGluZyB0aGUgZXZlbnQgdXAgdG8gaXRzIHBhcmVudHNcbiAgICAgICAqL1xuICAgICAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zcmNFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogaW1tZWRpYXRlbHkgc3RvcCBnZXN0dXJlIGRldGVjdGlvblxuICAgICAgICogbWlnaHQgYmUgdXNlZnVsIGFmdGVyIGEgc3dpcGUgd2FzIGRldGVjdGVkXG4gICAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAgICovXG4gICAgICBzdG9wRGV0ZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIERldGVjdGlvbi5zdG9wRGV0ZWN0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgR2VzdHVyZURldGVjdG9yXG4gKlxuICogQGNsYXNzIFBvaW50ZXJFdmVudFxuICogQHN0YXRpY1xuICovXG5Qb2ludGVyRXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuUG9pbnRlckV2ZW50ID0ge1xuICAvKipcbiAgICogaG9sZHMgYWxsIHBvaW50ZXJzLCBieSBgaWRlbnRpZmllcmBcbiAgICogQHByb3BlcnR5IHBvaW50ZXJzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBwb2ludGVyczoge30sXG5cbiAgLyoqXG4gICAqIGdldCB0aGUgcG9pbnRlcnMgYXMgYW4gYXJyYXlcbiAgICogQHJldHVybiB7QXJyYXl9IHRvdWNobGlzdFxuICAgKi9cbiAgZ2V0VG91Y2hMaXN0OiBmdW5jdGlvbiBnZXRUb3VjaExpc3QoKSB7XG4gICAgdmFyIHRvdWNobGlzdCA9IFtdO1xuICAgIC8vIHdlIGNhbiB1c2UgZm9yRWFjaCBzaW5jZSBwb2ludGVyRXZlbnRzIG9ubHkgaXMgaW4gSUUxMFxuICAgIFV0aWxzLmVhY2godGhpcy5wb2ludGVycywgZnVuY3Rpb24ocG9pbnRlcikge1xuICAgICAgdG91Y2hsaXN0LnB1c2gocG9pbnRlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdWNobGlzdDtcbiAgfSxcblxuICAvKipcbiAgICogdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBhIHBvaW50ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50VHlwZSBtYXRjaGVzIGBFVkVOVF9TVEFSVHxNT1ZFfEVORGBcbiAgICogQHBhcmFtIHtPYmplY3R9IHBvaW50ZXJFdmVudFxuICAgKi9cbiAgdXBkYXRlUG9pbnRlcjogZnVuY3Rpb24gdXBkYXRlUG9pbnRlcihldmVudFR5cGUsIHBvaW50ZXJFdmVudCkge1xuICAgIGlmKGV2ZW50VHlwZSA9PSBFVkVOVF9FTkQgfHwgKGV2ZW50VHlwZSAhPSBFVkVOVF9FTkQgJiYgcG9pbnRlckV2ZW50LmJ1dHRvbnMgIT09IDEpKSB7XG4gICAgICBkZWxldGUgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRlckV2ZW50LmlkZW50aWZpZXIgPSBwb2ludGVyRXZlbnQucG9pbnRlcklkO1xuICAgICAgdGhpcy5wb2ludGVyc1twb2ludGVyRXZlbnQucG9pbnRlcklkXSA9IHBvaW50ZXJFdmVudDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIGV2IG1hdGNoZXMgcG9pbnRlcnR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvaW50ZXJUeXBlIG1hdGNoZXMgYFBPSU5URVJfTU9VU0V8VE9VQ0h8UEVOYFxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZcbiAgICovXG4gIG1hdGNoVHlwZTogZnVuY3Rpb24gbWF0Y2hUeXBlKHBvaW50ZXJUeXBlLCBldikge1xuICAgIGlmKCFldi5wb2ludGVyVHlwZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwdCA9IGV2LnBvaW50ZXJUeXBlLFxuICAgICAgICB0eXBlcyA9IHt9O1xuXG4gICAgdHlwZXNbUE9JTlRFUl9NT1VTRV0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBQT0lOVEVSX01PVVNFKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9UT1VDSF0gPSAocHQgPT09IChldi5NU1BPSU5URVJfVFlQRV9UT1VDSCB8fCBQT0lOVEVSX1RPVUNIKSk7XG4gICAgdHlwZXNbUE9JTlRFUl9QRU5dID0gKHB0ID09PSAoZXYuTVNQT0lOVEVSX1RZUEVfUEVOIHx8IFBPSU5URVJfUEVOKSk7XG4gICAgcmV0dXJuIHR5cGVzW3BvaW50ZXJUeXBlXTtcbiAgfSxcblxuICAvKipcbiAgICogcmVzZXQgdGhlIHN0b3JlZCBwb2ludGVyc1xuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0TGlzdCgpIHtcbiAgICB0aGlzLnBvaW50ZXJzID0ge307XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICpcbiAqIEBjbGFzcyBEZXRlY3Rpb25cbiAqIEBzdGF0aWNcbiAqL1xuRGV0ZWN0aW9uID0gR2VzdHVyZURldGVjdG9yLmRldGVjdGlvbiA9IHtcbiAgLy8gY29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXG4gIGdlc3R1cmVzOiBbXSxcblxuICAvLyBkYXRhIG9mIHRoZSBjdXJyZW50IEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGRldGVjdGlvbiBzZXNzaW9uXG4gIGN1cnJlbnQ6IG51bGwsXG5cbiAgLy8gdGhlIHByZXZpb3VzIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHNlc3Npb24gZGF0YVxuICAvLyBpcyBhIGZ1bGwgY2xvbmUgb2YgdGhlIHByZXZpb3VzIGdlc3R1cmUuY3VycmVudCBvYmplY3RcbiAgcHJldmlvdXM6IG51bGwsXG5cbiAgLy8gd2hlbiB0aGlzIGJlY29tZXMgdHJ1ZSwgbm8gZ2VzdHVyZXMgYXJlIGZpcmVkXG4gIHN0b3BwZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBzdGFydCBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9IGluc3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgKi9cbiAgc3RhcnREZXRlY3Q6IGZ1bmN0aW9uIHN0YXJ0RGV0ZWN0KGluc3QsIGV2ZW50RGF0YSkge1xuICAgIC8vIGFscmVhZHkgYnVzeSB3aXRoIGEgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgZGV0ZWN0aW9uIG9uIGFuIGVsZW1lbnRcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIC8vIGhvbGRzIGN1cnJlbnQgc2Vzc2lvblxuICAgIHRoaXMuY3VycmVudCA9IHtcbiAgICAgIGluc3Q6IGluc3QsIC8vIHJlZmVyZW5jZSB0byBHZXN0dXJlRGV0ZWN0b3JJbnN0YW5jZSB3ZSdyZSB3b3JraW5nIGZvclxuICAgICAgc3RhcnRFdmVudDogVXRpbHMuZXh0ZW5kKHt9LCBldmVudERhdGEpLCAvLyBzdGFydCBldmVudERhdGEgZm9yIGRpc3RhbmNlcywgdGltaW5nIGV0Y1xuICAgICAgbGFzdEV2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGFcbiAgICAgIGxhc3RDYWxjRXZlbnQ6IGZhbHNlLCAvLyBsYXN0IGV2ZW50RGF0YSBmb3IgY2FsY3VsYXRpb25zLlxuICAgICAgZnV0dXJlQ2FsY0V2ZW50OiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGEgZm9yIGNhbGN1bGF0aW9ucy5cbiAgICAgIGxhc3RDYWxjRGF0YToge30sIC8vIGxhc3QgbGFzdENhbGNEYXRhXG4gICAgICBuYW1lOiAnJyAvLyBjdXJyZW50IGdlc3R1cmUgd2UncmUgaW4vZGV0ZWN0ZWQsIGNhbiBiZSAndGFwJywgJ2hvbGQnIGV0Y1xuICAgIH07XG5cbiAgICB0aGlzLmRldGVjdChldmVudERhdGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50RGF0YVxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBkZXRlY3Q6IGZ1bmN0aW9uIGRldGVjdChldmVudERhdGEpIHtcbiAgICBpZighdGhpcy5jdXJyZW50IHx8IHRoaXMuc3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBldmVudCBkYXRhIHdpdGggY2FsY3VsYXRpb25zIGFib3V0IHNjYWxlLCBkaXN0YW5jZSBldGNcbiAgICBldmVudERhdGEgPSB0aGlzLmV4dGVuZEV2ZW50RGF0YShldmVudERhdGEpO1xuXG4gICAgLy8gR2VzdHVyZURldGVjdG9yIGluc3RhbmNlIGFuZCBpbnN0YW5jZSBvcHRpb25zXG4gICAgdmFyIGluc3QgPSB0aGlzLmN1cnJlbnQuaW5zdCxcbiAgICAgICAgaW5zdE9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAvLyBjYWxsIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIGhhbmRsZXJzXG4gICAgVXRpbHMuZWFjaCh0aGlzLmdlc3R1cmVzLCBmdW5jdGlvbiB0cmlnZ2VyR2VzdHVyZShnZXN0dXJlKSB7XG4gICAgICAvLyBvbmx5IHdoZW4gdGhlIGluc3RhbmNlIG9wdGlvbnMgaGF2ZSBlbmFibGVkIHRoaXMgZ2VzdHVyZVxuICAgICAgaWYoIXRoaXMuc3RvcHBlZCAmJiBpbnN0LmVuYWJsZWQgJiYgaW5zdE9wdGlvbnNbZ2VzdHVyZS5uYW1lXSkge1xuICAgICAgICBnZXN0dXJlLmhhbmRsZXIuY2FsbChnZXN0dXJlLCBldmVudERhdGEsIGluc3QpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gc3RvcmUgYXMgcHJldmlvdXMgZXZlbnQgZXZlbnRcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHRoaXMuY3VycmVudC5sYXN0RXZlbnQgPSBldmVudERhdGE7XG4gICAgfVxuXG4gICAgaWYoZXZlbnREYXRhLmV2ZW50VHlwZSA9PSBFVkVOVF9FTkQpIHtcbiAgICAgIHRoaXMuc3RvcERldGVjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudERhdGE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgfSxcblxuICAvKipcbiAgICogY2xlYXIgdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHZhcnNcbiAgICogdGhpcyBpcyBjYWxsZWQgb24gZW5kRGV0ZWN0LCBidXQgY2FuIGFsc28gYmUgdXNlZCB3aGVuIGEgZmluYWwgR2VzdHVyZURldGVjdG9yLmdlc3R1cmUgaGFzIGJlZW4gZGV0ZWN0ZWRcbiAgICogdG8gc3RvcCBvdGhlciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMgZnJvbSBiZWluZyBmaXJlZFxuICAgKi9cbiAgc3RvcERldGVjdDogZnVuY3Rpb24gc3RvcERldGVjdCgpIHtcbiAgICAvLyBjbG9uZSBjdXJyZW50IGRhdGEgdG8gdGhlIHN0b3JlIGFzIHRoZSBwcmV2aW91cyBnZXN0dXJlXG4gICAgLy8gdXNlZCBmb3IgdGhlIGRvdWJsZSB0YXAgZ2VzdHVyZSwgc2luY2UgdGhpcyBpcyBhbiBvdGhlciBnZXN0dXJlIGRldGVjdCBzZXNzaW9uXG4gICAgdGhpcy5wcmV2aW91cyA9IFV0aWxzLmV4dGVuZCh7fSwgdGhpcy5jdXJyZW50KTtcblxuICAgIC8vIHJlc2V0IHRoZSBjdXJyZW50XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdmVsb2NpdHksIGFuZ2xlIGFuZCBkaXJlY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZW50ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICAgKiBAcGFyYW0ge051bWJlcn0gZGVsdGFYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YVlcbiAgICovXG4gIGdldENhbGN1bGF0ZWREYXRhOiBmdW5jdGlvbiBnZXRDYWxjdWxhdGVkRGF0YShldiwgY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgcmVjYWxjID0gZmFsc2UsXG4gICAgICAgIGNhbGNFdiA9IGN1ci5sYXN0Q2FsY0V2ZW50LFxuICAgICAgICBjYWxjRGF0YSA9IGN1ci5sYXN0Q2FsY0RhdGE7XG5cbiAgICBpZihjYWxjRXYgJiYgZXYudGltZVN0YW1wIC0gY2FsY0V2LnRpbWVTdGFtcCA+IEdlc3R1cmVEZXRlY3Rvci5DQUxDVUxBVEVfSU5URVJWQUwpIHtcbiAgICAgIGNlbnRlciA9IGNhbGNFdi5jZW50ZXI7XG4gICAgICBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBjYWxjRXYudGltZVN0YW1wO1xuICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBjYWxjRXYuY2VudGVyLmNsaWVudFg7XG4gICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIGNhbGNFdi5jZW50ZXIuY2xpZW50WTtcbiAgICAgIHJlY2FsYyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICBjdXIuZnV0dXJlQ2FsY0V2ZW50ID0gZXY7XG4gICAgfVxuXG4gICAgaWYoIWN1ci5sYXN0Q2FsY0V2ZW50IHx8IHJlY2FsYykge1xuICAgICAgY2FsY0RhdGEudmVsb2NpdHkgPSBVdGlscy5nZXRWZWxvY2l0eShkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICAgIGNhbGNEYXRhLmFuZ2xlID0gVXRpbHMuZ2V0QW5nbGUoY2VudGVyLCBldi5jZW50ZXIpO1xuICAgICAgY2FsY0RhdGEuZGlyZWN0aW9uID0gVXRpbHMuZ2V0RGlyZWN0aW9uKGNlbnRlciwgZXYuY2VudGVyKTtcblxuICAgICAgY3VyLmxhc3RDYWxjRXZlbnQgPSBjdXIuZnV0dXJlQ2FsY0V2ZW50IHx8IGV2O1xuICAgICAgY3VyLmZ1dHVyZUNhbGNFdmVudCA9IGV2O1xuICAgIH1cblxuICAgIGV2LnZlbG9jaXR5WCA9IGNhbGNEYXRhLnZlbG9jaXR5Lng7XG4gICAgZXYudmVsb2NpdHlZID0gY2FsY0RhdGEudmVsb2NpdHkueTtcbiAgICBldi5pbnRlcmltQW5nbGUgPSBjYWxjRGF0YS5hbmdsZTtcbiAgICBldi5pbnRlcmltRGlyZWN0aW9uID0gY2FsY0RhdGEuZGlyZWN0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBleHRlbmQgZXZlbnREYXRhIGZvciBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqIEByZXR1cm4ge09iamVjdH0gZXZcbiAgICovXG4gIGV4dGVuZEV2ZW50RGF0YTogZnVuY3Rpb24gZXh0ZW5kRXZlbnREYXRhKGV2KSB7XG4gICAgdmFyIGN1ciA9IHRoaXMuY3VycmVudCxcbiAgICAgICAgc3RhcnRFdiA9IGN1ci5zdGFydEV2ZW50LFxuICAgICAgICBsYXN0RXYgPSBjdXIubGFzdEV2ZW50IHx8IHN0YXJ0RXY7XG5cbiAgICAvLyB1cGRhdGUgdGhlIHN0YXJ0IHRvdWNobGlzdCB0byBjYWxjdWxhdGUgdGhlIHNjYWxlL3JvdGF0aW9uXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIIHx8IGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9SRUxFQVNFKSB7XG4gICAgICBzdGFydEV2LnRvdWNoZXMgPSBbXTtcbiAgICAgIFV0aWxzLmVhY2goZXYudG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgc3RhcnRFdi50b3VjaGVzLnB1c2goe1xuICAgICAgICAgIGNsaWVudFg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgY2xpZW50WTogdG91Y2guY2xpZW50WVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBkZWx0YVRpbWUgPSBldi50aW1lU3RhbXAgLSBzdGFydEV2LnRpbWVTdGFtcCxcbiAgICAgICAgZGVsdGFYID0gZXYuY2VudGVyLmNsaWVudFggLSBzdGFydEV2LmNlbnRlci5jbGllbnRYLFxuICAgICAgICBkZWx0YVkgPSBldi5jZW50ZXIuY2xpZW50WSAtIHN0YXJ0RXYuY2VudGVyLmNsaWVudFk7XG5cbiAgICB0aGlzLmdldENhbGN1bGF0ZWREYXRhKGV2LCBsYXN0RXYuY2VudGVyLCBkZWx0YVRpbWUsIGRlbHRhWCwgZGVsdGFZKTtcblxuICAgIFV0aWxzLmV4dGVuZChldiwge1xuICAgICAgc3RhcnRFdmVudDogc3RhcnRFdixcblxuICAgICAgZGVsdGFUaW1lOiBkZWx0YVRpbWUsXG4gICAgICBkZWx0YVg6IGRlbHRhWCxcbiAgICAgIGRlbHRhWTogZGVsdGFZLFxuXG4gICAgICBkaXN0YW5jZTogVXRpbHMuZ2V0RGlzdGFuY2Uoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBhbmdsZTogVXRpbHMuZ2V0QW5nbGUoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBkaXJlY3Rpb246IFV0aWxzLmdldERpcmVjdGlvbihzdGFydEV2LmNlbnRlciwgZXYuY2VudGVyKSxcbiAgICAgIHNjYWxlOiBVdGlscy5nZXRTY2FsZShzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpLFxuICAgICAgcm90YXRpb246IFV0aWxzLmdldFJvdGF0aW9uKHN0YXJ0RXYudG91Y2hlcywgZXYudG91Y2hlcylcbiAgICB9KTtcblxuICAgIHJldHVybiBldjtcbiAgfSxcblxuICAvKipcbiAgICogcmVnaXN0ZXIgbmV3IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGdlc3R1cmUgb2JqZWN0LCBzZWUgYGdlc3R1cmVzL2AgZm9yIGRvY3VtZW50YXRpb25cbiAgICogQHJldHVybiB7QXJyYXl9IGdlc3R1cmVzXG4gICAqL1xuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoZ2VzdHVyZSkge1xuICAgIC8vIGFkZCBhbiBlbmFibGUgZ2VzdHVyZSBvcHRpb25zIGlmIHRoZXJlIGlzIG5vIGdpdmVuXG4gICAgdmFyIG9wdGlvbnMgPSBnZXN0dXJlLmRlZmF1bHRzIHx8IHt9O1xuICAgIGlmKG9wdGlvbnNbZ2VzdHVyZS5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zW2dlc3R1cmUubmFtZV0gPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGV4dGVuZCBHZXN0dXJlRGV0ZWN0b3IgZGVmYXVsdCBvcHRpb25zIHdpdGggdGhlIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIG9wdGlvbnNcbiAgICBVdGlscy5leHRlbmQoR2VzdHVyZURldGVjdG9yLmRlZmF1bHRzLCBvcHRpb25zLCB0cnVlKTtcblxuICAgIC8vIHNldCBpdHMgaW5kZXhcbiAgICBnZXN0dXJlLmluZGV4ID0gZ2VzdHVyZS5pbmRleCB8fCAxMDAwO1xuXG4gICAgLy8gYWRkIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlIHRvIHRoZSBsaXN0XG4gICAgdGhpcy5nZXN0dXJlcy5wdXNoKGdlc3R1cmUpO1xuXG4gICAgLy8gc29ydCB0aGUgbGlzdCBieSBpbmRleFxuICAgIHRoaXMuZ2VzdHVyZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZihhLmluZGV4IDwgYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpZihhLmluZGV4ID4gYi5pbmRleCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2VzdHVyZXM7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAbW9kdWxlIEdlc3R1cmVEZXRlY3RvclxuICovXG5cbi8qKlxuICogY3JlYXRlIG5ldyBHZXN0dXJlRGV0ZWN0b3IgaW5zdGFuY2VcbiAqIGFsbCBtZXRob2RzIHNob3VsZCByZXR1cm4gdGhlIGluc3RhbmNlIGl0c2VsZiwgc28gaXQgaXMgY2hhaW5hYmxlLlxuICpcbiAqIEBjbGFzcyBJbnN0YW5jZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIG9wdGlvbnMgYXJlIG1lcmdlZCB3aXRoIGBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHNgXG4gKiBAcmV0dXJuIHtHZXN0dXJlRGV0ZWN0b3IuSW5zdGFuY2V9XG4gKi9cbkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgbGlzdGVuZXJPcHRpb25zID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXNzaXZlKSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogdW5kZWZpbmVkO1xuXG4gIC8vIHNldHVwIEdlc3R1cmVEZXRlY3RvckpTIHdpbmRvdyBldmVudHMgYW5kIHJlZ2lzdGVyIGFsbCBnZXN0dXJlc1xuICAvLyB0aGlzIGFsc28gc2V0cyB1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gIHNldHVwKGxpc3RlbmVyT3B0aW9ucyk7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbGVtZW50XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBlbmFibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBvcHRpb25zLCBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdHNcbiAgICogb3B0aW9ucyB3aXRoIGFuIF8gYXJlIGNvbnZlcnRlZCB0byBjYW1lbENhc2VcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIFV0aWxzLmVhY2gob3B0aW9ucywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICBkZWxldGUgb3B0aW9uc1tuYW1lXTtcbiAgICBvcHRpb25zW1V0aWxzLnRvQ2FtZWxDYXNlKG5hbWUpXSA9IHZhbHVlO1xuICB9KTtcblxuICB0aGlzLm9wdGlvbnMgPSBVdGlscy5leHRlbmQoVXRpbHMuZXh0ZW5kKHt9LCBHZXN0dXJlRGV0ZWN0b3IuZGVmYXVsdHMpLCBvcHRpb25zIHx8IHt9KTtcbiAgdGhpcy5vcHRpb25zLmxpc3RlbmVyT3B0aW9ucyA9IGxpc3RlbmVyT3B0aW9ucztcblxuICAvLyBhZGQgc29tZSBjc3MgdG8gdGhlIGVsZW1lbnQgdG8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGRvaW5nIGl0cyBuYXRpdmUgYmVoYXZpb3JcbiAgaWYodGhpcy5vcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgVXRpbHMudG9nZ2xlQmVoYXZpb3IodGhpcy5lbGVtZW50LCB0aGlzLm9wdGlvbnMuYmVoYXZpb3IsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIGV2ZW50IHN0YXJ0IGhhbmRsZXIgb24gdGhlIGVsZW1lbnQgdG8gc3RhcnQgdGhlIGRldGVjdGlvblxuICAgKiBAcHJvcGVydHkgZXZlbnRTdGFydEhhbmRsZXJcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRoaXMuZXZlbnRTdGFydEhhbmRsZXIgPSBFdmVudC5vblRvdWNoKGVsZW1lbnQsIEVWRU5UX1NUQVJULCBmdW5jdGlvbihldikge1xuICAgIGlmKHNlbGYuZW5hYmxlZCAmJiBldi5ldmVudFR5cGUgPT0gRVZFTlRfU1RBUlQpIHtcbiAgICAgIERldGVjdGlvbi5zdGFydERldGVjdChzZWxmLCBldik7XG4gICAgfSBlbHNlIGlmKGV2LmV2ZW50VHlwZSA9PSBFVkVOVF9UT1VDSCkge1xuICAgICAgRGV0ZWN0aW9uLmRldGVjdChldik7XG4gICAgfVxuICB9LCBsaXN0ZW5lck9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBrZWVwIGEgbGlzdCBvZiB1c2VyIGV2ZW50IGhhbmRsZXJzIHdoaWNoIG5lZWRzIHRvIGJlIHJlbW92ZWQgd2hlbiBjYWxsaW5nICdkaXNwb3NlJ1xuICAgKiBAcHJvcGVydHkgZXZlbnRIYW5kbGVyc1xuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXTtcbn07XG5cbkdlc3R1cmVEZXRlY3Rvci5JbnN0YW5jZS5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBAbWV0aG9kIG9uXG4gICAqIEBzaWduYXR1cmUgb24oZ2VzdHVyZXMsIGhhbmRsZXIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUFkZHMgYW4gZXZlbnQgaGFuZGxlciBmb3IgYSBnZXN0dXJlLiBBdmFpbGFibGUgZ2VzdHVyZXMgYXJlOiBkcmFnLCBkcmFnbGVmdCwgZHJhZ3JpZ2h0LCBkcmFndXAsIGRyYWdkb3duLCBob2xkLCByZWxlYXNlLCBzd2lwZSwgc3dpcGVsZWZ0LCBzd2lwZXJpZ2h0LCBzd2lwZXVwLCBzd2lwZWRvd24sIHRhcCwgZG91YmxldGFwLCB0b3VjaCwgdHJhbnNmb3JtLCBwaW5jaCwgcGluY2hpbiwgcGluY2hvdXQgYW5kIHJvdGF0ZS4gWy9lbl1cbiAgICogIFtqYV3jgrjjgqfjgrnjg4Hjg6Pjgavlr77jgZnjgovjgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgpLov73liqDjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovjgrjjgqfjgrnjg4Hjg6PlkI3jga/jgIFkcmFnIGRyYWdsZWZ0IGRyYWdyaWdodCBkcmFndXAgZHJhZ2Rvd24gaG9sZCByZWxlYXNlIHN3aXBlIHN3aXBlbGVmdCBzd2lwZXJpZ2h0IHN3aXBldXAgc3dpcGVkb3duIHRhcCBkb3VibGV0YXAgdG91Y2ggdHJhbnNmb3JtIHBpbmNoIHBpbmNoaW4gcGluY2hvdXQgcm90YXRlIOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBnZXN0dXJlc1xuICAgKiAgIFtlbl1BIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGdlc3R1cmVzLlsvZW5dXG4gICAqICAgW2phXeaknOefpeOBmeOCi+OCuOOCp+OCueODgeODo+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguOCueODmuODvOOCueOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOBjOOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogICBbZW5dQW4gZXZlbnQgaGFuZGxpbmcgZnVuY3Rpb24uWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44OP44Oz44OJ44Op44Go44Gq44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG9uOiBmdW5jdGlvbiBvbkV2ZW50KGdlc3R1cmVzLCBoYW5kbGVyLCBvcHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBFdmVudC5vbihzZWxmLmVsZW1lbnQsIGdlc3R1cmVzLCBoYW5kbGVyLCB1dGlsLmV4dGVuZCh7fSwgc2VsZi5vcHRpb25zLmxpc3RlbmVyT3B0aW9ucywgb3B0KSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgc2VsZi5ldmVudEhhbmRsZXJzLnB1c2goeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG9mZlxuICAgKiBAc2lnbmF0dXJlIG9mZihnZXN0dXJlcywgaGFuZGxlcilcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLlsvZW5dXG4gICAqICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5YmK6Zmk44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGdlc3R1cmVzXG4gICAqICAgW2VuXUEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgZ2VzdHVyZXMuWy9lbl1cbiAgICogICBbamFd44K444Kn44K544OB44Oj5ZCN44KS5oyH5a6a44GX44G+44GZ44CC44K544Oa44O844K544Gn6KSH5pWw5oyH5a6a44GZ44KL44GT44Go44GM44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgKiAgIFtlbl1BbiBldmVudCBoYW5kbGluZyBmdW5jdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjg4/jg7Pjg4njg6njgajjgarjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmZFdmVudChnZXN0dXJlcywgaGFuZGxlciwgb3B0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgRXZlbnQub2ZmKHNlbGYuZWxlbWVudCwgZ2VzdHVyZXMsIGhhbmRsZXIsIHV0aWwuZXh0ZW5kKHt9LCBzZWxmLm9wdGlvbnMubGlzdGVuZXJPcHRpb25zLCBvcHQpLCBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgaW5kZXggPSBVdGlscy5pbkFycmF5KHNlbGYuZXZlbnRIYW5kbGVycywgeyBnZXN0dXJlOiB0eXBlLCBoYW5kbGVyOiBoYW5kbGVyIH0sIHRydWUpO1xuICAgICAgaWYoaW5kZXggPj0gMCkge1xuICAgICAgICBzZWxmLmV2ZW50SGFuZGxlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICAvKipcbiAgICogdHJpZ2dlciBnZXN0dXJlIGV2ZW50XG4gICAqIEBtZXRob2QgdHJpZ2dlclxuICAgKiBAc2lnbmF0dXJlIHRyaWdnZXIoZ2VzdHVyZSwgZXZlbnREYXRhKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZ2VzdHVyZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V2ZW50RGF0YV1cbiAgICovXG4gIHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXJFdmVudChnZXN0dXJlLCBldmVudERhdGEpIHtcbiAgICAvLyBvcHRpb25hbFxuICAgIGlmKCFldmVudERhdGEpIHtcbiAgICAgIGV2ZW50RGF0YSA9IHt9O1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBET00gZXZlbnRcbiAgICB2YXIgZXZlbnQgPSBHZXN0dXJlRGV0ZWN0b3IuRE9DVU1FTlQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEV2ZW50KGdlc3R1cmUsIHRydWUsIHRydWUpO1xuICAgIGV2ZW50Lmdlc3R1cmUgPSBldmVudERhdGE7XG5cbiAgICAvLyB0cmlnZ2VyIG9uIHRoZSB0YXJnZXQgaWYgaXQgaXMgaW4gdGhlIGluc3RhbmNlIGVsZW1lbnQsXG4gICAgLy8gdGhpcyBpcyBmb3IgZXZlbnQgZGVsZWdhdGlvbiB0cmlja3NcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBpZihVdGlscy5oYXNQYXJlbnQoZXZlbnREYXRhLnRhcmdldCwgZWxlbWVudCkpIHtcbiAgICAgIGVsZW1lbnQgPSBldmVudERhdGEudGFyZ2V0O1xuICAgIH1cblxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZW5hYmxlXG4gICAqIEBzaWduYXR1cmUgZW5hYmxlKHN0YXRlKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1FbmFibGUgb3IgZGlzYWJsZSBnZXN0dXJlIGRldGVjdGlvbi5bL2VuXVxuICAgKiAgW2phXeOCuOOCp+OCueODgeODo+aknOefpeOCkuacieWKueWMli/nhKHlirnljJbjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXRlXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIGVuYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeacieWKueOBq+OBmeOCi+OBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHN0YXRlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGRpc3Bvc2VcbiAgICogQHNpZ25hdHVyZSBkaXNwb3NlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dUmVtb3ZlIGFuZCBkZXN0cm95IGFsbCBldmVudCBoYW5kbGVycyBmb3IgdGhpcyBpbnN0YW5jZS5bL2VuXVxuICAgKiAgW2phXeOBk+OBruOCpOODs+OCueOCv+ODs+OCueOBp+OBruOCuOOCp+OCueODgeODo+OBruaknOefpeOChOOAgeOCpOODmeODs+ODiOODj+ODs+ODieODqeOCkuWFqOOBpuino+mZpOOBl+OBpuW7g+ajhOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgIHZhciBpLCBlaDtcblxuICAgIC8vIHVuZG8gYWxsIGNoYW5nZXMgbWFkZSBieSBzdG9wX2Jyb3dzZXJfYmVoYXZpb3JcbiAgICBVdGlscy50b2dnbGVCZWhhdmlvcih0aGlzLmVsZW1lbnQsIHRoaXMub3B0aW9ucy5iZWhhdmlvciwgZmFsc2UpO1xuXG4gICAgLy8gdW5iaW5kIGFsbCBjdXN0b20gZXZlbnQgaGFuZGxlcnNcbiAgICBmb3IoaSA9IC0xOyAoZWggPSB0aGlzLmV2ZW50SGFuZGxlcnNbKytpXSk7KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgIFV0aWxzLm9mZih0aGlzLmVsZW1lbnQsIGVoLmdlc3R1cmUsIGVoLmhhbmRsZXIpO1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xuXG4gICAgLy8gdW5iaW5kIHRoZSBzdGFydCBldmVudCBsaXN0ZW5lclxuICAgIEV2ZW50Lm9mZih0aGlzLmVsZW1lbnQsIEVWRU5UX1RZUEVTW0VWRU5UX1NUQVJUXSwgdGhpcy5ldmVudFN0YXJ0SGFuZGxlcik7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuXG4vKipcbiAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAqL1xuLyoqXG4gKiBNb3ZlIHdpdGggeCBmaW5nZXJzIChkZWZhdWx0IDEpIGFyb3VuZCBvbiB0aGUgcGFnZS5cbiAqIFByZXZlbnRpbmcgdGhlIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvciBpcyBhIGdvb2Qgd2F5IHRvIGltcHJvdmUgZmVlbCBhbmQgd29ya2luZy5cbiAqIGBgYGBcbiAqICBHZXN0dXJlRGV0ZWN0b3J0aW1lLm9uKFwiZHJhZ1wiLCBmdW5jdGlvbihldikge1xuICogICAgY29uc29sZS5sb2coZXYpO1xuICogICAgZXYuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICogIH0pO1xuICogYGBgYFxuICpcbiAqIEBjbGFzcyBEcmFnXG4gKiBAc3RhdGljXG4gKi9cbi8qKlxuICogQGV2ZW50IGRyYWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnc3RhcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqL1xuLyoqXG4gKiBAZXZlbnQgZHJhcGxlZnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFncmlnaHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFndXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICovXG4vKipcbiAqIEBldmVudCBkcmFnZG93blxuICogQHBhcmFtIHtPYmplY3R9IGV2XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICovXG4oZnVuY3Rpb24obmFtZSkge1xuICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZHJhZ0dlc3R1cmUoZXYsIGluc3QpIHtcbiAgICB2YXIgY3VyID0gRGV0ZWN0aW9uLmN1cnJlbnQ7XG5cbiAgICAvLyBtYXggdG91Y2hlc1xuICAgIGlmKGluc3Qub3B0aW9ucy5kcmFnTWF4VG91Y2hlcyA+IDAgJiZcbiAgICAgIGV2LnRvdWNoZXMubGVuZ3RoID4gaW5zdC5vcHRpb25zLmRyYWdNYXhUb3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAvLyBvciB3ZSBjYW4gYmUgYWxyZWFkeSBpbiBkcmFnZ2luZ1xuICAgICAgaWYoZXYuZGlzdGFuY2UgPCBpbnN0Lm9wdGlvbnMuZHJhZ01pbkRpc3RhbmNlICYmXG4gICAgICAgIGN1ci5uYW1lICE9IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRDZW50ZXIgPSBjdXIuc3RhcnRFdmVudC5jZW50ZXI7XG5cbiAgICAgIC8vIHdlIGFyZSBkcmFnZ2luZyFcbiAgICAgIGlmKGN1ci5uYW1lICE9IG5hbWUpIHtcbiAgICAgICAgY3VyLm5hbWUgPSBuYW1lO1xuICAgICAgICBpZihpbnN0Lm9wdGlvbnMuZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbiAmJiBldi5kaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAvLyBXaGVuIGEgZHJhZyBpcyB0cmlnZ2VyZWQsIHNldCB0aGUgZXZlbnQgY2VudGVyIHRvIGRyYWdNaW5EaXN0YW5jZSBwaXhlbHMgZnJvbSB0aGUgb3JpZ2luYWwgZXZlbnQgY2VudGVyLlxuICAgICAgICAgIC8vIFdpdGhvdXQgdGhpcyBjb3JyZWN0aW9uLCB0aGUgZHJhZ2dlZCBkaXN0YW5jZSB3b3VsZCBqdW1wc3RhcnQgYXQgZHJhZ01pbkRpc3RhbmNlIHBpeGVscyBpbnN0ZWFkIG9mIGF0IDAuXG4gICAgICAgICAgLy8gSXQgbWlnaHQgYmUgdXNlZnVsIHRvIHNhdmUgdGhlIG9yaWdpbmFsIHN0YXJ0IHBvaW50IHNvbWV3aGVyZVxuICAgICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLmFicyhpbnN0Lm9wdGlvbnMuZHJhZ01pbkRpc3RhbmNlIC8gZXYuZGlzdGFuY2UpO1xuICAgICAgICAgIHN0YXJ0Q2VudGVyLnBhZ2VYICs9IGV2LmRlbHRhWCAqIGZhY3RvcjtcbiAgICAgICAgICBzdGFydENlbnRlci5wYWdlWSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG4gICAgICAgICAgc3RhcnRDZW50ZXIuY2xpZW50WCArPSBldi5kZWx0YVggKiBmYWN0b3I7XG4gICAgICAgICAgc3RhcnRDZW50ZXIuY2xpZW50WSArPSBldi5kZWx0YVkgKiBmYWN0b3I7XG5cbiAgICAgICAgICAvLyByZWNhbGN1bGF0ZSBldmVudCBkYXRhIHVzaW5nIG5ldyBzdGFydCBwb2ludFxuICAgICAgICAgIGV2ID0gRGV0ZWN0aW9uLmV4dGVuZEV2ZW50RGF0YShldik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbG9jayBkcmFnIHRvIGF4aXM/XG4gICAgICBpZihjdXIubGFzdEV2ZW50LmRyYWdMb2NrVG9BeGlzIHx8XG4gICAgICAgICggaW5zdC5vcHRpb25zLmRyYWdMb2NrVG9BeGlzICYmXG4gICAgICAgICAgaW5zdC5vcHRpb25zLmRyYWdMb2NrTWluRGlzdGFuY2UgPD0gZXYuZGlzdGFuY2VcbiAgICAgICAgKSkge1xuICAgICAgICAgIGV2LmRyYWdMb2NrVG9BeGlzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGtlZXAgZGlyZWN0aW9uIG9uIHRoZSBheGlzIHRoYXQgdGhlIGRyYWcgZ2VzdHVyZSBzdGFydGVkIG9uXG4gICAgICAgIHZhciBsYXN0RGlyZWN0aW9uID0gY3VyLmxhc3RFdmVudC5kaXJlY3Rpb247XG4gICAgICAgIGlmKGV2LmRyYWdMb2NrVG9BeGlzICYmIGxhc3REaXJlY3Rpb24gIT09IGV2LmRpcmVjdGlvbikge1xuICAgICAgICAgIGlmKFV0aWxzLmlzVmVydGljYWwobGFzdERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVkgPCAwKSA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBldi5kaXJlY3Rpb24gPSAoZXYuZGVsdGFYIDwgMCkgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICBpZighdHJpZ2dlcmVkKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnc3RhcnQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgZXZlbnRzXG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7XG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lICsgZXYuZGlyZWN0aW9uLCBldik7XG5cbiAgICAgICAgdmFyIGlzVmVydGljYWwgPSBVdGlscy5pc1ZlcnRpY2FsKGV2LmRpcmVjdGlvbik7XG5cbiAgICAgICAgLy8gYmxvY2sgdGhlIGJyb3dzZXIgZXZlbnRzXG4gICAgICAgIGlmKChpbnN0Lm9wdGlvbnMuZHJhZ0Jsb2NrVmVydGljYWwgJiYgaXNWZXJ0aWNhbCkgfHxcbiAgICAgICAgICAoaW5zdC5vcHRpb25zLmRyYWdCbG9ja0hvcml6b250YWwgJiYgIWlzVmVydGljYWwpKSB7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9SRUxFQVNFOlxuICAgICAgICBpZih0cmlnZ2VyZWQgJiYgZXYuY2hhbmdlZExlbmd0aCA8PSBpbnN0Lm9wdGlvbnMuZHJhZ01heFRvdWNoZXMpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIobmFtZSArICdlbmQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfRU5EOlxuICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkRyYWcgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDUwLFxuICAgICAgaGFuZGxlcjogZHJhZ0dlc3R1cmUsXG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogbWluaW1hbCBtb3ZlbWVudCB0aGF0IGhhdmUgdG8gYmUgbWFkZSBiZWZvcmUgdGhlIGRyYWcgZXZlbnQgZ2V0cyB0cmlnZ2VyZWRcbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdNaW5EaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxMFxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ01pbkRpc3RhbmNlOiAxMCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IGRyYWdEaXN0YW5jZUNvcnJlY3Rpb24gdG8gdHJ1ZSB0byBtYWtlIHRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgZHJhZ1xuICAgICAgICAgKiBiZSBjYWxjdWxhdGVkIGZyb20gd2hlcmUgdGhlIGRyYWcgd2FzIHRyaWdnZXJlZCwgbm90IGZyb20gd2hlcmUgdGhlIHRvdWNoIHN0YXJ0ZWQuXG4gICAgICAgICAqIFVzZWZ1bCB0byBhdm9pZCBhIGplcmstc3RhcnRpbmcgZHJhZywgd2hpY2ggY2FuIG1ha2UgZmluZS1hZGp1c3RtZW50c1xuICAgICAgICAgKiB0aHJvdWdoIGRyYWdnaW5nIGRpZmZpY3VsdCwgYW5kIGJlIHZpc3VhbGx5IHVuYXBwZWFsaW5nLlxuICAgICAgICAgKiBAcHJvcGVydHkgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvblxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Rpc3RhbmNlQ29ycmVjdGlvbjogdHJ1ZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IDAgZm9yIHVubGltaXRlZCwgYnV0IHRoaXMgY2FuIGNvbmZsaWN0IHdpdGggdHJhbnNmb3JtXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTWF4VG91Y2hlc1xuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICBkcmFnTWF4VG91Y2hlczogMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJldmVudCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3Igd2hlbiBkcmFnZ2luZyBvY2N1cnNcbiAgICAgICAgICogYmUgY2FyZWZ1bCB3aXRoIGl0LCBpdCBtYWtlcyB0aGUgZWxlbWVudCBhIGJsb2NraW5nIGVsZW1lbnRcbiAgICAgICAgICogd2hlbiB5b3UgYXJlIHVzaW5nIHRoZSBkcmFnIGdlc3R1cmUsIGl0IGlzIGEgZ29vZCBwcmFjdGljZSB0byBzZXQgdGhpcyB0cnVlXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tIb3Jpem9udGFsXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgZHJhZ0Jsb2NrSG9yaXpvbnRhbDogZmFsc2UsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNhbWUgYXMgYGRyYWdCbG9ja0hvcml6b250YWxgLCBidXQgZm9yIHZlcnRpY2FsIG1vdmVtZW50XG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnQmxvY2tWZXJ0aWNhbFxuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdCbG9ja1ZlcnRpY2FsOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhZ0xvY2tUb0F4aXMga2VlcHMgdGhlIGRyYWcgZ2VzdHVyZSBvbiB0aGUgYXhpcyB0aGF0IGl0IHN0YXJ0ZWQgb24sXG4gICAgICAgICAqIEl0IGRpc2FsbG93cyB2ZXJ0aWNhbCBkaXJlY3Rpb25zIGlmIHRoZSBpbml0aWFsIGRpcmVjdGlvbiB3YXMgaG9yaXpvbnRhbCwgYW5kIHZpY2UgdmVyc2EuXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkcmFnTG9ja1RvQXhpc1xuICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdMb2NrVG9BeGlzOiBmYWxzZSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZHJhZyBsb2NrIG9ubHkga2lja3MgaW4gd2hlbiBkaXN0YW5jZSA+IGRyYWdMb2NrTWluRGlzdGFuY2VcbiAgICAgICAgICogVGhpcyB3YXksIGxvY2tpbmcgb2NjdXJzIG9ubHkgd2hlbiB0aGUgZGlzdGFuY2UgaGFzIGJlY29tZSBsYXJnZSBlbm91Z2ggdG8gcmVsaWFibHkgZGV0ZXJtaW5lIHRoZSBkaXJlY3Rpb25cbiAgICAgICAgICogQHByb3BlcnR5IGRyYWdMb2NrTWluRGlzdGFuY2VcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMjVcbiAgICAgICAgICovXG4gICAgICAgIGRyYWdMb2NrTWluRGlzdGFuY2U6IDI1XG4gICAgICB9XG4gICAgfTtcbiAgfSkoJ2RyYWcnKTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHRyaWdnZXIgYSBzaW1wbGUgZ2VzdHVyZSBldmVudCwgc28geW91IGNhbiBkbyBhbnl0aGluZyBpbiB5b3VyIGhhbmRsZXIuXG4gICAqIG9ubHkgdXNhYmxlIGlmIHlvdSBrbm93IHdoYXQgeW91ciBkb2luZy4uLlxuICAgKlxuICAgKiBAY2xhc3MgR2VzdHVyZVxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IGdlc3R1cmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuR2VzdHVyZSA9IHtcbiAgICBuYW1lOiAnZ2VzdHVyZScsXG4gICAgaW5kZXg6IDEzMzcsXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gcmVsZWFzZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiBUb3VjaCBzdGF5cyBhdCB0aGUgc2FtZSBwbGFjZSBmb3IgeCB0aW1lXG4gICAqXG4gICAqIEBjbGFzcyBIb2xkXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgaG9sZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqL1xuICAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0aW1lcjtcblxuICAgIGZ1bmN0aW9uIGhvbGRHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGluc3Qub3B0aW9ucyxcbiAgICAgICAgICBjdXJyZW50ID0gRGV0ZWN0aW9uLmN1cnJlbnQ7XG5cbiAgICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgRVZFTlRfU1RBUlQ6XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBnZXN0dXJlIHNvIHdlIGNhbiBjaGVjayBpbiB0aGUgdGltZW91dCBpZiBpdCBzdGlsbCBpc1xuICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIC8vIHNldCB0aW1lciBhbmQgaWYgYWZ0ZXIgdGhlIHRpbWVvdXQgaXQgc3RpbGwgaXMgaG9sZCxcbiAgICAgICAgLy8gd2UgdHJpZ2dlciB0aGUgaG9sZCBldmVudFxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYoY3VycmVudCAmJiBjdXJyZW50Lm5hbWUgPT0gbmFtZSkge1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUsIGV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdGlvbnMuaG9sZFRpbWVvdXQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICBpZihldi5kaXN0YW5jZSA+IG9wdGlvbnMuaG9sZFRocmVzaG9sZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLkhvbGQgPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDEwLFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcm9wZXJ0eSBob2xkVGltZW91dFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCA1MDBcbiAgICAgICAgICovXG4gICAgICAgIGhvbGRUaW1lb3V0OiA1MDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1vdmVtZW50IGFsbG93ZWQgd2hpbGUgaG9sZGluZ1xuICAgICAgICAgKiBAcHJvcGVydHkgaG9sZFRocmVzaG9sZFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyXG4gICAgICAgICAqL1xuICAgICAgICBob2xkVGhyZXNob2xkOiAyXG4gICAgICB9LFxuICAgICAgaGFuZGxlcjogaG9sZEdlc3R1cmVcbiAgICB9O1xuICB9KSgnaG9sZCcpO1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogd2hlbiBhIHRvdWNoIGlzIGJlaW5nIHJlbGVhc2VkIGZyb20gdGhlIHBhZ2VcbiAgICpcbiAgICogQGNsYXNzIFJlbGVhc2VcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCByZWxlYXNlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlJlbGVhc2UgPSB7XG4gICAgbmFtZTogJ3JlbGVhc2UnLFxuICAgIGluZGV4OiBJbmZpbml0eSxcbiAgICBoYW5kbGVyOiBmdW5jdGlvbiByZWxlYXNlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG1vZHVsZSBnZXN0dXJlc1xuICAgKi9cbiAgLyoqXG4gICAqIHRyaWdnZXJzIHN3aXBlIGV2ZW50cyB3aGVuIHRoZSBlbmQgdmVsb2NpdHkgaXMgYWJvdmUgdGhlIHRocmVzaG9sZFxuICAgKiBmb3IgYmVzdCB1c2FnZSwgc2V0IGBwcmV2ZW50RGVmYXVsdGAgKG9uIHRoZSBkcmFnIGdlc3R1cmUpIHRvIGB0cnVlYFxuICAgKiBgYGBgXG4gICAqICBHZXN0dXJlRGV0ZWN0b3J0aW1lLm9uKFwiZHJhZ2xlZnQgc3dpcGVsZWZ0XCIsIGZ1bmN0aW9uKGV2KSB7XG4gICAqICAgIGNvbnNvbGUubG9nKGV2KTtcbiAgICogICAgZXYuZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgKiAgfSk7XG4gICAqIGBgYGBcbiAgICpcbiAgICogQGNsYXNzIFN3aXBlXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHN3aXBlbGVmdFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVyaWdodFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGV1cFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgc3dpcGVkb3duXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgR2VzdHVyZURldGVjdG9yLmdlc3R1cmVzLlN3aXBlID0ge1xuICAgIG5hbWU6ICdzd2lwZScsXG4gICAgaW5kZXg6IDQwLFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAvKipcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZU1pblRvdWNoZXNcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgKi9cbiAgICAgIHN3aXBlTWluVG91Y2hlczogMSxcblxuICAgICAgLyoqXG4gICAgICAgKiBAcHJvcGVydHkgc3dpcGVNYXhUb3VjaGVzXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICovXG4gICAgICBzd2lwZU1heFRvdWNoZXM6IDEsXG5cbiAgICAgIC8qKlxuICAgICAgICogaG9yaXpvbnRhbCBzd2lwZSB2ZWxvY2l0eVxuICAgICAgICogQHByb3BlcnR5IHN3aXBlVmVsb2NpdHlYXG4gICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICogQGRlZmF1bHQgMC42XG4gICAgICAgKi9cbiAgICAgIHN3aXBlVmVsb2NpdHlYOiAwLjYsXG5cbiAgICAgIC8qKlxuICAgICAgICogdmVydGljYWwgc3dpcGUgdmVsb2NpdHlcbiAgICAgICAqIEBwcm9wZXJ0eSBzd2lwZVZlbG9jaXR5WVxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqIEBkZWZhdWx0IDAuNlxuICAgICAgICovXG4gICAgICBzd2lwZVZlbG9jaXR5WTogMC42XG4gICAgfSxcblxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHN3aXBlR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1JFTEVBU0UpIHtcbiAgICAgICAgdmFyIHRvdWNoZXMgPSBldi50b3VjaGVzLmxlbmd0aCxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBpbnN0Lm9wdGlvbnM7XG5cbiAgICAgICAgLy8gbWF4IHRvdWNoZXNcbiAgICAgICAgaWYodG91Y2hlcyA8IG9wdGlvbnMuc3dpcGVNaW5Ub3VjaGVzIHx8XG4gICAgICAgICAgdG91Y2hlcyA+IG9wdGlvbnMuc3dpcGVNYXhUb3VjaGVzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgIGlmKGV2LnZlbG9jaXR5WCA+IG9wdGlvbnMuc3dpcGVWZWxvY2l0eVggfHxcbiAgICAgICAgICBldi52ZWxvY2l0eVkgPiBvcHRpb25zLnN3aXBlVmVsb2NpdHlZKSB7XG4gICAgICAgICAgLy8gdHJpZ2dlciBzd2lwZSBldmVudHNcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lLCBldik7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogU2luZ2xlIHRhcCBhbmQgYSBkb3VibGUgdGFwIG9uIGEgcGxhY2VcbiAgICpcbiAgICogQGNsYXNzIFRhcFxuICAgKiBAc3RhdGljXG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRhcFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIC8qKlxuICAgKiBAZXZlbnQgZG91YmxldGFwXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICovXG4gIChmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGhhc01vdmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB0YXBHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGluc3Qub3B0aW9ucyxcbiAgICAgICAgICBjdXJyZW50ID0gRGV0ZWN0aW9uLmN1cnJlbnQsXG4gICAgICAgICAgcHJldiA9IERldGVjdGlvbi5wcmV2aW91cyxcbiAgICAgICAgICBzaW5jZVByZXYsXG4gICAgICAgICAgZGlkRG91YmxlVGFwO1xuXG4gICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICBoYXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9NT1ZFOlxuICAgICAgICBoYXNNb3ZlZCA9IGhhc01vdmVkIHx8IChldi5kaXN0YW5jZSA+IG9wdGlvbnMudGFwTWF4RGlzdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFVkVOVF9FTkQ6XG4gICAgICAgIGlmKCFVdGlscy5pblN0cihldi5zcmNFdmVudC50eXBlLCAnY2FuY2VsJykgJiYgZXYuZGVsdGFUaW1lIDwgb3B0aW9ucy50YXBNYXhUaW1lICYmICFoYXNNb3ZlZCkge1xuICAgICAgICAgIC8vIHByZXZpb3VzIGdlc3R1cmUsIGZvciB0aGUgZG91YmxlIHRhcCBzaW5jZSB0aGVzZSBhcmUgdHdvIGRpZmZlcmVudCBnZXN0dXJlIGRldGVjdGlvbnNcbiAgICAgICAgICBzaW5jZVByZXYgPSBwcmV2ICYmIHByZXYubGFzdEV2ZW50ICYmIGV2LnRpbWVTdGFtcCAtIHByZXYubGFzdEV2ZW50LnRpbWVTdGFtcDtcbiAgICAgICAgICBkaWREb3VibGVUYXAgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIGRvdWJsZSB0YXBcbiAgICAgICAgICBpZihwcmV2ICYmIHByZXYubmFtZSA9PSBuYW1lICYmXG4gICAgICAgICAgICAoc2luY2VQcmV2ICYmIHNpbmNlUHJldiA8IG9wdGlvbnMuZG91YmxlVGFwSW50ZXJ2YWwpICYmXG4gICAgICAgICAgICBldi5kaXN0YW5jZSA8IG9wdGlvbnMuZG91YmxlVGFwRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcignZG91YmxldGFwJywgZXYpO1xuICAgICAgICAgICAgZGlkRG91YmxlVGFwID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkbyBhIHNpbmdsZSB0YXBcbiAgICAgICAgICBpZighZGlkRG91YmxlVGFwIHx8IG9wdGlvbnMudGFwQWx3YXlzKSB7XG4gICAgICAgICAgICBjdXJyZW50Lm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaW5zdC50cmlnZ2VyKGN1cnJlbnQubmFtZSwgZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBHZXN0dXJlRGV0ZWN0b3IuZ2VzdHVyZXMuVGFwID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGluZGV4OiAxMDAsXG4gICAgICBoYW5kbGVyOiB0YXBHZXN0dXJlLFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCB0aW1lIG9mIGEgdGFwLCB0aGlzIGlzIGZvciB0aGUgc2xvdyB0YXBwZXJzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0YXBNYXhUaW1lXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDI1MFxuICAgICAgICAgKi9cbiAgICAgICAgdGFwTWF4VGltZTogMjUwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggZGlzdGFuY2Ugb2YgbW92ZW1lbnQgb2YgYSB0YXAsIHRoaXMgaXMgZm9yIHRoZSBzbG93IHRhcHBlcnNcbiAgICAgICAgICogQHByb3BlcnR5IHRhcE1heERpc3RhbmNlXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICAgICAqL1xuICAgICAgICB0YXBNYXhEaXN0YW5jZTogMTAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFsd2F5cyB0cmlnZ2VyIHRoZSBgdGFwYCBldmVudCwgZXZlbiB3aGlsZSBkb3VibGUtdGFwcGluZ1xuICAgICAgICAgKiBAcHJvcGVydHkgdGFwQWx3YXlzXG4gICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0YXBBbHdheXM6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1heCBkaXN0YW5jZSBiZXR3ZWVuIHR3byB0YXBzXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBEaXN0YW5jZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAyMFxuICAgICAgICAgKi9cbiAgICAgICAgZG91YmxlVGFwRGlzdGFuY2U6IDIwLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtYXggdGltZSBiZXR3ZWVuIHR3byB0YXBzXG4gICAgICAgICAqIEBwcm9wZXJ0eSBkb3VibGVUYXBJbnRlcnZhbFxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAzMDBcbiAgICAgICAgICovXG4gICAgICAgIGRvdWJsZVRhcEludGVydmFsOiAzMDBcbiAgICAgIH1cbiAgICB9O1xuICB9KSgndGFwJyk7XG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgZ2VzdHVyZXNcbiAgICovXG4gIC8qKlxuICAgKiB3aGVuIGEgdG91Y2ggaXMgYmVpbmcgdG91Y2hlZCBhdCB0aGUgcGFnZVxuICAgKlxuICAgKiBAY2xhc3MgVG91Y2hcbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0b3VjaFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG4gIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5Ub3VjaCA9IHtcbiAgICBuYW1lOiAndG91Y2gnLFxuICAgIGluZGV4OiAtSW5maW5pdHksXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIC8qKlxuICAgICAgICogY2FsbCBwcmV2ZW50RGVmYXVsdCBhdCB0b3VjaHN0YXJ0LCBhbmQgbWFrZXMgdGhlIGVsZW1lbnQgYmxvY2tpbmcgYnkgZGlzYWJsaW5nIHRoZSBzY3JvbGxpbmcgb2YgdGhlIHBhZ2UsXG4gICAgICAgKiBidXQgaXQgaW1wcm92ZXMgZ2VzdHVyZXMgbGlrZSB0cmFuc2Zvcm1pbmcgYW5kIGRyYWdnaW5nLlxuICAgICAgICogYmUgY2FyZWZ1bCB3aXRoIHVzaW5nIHRoaXMsIGl0IGNhbiBiZSB2ZXJ5IGFubm95aW5nIGZvciB1c2VycyB0byBiZSBzdHVjayBvbiB0aGUgcGFnZVxuICAgICAgICogQHByb3BlcnR5IHByZXZlbnREZWZhdWx0XG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnREZWZhdWx0OiBmYWxzZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkaXNhYmxlIG1vdXNlIGV2ZW50cywgc28gb25seSB0b3VjaCAob3IgcGVuISkgaW5wdXQgdHJpZ2dlcnMgZXZlbnRzXG4gICAgICAgKiBAcHJvcGVydHkgcHJldmVudE1vdXNlXG4gICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnRNb3VzZTogZmFsc2VcbiAgICB9LFxuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIHRvdWNoR2VzdHVyZShldiwgaW5zdCkge1xuICAgICAgaWYoaW5zdC5vcHRpb25zLnByZXZlbnRNb3VzZSAmJiBldi5wb2ludGVyVHlwZSA9PSBQT0lOVEVSX01PVVNFKSB7XG4gICAgICAgIGV2LnN0b3BEZXRlY3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZihpbnN0Lm9wdGlvbnMucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgaWYoZXYuZXZlbnRUeXBlID09IEVWRU5UX1RPVUNIKSB7XG4gICAgICAgIGluc3QudHJpZ2dlcigndG91Y2gnLCBldik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbW9kdWxlIGdlc3R1cmVzXG4gICAqL1xuICAvKipcbiAgICogVXNlciB3YW50IHRvIHNjYWxlIG9yIHJvdGF0ZSB3aXRoIDIgZmluZ2Vyc1xuICAgKiBQcmV2ZW50aW5nIHRoZSBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3IgaXMgYSBnb29kIHdheSB0byBpbXByb3ZlIGZlZWwgYW5kIHdvcmtpbmcuIFRoaXMgY2FuIGJlIGRvbmUgd2l0aCB0aGVcbiAgICogYHByZXZlbnREZWZhdWx0YCBvcHRpb24uXG4gICAqXG4gICAqIEBjbGFzcyBUcmFuc2Zvcm1cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHRyYW5zZm9ybXN0YXJ0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCB0cmFuc2Zvcm1lbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHBpbmNoaW5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuICAvKipcbiAgICogQGV2ZW50IHBpbmNob3V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICAgKi9cbiAgLyoqXG4gICAqIEBldmVudCByb3RhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2XG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKi9cbiAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgdHJpZ2dlcmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1HZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEVWRU5UX1NUQVJUOlxuICAgICAgICB0cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfTU9WRTpcbiAgICAgICAgLy8gYXQgbGVhc3QgbXVsdGl0b3VjaFxuICAgICAgICBpZihldi50b3VjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2NhbGVUaHJlc2hvbGQgPSBNYXRoLmFicygxIC0gZXYuc2NhbGUpO1xuICAgICAgICB2YXIgcm90YXRpb25UaHJlc2hvbGQgPSBNYXRoLmFicyhldi5yb3RhdGlvbik7XG5cbiAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgIGlmKHNjYWxlVGhyZXNob2xkIDwgaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblNjYWxlICYmXG4gICAgICAgICAgcm90YXRpb25UaHJlc2hvbGQgPCBpbnN0Lm9wdGlvbnMudHJhbnNmb3JtTWluUm90YXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBhcmUgdHJhbnNmb3JtaW5nIVxuICAgICAgICBEZXRlY3Rpb24uY3VycmVudC5uYW1lID0gbmFtZTtcblxuICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICBpZighdHJpZ2dlcmVkKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnc3RhcnQnLCBldik7XG4gICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3QudHJpZ2dlcihuYW1lLCBldik7IC8vIGJhc2ljIHRyYW5zZm9ybSBldmVudFxuXG4gICAgICAgIC8vIHRyaWdnZXIgcm90YXRlIGV2ZW50XG4gICAgICAgIGlmKHJvdGF0aW9uVGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblJvdGF0aW9uKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdyb3RhdGUnLCBldik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmlnZ2VyIHBpbmNoIGV2ZW50XG4gICAgICAgIGlmKHNjYWxlVGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybU1pblNjYWxlKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKCdwaW5jaCcsIGV2KTtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJyArIChldi5zY2FsZSA8IDEgPyAnaW4nIDogJ291dCcpLCBldik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVZFTlRfUkVMRUFTRTpcbiAgICAgICAgaWYodHJpZ2dlcmVkICYmIGV2LmNoYW5nZWRMZW5ndGggPCAyKSB7XG4gICAgICAgICAgaW5zdC50cmlnZ2VyKG5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIEdlc3R1cmVEZXRlY3Rvci5nZXN0dXJlcy5UcmFuc2Zvcm0gPSB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgaW5kZXg6IDQ1LFxuICAgICAgZGVmYXVsdHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1pbmltYWwgc2NhbGUgZmFjdG9yLCBubyBzY2FsZSBpcyAxLCB6b29taW4gaXMgdG8gMCBhbmQgem9vbW91dCB1bnRpbCBoaWdoZXIgdGhlbiAxXG4gICAgICAgICAqIEBwcm9wZXJ0eSB0cmFuc2Zvcm1NaW5TY2FsZVxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwLjAxXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2Zvcm1NaW5TY2FsZTogMC4wMSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAgICAgKiBAcHJvcGVydHkgdHJhbnNmb3JtTWluUm90YXRpb25cbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNmb3JtTWluUm90YXRpb246IDFcbiAgICAgIH0sXG5cbiAgICAgIGhhbmRsZXI6IHRyYW5zZm9ybUdlc3R1cmVcbiAgICB9O1xuICB9KSgndHJhbnNmb3JtJyk7XG5cbmV4cG9ydCBkZWZhdWx0IEdlc3R1cmVEZXRlY3RvcjtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmxldCByZWFkeU1hcCwgcXVldWVNYXA7XG5cbmZ1bmN0aW9uIGlzQ29udGVudFJlYWR5KGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xuICB9XG4gIHJldHVybiByZWFkeU1hcC5oYXMoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRSZWFkeShlbGVtZW50KSB7XG4gIHJlYWR5TWFwLnNldChlbGVtZW50LCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2FsbGJhY2soZWxlbWVudCwgZm4pIHtcbiAgaWYgKCFxdWV1ZU1hcC5oYXMoZWxlbWVudCkpIHtcbiAgICBxdWV1ZU1hcC5zZXQoZWxlbWVudCwgW10pO1xuICB9XG4gIHF1ZXVlTWFwLmdldChlbGVtZW50KS5wdXNoKGZuKTtcbn1cblxuZnVuY3Rpb24gY29uc3VtZVF1ZXVlKGVsZW1lbnQpIHtcbiAgY29uc3QgY2FsbGJhY2tzID0gcXVldWVNYXAuZ2V0KGVsZW1lbnQsIFtdKSB8fCBbXTtcbiAgcXVldWVNYXAuZGVsZXRlKGVsZW1lbnQpO1xuICBjYWxsYmFja3MuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGVudFJlYWR5KGVsZW1lbnQsIGZuID0gKCkgPT4ge30pIHtcbiAgaWYgKHJlYWR5TWFwID09PSB1bmRlZmluZWQpIHtcbiAgICByZWFkeU1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcXVldWVNYXAgPSBuZXcgV2Vha01hcCgpO1xuICB9XG5cbiAgYWRkQ2FsbGJhY2soZWxlbWVudCwgZm4pO1xuXG4gIGlmIChpc0NvbnRlbnRSZWFkeShlbGVtZW50KSkge1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGNoYW5nZXMgPT4ge1xuICAgIHNldENvbnRlbnRSZWFkeShlbGVtZW50KTtcbiAgICBjb25zdW1lUXVldWUoZWxlbWVudCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIGNoYXJhY3RlckRhdGE6IHRydWV9KTtcblxuICAvLyBmYWlsYmFjayBmb3IgZWxlbWVudHMgaGFzIGVtcHR5IGNvbnRlbnQuXG4gIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgc2V0Q29udGVudFJlYWR5KGVsZW1lbnQpO1xuICAgIGNvbnN1bWVRdWV1ZShlbGVtZW50KTtcbiAgfSk7XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5jbGFzcyBUb2FzdFF1ZXVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICB9XG5cbiAgYWRkKGZuLCBwcm9taXNlKSB7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKGZuKTtcblxuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgc2V0SW1tZWRpYXRlKHRoaXMucXVldWVbMF0pO1xuICAgIH1cblxuICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnF1ZXVlWzBdLCAxMDAwLzMwKTsgLy8gQXBwbHkgc29tZSB2aXN1YWwgZGVsYXlcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgVG9hc3RRdWV1ZSgpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi9jb250ZW50LXJlYWR5JztcbmltcG9ydCBUb2FzdFF1ZXVlIGZyb20gJy4vaW50ZXJuYWwvdG9hc3QtcXVldWUnO1xuXG5jb25zdCBfc2V0QXR0cmlidXRlcyA9IChlbGVtZW50LCBvcHRpb25zKSA9PiB7XG4gIFsnaWQnLCAnY2xhc3MnLCAnYW5pbWF0aW9uJ11cbiAgICAuZm9yRWFjaChhID0+IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoYSkgJiYgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYSwgb3B0aW9uc1thXSkpO1xuXG4gIGlmIChvcHRpb25zLm1vZGlmaWVyKSB7XG4gICAgdXRpbC5hZGRNb2RpZmllcihlbGVtZW50LCBvcHRpb25zLm1vZGlmaWVyKTtcbiAgfVxufTtcblxuY29uc3QgX25vcm1hbGl6ZUFyZ3VtZW50cyA9IChtZXNzYWdlLCBvcHRpb25zID0ge30sIGRlZmF1bHRzID0ge30pID0+IHtcbiAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycgPyAob3B0aW9ucy5tZXNzYWdlID0gbWVzc2FnZSkgOiAob3B0aW9ucyA9IG1lc3NhZ2UpO1xuICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMubWVzc2FnZSAmJiAhb3B0aW9ucy5tZXNzYWdlSFRNTCkge1xuICAgIHV0aWwudGhyb3coJ05vdGlmaWNhdGlvbnMgbXVzdCBjb250YWluIGEgbWVzc2FnZScpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2J1dHRvbkxhYmVscycpIHx8IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2J1dHRvbkxhYmVsJykpIHtcbiAgICBvcHRpb25zLmJ1dHRvbkxhYmVscyA9IG9wdGlvbnMuYnV0dG9uTGFiZWxzIHx8IG9wdGlvbnMuYnV0dG9uTGFiZWw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuYnV0dG9uTGFiZWxzKSkge1xuICAgICAgb3B0aW9ucy5idXR0b25MYWJlbHMgPSBbb3B0aW9ucy5idXR0b25MYWJlbHMgfHwgJyddXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHV0aWwuZXh0ZW5kKHtcbiAgICAgIGNvbXBpbGU6IHBhcmFtID0+IHBhcmFtLFxuICAgICAgY2FsbGJhY2s6IHBhcmFtID0+IHBhcmFtLFxuICAgICAgYW5pbWF0aW9uOiAnZGVmYXVsdCcsXG4gICAgICBjYW5jZWxhYmxlOiBmYWxzZSxcbiAgICAgIHByaW1hcnlCdXR0b25JbmRleDogKG9wdGlvbnMuYnV0dG9uTGFiZWxzIHx8IGRlZmF1bHRzLmJ1dHRvbkxhYmVscyB8fCBbXSkubGVuZ3RoIC0gMVxuICAgIH0sIGRlZmF1bHRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQG9iamVjdCBvbnMubm90aWZpY2F0aW9uXG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvbm90aWZpY2F0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFV0aWxpdHkgbWV0aG9kcyB0byBjcmVhdGUgZGlmZmVyZW50IGtpbmRzIG9mIG5vdGlmaWNhdGlvbnMuIFRoZXJlIGFyZSB0aHJlZSBtZXRob2RzIGF2YWlsYWJsZTpcbiAqXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24uY29uZmlybSgpYFxuICogICAgICogYG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KClgXG4gKiAgICAgKiBgb25zLm5vdGlmaWNhdGlvbi50b2FzdCgpYFxuICpcbiAqICAgICBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBkaWFsb2cgb24gQW5kcm9pZCBkZXZpY2VzLlxuICogICBbL2VuXVxuICogICBbamFd44GE44GP44Gk44GL44Gu56iu6aGe44Gu44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44KS5L2c5oiQ44GZ44KL44Gf44KB44Gu44Om44O844OG44Kj44Oq44OG44Kj44Oh44K944OD44OJ44KS5Y+O44KB44Gf44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdIZWxsbywgd29ybGQhJyk7XG4gKlxuICogb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKCdBcmUgeW91IHJlYWR5PycpXG4gKiAgIC50aGVuKFxuICogICAgIGZ1bmN0aW9uKGFuc3dlcikge1xuICogICAgICAgaWYgKGFuc3dlciA9PT0gMSkge1xuICogICAgICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KCdMZXRcXCdzIGdvIScpO1xuICogICAgICAgfVxuICogICAgIH1cbiAqICAgKTtcbiAqXG4gKiBvbnMubm90aWZpY2F0aW9uLnByb21wdCgnSG93IG9sZCBhcmUgPycpXG4gKiAgIC50aGVuKFxuICogICAgIGZ1bmN0aW9uKGFnZSkge1xuICogICAgICAgb25zLm5vdGlmaWNhdGlvbi5hbGVydCgnWW91IGFyZSAnICsgYWdlICsgJyB5ZWFycyBvbGQuJyk7XG4gKiAgICAgfVxuICogICApO1xuICovXG5jb25zdCBub3RpZmljYXRpb24gPSB7fTtcblxubm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyA9ICguLi5wYXJhbXMpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICBjb25zdCBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyguLi5wYXJhbXMpO1xuICB1dGlsLmNoZWNrTWlzc2luZ0ltcG9ydCgnQWxlcnREaWFsb2cnLCAnQWxlcnREaWFsb2dCdXR0b24nKTtcblxuICAvLyBQcm9tcHQgaW5wdXQgc3RyaW5nXG4gIGxldCBpbnB1dFN0cmluZyA9ICcnO1xuICBpZiAob3B0aW9ucy5pc1Byb21wdCkge1xuICAgIGlucHV0U3RyaW5nID0gYFxuICAgICAgPGlucHV0XG4gICAgICAgIGNsYXNzPVwidGV4dC1pbnB1dCB0ZXh0LWlucHV0LS11bmRlcmJhclwiXG4gICAgICAgIHR5cGU9XCIke29wdGlvbnMuaW5wdXRUeXBlIHx8ICd0ZXh0J31cIlxuICAgICAgICBwbGFjZWhvbGRlcj1cIiR7b3B0aW9ucy5wbGFjZWhvbGRlciB8fCAnJ31cIlxuICAgICAgICB2YWx1ZT1cIiR7b3B0aW9ucy5kZWZhdWx0VmFsdWUgfHwgJyd9XCJcbiAgICAgICAgc3R5bGU9XCJ3aWR0aDogMTAwJTsgbWFyZ2luLXRvcDogMTBweDtcIlxuICAgICAgLz5cbiAgICBgO1xuICB9XG5cbiAgLy8gQnV0dG9ucyBzdHJpbmdcbiAgbGV0IGJ1dHRvbnMgPSAnJztcbiAgb3B0aW9ucy5idXR0b25MYWJlbHMuZm9yRWFjaCgobGFiZWwsIGluZGV4KSA9PiB7XG4gICAgYnV0dG9ucyArPSBgXG4gICAgICA8b25zLWFsZXJ0LWRpYWxvZy1idXR0b25cbiAgICAgICAgY2xhc3M9XCJcbiAgICAgICAgICAke2luZGV4ID09PSBvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleCA/ICcgYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsJyA6ICcnfVxuICAgICAgICAgICR7b3B0aW9ucy5idXR0b25MYWJlbHMubGVuZ3RoIDw9IDIgPyAnIGFsZXJ0LWRpYWxvZy1idXR0b24tLXJvd2Zvb3RlcicgOiAnJ31cbiAgICAgICAgXCJcbiAgICAgICAgc3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmU7XCI+XG4gICAgICAgICR7bGFiZWx9XG4gICAgICA8L29ucy1hbGVydC1kaWFsb2ctYnV0dG9uPlxuICAgIGA7XG4gIH0pO1xuXG4gIC8vIERpYWxvZyBFbGVtZW50XG4gIGxldCBlbCA9IHt9O1xuICBjb25zdCBfZGVzdHJveURpYWxvZyA9ICgpID0+IHtcbiAgICBpZiAoZWwuZGlhbG9nLm9uRGlhbG9nQ2FuY2VsKSB7XG4gICAgICBlbC5kaWFsb2cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlhbG9nLWNhbmNlbCcsIGVsLmRpYWxvZy5vbkRpYWxvZ0NhbmNlbCk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoZWwpLmZvckVhY2goa2V5ID0+IGRlbGV0ZSBlbFtrZXldKTtcbiAgICBlbCA9IG51bGw7XG5cbiAgICBpZiAob3B0aW9ucy5kZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbnMuZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcblxuICBlbC5kaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvbnMtYWxlcnQtZGlhbG9nJyk7XG4gIGVsLmRpYWxvZy5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1tYXNrXCJcbiAgICAgIHN0eWxlPVwiXG4gICAgICAgICR7b3B0aW9ucy5tYXNrQ29sb3IgPyAnYmFja2dyb3VuZC1jb2xvcjogJyArIG9wdGlvbnMubWFza0NvbG9yIDogJyd9XG4gICAgICBcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRhaW5lclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLXRpdGxlXCI+XG4gICAgICAgICAgJHtvcHRpb25zLnRpdGxlIHx8ICcnfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gICAgICAgICAgJHtvcHRpb25zLm1lc3NhZ2UgfHwgb3B0aW9ucy5tZXNzYWdlSFRNTH1cbiAgICAgICAgICAke2lucHV0U3RyaW5nfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIlxuICAgICAgICAgIGFsZXJ0LWRpYWxvZy1mb290ZXJcbiAgICAgICAgICAke29wdGlvbnMuYnV0dG9uTGFiZWxzLmxlbmd0aCA8PSAyID8gJyBhbGVydC1kaWFsb2ctZm9vdGVyLS1yb3dmb290ZXInIDogJyd9XG4gICAgICAgIFwiPlxuICAgICAgICAgICR7YnV0dG9uc31cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYDtcbiAgY29udGVudFJlYWR5KGVsLmRpYWxvZyk7XG5cbiAgLy8gU2V0IGF0dHJpYnV0ZXNcbiAgX3NldEF0dHJpYnV0ZXMoZWwuZGlhbG9nLCBvcHRpb25zKTtcblxuICAvLyBQcm9tcHQgZXZlbnRzXG4gIGlmIChvcHRpb25zLmlzUHJvbXB0ICYmIG9wdGlvbnMuc3VibWl0T25FbnRlcikge1xuICAgIGVsLmlucHV0ID0gZWwuZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoJy50ZXh0LWlucHV0Jyk7XG4gICAgZWwuaW5wdXQub25rZXlwcmVzcyA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAxMykge1xuICAgICAgICBlbC5kaWFsb2cuaGlkZSgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZSA9IGVsLmlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICBfZGVzdHJveURpYWxvZygpO1xuICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQnV0dG9uIGV2ZW50c1xuICBlbC5mb290ZXIgPSBlbC5kaWFsb2cucXVlcnlTZWxlY3RvcignLmFsZXJ0LWRpYWxvZy1mb290ZXInKTtcbiAgdXRpbC5hcnJheUZyb20oZWwuZGlhbG9nLnF1ZXJ5U2VsZWN0b3JBbGwoJy5hbGVydC1kaWFsb2ctYnV0dG9uJykpLmZvckVhY2goKGJ1dHRvbkVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgYnV0dG9uRWxlbWVudC5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBlbC5kaWFsb2cuaGlkZSgpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgIGxldCByZXNvbHZlVmFsdWUgPSBpbmRleDtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaXNQcm9tcHQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlVmFsdWUgPSBpbmRleCA9PT0gb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXggPyBlbC5pbnB1dC52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWwuZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICAgICAgICBfZGVzdHJveURpYWxvZygpO1xuICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzb2x2ZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZWwuZm9vdGVyLmFwcGVuZENoaWxkKGJ1dHRvbkVsZW1lbnQpO1xuICB9KTtcblxuICAvLyBDYW5jZWwgZXZlbnRzXG4gIGlmIChvcHRpb25zLmNhbmNlbGFibGUpIHtcbiAgICBlbC5kaWFsb2cuY2FuY2VsYWJsZSA9IHRydWU7XG4gICAgZWwuZGlhbG9nLm9uRGlhbG9nQ2FuY2VsID0gKCkgPT4ge1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgZWwuZGlhbG9nLnJlbW92ZSgpO1xuICAgICAgICBfZGVzdHJveURpYWxvZygpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNvbHZlVmFsdWUgPSBvcHRpb25zLmlzUHJvbXB0ID8gbnVsbCA6IC0xO1xuICAgICAgb3B0aW9ucy5jYWxsYmFjayhyZXNvbHZlVmFsdWUpO1xuICAgICAgcmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xuICAgIH07XG4gICAgZWwuZGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoJ2RpYWxvZy1jYW5jZWwnLCBlbC5kaWFsb2cub25EaWFsb2dDYW5jZWwsIGZhbHNlKTtcbiAgfVxuXG4gIC8vIFNob3cgZGlhbG9nXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwuZGlhbG9nKTtcbiAgb3B0aW9ucy5jb21waWxlKGVsLmRpYWxvZyk7XG4gIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgZWwuZGlhbG9nLnNob3coKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoZWwuaW5wdXQgJiYgb3B0aW9ucy5pc1Byb21wdCAmJiBvcHRpb25zLmF1dG9mb2N1cykge1xuICAgICAgICAgIGNvbnN0IHN0ckxlbmd0aCA9IGVsLmlucHV0LnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICBlbC5pbnB1dC5mb2N1cygpO1xuICAgICAgICAgIGVsLmlucHV0LnNldFNlbGVjdGlvblJhbmdlKHN0ckxlbmd0aCwgc3RyTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQG1ldGhvZCBhbGVydFxuICogQHNpZ25hdHVyZSBhbGVydChtZXNzYWdlIFssIG9wdGlvbnNdIHwgb3B0aW9ucylcbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1XaWxsIHJlc29sdmUgdG8gdGhlIGluZGV4IG9mIHRoZSBidXR0b24gdGhhdCB3YXMgcHJlc3NlZCBvciBgLTFgIHdoZW4gY2FuY2VsZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICogICBbZW5dTm90aWZpY2F0aW9uIG1lc3NhZ2UuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwgYnV0IGlmIGl0J3Mgbm90IGRlZmluZWQgZWl0aGVyIGBvcHRpb25zLm1lc3NhZ2VgIG9yIGBvcHRpb25zLm1lc3NhZ2VIVE1MYCBtdXN0IGJlIGRlZmluZWQgaW5zdGVhZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2VdXG4gKiAgIFtlbl1Ob3RpZmljYXRpb24gbWVzc2FnZS5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gr6KGo56S644GZ44KL5paH5a2X5YiX44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlSFRNTF1cbiAqICAgW2VuXU5vdGlmaWNhdGlvbiBtZXNzYWdlIGluIEhUTUwuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBq+ihqOekuuOBmeOCi0hUTUzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmcgfCBBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgXCJPS1wiYC5bL2VuXVxuICogICBbamFd56K66KqN44Oc44K/44Oz44Gu44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJPS1wi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcmltYXJ5QnV0dG9uSW5kZXhdXG4gKiAgIFtlbl1JbmRleCBvZiBwcmltYXJ5IGJ1dHRvbi4gRGVmYXVsdCBpcyB0aGUgbGFzdCBvbmUuWy9lbl1cbiAqICAgW2phXeODl+ODqeOCpOODnuODquODnOOCv+ODs+OBruOCpOODs+ODh+ODg+OCr+OCueOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBryAwIOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNhbmNlbGFibGVdXG4gKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgY2FuY2VsYWJsZSBvciBub3QuIERlZmF1bHQgaXMgYGZhbHNlYC4gSWYgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIGl0IGNhbiBiZSBjbG9zZWQgYnkgY2xpY2tpbmcgdGhlIGJhY2tncm91bmQgb3IgcHJlc3NpbmcgdGhlIEFuZHJvaWQgYmFjayBidXR0b24uWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+WPr+iDveOBi+OBqeOBhuOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgbm9uZWAgYW5kIGBmYWRlYC4gRGVmYXVsdCBpcyBgZmFkZWAuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWRdXG4gKiAgIFtlbl1UaGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCdzIElELlsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n6KaB57Sg44GuSUTjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNsYXNzXVxuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGVsZW1lbnQncyBjbGFzcy5bL2VuXVxuICogICBbamFdb25zLWFsZXJ0LWRpYWxvZ+imgee0oOOBrmNsYXNz44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50aXRsZV1cbiAqICAgW2VuXURpYWxvZyB0aXRsZS4gRGVmYXVsdCBpcyBgXCJBbGVydFwiYC5bL2VuXVxuICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu5LiK6YOo44Gr6KGo56S644GZ44KL44K/44Kk44OI44Or44KS5oyH5a6a44GX44G+44GZ44CCXCJBbGVydFwi44GM44OH44OV44Kp44Or44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tb2RpZmllcl1cbiAqICAgW2VuXU1vZGlmaWVyIGZvciB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga5tb2RpZmllcuWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWFza0NvbG9yXVxuICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQgbWFzay4gRGVmYXVsdCBpcyBcInJnYmEoMCwgMCwgMCwgMC4yKVwiIChcInJnYmEoMCwgMCwgMCwgMC4zKVwiIGZvciBNYXRlcmlhbCkuWy9lbl1cbiAqICAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFmdGVyIGRpYWxvZyBoYXMgYmVlbiBjbG9zZWQuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmWieOBmOOCieOCjOOBn+aZguOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYW4gYWxlcnQgZGlhbG9nIHRvIHNob3cgdGhlIHVzZXIgYSBtZXNzYWdlLlxuICpcbiAqICAgICBUaGUgY29udGVudCBvZiB0aGUgbWVzc2FnZSBjYW4gYmUgZWl0aGVyIHNpbXBsZSB0ZXh0IG9yIEhUTUwuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmFsZXJ0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24uYWxlcnQob3B0aW9ucyk7XG4gKiAgICAgYGBgXG4gKlxuICogICAgIE11c3Qgc3BlY2lmeSBlaXRoZXIgYG1lc3NhZ2VgIG9yIGBtZXNzYWdlSFRNTGAuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjg6bjg7zjgrbjg7zjgbjjg6Hjg4Pjgrvjg7zjgrjjgpLopovjgZvjgovjgZ/jgoHjga7jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJcbiAqICAgICDooajnpLrjgZnjgovjg6Hjg4Pjgrvjg7zjgrjjga/jgIHjg4bjgq3jgrnjg4jjgYvjgoLjgZfjgY/jga9IVE1M44KS5oyH5a6a44Gn44GN44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxuICogICBbL2phXVxuICovXG5ub3RpZmljYXRpb24uYWxlcnQgPSAobWVzc2FnZSwgb3B0aW9ucykgPT5cbiAgbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgYnV0dG9uTGFiZWxzOiBbJ09LJ10sXG4gICAgdGl0bGU6ICdBbGVydCdcbiAgfSk7XG5cbi8qKlxuICogQG1ldGhvZCBjb25maXJtXG4gKiBAc2lnbmF0dXJlIGNvbmZpcm0obWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHRvIHRoZSBpbmRleCBvZiB0aGUgYnV0dG9uIHRoYXQgd2FzIHByZXNzZWQgb3IgYC0xYCB3aGVuIGNhbmNlbGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXU5vdGlmaWNhdGlvbiBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMuYnV0dG9uTGFiZWxzXVxuICogICBbZW5dTGFiZWxzIGZvciB0aGUgYnV0dG9ucy4gRGVmYXVsdCBpcyBgW1wiQ2FuY2VsXCIsIFwiT0tcIl1gLlsvZW5dXG4gKiAgIFtqYV3jg5zjgr/jg7Pjga7jg6njg5njg6vjga7phY3liJfjgpLmjIflrprjgZfjgb7jgZnjgIJbXCJDYW5jZWxcIiwgXCJPS1wiXeOBjOODh+ODleOCqeODq+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpbWFyeUJ1dHRvbkluZGV4XVxuICogICBbZW5dSW5kZXggb2YgcHJpbWFyeSBidXR0b24uIERlZmF1bHQgaXMgdGhlIGxhc3Qgb25lLlsvZW5dXG4gKiAgIFtqYV3jg5fjg6njgqTjg57jg6rjg5zjgr/jg7Pjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga8gMSDjgafjgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgZGlhbG9nIHRvIGFzayB0aGUgdXNlciBmb3IgY29uZmlybWF0aW9uLiBFeHRlbmRzIGBhbGVydCgpYCBwYXJhbWV0ZXJzLlxuICogICAgIFRoZSBkZWZhdWx0IGJ1dHRvbiBsYWJlbHMgYXJlIGBcIkNhbmNlbFwiYCBhbmQgYFwiT0tcImAgYnV0IHRoZXkgY2FuIGJlIGN1c3RvbWl6ZWQuXG4gKlxuICogICAgIEl0IGNhbiBiZSBjYWxsZWQgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICpcbiAqICAgICBgYGBcbiAqICAgICBvbnMubm90aWZpY2F0aW9uLmNvbmZpcm0obWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi5jb25maXJtKG9wdGlvbnMpO1xuICogICAgIGBgYFxuICpcbiAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIGBtZXNzYWdlYCBvciBgbWVzc2FnZUhUTUxgLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Om44O844K244Gr56K66KqN44KS5L+D44GZ44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCXG4gKiAgICAg44OH44Kq44Or44Go44Gu44Oc44K/44Oz44Op44OZ44Or44Gv44CBXCJDYW5jZWxcIuOBqFwiT0tcIuOBp+OBmeOBjOOAgeOBk+OCjOOBr+OBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBp+OCq+OCueOCv+ODnuOCpOOCuuOBp+OBjeOBvuOBmeOAglxuICogICAgIOOBk+OBruODoeOCveODg+ODieOBruW8leaVsOOBq+OBr+OAgW9wdGlvbnMubWVzc2FnZeOCguOBl+OBj+OBr29wdGlvbnMubWVzc2FnZUhUTUzjga7jganjgaHjgonjgYvjgpLlv4XjgZrmjIflrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqL1xubm90aWZpY2F0aW9uLmNvbmZpcm0gPSAobWVzc2FnZSwgb3B0aW9ucykgPT5cbiAgbm90aWZpY2F0aW9uLl9jcmVhdGVBbGVydERpYWxvZyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgYnV0dG9uTGFiZWxzOiBbJ0NhbmNlbCcsICdPSyddLFxuICAgIHRpdGxlOiAnQ29uZmlybSdcbiAgfSk7XG5cbi8qKlxuICogQG1ldGhvZCBwcm9tcHRcbiAqIEBzaWduYXR1cmUgcHJvbXB0KG1lc3NhZ2UgWywgb3B0aW9uc10gfCBvcHRpb25zKVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqICAgW2VuXU5vdGlmaWNhdGlvbiBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIGVpdGhlciBgb3B0aW9ucy5tZXNzYWdlYCBvciBgb3B0aW9ucy5tZXNzYWdlSFRNTGAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHRvIHRoZSBpbnB1dCB2YWx1ZSB3aGVuIHRoZSBkaWFsb2cgaXMgY2xvc2VkIG9yIGBudWxsYCB3aGVuIGNhbmNlbGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZyB8IEFycmF5fSBbb3B0aW9ucy5idXR0b25MYWJlbHNdXG4gKiAgIFtlbl1MYWJlbHMgZm9yIHRoZSBidXR0b25zLiBEZWZhdWx0IGlzIGBcIk9LXCJgLlsvZW5dXG4gKiAgIFtqYV3norroqo3jg5zjgr/jg7Pjga7jg6njg5njg6vjgpLmjIflrprjgZfjgb7jgZnjgIJcIk9LXCLjgYzjg4fjg5Xjgqnjg6vjg4jjgafjgZnjgIJbL2phXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByaW1hcnlCdXR0b25JbmRleF1cbiAqICAgW2VuXUluZGV4IG9mIHByaW1hcnkgYnV0dG9uLiBEZWZhdWx0IGlzIHRoZSBsYXN0IG9uZS5bL2VuXVxuICogICBbamFd44OX44Op44Kk44Oe44Oq44Oc44K/44Oz44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvIDAg44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wbGFjZWhvbGRlcl1cbiAqICAgW2VuXVBsYWNlaG9sZGVyIGZvciB0aGUgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFd44OG44Kt44K544OI5qyE44Gu44OX44Os44O844K544Ob44Or44OA44Gr6KGo56S644GZ44KL44OG44Kt44K544OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5kZWZhdWx0VmFsdWVdXG4gKiAgIFtlbl1EZWZhdWx0IHZhbHVlIGZvciB0aGUgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFd44OG44Kt44K544OI5qyE44Gu44OH44OV44Kp44Or44OI44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pbnB1dFR5cGVdXG4gKiAgIFtlbl1UeXBlIG9mIHRoZSBpbnB1dCBlbGVtZW50IChgcGFzc3dvcmRgLCBgZGF0ZWAuLi4pLiBEZWZhdWx0IGlzIGB0ZXh0YC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b2ZvY3VzXVxuICogICBbZW5dQXV0b2ZvY3VzIHRoZSBpbnB1dCBlbGVtZW50LiBEZWZhdWx0IGlzIGB0cnVlYC4gSW4gQ29yZG92YSwgYEtleWJvYXJkRGlzcGxheVJlcXVpcmVzVXNlckFjdGlvbmAgaW4gYGNvbmZpZy54bWxgIG11c3QgYmUgYGZhbHNlYCB0byBhY3RpdmF0ZSB0aGlzIGZlYXR1cmUuWy9lbl1cbiAqICAgW2phXWlucHV06KaB57Sg44Gr6Ieq5YuV55qE44Gr44OV44Kp44O844Kr44K544GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvdHJ1ZeOBp+OBmeOAgkNvcmRvdmHnkrDlooPjgafjga/jgIHjgZPjga7mqZ/og73jgpLmnInlirnjgavjgZnjgovjgZ/jgoHjgavjga8gYGNvbmZpZy54bWxgIOOBpyBgS2V5Ym9hcmREaXNwbGF5UmVxdWlyZXNVc2VyQWN0aW9uYCDjgpIgYGZhbHNlYCDjgavoqK3lrprjgZnjgovlv4XopoHjgYzjgYLjgorjgb7jgZnjgIJbL2phXVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zdWJtaXRPbkVudGVyXVxuICogICBbZW5dU3VibWl0IGF1dG9tYXRpY2FsbHkgd2hlbiBlbnRlciBpcyBwcmVzc2VkLiBEZWZhdWx0IGlzIGB0cnVlYC5bL2VuXVxuICogICBbamFdRW50ZXLjgYzmirzjgZXjgozjgZ/pmpvjgavjgZ3jga5mb3Jt44KSc3VibWl044GZ44KL44GL44Gp44GG44GL44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvdHJ1ZeOBp+OBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIERpc3BsYXkgYSBkaWFsb2cgd2l0aCBhIHByb21wdCB0byBhc2sgdGhlIHVzZXIgYSBxdWVzdGlvbi4gRXh0ZW5kcyBgYWxlcnQoKWAgcGFyYW1ldGVycy5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKlxuICogICAgIGBgYFxuICogICAgIG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KG1lc3NhZ2UsIG9wdGlvbnMpO1xuICogICAgIG9ucy5ub3RpZmljYXRpb24ucHJvbXB0KG9wdGlvbnMpO1xuICogICAgIGBgYFxuICpcbiAqICAgICBNdXN0IHNwZWNpZnkgZWl0aGVyIGBtZXNzYWdlYCBvciBgbWVzc2FnZUhUTUxgLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Om44O844K244O844Gr5YWl5Yqb44KS5L+D44GZ44OA44Kk44Ki44Ot44Kw44KS6KGo56S644GX44G+44GZ44CCXG4gKiAgICAg44GT44Gu44Oh44K944OD44OJ44Gu5byV5pWw44Gr44Gv44CBb3B0aW9ucy5tZXNzYWdl44KC44GX44GP44Gvb3B0aW9ucy5tZXNzYWdlSFRNTOOBruOBqeOBoeOCieOBi+OCkuW/heOBmuaMh+WumuOBmeOCi+W/heimgeOBjOOBguOCiuOBvuOBmeOAglxuICogICBbL2phXVxuICovXG5ub3RpZmljYXRpb24ucHJvbXB0ID0gKG1lc3NhZ2UsIG9wdGlvbnMpID0+XG4gIG5vdGlmaWNhdGlvbi5fY3JlYXRlQWxlcnREaWFsb2cobWVzc2FnZSwgb3B0aW9ucywge1xuICAgIGJ1dHRvbkxhYmVsczogWydPSyddLFxuICAgIHRpdGxlOiAnQWxlcnQnLFxuICAgIGlzUHJvbXB0OiB0cnVlLFxuICAgIGF1dG9mb2N1czogdHJ1ZSxcbiAgICBzdWJtaXRPbkVudGVyOiB0cnVlXG4gIH0pO1xuXG4vKipcbiAqIEBtZXRob2QgdG9hc3RcbiAqIEBzaWduYXR1cmUgdG9hc3QobWVzc2FnZSBbLCBvcHRpb25zXSB8IG9wdGlvbnMpXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHdoZW4gdGhlIHRvYXN0IGlzIGhpZGRlbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiAgIFtlbl1Ub2FzdCBtZXNzYWdlLiBUaGlzIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGJ1dCBpZiBpdCdzIG5vdCBkZWZpbmVkIHRoZW4gYG9wdGlvbnMubWVzc2FnZWAgbXVzdCBiZSBkZWZpbmVkIGluc3RlYWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5tZXNzYWdlXVxuICogICBbZW5dTm90aWZpY2F0aW9uIG1lc3NhZ2UuWy9lbl1cbiAqICAgW2phXeODiOODvOOCueODiOOBq+ihqOekuuOBmeOCi+aWh+Wtl+WIl+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYnV0dG9uTGFiZWxdXG4gKiAgIFtlbl1MYWJlbCBmb3IgdGhlIGJ1dHRvbi5bL2VuXVxuICogICBbamFd56K66KqN44Oc44K/44Oz44Gu44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBub25lYCwgYGZhZGVgLCBgYXNjZW5kYCwgYGxpZnRgIGFuZCBgZmFsbGAuIERlZmF1bHQgaXMgYGFzY2VuZGAgZm9yIEFuZHJvaWQgYW5kIGBsaWZ0YCBmb3IgaU9TLlsvZW5dXG4gKiAgIFtqYV3jg4jjg7zjgrnjg4jjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCIsIFwiYXNjZW5kXCIsIFwibGlmdFwiLCBcImZhbGxcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGltZW91dF1cbiAqICAgW2VuXU51bWJlciBvZiBtaWxpc2Vjb25kcyB3aGVyZSB0aGUgdG9hc3QgaXMgdmlzaWJsZSBiZWZvcmUgaGlkaW5nIGF1dG9tYXRpY2FsbHkuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvcmNlXVxuICogICBbZW5dSWYgYHRydWVgLCB0aGUgdG9hc3Qgc2tpcHMgdGhlIG5vdGlmaWNhdGlvbiBxdWV1ZSBhbmQgaXMgc2hvd24gaW1tZWRpYXRlbHkuIERlZmF1bHRzIHRvIGBmYWxzZWAuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWRdXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9hc3Q+YCBlbGVtZW50J3MgSUQuWy9lbl1cbiAqICAgW2phXW9ucy10b2FzdOimgee0oOOBrklE44CCWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5jbGFzc11cbiAqICAgW2VuXVRoZSBgPG9ucy10b2FzdD5gIGVsZW1lbnQncyBjbGFzcy5bL2VuXVxuICogICBbamFdb25zLXRvYXN06KaB57Sg44GuY2xhc3PjgIJbL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1vZGlmaWVyXVxuICogICBbZW5dTW9kaWZpZXIgZm9yIHRoZSBlbGVtZW50LlsvZW5dXG4gKiAgIFtqYV3jg4jjg7zjgrnjg4jjga5tb2RpZmllcuWxnuaAp+OBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgYWZ0ZXIgdG9hc3QgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gKiAgIFtqYV3jg4jjg7zjgrnjg4jjgYzplonjgZjjgonjgozjgZ/mmYLjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5IGEgc2ltcGxlIG5vdGlmaWNhdGlvbiB0b2FzdCB3aXRoIGFuIG9wdGlvbmFsIGJ1dHRvbiB0aGF0IGNhbiBiZSB1c2VkIGZvciBzaW1wbGUgYWN0aW9ucy5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGNhbGxlZCBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKlxuICogICAgIGBgYFxuICogICAgIG9ucy5ub3RpZmljYXRpb24udG9hc3QobWVzc2FnZSwgb3B0aW9ucyk7XG4gKiAgICAgb25zLm5vdGlmaWNhdGlvbi50b2FzdChvcHRpb25zKTtcbiAqICAgICBgYGBcbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm5vdGlmaWNhdGlvbi50b2FzdCA9IChtZXNzYWdlLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICB1dGlsLmNoZWNrTWlzc2luZ0ltcG9ydCgnVG9hc3QnKTsgLy8gVGhyb3dzIGVycm9yLCBtdXN0IGJlIGluc2lkZSBwcm9taXNlXG5cbiAgICBvcHRpb25zID0gX25vcm1hbGl6ZUFyZ3VtZW50cyhtZXNzYWdlLCBvcHRpb25zLCB7XG4gICAgICB0aW1lb3V0OiAwLFxuICAgICAgZm9yY2U6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBsZXQgdG9hc3QgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPG9ucy10b2FzdD5cbiAgICAgICAgJHtvcHRpb25zLm1lc3NhZ2V9XG4gICAgICAgICR7b3B0aW9ucy5idXR0b25MYWJlbHMgPyBgPGJ1dHRvbj4ke29wdGlvbnMuYnV0dG9uTGFiZWxzWzBdfTwvYnV0dG9uPmAgOiAnJ31cbiAgICAgIDwvb25zLXRvYXN0PlxuICAgIGApO1xuXG4gICAgX3NldEF0dHJpYnV0ZXModG9hc3QsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgZmluaXNoID0gdmFsdWUgPT4ge1xuICAgICAgaWYgKHRvYXN0KSB7XG4gICAgICAgIHRvYXN0XG4gICAgICAgIC5oaWRlKClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmICh0b2FzdCkge1xuICAgICAgICAgICAgdG9hc3QucmVtb3ZlKCk7XG4gICAgICAgICAgICB0b2FzdCA9IG51bGw7XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zLmJ1dHRvbkxhYmVscykge1xuICAgICAgdXRpbC5maW5kQ2hpbGQodG9hc3QuX3RvYXN0LCAnYnV0dG9uJykub25jbGljayA9ICgpID0+IGZpbmlzaCgwKTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRvYXN0KTtcbiAgICBvcHRpb25zLmNvbXBpbGUodG9hc3QpO1xuXG4gICAgY29uc3Qgc2hvdyA9ICgpID0+IHtcbiAgICAgIHRvYXN0LnBhcmVudEVsZW1lbnQgJiYgdG9hc3Quc2hvdyhvcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZmluaXNoKC0xKSwgb3B0aW9ucy50aW1lb3V0KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IG9wdGlvbnMuZm9yY2UgPyBzaG93KCkgOiBUb2FzdFF1ZXVlLmFkZChzaG93LCBwcm9taXNlKSlcbiAgfSk7XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBub3RpZmljYXRpb247XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuXG4vLyBWYWxpZGF0ZSBwYXJhbWV0ZXJzXG5jb25zdCBjaGVja09wdGlvbnMgPSBvcHRpb25zID0+IHtcbiAgY29uc3QgZXJyID0gKHByb3AsIHR5cGUgPSAnRnVuY3Rpb24nKSA9PiB1dGlsLnRocm93KGBcIm9wdGlvbnMuJHtwcm9wfVwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgJHt0eXBlfWApO1xuICBjb25zdCBoYXNPd25Qcm9wZXJ0eSA9IHByb3AgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgcHJvcCk7XG4gIGNvbnN0IGluc3RhbmNlT2YgPSAocHJvcCwgdHlwZSA9IEZ1bmN0aW9uKSA9PiBvcHRpb25zW3Byb3BdIGluc3RhbmNlb2YgdHlwZTtcblxuICBjb25zdCBiID0gJ2J1dHRvbnMnLCBjYiA9ICdjYWxsYmFjaycsIGMgPSAnY29tcGlsZScsIGQgPSAnZGVzdHJveSc7XG4gICghaGFzT3duUHJvcGVydHkoYikgfHwgIWluc3RhbmNlT2YoYiwgQXJyYXkpKSAmJiBlcnIoYiwgJ0FycmF5Jyk7XG4gIChoYXNPd25Qcm9wZXJ0eShjYikgJiYgIWluc3RhbmNlT2YoY2IpKSAmJiBlcnIoY2IpO1xuICAoaGFzT3duUHJvcGVydHkoYykgJiYgIWluc3RhbmNlT2YoYykpICYmIGVycihjKTtcbiAgKGhhc093blByb3BlcnR5KGQpICYmICFpbnN0YW5jZU9mKGQpKSAmJiBlcnIoZCk7XG59O1xuXG4vLyBBY3Rpb24gU2hlZXRcbmV4cG9ydCBkZWZhdWx0IChvcHRpb25zID0ge30pID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICB1dGlsLmNoZWNrTWlzc2luZ0ltcG9ydCgnQWN0aW9uU2hlZXQnKTtcbiAgY2hlY2tPcHRpb25zKG9wdGlvbnMpO1xuXG4gIC8vIE1haW4gY29tcG9uZW50XG4gIGxldCBhY3Rpb25TaGVldCA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgPG9ucy1hY3Rpb24tc2hlZXRcbiAgICAgICR7b3B0aW9ucy50aXRsZSA/IGB0aXRsZT1cIiR7b3B0aW9ucy50aXRsZX1cImAgOiAnJ31cbiAgICAgICR7b3B0aW9ucy5jYW5jZWxhYmxlID8gJ2NhbmNlbGFibGUnIDogJyd9XG4gICAgICAke29wdGlvbnMubW9kaWZpZXIgPyBgbW9kaWZpZXI9XCIke29wdGlvbnMubW9kaWZpZXJ9XCJgIDogJyd9XG4gICAgICAke29wdGlvbnMubWFza0NvbG9yID8gYG1hc2stY29sb3I9XCIke29wdGlvbnMubWFza0NvbG9yfVwiYCA6ICcnfVxuICAgICAgJHtvcHRpb25zLmlkID8gYGlkPVwiJHtvcHRpb25zLmlkfVwiYCA6ICcnfVxuICAgICAgJHtvcHRpb25zLmNsYXNzID8gYGNsYXNzPVwiJHtvcHRpb25zLmNsYXNzfVwiYCA6ICcnfVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3M9XCJhY3Rpb24tc2hlZXRcIj48L2Rpdj5cbiAgICA8L29ucy1hY3Rpb24tc2hlZXQ+XG4gIGApO1xuXG4gIC8vIFJlc29sdmUgYWN0aW9uIGFuZCBjbGVhbiB1cFxuICBjb25zdCBmaW5pc2ggPSAoZXZlbnQsIGluZGV4ID0gLTEpID0+IHtcbiAgICBpZiAoYWN0aW9uU2hlZXQpIHtcbiAgICAgIG9wdGlvbnMuZGVzdHJveSAmJiBvcHRpb25zLmRlc3Ryb3koYWN0aW9uU2hlZXQpO1xuXG4gICAgICBhY3Rpb25TaGVldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkaWFsb2ctY2FuY2VsJywgZmluaXNoLCBmYWxzZSk7XG4gICAgICBhY3Rpb25TaGVldC5yZW1vdmUoKTtcbiAgICAgIGFjdGlvblNoZWV0ID0gbnVsbDtcblxuICAgICAgb3B0aW9ucy5jYWxsYmFjayAmJiBvcHRpb25zLmNhbGxiYWNrKGluZGV4KTtcbiAgICAgIHJlc29sdmUoaW5kZXgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBMaW5rIGNhbmNlbCBoYW5kbGVyXG4gIGFjdGlvblNoZWV0LmFkZEV2ZW50TGlzdGVuZXIoJ2RpYWxvZy1jYW5jZWwnLCBmaW5pc2gsIGZhbHNlKTtcblxuICAvLyBDcmVhdGUgYnV0dG9ucyBhbmQgbGluayBhY3Rpb24gaGFuZGxlclxuICBjb25zdCBidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBvcHRpb25zLmJ1dHRvbnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBidXR0b25PcHRpb25zID0gKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykgPyB7IGxhYmVsOiBpdGVtIH0gOiB7IC4uLml0ZW0gfTtcbiAgICBpZiAob3B0aW9ucy5kZXN0cnVjdGl2ZSA9PT0gaW5kZXgpIHtcbiAgICAgIGJ1dHRvbk9wdGlvbnMubW9kaWZpZXIgPSAoYnV0dG9uT3B0aW9ucy5tb2RpZmllciB8fCAnJykgKyAnIGRlc3RydWN0aXZlJztcbiAgICB9XG5cbiAgICBjb25zdCBidXR0b24gPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICAgICAgPG9ucy1hY3Rpb24tc2hlZXQtYnV0dG9uXG4gICAgICAgICR7YnV0dG9uT3B0aW9ucy5pY29uID8gYGljb249XCIke2J1dHRvbk9wdGlvbnMuaWNvbn1cImAgOiAnJ31cbiAgICAgICAgJHtidXR0b25PcHRpb25zLm1vZGlmaWVyID8gYG1vZGlmaWVyPVwiJHtidXR0b25PcHRpb25zLm1vZGlmaWVyfVwiYCA6ICcnfVxuICAgICAgPlxuICAgICAgICAke2J1dHRvbk9wdGlvbnMubGFiZWx9XG4gICAgICA8L29ucy1hY3Rpb24tc2hlZXQtYnV0dG9uPlxuICAgIGApO1xuXG4gICAgYnV0dG9uLm9uY2xpY2sgPSBldmVudCA9PiBhY3Rpb25TaGVldC5oaWRlKCkudGhlbigoKSA9PiBmaW5pc2goZXZlbnQsIGluZGV4KSk7XG4gICAgYnV0dG9ucy5hcHBlbmRDaGlsZChidXR0b24pO1xuICB9KTtcblxuICAvLyBGaW5pc2ggY29tcG9uZW50IGFuZCBhdHRhY2hcbiAgdXRpbC5maW5kQ2hpbGQoYWN0aW9uU2hlZXQsICcuYWN0aW9uLXNoZWV0JykuYXBwZW5kQ2hpbGQoYnV0dG9ucyk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYWN0aW9uU2hlZXQpO1xuICBvcHRpb25zLmNvbXBpbGUgJiYgb3B0aW9ucy5jb21waWxlKGVsLmRpYWxvZyk7XG5cbiAgLy8gU2hvd1xuICBzZXRJbW1lZGlhdGUoKCkgPT4gYWN0aW9uU2hlZXQuc2hvdyh7XG4gICAgYW5pbWF0aW9uOiBvcHRpb25zLmFuaW1hdGlvbixcbiAgICBhbmltYXRpb25PcHRpb25zOiBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNcbiAgfSkpO1xufSk7XG4iLCIvKipcbiAqIE1pY3JvRXZlbnQgLSB0byBtYWtlIGFueSBqcyBvYmplY3QgYW4gZXZlbnQgZW1pdHRlciAoc2VydmVyIG9yIGJyb3dzZXIpXG4gKlxuICogLSBwdXJlIGphdmFzY3JpcHQgLSBzZXJ2ZXIgY29tcGF0aWJsZSwgYnJvd3NlciBjb21wYXRpYmxlXG4gKiAtIGRvbnQgcmVseSBvbiB0aGUgYnJvd3NlciBkb21zXG4gKiAtIHN1cGVyIHNpbXBsZSAtIHlvdSBnZXQgaXQgaW1tZWRpYXRlbHksIG5vIG15c3RlcnksIG5vIG1hZ2ljIGludm9sdmVkXG4gKlxuICogLSBjcmVhdGUgYSBNaWNyb0V2ZW50RGVidWcgd2l0aCBnb29kaWVzIHRvIGRlYnVnXG4gKiAgIC0gbWFrZSBpdCBzYWZlciB0byB1c2VcbiovXG5cbi8qKiBOT1RFOiBUaGlzIGxpYnJhcnkgaXMgY3VzdG9taXplZCBmb3IgT25zZW4gVUkuICovXG5cbmNvbnN0IE1pY3JvRXZlbnQgID0gZnVuY3Rpb24oKXt9O1xuTWljcm9FdmVudC5wcm90b3R5cGUgID0ge1xuICBvbjogZnVuY3Rpb24oZXZlbnQsIGZjdCl7XG4gICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSB0aGlzLl9ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgIHRoaXMuX2V2ZW50c1tldmVudF0ucHVzaChmY3QpO1xuICB9LFxuICBvbmNlOiBmdW5jdGlvbihldmVudCwgZmN0KXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYub2ZmKGV2ZW50LCB3cmFwcGVyKTtcbiAgICAgIHJldHVybiBmY3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIHRoaXMub24oZXZlbnQsIHdyYXBwZXIpO1xuICB9LFxuICBvZmY6IGZ1bmN0aW9uKGV2ZW50LCBmY3Qpe1xuICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgICBpZiAoZXZlbnQgaW4gdGhpcy5fZXZlbnRzID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50c1tldmVudF0gPSB0aGlzLl9ldmVudHNbZXZlbnRdXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKF9mY3QpIHtcbiAgICAgICAgaWYgKGZjdCkge1xuICAgICAgICAgICByZXR1cm4gZmN0ICE9PSBfZmN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0sXG4gIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50IC8qICwgYXJncy4uLiAqLyl7XG4gICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAgIGlmIChldmVudCBpbiB0aGlzLl9ldmVudHMgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9ldmVudHNbZXZlbnRdLmxlbmd0aDsgaSsrKXtcbiAgICAgIHRoaXMuX2V2ZW50c1tldmVudF1baV0uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIG1peGluIHdpbGwgZGVsZWdhdGUgYWxsIE1pY3JvRXZlbnQuanMgZnVuY3Rpb24gaW4gdGhlIGRlc3RpbmF0aW9uIG9iamVjdFxuICpcbiAqIC0gcmVxdWlyZSgnTWljcm9FdmVudCcpLm1peGluKEZvb2Jhcikgd2lsbCBtYWtlIEZvb2JhciBhYmxlIHRvIHVzZSBNaWNyb0V2ZW50XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRoZSBvYmplY3Qgd2hpY2ggd2lsbCBzdXBwb3J0IE1pY3JvRXZlbnRcbiovXG5NaWNyb0V2ZW50Lm1peGluICA9IGZ1bmN0aW9uKGRlc3RPYmplY3Qpe1xuICB2YXIgcHJvcHMgPSBbJ29uJywgJ29uY2UnLCAnb2ZmJywgJ2VtaXQnXTtcbiAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSArKyl7XG4gICAgaWYgKHR5cGVvZiBkZXN0T2JqZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkZXN0T2JqZWN0LnByb3RvdHlwZVtwcm9wc1tpXV0gID0gTWljcm9FdmVudC5wcm90b3R5cGVbcHJvcHNbaV1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0T2JqZWN0W3Byb3BzW2ldXSA9IE1pY3JvRXZlbnQucHJvdG90eXBlW3Byb3BzW2ldXTtcbiAgICB9XG4gIH1cbn1cblxud2luZG93Lk1pY3JvRXZlbnQgPSBNaWNyb0V2ZW50O1xuZXhwb3J0IGRlZmF1bHQgTWljcm9FdmVudDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBNaWNyb0V2ZW50IGZyb20gJy4vbWljcm9ldmVudCc7XG5cbmNvbnN0IGNyZWF0ZSA9ICgpID0+IHtcblxuICAvKipcbiAgICogQG9iamVjdCBvbnMub3JpZW50YXRpb25cbiAgICogQGNhdGVnb3J5IHV0aWxcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVV0aWxpdHkgbWV0aG9kcyBmb3Igb3JpZW50YXRpb24gZGV0ZWN0aW9uLlsvZW5dXG4gICAqICAgW2phXeeUu+mdouOBruOCquODquOCqOODs+ODhuODvOOCt+ODp+ODs+aknOefpeOBruOBn+OCgeOBruODpuODvOODhuOCo+ODquODhuOCo+ODoeOCveODg+ODieOCkuWPjuOCgeOBpuOBhOOCi+OCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuICBjb25zdCBvYmogPSB7XG4gICAgLyoqXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGRldmljZSBvcmllbnRhdGlvbiBjaGFuZ2VzLlsvZW5dXG4gICAgICogICBbamFd44OH44OQ44Kk44K544Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GM5aSJ5YyW44GX44Gf6Zqb44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQuaXNQb3J0cmFpdFxuICAgICAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcmllbnRhdGlvbiBpcyBwb3J0cmFpdCBtb2RlLlsvZW5dXG4gICAgICogICBbamFd54++5Zyo44Gu44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjga7loLTlkIjjgat0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb25cbiAgICAgKiBAc2lnbmF0dXJlIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dQWRkIGFuIGV2ZW50IGxpc3RlbmVyLlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44Oq44K544OK44O844KS6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lXG4gICAgICogICBbZW5dTmFtZSBvZiB0aGUgZXZlbnQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogICBbZW5dRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuWy9lbl1cbiAgICAgKiAgIFtqYV3jgZPjga7jgqTjg5njg7Pjg4jjgYznmbrngavjgZXjgozjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBvbmNlXG4gICAgICogQHNpZ25hdHVyZSBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogIFtlbl1BZGQgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCdzIG9ubHkgdHJpZ2dlcmVkIG9uY2UuWy9lbl1cbiAgICAgKiAgW2phXeS4gOW6puOBoOOBkeWRvOOBs+WHuuOBleOCjOOCi+OCpOODmeODs+ODiOODquOCueODiuODvOOCkui/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI44GM55m654Gr44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2Qgb2ZmXG4gICAgICogQHNpZ25hdHVyZSBvZmYoZXZlbnROYW1lLCBbbGlzdGVuZXJdKVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICBbZW5dUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyLiBJZiB0aGUgbGlzdGVuZXIgaXMgbm90IHNwZWNpZmllZCBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZXZlbnQgdHlwZSB3aWxsIGJlIHJlbW92ZWQuWy9lbl1cbiAgICAgKiAgW2phXeOCpOODmeODs+ODiOODquOCueODiuODvOOCkuWJiumZpOOBl+OBvuOBmeOAguOCguOBl+OCpOODmeODs+ODiOODquOCueODiuODvOOCkuaMh+WumuOBl+OBquOBi+OBo+OBn+WgtOWQiOOBq+OBr+OAgeOBneOBruOCpOODmeODs+ODiOOBq+e0kOOBpeOBj+WFqOOBpuOBruOCpOODmeODs+ODiOODquOCueODiuODvOOBjOWJiumZpOOBleOCjOOBvuOBmeOAglsvamFdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqICAgW2VuXU5hbWUgb2YgdGhlIGV2ZW50LlsvZW5dXG4gICAgICogICBbamFd44Kk44OZ44Oz44OI5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLlsvZW5dXG4gICAgICogICBbamFd5YmK6Zmk44GZ44KL44Kk44OZ44Oz44OI44Oq44K544OK44O844KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cblxuICAgIC8vIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiB0byBkZXRlY3QgaWYgd2hldGhlciBjdXJyZW50IHNjcmVlbiBpcyBwb3J0cmFpdCBvciBub3RcbiAgICBfaXNQb3J0cmFpdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGlzUG9ydHJhaXRcbiAgICAgKiBAc2lnbmF0dXJlIGlzUG9ydHJhaXQoKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIHBvcnRyYWl0IG1vZGUuWy9lbl1cbiAgICAgKiAgIFtqYV3jgqrjg6rjgqjjg7Pjg4bjg7zjgrfjg6fjg7PjgYxwb3J0cmFpdOODouODvOODieOBruWgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqICAgW2VuXVJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gb3JpZW50YXRpb24gaXMgcG9ydHJhaXQgb3Igbm90LlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMcG9ydHJhaXTjg6Ljg7zjg4njgYvjganjgYbjgYvjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgICAqL1xuICAgIGlzUG9ydHJhaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUG9ydHJhaXQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBpc0xhbmRzY2FwZVxuICAgICAqIEBzaWduYXR1cmUgaXNMYW5kc2NhcGUoKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogICBbZW5dV2lsbCBiZSB0cnVlIGlmIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uIGlzIGxhbmRzY2FwZSBtb2RlLlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44Gu5aC05ZCI44GrdHJ1ZeOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHNjcmVlbiBvcmllbnRhdGlvbiBpcyBsYW5kc2NhcGUgb3Igbm90LlsvZW5dXG4gICAgICogICBbamFd44Kq44Oq44Ko44Oz44OG44O844K344On44Oz44GMbGFuZHNjYXBl44Oi44O844OJ44GL44Gp44GG44GL44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICAgKi9cbiAgICBpc0xhbmRzY2FwZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMuaXNQb3J0cmFpdCgpO1xuICAgIH0sXG5cbiAgICBfaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25ET01Db250ZW50TG9hZGVkLmJpbmQodGhpcyksIGZhbHNlKTtcblxuICAgICAgaWYgKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX29uUmVzaXplLmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0ID4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX29uRE9NQ29udGVudExvYWRlZDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9pbnN0YWxsSXNQb3J0cmFpdEltcGxlbWVudGF0aW9uKCk7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiB0aGlzLmlzUG9ydHJhaXQoKX0pO1xuICAgIH0sXG5cbiAgICBfaW5zdGFsbElzUG9ydHJhaXRJbXBsZW1lbnRhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpc1BvcnRyYWl0ID0gd2luZG93LmlubmVyV2lkdGggPCB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIGlmICghKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSkge1xuICAgICAgICB0aGlzLl9pc1BvcnRyYWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodCA+IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cub3JpZW50YXRpb24gJSAxODAgPT09IDApIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSAwID8gaXNQb3J0cmFpdCA6ICFpc1BvcnRyYWl0O1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNQb3J0cmFpdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cub3JpZW50YXRpb24gJSAxODApID09PSA5MCA/IGlzUG9ydHJhaXQgOiAhaXNQb3J0cmFpdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX29uT3JpZW50YXRpb25DaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgaXNQb3J0cmFpdCA9IHRoaXMuX2lzUG9ydHJhaXQoKTtcblxuICAgICAgLy8gV2FpdCBmb3IgdGhlIGRpbWVuc2lvbnMgdG8gY2hhbmdlIGJlY2F1c2VcbiAgICAgIC8vIG9mIEFuZHJvaWQgaW5jb25zaXN0ZW5jeS5cbiAgICAgIGxldCBuSXRlciA9IDA7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgbkl0ZXIrKztcblxuICAgICAgICBjb25zdCB3ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgaWYgKChpc1BvcnRyYWl0ICYmIHcgPD0gaCkgfHxcbiAgICAgICAgICAgKCFpc1BvcnRyYWl0ICYmIHcgPj0gaCkpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIHtpc1BvcnRyYWl0OiBpc1BvcnRyYWl0fSk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH0gZWxzZSBpZiAobkl0ZXIgPT09IDUwKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2UnLCB7aXNQb3J0cmFpdDogaXNQb3J0cmFpdH0pO1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9LCAyMCk7XG4gICAgfSxcblxuICAgIC8vIFJ1biBvbiBub3QgbW9iaWxlIGJyb3dzZXIuXG4gICAgX29uUmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywge2lzUG9ydHJhaXQ6IHRoaXMuaXNQb3J0cmFpdCgpfSk7XG4gICAgfVxuICB9O1xuXG4gIE1pY3JvRXZlbnQubWl4aW4ob2JqKTtcblxuICByZXR1cm4gb2JqO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlKCkuX2luaXQoKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQG9iamVjdCBvbnMubW9kaWZpZXJcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVXRpbGl0eSBtZXRob2RzIHRvIGNoYW5nZSBtb2RpZmllciBhdHRyaWJ1dGVzIG9mIE9uc2VuIFVJIGVsZW1lbnRzLi5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogb25zLm1vZGlmaWVyLmFkZChteU9uc0lucHV0RWxlbWVudCwgJ3VuZGVyYmFyJyk7XG4gKiBvbnMubW9kaWZpZXIudG9nZ2xlKG15T25zVG9hc3RFbGVtZW50LCAnY3VzdG9tLW1vZGlmaWVyJyk7XG4gKlxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBAbWV0aG9kIGFkZFxuICAgKiBAc2lnbmF0dXJlIGFkZChlbGVtZW50LCBtb2RpZmllciBbLCBtb2RpZmllcl0pXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1BZGQgdGhlIHNwZWNpZmllZCBtb2RpZmllcnMgdG8gdGhlIGVsZW1lbnQgaWYgdGhleSBhcmUgbm90IGFscmVhZHkgaW5jbHVkZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJcbiAgICogICBbZW5dTmFtZSBvZiB0aGUgbW9kaWZpZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGFkZDogKGVsZW1lbnQsIC4uLm1vZGlmaWVycykgPT4gbW9kaWZpZXJzLmZvckVhY2gobW9kaWZpZXIgPT4gdXRpbC5hZGRNb2RpZmllcihlbGVtZW50LCBtb2RpZmllcikpLFxuICAvKipcbiAgICogQG1ldGhvZCByZW1vdmVcbiAgICogQHNpZ25hdHVyZSByZW1vdmUoZWxlbWVudCwgbW9kaWZpZXIgWywgbW9kaWZpZXJdKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmVtb3ZlIHRoZSBzcGVjaWZpZWQgbW9kaWZpZXJzIGZyb20gdGhlIGVsZW1lbnQgaWYgdGhleSBhcmUgaW5jbHVkZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJcbiAgICogICBbZW5dTmFtZSBvZiB0aGUgbW9kaWZpZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHJlbW92ZTogKGVsZW1lbnQsIC4uLm1vZGlmaWVycykgPT4gbW9kaWZpZXJzLmZvckVhY2gobW9kaWZpZXIgPT4gdXRpbC5yZW1vdmVNb2RpZmllcihlbGVtZW50LCBtb2RpZmllcikpLFxuICAvKipcbiAgICogQG1ldGhvZCBjb250YWluc1xuICAgKiBAc2lnbmF0dXJlIGNvbnRhaW5zKGVsZW1lbnQsIG1vZGlmaWVyKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2hlY2sgd2hldGhlciB0aGUgc3BlY2lmaWVkIG1vZGlmaWVyIGlzIGluY2x1ZGVkIGluIHRoZSBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogICBbZW5dVGFyZ2V0IGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1vZGlmaWVyXG4gICAqICAgW2VuXU5hbWUgb2YgdGhlIG1vZGlmaWVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqICAgW2VuXWB0cnVlYCB3aGVuIHRoZSBzcGVjaWZpZWQgbW9kaWZpZXIgaXMgZm91bmQgaW4gdGhlIGVsZW1lbnQncyBgbW9kaWZpZXJgIGF0dHJpYnV0ZS4gYGZhbHNlYCBvdGhlcndpc2UuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGNvbnRhaW5zOiB1dGlsLmhhc01vZGlmaWVyLFxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoZWxlbWVudCwgbW9kaWZpZXIgWywgZm9yY2VdKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIHRoZSBzcGVjaWZpZWQgbW9kaWZpZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiAgIFtlbl1UYXJnZXQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kaWZpZXJcbiAgICogICBbZW5dTmFtZSBvZiB0aGUgbW9kaWZpZXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcmNlXG4gICAqICAgW2VuXUlmIGl0IGV2YWx1YXRlcyB0byB0cnVlLCBhZGQgc3BlY2lmaWVkIG1vZGlmaWVyIHZhbHVlLCBhbmQgaWYgaXQgZXZhbHVhdGVzIHRvIGZhbHNlLCByZW1vdmUgaXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZTogdXRpbC50b2dnbGVNb2RpZmllclxufTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgTWljcm9FdmVudCBmcm9tICcuL21pY3JvZXZlbnQnO1xuXG5jb25zdCBzb2Z0d2FyZUtleWJvYXJkID0gbmV3IE1pY3JvRXZlbnQoKTtcbnNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSBmYWxzZTtcblxuY29uc3Qgb25TaG93ID0gKCkgPT4ge1xuICBzb2Z0d2FyZUtleWJvYXJkLl92aXNpYmxlID0gdHJ1ZTtcbiAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdzaG93Jyk7XG59O1xuXG5jb25zdCBvbkhpZGUgPSAoKSA9PiB7XG4gIHNvZnR3YXJlS2V5Ym9hcmQuX3Zpc2libGUgPSBmYWxzZTtcbiAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdoaWRlJyk7XG59O1xuXG5jb25zdCBiaW5kRXZlbnRzID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIEtleWJvYXJkICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJ0aW5tb3NlL2NvcmRvdmEta2V5Ym9hcmQvYmxvYi85NWYzZGEzYTM4ZDhmOGUxZmE0MWZiZjQwMTQ1MzUyYzEzNTM1YTAwL1JFQURNRS5tZFxuICAgIEtleWJvYXJkLm9uc2hvdyA9IG9uU2hvdztcbiAgICBLZXlib2FyZC5vbmhpZGUgPSBvbkhpZGU7XG4gICAgc29mdHdhcmVLZXlib2FyZC5lbWl0KCdpbml0Jywge3Zpc2libGU6IEtleWJvYXJkLmlzVmlzaWJsZX0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvcmRvdmEucGx1Z2lucyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvcmRvdmEucGx1Z2lucy5LZXlib2FyZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZHJpZnR5Y28vaW9uaWMtcGx1Z2lucy1rZXlib2FyZC9ibG9iL2NhMjdlY2YvUkVBRE1FLm1kXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ25hdGl2ZS5rZXlib2FyZHNob3cnLCBvblNob3cpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCduYXRpdmUua2V5Ym9hcmRoaWRlJywgb25IaWRlKTtcbiAgICBzb2Z0d2FyZUtleWJvYXJkLmVtaXQoJ2luaXQnLCB7dmlzaWJsZTogY29yZG92YS5wbHVnaW5zLktleWJvYXJkLmlzVmlzaWJsZX0pO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBub1BsdWdpbkVycm9yID0gKCkgPT4ge1xuICB1dGlsLndhcm4oJ29ucy1rZXlib2FyZDogQ29yZG92YSBLZXlib2FyZCBwbHVnaW4gaXMgbm90IHByZXNlbnQuJyk7XG59O1xuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsICgpID0+IHtcbiAgaWYgKCFiaW5kRXZlbnRzKCkpIHtcbiAgICBpZiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW29ucy1rZXlib2FyZC1hY3RpdmVdJykgfHxcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tvbnMta2V5Ym9hcmQtaW5hY3RpdmVdJykpIHtcbiAgICAgIG5vUGx1Z2luRXJyb3IoKTtcbiAgICB9XG5cbiAgICBzb2Z0d2FyZUtleWJvYXJkLm9uID0gbm9QbHVnaW5FcnJvcjtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNvZnR3YXJlS2V5Ym9hcmQ7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5jb25zdCBnZW5lcmF0ZUlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaSsrO1xuICB9O1xufSkoKTtcblxuLyoqXG4gKiBEb29yIGxvY2tpbmcgc3lzdGVtLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmxvZ11cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9vckxvY2sge1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX2xvY2tMaXN0ID0gW107XG4gICAgdGhpcy5fd2FpdExpc3QgPSBbXTtcbiAgICB0aGlzLl9sb2cgPSBvcHRpb25zLmxvZyB8fCBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgbG9jay5cbiAgICpcbiAgICogQHJldHVybiB7RnVuY3Rpb259IENhbGxiYWNrIGZvciB1bmxvY2tpbmcuXG4gICAqL1xuICBsb2NrKCkge1xuICAgIGNvbnN0IHVubG9jayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3VubG9jayh1bmxvY2spO1xuICAgIH07XG4gICAgdW5sb2NrLmlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIHRoaXMuX2xvY2tMaXN0LnB1c2godW5sb2NrKTtcbiAgICB0aGlzLl9sb2coJ2xvY2s6ICcgKyAodW5sb2NrLmlkKSk7XG5cbiAgICByZXR1cm4gdW5sb2NrO1xuICB9XG5cbiAgX3VubG9jayhmbikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbG9ja0xpc3QuaW5kZXhPZihmbik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWdpc3RlcmVkIGluIHRoZSBsb2NrIGxpc3QuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9ja0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLl9sb2coJ3VubG9jazogJyArIGZuLmlkKTtcblxuICAgIHRoaXMuX3RyeVRvRnJlZVdhaXRMaXN0KCk7XG4gIH1cblxuICBfdHJ5VG9GcmVlV2FpdExpc3QoKSB7XG4gICAgd2hpbGUgKCF0aGlzLmlzTG9ja2VkKCkgJiYgdGhpcy5fd2FpdExpc3QubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fd2FpdExpc3Quc2hpZnQoKSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZvciB3YWl0aW5nIHVubG9ja2VkIGRvb3IuXG4gICAqXG4gICAqIEBwYXJhbXMge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBvbiB1bmxvY2tpbmcgdGhlIGRvb3IgY29tcGxldGVseS5cbiAgICovXG4gIHdhaXRVbmxvY2soY2FsbGJhY2spIHtcbiAgICBpZiAoIShjYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY2FsbGJhY2sgcGFyYW0gbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzTG9ja2VkKCkpIHtcbiAgICAgIHRoaXMuX3dhaXRMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNMb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2tMaXN0Lmxlbmd0aCA+IDA7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5pbXBvcnQgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwnO1xuXG4vLyBEZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBnbG9iYWwgUGFnZUxvYWRlci5cbmZ1bmN0aW9uIGxvYWRQYWdlKHtwYWdlLCBwYXJlbnQsIHBhcmFtcyA9IHt9fSwgZG9uZSkge1xuICBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHBhZ2UpLnRoZW4oaHRtbCA9PiB7XG4gICAgY29uc3QgcGFnZUVsZW1lbnQgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKHBhZ2VFbGVtZW50KTtcblxuICAgIGRvbmUocGFnZUVsZW1lbnQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdW5sb2FkUGFnZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Ll9kZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICBlbGVtZW50Ll9kZXN0cm95KCk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUGFnZUxvYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgaGFzIFwiZWxlbWVudFwiIHByb3BlcnR5IGFuZCBcInVubG9hZFwiIGZ1bmN0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3IobG9hZGVyLCB1bmxvYWRlcikge1xuICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gbG9hZGVyIDogbG9hZFBhZ2U7XG4gICAgdGhpcy5fdW5sb2FkZXIgPSB1bmxvYWRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gdW5sb2FkZXIgOiB1bmxvYWRQYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpbnRlcm5hbCBsb2FkZXIgaW1wbGVtZW50YXRpb24uXG4gICAqL1xuICBzZXQgaW50ZXJuYWxMb2FkZXIoZm4pIHtcbiAgICBpZiAoIShmbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ZpcnN0IHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlciA9IGZuO1xuICB9XG5cbiAgZ2V0IGludGVybmFsTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2FkZXI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG9wdGlvbnMucGFnZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG9wdGlvbnMucGFyZW50IEEgbG9jYXRpb24gdG8gbG9hZCBwYWdlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyYW1zXSBFeHRyYSBwYXJhbWV0ZXJzIGZvciBvbnMtcGFnZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSBUYWtlIGFuIG9iamVjdCB0aGF0IGhhcyBcImVsZW1lbnRcIiBwcm9wZXJ0eSBhbmQgXCJ1bmxvYWRcIiBmdW5jdGlvbi5cbiAgICovXG4gIGxvYWQoe3BhZ2UsIHBhcmVudCwgcGFyYW1zID0ge319LCBkb25lKSB7XG4gICAgdGhpcy5fbG9hZGVyKHtwYWdlLCBwYXJlbnQsIHBhcmFtc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgIGlmICghKHBhZ2VFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3BhZ2VFbGVtZW50IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRWxlbWVudC4nKTtcbiAgICAgIH1cblxuICAgICAgZG9uZShwYWdlRWxlbWVudCk7XG4gICAgfSk7XG4gIH1cblxuICB1bmxvYWQocGFnZUVsZW1lbnQpIHtcbiAgICBpZiAoIShwYWdlRWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBFcnJvcigncGFnZUVsZW1lbnQgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBFbGVtZW50LicpO1xuICAgIH1cblxuICAgIHRoaXMuX3VubG9hZGVyKHBhZ2VFbGVtZW50KTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdFBhZ2VMb2FkZXIgPSBuZXcgUGFnZUxvYWRlcigpO1xuXG5leHBvcnQgY29uc3QgaW5zdGFudFBhZ2VMb2FkZXIgPSBuZXcgUGFnZUxvYWRlcihcbiAgZnVuY3Rpb24oe3BhZ2UsIHBhcmVudCwgcGFyYW1zID0ge319LCBkb25lKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHV0aWwuY3JlYXRlRWxlbWVudChwYWdlLnRyaW0oKSk7XG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuXG4gICAgZG9uZShlbGVtZW50KTtcbiAgfSxcbiAgdW5sb2FkUGFnZVxuKTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cydcbmltcG9ydCBhbmltaXQgZnJvbSAnLi9hbmltaXQnXG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4vZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybSc7XG5pbXBvcnQgbm90aWZpY2F0aW9uIGZyb20gJy4vbm90aWZpY2F0aW9uJztcbmltcG9ydCBhY3Rpb25TaGVldCBmcm9tICcuL2FjdGlvbi1zaGVldCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbCc7XG5pbXBvcnQgb3JpZW50YXRpb24gZnJvbSAnLi9vcmllbnRhdGlvbic7XG5pbXBvcnQgbW9kaWZpZXIgZnJvbSAnLi9tb2RpZmllcic7XG5pbXBvcnQgc29mdHdhcmVLZXlib2FyZCBmcm9tICcuL3NvZnR3YXJlLWtleWJvYXJkJztcbmltcG9ydCBwYWdlQXR0cmlidXRlRXhwcmVzc2lvbiBmcm9tICcuL3BhZ2UtYXR0cmlidXRlLWV4cHJlc3Npb24nO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuL2F1dG9zdHlsZSc7XG5pbXBvcnQgRG9vckxvY2sgZnJvbSAnLi9kb29ybG9jayc7XG5pbXBvcnQgeyBkZWZhdWx0UGFnZUxvYWRlciwgUGFnZUxvYWRlciB9IGZyb20gJy4vcGFnZS1sb2FkZXInO1xuXG4vKipcbiAqIEBvYmplY3Qgb25zXG4gKiBAY2F0ZWdvcnkgdXRpbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtqYV1PbnNlbiBVSeOBp+WIqeeUqOOBp+OBjeOCi+OCsOODreODvOODkOODq+OBquOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gKiAgIFtlbl1BIGdsb2JhbCBvYmplY3QgdGhhdCdzIHVzZWQgaW4gT25zZW4gVUkuIFsvZW5dXG4gKi9cbmNvbnN0IG9ucyA9IHtcbiAgYW5pbWl0LFxuICBkZWZhdWx0UGFnZUxvYWRlcixcbiAgZWxlbWVudHMsXG4gIEdlc3R1cmVEZXRlY3RvcixcbiAgbW9kaWZpZXIsXG4gIG5vdGlmaWNhdGlvbixcbiAgb3JpZW50YXRpb24sXG4gIHBhZ2VBdHRyaWJ1dGVFeHByZXNzaW9uLFxuICBQYWdlTG9hZGVyLFxuICBwbGF0Zm9ybSxcbiAgc29mdHdhcmVLZXlib2FyZCxcbiAgX2F1dG9TdHlsZTogYXV0b1N0eWxlLFxuICBfaW50ZXJuYWw6IGludGVybmFsLFxuICBfcmVhZHlMb2NrOiBuZXcgRG9vckxvY2soKSxcbiAgX3V0aWw6IHV0aWwsXG59O1xuXG5vbnMucGxhdGZvcm0uc2VsZWN0KCh3aW5kb3cubG9jYXRpb24uc2VhcmNoLm1hdGNoKC9wbGF0Zm9ybT0oW1xcdy1dKykvKSB8fCBbXSlbMV0pO1xuXG53YWl0RGV2aWNlUmVhZHkoKTtcblxuY29uc3QgcmVhZHlFcnJvciA9IGFmdGVyID0+IHV0aWwudGhyb3coYFRoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkICR7YWZ0ZXIgPyAnYWZ0ZXInIDogJ2JlZm9yZSd9IG9ucy5pc1JlYWR5KCkgaXMgdHJ1ZWApO1xuXG4vKipcbiAqIEBtZXRob2QgaXNSZWFkeVxuICogQHNpZ25hdHVyZSBpc1JlYWR5KClcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiAgIFtlbl1XaWxsIGJlIHRydWUgaWYgT25zZW4gVUkgaXMgaW5pdGlhbGl6ZWQuWy9lbl1cbiAqICAgW2phXeWIneacn+WMluOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJldHVybnMgdHJ1ZSBpZiBPbnNlbiBVSSBpcyBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFdT25zZW4gVUnjgYzjgZnjgafjgavliJ3mnJ/ljJbjgZXjgozjgabjgYTjgovjgYvjganjgYbjgYvjgpLov5TjgZnjg6Hjgr3jg4Pjg4njgafjgZnjgIJbL2phXVxuICovXG5vbnMuaXNSZWFkeSA9ICgpID0+IHtcbiAgcmV0dXJuICFvbnMuX3JlYWR5TG9jay5pc0xvY2tlZCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGlzV2ViVmlld1xuICogQHNpZ25hdHVyZSBpc1dlYlZpZXcoKVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqICAgW2VuXVdpbGwgYmUgdHJ1ZSBpZiB0aGUgYXBwIGlzIHJ1bm5pbmcgaW4gQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq3RydWXjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZXR1cm5zIHRydWUgaWYgcnVubmluZyBpbnNpZGUgQ29yZG92YS5bL2VuXVxuICogICBbamFdQ29yZG92YeOBp+Wun+ihjOOBleOCjOOBpuOBhOOCi+OBi+OBqeOBhuOBi+OCkui/lOOBmeODoeOCveODg+ODieOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5pc1dlYlZpZXcgPSBvbnMucGxhdGZvcm0uaXNXZWJWaWV3O1xuXG4vKipcbiAqIEBtZXRob2QgcmVhZHlcbiAqIEBzaWduYXR1cmUgcmVhZHkoY2FsbGJhY2spXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2phXeOCouODl+ODquOBruWIneacn+WMluOBq+WIqeeUqOOBmeOCi+ODoeOCveODg+ODieOBp+OBmeOAgua4oeOBleOCjOOBn+mWouaVsOOBr+OAgU9uc2VuIFVJ44Gu5Yid5pyf5YyW44GM57WC5LqG44GX44Gm44GE44KL5pmC54K544Gn5b+F44Ga5ZG844Gw44KM44G+44GZ44CCWy9qYV1cbiAqICAgW2VuXU1ldGhvZCB1c2VkIHRvIHdhaXQgZm9yIGFwcCBpbml0aWFsaXphdGlvbi4gV2FpdHMgZm9yIGBET01Db250ZW50TG9hZGVkYCBhbmQgYGRldmljZXJlYWR5YCwgd2hlbiBuZWNlc3NhcnksIGJlZm9yZSBleGVjdXRpbmcgdGhlIGNhbGxiYWNrLlsvZW5dXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogICBbZW5dRnVuY3Rpb24gdGhhdCBleGVjdXRlcyBhZnRlciBPbnNlbiBVSSBoYXMgYmVlbiBpbml0aWFsaXplZC5bL2VuXVxuICogICBbamFdT25zZW4gVUnjgYzliJ3mnJ/ljJbjgYzlrozkuobjgZfjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMucmVhZHkgPSBjYWxsYmFjayA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBlbHNlIHtcbiAgICBvbnMuX3JlYWR5TG9jay53YWl0VW5sb2NrKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldERlZmF1bHREZXZpY2VCYWNrQnV0dG9uTGlzdGVuZXJcbiAqIEBzaWduYXR1cmUgc2V0RGVmYXVsdERldmljZUJhY2tCdXR0b25MaXN0ZW5lcihsaXN0ZW5lcilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHdoZW4gZGV2aWNlIGJhY2sgYnV0dG9uIGlzIHByZXNzZWQuIE11c3QgYmUgY2FsbGVkIG9uIGBvbnMucmVhZHlgLlsvZW5dXG4gKiAgIFtqYV3jg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7PjgYzmirzjgZXjgozjgZ/mmYLjgavlrp/ooYzjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1TZXQgZGVmYXVsdCBoYW5kbGVyIGZvciBkZXZpY2UgYmFjayBidXR0b24uWy9lbl1cbiAqICAgW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOBn+OCgeOBruODh+ODleOCqeODq+ODiOOBruODj+ODs+ODieODqeOCkuioreWumuOBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5zZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgaWYgKCFvbnMuaXNSZWFkeSgpKSB7XG4gICAgcmVhZHlFcnJvcih0cnVlKTtcbiAgfVxuICBvbnMuX2RlZmF1bHREZXZpY2VCYWNrQnV0dG9uSGFuZGxlci5zZXRMaXN0ZW5lcihsaXN0ZW5lcik7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpXG4gKiBAZGVzY3JpcHRpb25cbiAqIFtlbl1EaXNhYmxlIGRldmljZSBiYWNrIGJ1dHRvbiBldmVudCBoYW5kbGVyLiBNdXN0IGJlIGNhbGxlZCBvbiBgb25zLnJlYWR5YC5bL2VuXVxuICogW2phXeODh+ODkOOCpOOCueOBruODkOODg+OCr+ODnOOCv+ODs+OBruOCpOODmeODs+ODiOOCkuWPl+OBkeS7mOOBkeOBquOBhOOCiOOBhuOBq+OBl+OBvuOBmeOAglsvamFdXG4gKi9cbm9ucy5kaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFvbnMuaXNSZWFkeSgpKSB7XG4gICAgcmVhZHlFcnJvcih0cnVlKTtcbiAgfVxuICBpbnRlcm5hbC5kYmJEaXNwYXRjaGVyLmRpc2FibGUoKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlclxuICogQHNpZ25hdHVyZSBlbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpXG4gKiBAZGVzY3JpcHRpb25cbiAqIFtlbl1FbmFibGUgZGV2aWNlIGJhY2sgYnV0dG9uIGV2ZW50IGhhbmRsZXIuIE11c3QgYmUgY2FsbGVkIG9uIGBvbnMucmVhZHlgLlsvZW5dXG4gKiBbamFd44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44Gu44Kk44OZ44Oz44OI44KS5Y+X44GR5LuY44GR44KL44KI44GG44Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmVuYWJsZURldmljZUJhY2tCdXR0b25IYW5kbGVyID0gZnVuY3Rpb24oKSB7XG4gIGlmICghb25zLmlzUmVhZHkoKSkge1xuICAgIHJlYWR5RXJyb3IodHJ1ZSk7XG4gIH1cbiAgaW50ZXJuYWwuZGJiRGlzcGF0Y2hlci5lbmFibGUoKTtcbn07XG5cbm9ucy5maXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gIGludGVybmFsLmRiYkRpc3BhdGNoZXIuZmlyZURldmljZUJhY2tCdXR0b25FdmVudCgpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUF1dG9TdGF0dXNCYXJGaWxsXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUF1dG9TdGF0dXNCYXJGaWxsKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIHN0YXR1cyBiYXIgZmlsbCBmZWF0dXJlIG9uIGlPUzcgYW5kIGFib3ZlIChleGNlcHQgZm9yIGlQaG9uZSBYKS4gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIGBvbnMucmVhZHlgLlsvZW5dXG4gKiAgIFtqYV1pT1M35Lul5LiK77yIaVBob25lIFjjga/pmaTjgY/vvInjgafjgIHjgrnjg4bjg7zjgr/jgrnjg5Djg7zpg6jliIbjga7pq5jjgZXjgpLoh6rli5XnmoTjgavln4vjgoHjgovlh6bnkIbjgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwgPSAoKSA9PiB7XG4gIGlmIChvbnMuaXNSZWFkeSgpKSB7XG4gICAgcmVhZHlFcnJvcihmYWxzZSk7XG4gIH1cbiAgaW50ZXJuYWwuY29uZmlnLmF1dG9TdGF0dXNCYXJGaWxsID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGxcbiAqIEBzaWduYXR1cmUgZGlzYWJsZUF1dG9TdGF0dXNCYXJGaWxsKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBzdGF0dXMgYmFyIGZpbGwgZmVhdHVyZSBvbiBpT1M3IGFuZCBhYm92ZSAoZXhjZXB0IGZvciBpUGhvbmUgWCkuIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBgb25zLnJlYWR5YC5bL2VuXVxuICogICBbamFdaU9TN+S7peS4iu+8iGlQaG9uZSBY44Gv6Zmk44GP77yJ44Gn44CB44K544OG44O844K/44K544OQ44O86YOo5YiG44Gu6auY44GV44KS6Ieq5YuV55qE44Gr5Z+L44KB44KL5Yem55CG44KS54Sh5Yq544Gr44GX44G+44GZ44CCWy9qYV1cbiAqL1xub25zLmRpc2FibGVBdXRvU3RhdHVzQmFyRmlsbCA9ICgpID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICByZWFkeUVycm9yKGZhbHNlKTtcbiAgfVxuICBpbnRlcm5hbC5jb25maWcuYXV0b1N0YXR1c0JhckZpbGwgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBtb2NrU3RhdHVzQmFyXG4gKiBAc2lnbmF0dXJlIG1vY2tTdGF0dXNCYXIoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGVzIGEgc3RhdGljIGVsZW1lbnQgc2ltaWxhciB0byBpT1Mgc3RhdHVzIGJhci4gT25seSB1c2VmdWwgZm9yIGJyb3dzZXIgdGVzdGluZy4gTXVzdCBiZSBjYWxsZWQgYmVmb3JlIGBvbnMucmVhZHlgLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMubW9ja1N0YXR1c0JhciA9ICgpID0+IHtcbiAgaWYgKG9ucy5pc1JlYWR5KCkpIHtcbiAgICByZWFkeUVycm9yKGZhbHNlKTtcbiAgfVxuXG4gIGNvbnN0IG1vY2sgPSAoKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudC5ib2R5LmNoaWxkcmVuWzBdIHx8ICFkb2N1bWVudC5ib2R5LmNoaWxkcmVuWzBdLmNsYXNzTGlzdC5jb250YWlucygnb25zLXN0YXR1cy1iYXItbW9jaycpKSB7XG4gICAgICBjb25zdCBhbmRyb2lkID0gcGxhdGZvcm0uaXNBbmRyb2lkKCksIGkgPSBpID0+IGA8aSBjbGFzcz1cIiR7aS5zcGxpdCgnLScpWzBdfSAke2l9XCI+PC9pPmA7XG4gICAgICBjb25zdCBsZWZ0ID0gYW5kcm9pZCA/IGAke2koJ3ptZGktdHdpdHRlcicpfSAke2koJ3ptZGktZ29vZ2xlLXBsYXknKX1gIDogYE5vIFNJTSAke2koJ2ZhLXdpZmknKX1gLFxuICAgICAgICBjZW50ZXIgPSBhbmRyb2lkID8gJycgOiAnMTI6MjggUE0nLFxuICAgICAgICByaWdodCA9IGFuZHJvaWQgPyBgJHtpKCd6bWRpLW5ldHdvcmsnKX0gJHtpKCd6bWRpLXdpZmknKX0gJHtpKCd6bWRpLWJhdHRlcnknKX0gMTI6MjggUE1gIDogYDgwJSAke2koJ2ZhLWJhdHRlcnktdGhyZWUtcXVhcnRlcnMnKX1gO1xuXG4gICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEJlZm9yZSh1dGlsLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIGA8ZGl2IGNsYXNzPVwib25zLXN0YXR1cy1iYXItbW9jayAke2FuZHJvaWQgPyAnYW5kcm9pZCcgOiAnaW9zJ31cIj5gICtcbiAgICAgICAgICBgPGRpdj4ke2xlZnR9PC9kaXY+PGRpdj4ke2NlbnRlcn08L2Rpdj48ZGl2PiR7cmlnaHR9PC9kaXY+YCArXG4gICAgICAgIGA8L2Rpdj5gXG4gICAgICApLCBkb2N1bWVudC5ib2R5LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfTtcblxuICBkb2N1bWVudC5ib2R5XG4gICAgPyBtb2NrKClcbiAgICA6IGludGVybmFsLndhaXRET01Db250ZW50TG9hZGVkKG1vY2spO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVBbmltYXRpb25zXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVBbmltYXRpb25zKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRGlzYWJsZSBhbGwgYW5pbWF0aW9ucy4gQ291bGQgYmUgaGFuZHkgZm9yIHRlc3RpbmcgYW5kIG9sZGVyIGRldmljZXMuWy9lbl1cbiAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+OCkuWFqOOBpueEoeWKueOBq+OBl+OBvuOBmeOAguODhuOCueODiOOBrumam+OBq+S+v+WIqeOBp+OBmeOAglsvamFdXG4gKi9cbm9ucy5kaXNhYmxlQW5pbWF0aW9ucyA9ICgpID0+IHtcbiAgaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZW5hYmxlQW5pbWF0aW9uc1xuICogQHNpZ25hdHVyZSBlbmFibGVBbmltYXRpb25zKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIGFuaW1hdGlvbnMgKGRlZmF1bHQpLlsvZW5dXG4gKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmnInlirnjgavjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuZW5hYmxlQW5pbWF0aW9ucyA9ICgpID0+IHtcbiAgaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCA9IGZhbHNlO1xufTtcblxub25zLl9kaXNhYmxlV2FybmluZ3MgPSAoKSA9PiB7XG4gIGludGVybmFsLmNvbmZpZy53YXJuaW5nc0Rpc2FibGVkID0gdHJ1ZTtcbn07XG5cbm9ucy5fZW5hYmxlV2FybmluZ3MgPSAoKSA9PiB7XG4gIGludGVybmFsLmNvbmZpZy53YXJuaW5nc0Rpc2FibGVkID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZUF1dG9TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGRpc2FibGVBdXRvU3R5bGluZygpXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXURpc2FibGUgYXV0b21hdGljIHN0eWxpbmcuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm9ucy5kaXNhYmxlQXV0b1N0eWxpbmcgPSBhdXRvU3R5bGUuZGlzYWJsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGVuYWJsZUF1dG9TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGVuYWJsZUF1dG9TdHlsaW5nKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dRW5hYmxlIGF1dG9tYXRpYyBzdHlsaW5nIGJhc2VkIG9uIE9TIChkZWZhdWx0KS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmVuYWJsZUF1dG9TdHlsaW5nID0gYXV0b1N0eWxlLmVuYWJsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGRpc2FibGVJY29uQXV0b1ByZWZpeFxuICogQHNpZ25hdHVyZSBkaXNhYmxlSWNvbkF1dG9QcmVmaXgoKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1EaXNhYmxlIGFkZGluZyBgZmEtYCBwcmVmaXggYXV0b21hdGljYWxseSB0byBgb25zLWljb25gIGNsYXNzZXMuIFVzZWZ1bCB3aGVuIGluY2x1ZGluZyBjdXN0b20gaWNvbiBwYWNrcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLmRpc2FibGVJY29uQXV0b1ByZWZpeCA9ICgpID0+IHtcbiAgdXRpbC5jaGVja01pc3NpbmdJbXBvcnQoJ0ljb24nKTtcbiAgZWxlbWVudHMuSWNvbi5zZXRBdXRvUHJlZml4KGZhbHNlKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBmb3JjZVVJV2ViVmlld1Njcm9sbEZpeFxuICogQHNpZ25hdHVyZSBmb3JjZVVJV2ViVmlld1Njcm9sbEZpeCgpXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBmaXguXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUFwcGxpZXMgYSBmaXggZm9yIGlPUyBVSVdlYlZpZXcgd2hpY2ggcHJldmVudHMgc2Nyb2xsIGV2ZW50cyBqdW1waW5nIHRvIHBhZ2VzIHVuZGVyIHRoZSB0b3AgbGF5ZXIuIFRoaXMgbWF5IHZpc3VhbGx5IGFmZmVjdCBub3JtYWwgc2Nyb2xsaW5nIG9mIFVJV2ViVmlldyBpZiB5b3Ugb3BlbiBhIGRpYWxvZy9tZW51IGJlZm9yZSB0aGUgc2Nyb2xsIG1vbWVudHVtIGZpbmlzaGVkLiBEaXNhYmxlZCBieSBkZWZhdWx0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5vbnMuZm9yY2VVSVdlYlZpZXdTY3JvbGxGaXggPSAoZm9yY2UgPSB0cnVlKSA9PiB7XG4gIGludGVybmFsLmNvbmZpZy5mb3JjZVVJV2ViVmlld1Njcm9sbEZpeCA9IGZvcmNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGZvcmNlUGxhdGZvcm1TdHlsaW5nXG4gKiBAc2lnbmF0dXJlIGZvcmNlUGxhdGZvcm1TdHlsaW5nKHBsYXRmb3JtKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1SZWZyZXNoIHN0eWxpbmcgZm9yIHRoZSBnaXZlbiBwbGF0Zm9ybS4gT25seSB1c2VmdWwgZm9yIGRlbW9zLiBVc2UgYG9ucy5wbGF0Zm9ybS5zZWxlY3QoLi4uKWAgaW5zdGVhZCBmb3IgZGV2ZWxvcG1lbnQgYW5kIHByb2R1Y3Rpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge3N0cmluZ30gcGxhdGZvcm0gTmV3IHBsYXRmb3JtIHRvIHN0eWxlIHRoZSBlbGVtZW50cy5cbiAqL1xub25zLmZvcmNlUGxhdGZvcm1TdHlsaW5nID0gbmV3UGxhdGZvcm0gPT4ge1xuICBvbnMuZW5hYmxlQXV0b1N0eWxpbmcoKTtcbiAgb25zLnBsYXRmb3JtLnNlbGVjdChuZXdQbGF0Zm9ybSB8fCAnaW9zJyk7XG5cbiAgb25zLl91dGlsLmFycmF5RnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqJykpXG4gICAgLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb25zLWlmJykge1xuICAgICAgICBlbGVtZW50Ll9wbGF0Zm9ybVVwZGF0ZSgpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnRhZ05hbWUubWF0Y2goL15vbnMtL2kpKSB7XG4gICAgICAgIGF1dG9TdHlsZS5wcmVwYXJlKGVsZW1lbnQsIHRydWUpO1xuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtdGFiYmFyJykge1xuICAgICAgICAgIGVsZW1lbnQuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBwcmVsb2FkXG4gKiBAc2lnbmF0dXJlIHByZWxvYWQodGVtcGxhdGVQYXRocylcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0ZW1wbGF0ZVBhdGhzXG4gKiAgIFtlbl1TZXQgb2YgSFRNTCBmaWxlIHBhdGhzIGNvbnRhaW5pbmcgJ29ucy1wYWdlJyBlbGVtZW50cy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEByZXR1cm4ge1Byb21pc2V9XG4gKiAgIFtlbl1Qcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgdGhlIHRlbXBsYXRlcyBhcmUgY2FjaGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1TZXBhcmF0ZWQgZmlsZXMgbmVlZCB0byBiZSByZXF1ZXN0ZWQgb24gZGVtYW5kIGFuZCB0aGlzIGNhbiBzbGlnaHRseSBkZWxheSBwdXNoaW5nIG5ldyBwYWdlcy4gVGhpcyBtZXRob2QgcmVxdWVzdHMgYW5kIGNhY2hlcyB0ZW1wbGF0ZXMgZm9yIGxhdGVyIHVzZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLnByZWxvYWQgPSBmdW5jdGlvbih0ZW1wbGF0ZXMgPSBbXSkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoKHRlbXBsYXRlcyBpbnN0YW5jZW9mIEFycmF5ID8gdGVtcGxhdGVzIDogW3RlbXBsYXRlc10pLm1hcCh0ZW1wbGF0ZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHV0aWwudGhyb3coJ0V4cGVjdGVkIHN0cmluZyBhcmd1bWVudHMgYnV0IGdvdCAnICsgdHlwZW9mIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVybmFsLmdldFRlbXBsYXRlSFRNTEFzeW5jKHRlbXBsYXRlKTtcbiAgfSkpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZUVsZW1lbnRcbiAqIEBzaWduYXR1cmUgY3JlYXRlRWxlbWVudCh0ZW1wbGF0ZSwgb3B0aW9ucylcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZW1wbGF0ZVxuICogICBbZW5dRWl0aGVyIGFuIEhUTUwgZmlsZSBwYXRoLCBhIGA8dGVtcGxhdGU+YCBpZCBvciBhbiBIVE1MIHN0cmluZyBzdWNoIGFzIGAnPGRpdiBpZD1cImZvb1wiPmhvZ2U8L2Rpdj4nYC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW58SFRNTEVsZW1lbnR9IFtvcHRpb25zLmFwcGVuZF1cbiAqICAgW2VuXVdoZXRoZXIgb3Igbm90IHRoZSBlbGVtZW50IHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGFwcGVuZGVkIHRvIHRoZSBET00uICBEZWZhdWx0cyB0byBgZmFsc2VgLiBJZiBgdHJ1ZWAgdmFsdWUgaXMgZ2l2ZW4sIGBkb2N1bWVudC5ib2R5YCB3aWxsIGJlIHVzZWQgYXMgdGhlIHRhcmdldC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtvcHRpb25zLmluc2VydEJlZm9yZV1cbiAqICAgW2VuXVJlZmVyZW5jZSBub2RlIHRoYXQgYmVjb21lcyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBuZXcgbm9kZSAoYG9wdGlvbnMuYXBwZW5kYCBlbGVtZW50KS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fFByb21pc2V9XG4gKiAgIFtlbl1JZiB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgd2FzIGFuIGlubGluZSBIVE1MIHN0cmluZywgaXQgcmV0dXJucyB0aGUgbmV3IGVsZW1lbnQuIE90aGVyd2lzZSwgaXQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbmV3IGVsZW1lbnQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIG5ldyBlbGVtZW50IGZyb20gYSB0ZW1wbGF0ZS4gQm90aCBpbmxpbmUgSFRNTCBhbmQgZXh0ZXJuYWwgZmlsZXMgYXJlIHN1cHBvcnRlZCBhbHRob3VnaCB0aGUgcmV0dXJuIHZhbHVlIGRpZmZlcnMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbm9ucy5jcmVhdGVFbGVtZW50ID0gKHRlbXBsYXRlLCBvcHRpb25zID0ge30pID0+IHtcbiAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS50cmltKCk7XG5cbiAgY29uc3QgY3JlYXRlID0gaHRtbCA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IG9ucy5fdXRpbC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG5cbiAgICBpZiAob3B0aW9ucy5hcHBlbmQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMuYXBwZW5kIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBvcHRpb25zLmFwcGVuZCA6IGRvY3VtZW50LmJvZHk7XG4gICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG9wdGlvbnMuaW5zZXJ0QmVmb3JlIHx8IG51bGwpO1xuICAgICAgb3B0aW9ucy5saW5rIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgb3B0aW9ucy5saW5rKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9O1xuXG4gIHJldHVybiB0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICc8JyA/IGNyZWF0ZSh0ZW1wbGF0ZSkgOiBpbnRlcm5hbC5nZXRQYWdlSFRNTEFzeW5jKHRlbXBsYXRlKS50aGVuKGNyZWF0ZSk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlUG9wb3ZlclxuICogQHNpZ25hdHVyZSBjcmVhdGVQb3BvdmVyKHBhZ2UsIFtvcHRpb25zXSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGEgPHRlbXBsYXRlPiBjb250YWluaW5nIGEgPG9ucy1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr2A8dGVtcGxhdGU+YOOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGFyZW50U2NvcGVdXG4gKiAgIFtlbl1QYXJlbnQgc2NvcGUgb2YgdGhlIGRpYWxvZy4gVXNlZCB0byBiaW5kIG1vZGVscyBhbmQgYWNjZXNzIHNjb3BlIG1ldGhvZHMgZnJvbSB0aGUgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDlhoXjgafliKnnlKjjgZnjgovopqrjgrnjgrPjg7zjg5fjgpLmjIflrprjgZfjgb7jgZnjgILjg4DjgqTjgqLjg63jgrDjgYvjgonjg6Ljg4fjg6vjgoTjgrnjgrPjg7zjg5fjga7jg6Hjgr3jg4Pjg4njgavjgqLjgq/jgrvjgrnjgZnjgovjga7jgavkvb/jgYTjgb7jgZnjgILjgZPjga7jg5Hjg6njg6Hjg7zjgr/jga9Bbmd1bGFySlPjg5DjgqTjg7Pjg4fjgqPjg7PjgrDjgafjga7jgb/liKnnlKjjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHBvcG92ZXIgY29tcG9uZW50IG9iamVjdC5bL2VuXVxuICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844Gu44Kz44Oz44Od44O844ON44Oz44OI44Kq44OW44K444Kn44Kv44OI44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNyZWF0ZSBhIHBvcG92ZXIgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjg53jg4Pjg5fjgqrjg7zjg5Djg7zjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG4vKipcbiAqIEBtZXRob2QgY3JlYXRlRGlhbG9nXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZURpYWxvZyhwYWdlLCBbb3B0aW9uc10pXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhbiBgPHRlbXBsYXRlPmAgY29udGFpbmluZyBhIDxvbnMtZGlhbG9nPiBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXXBhZ2Xjga5VUkzjgYvjgIHjgoLjgZfjgY/jga9gPHRlbXBsYXRlPmDjgaflrqPoqIDjgZfjgZ/jg4bjg7Pjg5fjg6zjg7zjg4jjga5pZOWxnuaAp+OBruWApOOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqICAgW2VuXVByb21pc2Ugb2JqZWN0IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRpYWxvZyBjb21wb25lbnQgb2JqZWN0LlsvZW5dXG4gKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgpLop6PmsbrjgZnjgotQcm9taXNl44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQ3JlYXRlIGEgZGlhbG9nIGluc3RhbmNlIGZyb20gYSB0ZW1wbGF0ZS5bL2VuXVxuICogICBbamFd44OG44Oz44OX44Os44O844OI44GL44KJ44OA44Kk44Ki44Ot44Kw44Gu44Kk44Oz44K544K/44Oz44K544KS55Sf5oiQ44GX44G+44GZ44CCWy9qYV1cbiAqL1xuLyoqXG4gKiBAbWV0aG9kIGNyZWF0ZUFsZXJ0RGlhbG9nXG4gKiBAc2lnbmF0dXJlIGNyZWF0ZUFsZXJ0RGlhbG9nKHBhZ2UsIFtvcHRpb25zXSlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlXG4gKiAgIFtlbl1QYWdlIG5hbWUuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBmaWxlIG9yIGFuIGA8dGVtcGxhdGU+YCBjb250YWluaW5nIGEgPG9ucy1hbGVydC1kaWFsb2c+IGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr2A8dGVtcGxhdGU+YOOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dUHJvbWlzZSBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgYWxlcnQgZGlhbG9nIGNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAqICAgW2phXeODgOOCpOOCouODreOCsOOBruOCs+ODs+ODneODvOODjeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOCkuino+axuuOBmeOCi1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1DcmVhdGUgYSBhbGVydCBkaWFsb2cgaW5zdGFuY2UgZnJvbSBhIHRlbXBsYXRlLlsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqTjg7Pjgrnjgr/jg7PjgrnjgpLnlJ/miJDjgZfjgb7jgZnjgIJbL2phXVxuICovXG5vbnMuY3JlYXRlUG9wb3ZlciA9IG9ucy5jcmVhdGVEaWFsb2cgPSBvbnMuY3JlYXRlQWxlcnREaWFsb2cgPSAodGVtcGxhdGUsIG9wdGlvbnMgPSB7fSkgPT4gb25zLmNyZWF0ZUVsZW1lbnQodGVtcGxhdGUsIHsgYXBwZW5kOiB0cnVlLCAuLi5vcHRpb25zIH0pO1xuXG4vKipcbiAqIEBtZXRob2Qgb3BlbkFjdGlvblNoZWV0XG4gKiBAc2lnbmF0dXJlIG9wZW5BY3Rpb25TaGVldChvcHRpb25zKVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1TaG93cyBhbiBpbnN0YW50IEFjdGlvbiBTaGVldCBhbmQgbGV0cyB0aGUgdXNlciBjaG9vc2UgYW4gYWN0aW9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLmJ1dHRvbnNdXG4gKiAgIFtlbl1SZXByZXNlbnQgZWFjaCBidXR0b24gb2YgdGhlIGFjdGlvbiBzaGVldCBmb2xsb3dpbmcgdGhlIHNwZWNpZmllZCBvcmRlci4gRXZlcnkgaXRlbSBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIGxhYmVsIG9yIGFuIG9iamVjdCBjb250YWluaW5nIGBsYWJlbGAsIGBpY29uYCBhbmQgYG1vZGlmaWVyYCBwcm9wZXJ0aWVzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRpdGxlXVxuICogICBbZW5dT3B0aW9uYWwgdGl0bGUgZm9yIHRoZSBhY3Rpb24gc2hlZXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGVzdHJ1Y3RpdmVdXG4gKiAgIFtlbl1PcHRpb25hbCBpbmRleCBvZiB0aGUgXCJkZXN0cnVjdGl2ZVwiIGJ1dHRvbiAob25seSBmb3IgaU9TKS4gSXQgY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgYnV0dG9uIGFycmF5IGFzIHdlbGwuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNhbmNlbGFibGVdXG4gKiAgIFtlbl1XaGV0aGVyIHRoZSBhY3Rpb24gc2hlZXQgY2FuIGJlIGNhbmNlbGVkIGJ5IHRhcHBpbmcgb24gdGhlIGJhY2tncm91bmQgbWFzayBvciBub3QuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubW9kaWZpZXJdXG4gKiAgIFtlbl1Nb2RpZmllciBhdHRyaWJ1dGUgb2YgdGhlIGFjdGlvbiBzaGVldC4gRS5nLiBgJ2Rlc3RydWN0aXZlJ2AuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWFza0NvbG9yXVxuICogICBbZW5dT3B0aW9uYWxseSBjaGFuZ2UgdGhlIGJhY2tncm91bmQgbWFzayBjb2xvci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZF1cbiAqICAgW2VuXVRoZSBlbGVtZW50J3MgaWQgYXR0cmlidXRlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNsYXNzXVxuICogICBbZW5dVGhlIGVsZW1lbnQncyBjbGFzcyBhdHRyaWJ1dGUuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICogICBbZW5dV2lsbCByZXNvbHZlIHdoZW4gdGhlIGFjdGlvbiBzaGVldCBpcyBjbG9zZWQuIFRoZSByZXNvbHZlIHZhbHVlIGlzIGVpdGhlciB0aGUgaW5kZXggb2YgdGhlIHRhcHBlZCBidXR0b24gb3IgLTEgd2hlbiBjYW5jZWxlZC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xub25zLm9wZW5BY3Rpb25TaGVldCA9IGFjdGlvblNoZWV0O1xuXG4vKipcbiAqIEBtZXRob2QgcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlclxuICogQHNpZ25hdHVyZSByZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyKHBhZ2UpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICogICBbZW5dUGFnZSBuYW1lLiBDYW4gYmUgZWl0aGVyIGFuIEhUTUwgZmlsZSBvciBhIGA8dGVtcGxhdGU+YCBpZC5bL2VuXVxuICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr2A8dGVtcGxhdGU+YOOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dSWYgbm8gcGFnZSBpcyBkZWZpbmVkIGZvciB0aGUgYG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyYCBhdHRyaWJ1dGUgaXQgd2lsbCB3YWl0IGZvciB0aGlzIG1ldGhvZCBiZWluZyBjYWxsZWQgYmVmb3JlIGxvYWRpbmcgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy1sb2FkaW5nLXBsYWNlaG9sZGVy44Gu5bGe5oCn5YCk44Go44GX44Gm44Oa44O844K444GM5oyH5a6a44GV44KM44Gm44GE44Gq44GE5aC05ZCI44Gv44CB44Oa44O844K444Ot44O844OJ5YmN44Gr5ZG844Gw44KM44KLb25zLnJlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXLlh6bnkIbjgYzooYzjgo/jgozjgovjgb7jgafooajnpLrjgZXjgozjgb7jgZvjgpPjgIJbL2phXVxuICovXG5vbnMucmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlciA9IChwYWdlLCBsaW5rKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnRzID0gb25zLl91dGlsLmFycmF5RnJvbSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW29ucy1sb2FkaW5nLXBsYWNlaG9sZGVyXScpKTtcbiAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHV0aWwudGhyb3coJ05vIG9ucy1sb2FkaW5nLXBsYWNlaG9sZGVyIGV4aXN0cycpO1xuICB9XG5cbiAgZWxlbWVudHNcbiAgICAuZmlsdGVyKGVsZW1lbnQgPT4gIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdwYWdlJykpXG4gICAgLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnb25zLWxvYWRpbmctcGxhY2Vob2xkZXInLCBwYWdlKTtcbiAgICAgIG9ucy5fcmVzb2x2ZUxvYWRpbmdQbGFjZWhvbGRlcihlbGVtZW50LCBwYWdlLCBsaW5rKTtcbiAgICB9KTtcbn07XG5cblxub25zLl9zZXR1cExvYWRpbmdQbGFjZUhvbGRlcnMgPSBmdW5jdGlvbigpIHtcbiAgb25zLnJlYWR5KCgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50cyA9IG9ucy5fdXRpbC5hcnJheUZyb20od2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tvbnMtbG9hZGluZy1wbGFjZWhvbGRlcl0nKSk7XG5cbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgcGFnZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdvbnMtbG9hZGluZy1wbGFjZWhvbGRlcicpO1xuICAgICAgaWYgKHR5cGVvZiBwYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBvbnMuX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIoZWxlbWVudCwgcGFnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxub25zLl9yZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyID0gZnVuY3Rpb24ocGFyZW50LCBwYWdlLCBsaW5rID0gKChlbCwgZG9uZSkgPT4gZG9uZSgpKSkge1xuICBwYWdlICYmIG9ucy5jcmVhdGVFbGVtZW50KHBhZ2UpXG4gICAgLnRoZW4oZWxlbWVudCA9PiB7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICBsaW5rKGVsZW1lbnQsICgpID0+IHtcbiAgICAgICAgd2hpbGUgKHBhcmVudC5maXJzdENoaWxkICYmIHBhcmVudC5maXJzdENoaWxkICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgIH0pO1xuICAgIH0pXG4gICAgLmNhdGNoKGVycm9yID0+IFByb21pc2UucmVqZWN0KCdVbmFibGVkIHRvIHJlc29sdmUgcGxhY2Vob2xkZXI6ICcgKyBlcnJvcikpO1xufTtcblxuZnVuY3Rpb24gd2FpdERldmljZVJlYWR5KCkge1xuICBjb25zdCB1bmxvY2tEZXZpY2VSZWFkeSA9IG9ucy5fcmVhZHlMb2NrLmxvY2soKTtcbiAgY29uc3QgZXhlY1VubG9jayA9ICgpID0+IHtcbiAgICBpZiAob25zLmlzV2ViVmlldygpKSB7XG4gICAgICAvLyBDYWxsYmFjayBmb3IgZXZlbnQgRGV2aWNlUmVhZHkgaXMgY2FsbGVkIGV2ZW4gaWYgdGhlIGV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gZmlyZWRcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkZXZpY2VyZWFkeScsIHVubG9ja0RldmljZVJlYWR5LCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVubG9ja0RldmljZVJlYWR5KCk7XG4gICAgfVxuICB9XG4gIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnIHx8XG4gICAgICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGVkJyB8fFxuICAgICAgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJykge1xuICAgIHNldEltbWVkaWF0ZShleGVjVW5sb2NrKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGV4ZWNVbmxvY2ssIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBtZXRob2QgZ2V0U2NyaXB0UGFnZVxuICogQHNpZ25hdHVyZSBnZXRTY3JpcHRQYWdlKClcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dQWNjZXNzIHRoZSBsYXN0IGNyZWF0ZWQgcGFnZSBmcm9tIHRoZSBjdXJyZW50IGBzY3JpcHRgIHNjb3BlLiBPbmx5IHdvcmtzIGluc2lkZSBgPHNjcmlwdD48L3NjcmlwdD5gIHRhZ3MgdGhhdCBhcmUgZGlyZWN0IGNoaWxkcmVuIG9mIGBvbnMtcGFnZWAgZWxlbWVudC4gVXNlIHRoaXMgdG8gYWRkIGxpZmVjeWNsZSBob29rcyB0byBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqICAgW2VuXVJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcGFnZSBlbGVtZW50LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5jb25zdCBnZXRDUyA9ICdjdXJyZW50U2NyaXB0JyBpbiBkb2N1bWVudCA/ICgpID0+IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgOiAoKSA9PiBkb2N1bWVudC5zY3JpcHRzW2RvY3VtZW50LnNjcmlwdHMubGVuZ3RoIC0gMV07XG5vbnMuZ2V0U2NyaXB0UGFnZSA9ICgpID0+IGdldENTKCkgJiYgL29ucy1wYWdlL2kudGVzdChnZXRDUygpLnBhcmVudEVsZW1lbnQudGFnTmFtZSkgJiYgZ2V0Q1MoKS5wYXJlbnRFbGVtZW50IHx8IG51bGw7XG5cbmV4cG9ydCBkZWZhdWx0IG9ucztcbiIsIjsoZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0LyoqXG5cdCAqIEBwcmVzZXJ2ZSBGYXN0Q2xpY2s6IHBvbHlmaWxsIHRvIHJlbW92ZSBjbGljayBkZWxheXMgb24gYnJvd3NlcnMgd2l0aCB0b3VjaCBVSXMuXG5cdCAqXG5cdCAqIEBjb2RpbmdzdGFuZGFyZCBmdGxhYnMtanN2MlxuXHQgKiBAY29weXJpZ2h0IFRoZSBGaW5hbmNpYWwgVGltZXMgTGltaXRlZCBbQWxsIFJpZ2h0cyBSZXNlcnZlZF1cblx0ICogQGxpY2Vuc2UgTUlUIExpY2Vuc2UgKHNlZSBMSUNFTlNFLnR4dClcblx0ICovXG5cblx0Lypqc2xpbnQgYnJvd3Nlcjp0cnVlLCBub2RlOnRydWUqL1xuXHQvKmdsb2JhbCBkZWZpbmUsIEV2ZW50LCBOb2RlKi9cblxuXG5cdC8qKlxuXHQgKiBJbnN0YW50aWF0ZSBmYXN0LWNsaWNraW5nIGxpc3RlbmVycyBvbiB0aGUgc3BlY2lmaWVkIGxheWVyLlxuXHQgKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICogQHBhcmFtIHtFbGVtZW50fSBsYXllciBUaGUgbGF5ZXIgdG8gbGlzdGVuIG9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzXG5cdCAqL1xuXHRmdW5jdGlvbiBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpIHtcblx0XHR2YXIgb2xkT25DbGljaztcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciBhIGNsaWNrIGlzIGN1cnJlbnRseSBiZWluZyB0cmFja2VkLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgYm9vbGVhblxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXG5cblx0XHQvKipcblx0XHQgKiBUaW1lc3RhbXAgZm9yIHdoZW4gY2xpY2sgdHJhY2tpbmcgc3RhcnRlZC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gMDtcblxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGVsZW1lbnQgYmVpbmcgdHJhY2tlZCBmb3IgYSBjbGljay5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIEV2ZW50VGFyZ2V0XG5cdFx0ICovXG5cdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblxuXG5cdFx0LyoqXG5cdFx0ICogWC1jb29yZGluYXRlIG9mIHRvdWNoIHN0YXJ0IGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50b3VjaFN0YXJ0WCA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFktY29vcmRpbmF0ZSBvZiB0b3VjaCBzdGFydCBldmVudC5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMudG91Y2hTdGFydFkgPSAwO1xuXG5cblx0XHQvKipcblx0XHQgKiBJRCBvZiB0aGUgbGFzdCB0b3VjaCwgcmV0cmlldmVkIGZyb20gVG91Y2guaWRlbnRpZmllci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIG51bWJlclxuXHRcdCAqL1xuXHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IDA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRvdWNobW92ZSBib3VuZGFyeSwgYmV5b25kIHdoaWNoIGEgY2xpY2sgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRvdWNoQm91bmRhcnkgPSBvcHRpb25zLnRvdWNoQm91bmRhcnkgfHwgMTA7XG5cblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBGYXN0Q2xpY2sgbGF5ZXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBFbGVtZW50XG5cdFx0ICovXG5cdFx0dGhpcy5sYXllciA9IGxheWVyO1xuXG5cdFx0LyoqXG5cdFx0ICogVGhlIG1pbmltdW0gdGltZSBiZXR3ZWVuIHRhcCh0b3VjaHN0YXJ0IGFuZCB0b3VjaGVuZCkgZXZlbnRzXG5cdFx0ICpcblx0XHQgKiBAdHlwZSBudW1iZXJcblx0XHQgKi9cblx0XHR0aGlzLnRhcERlbGF5ID0gb3B0aW9ucy50YXBEZWxheSB8fCAyMDA7XG5cblx0XHQvKipcblx0XHQgKiBUaGUgbWF4aW11bSB0aW1lIGZvciBhIHRhcFxuXHRcdCAqXG5cdFx0ICogQHR5cGUgbnVtYmVyXG5cdFx0ICovXG5cdFx0dGhpcy50YXBUaW1lb3V0ID0gb3B0aW9ucy50YXBUaW1lb3V0IHx8IDcwMDtcblxuXHRcdGlmIChGYXN0Q2xpY2subm90TmVlZGVkKGxheWVyKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFNvbWUgb2xkIHZlcnNpb25zIG9mIEFuZHJvaWQgZG9uJ3QgaGF2ZSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuXHRcdGZ1bmN0aW9uIGJpbmQobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTsgfTtcblx0XHR9XG5cblxuXHRcdHZhciBtZXRob2RzID0gWydvbk1vdXNlJywgJ29uQ2xpY2snLCAnb25Ub3VjaFN0YXJ0JywgJ29uVG91Y2hNb3ZlJywgJ29uVG91Y2hFbmQnLCAnb25Ub3VjaENhbmNlbCddO1xuXHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb250ZXh0W21ldGhvZHNbaV1dID0gYmluZChjb250ZXh0W21ldGhvZHNbaV1dLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnMgYXMgcmVxdWlyZWRcblx0XHRpZiAoZGV2aWNlSXNBbmRyb2lkKSB7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2UsIHRydWUpO1xuXHRcdH1cblxuXHRcdGxheWVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrLCB0cnVlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblRvdWNoU3RhcnQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uVG91Y2hNb3ZlLCBmYWxzZSk7XG5cdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uVG91Y2hFbmQsIGZhbHNlKTtcblx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Ub3VjaENhbmNlbCwgZmFsc2UpO1xuXG5cdFx0Ly8gSGFjayBpcyByZXF1aXJlZCBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IEV2ZW50I3N0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAoZS5nLiBBbmRyb2lkIDIpXG5cdFx0Ly8gd2hpY2ggaXMgaG93IEZhc3RDbGljayBub3JtYWxseSBzdG9wcyBjbGljayBldmVudHMgYnViYmxpbmcgdG8gY2FsbGJhY2tzIHJlZ2lzdGVyZWQgb24gdGhlIEZhc3RDbGlja1xuXHRcdC8vIGxheWVyIHdoZW4gdGhleSBhcmUgY2FuY2VsbGVkLlxuXHRcdGlmICghRXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbikge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBybXYgPSBOb2RlLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdHJtdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCBjYWxsYmFjaywgY2FwdHVyZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm12LmNhbGwobGF5ZXIsIHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0bGF5ZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrLCBjYXB0dXJlKSB7XG5cdFx0XHRcdHZhciBhZHYgPSBOb2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NsaWNrJykge1xuXHRcdFx0XHRcdGFkdi5jYWxsKGxheWVyLCB0eXBlLCBjYWxsYmFjay5oaWphY2tlZCB8fCAoY2FsbGJhY2suaGlqYWNrZWQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0aWYgKCFldmVudC5wcm9wYWdhdGlvblN0b3BwZWQpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soZXZlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pLCBjYXB0dXJlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhZHYuY2FsbChsYXllciwgdHlwZSwgY2FsbGJhY2ssIGNhcHR1cmUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIElmIGEgaGFuZGxlciBpcyBhbHJlYWR5IGRlY2xhcmVkIGluIHRoZSBlbGVtZW50J3Mgb25jbGljayBhdHRyaWJ1dGUsIGl0IHdpbGwgYmUgZmlyZWQgYmVmb3JlXG5cdFx0Ly8gRmFzdENsaWNrJ3Mgb25DbGljayBoYW5kbGVyLiBGaXggdGhpcyBieSBwdWxsaW5nIG91dCB0aGUgdXNlci1kZWZpbmVkIGhhbmRsZXIgZnVuY3Rpb24gYW5kXG5cdFx0Ly8gYWRkaW5nIGl0IGFzIGxpc3RlbmVyLlxuXHRcdGlmICh0eXBlb2YgbGF5ZXIub25jbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuXG5cdFx0XHQvLyBBbmRyb2lkIGJyb3dzZXIgb24gYXQgbGVhc3QgMy4yIHJlcXVpcmVzIGEgbmV3IHJlZmVyZW5jZSB0byB0aGUgZnVuY3Rpb24gaW4gbGF5ZXIub25jbGlja1xuXHRcdFx0Ly8gLSB0aGUgb2xkIG9uZSB3b24ndCB3b3JrIGlmIHBhc3NlZCB0byBhZGRFdmVudExpc3RlbmVyIGRpcmVjdGx5LlxuXHRcdFx0b2xkT25DbGljayA9IGxheWVyLm9uY2xpY2s7XG5cdFx0XHRsYXllci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdG9sZE9uQ2xpY2soZXZlbnQpO1xuXHRcdFx0fSwgZmFsc2UpO1xuXHRcdFx0bGF5ZXIub25jbGljayA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogV2luZG93cyBQaG9uZSA4LjEgZmFrZXMgdXNlciBhZ2VudCBzdHJpbmcgdG8gbG9vayBsaWtlIEFuZHJvaWQgYW5kIGlQaG9uZS5cblx0KlxuXHQqIEB0eXBlIGJvb2xlYW5cblx0Ki9cblx0dmFyIGRldmljZUlzV2luZG93c1Bob25lID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKSA+PSAwO1xuXG5cdC8qKlxuXHQgKiBBbmRyb2lkIHJlcXVpcmVzIGV4Y2VwdGlvbnMuXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA+IDAgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyByZXF1aXJlcyBleGNlcHRpb25zLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1MgPSAvaVAoYWR8aG9uZXxvZCkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIWRldmljZUlzV2luZG93c1Bob25lO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA0IHJlcXVpcmVzIGFuIGV4Y2VwdGlvbiBmb3Igc2VsZWN0IGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBAdHlwZSBib29sZWFuXG5cdCAqL1xuXHR2YXIgZGV2aWNlSXNJT1M0ID0gZGV2aWNlSXNJT1MgJiYgKC9PUyA0X1xcZChfXFxkKT8vKS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cblx0LyoqXG5cdCAqIGlPUyA2LjAtNy4qIHJlcXVpcmVzIHRoZSB0YXJnZXQgZWxlbWVudCB0byBiZSBtYW51YWxseSBkZXJpdmVkXG5cdCAqXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQgPSBkZXZpY2VJc0lPUyAmJiAoL09TIFs2LTddX1xcZC8pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cblx0LyoqXG5cdCAqIEJsYWNrQmVycnkgcmVxdWlyZXMgZXhjZXB0aW9ucy5cblx0ICpcblx0ICogQHR5cGUgYm9vbGVhblxuXHQgKi9cblx0dmFyIGRldmljZUlzQmxhY2tCZXJyeTEwID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdCQjEwJykgPiAwO1xuXG5cdC8qKlxuXHQgKiBWYWxpZCB0eXBlcyBmb3IgdGV4dCBpbnB1dHNcblx0ICpcblx0ICogQHR5cGUgYXJyYXlcblx0ICovXG5cdHZhciB0ZXh0RmllbGRzID0gWydlbWFpbCcsICdudW1iZXInLCAncGFzc3dvcmQnLCAnc2VhcmNoJywgJ3RlbCcsICd0ZXh0JywgJ3VybCddO1xuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBhIGdpdmVuIGVsZW1lbnQgcmVxdWlyZXMgYSBuYXRpdmUgY2xpY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IG5lZWRzIGEgbmF0aXZlIGNsaWNrXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzQ2xpY2sgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cblx0XHQvLyBEb24ndCBzZW5kIGEgc3ludGhldGljIGNsaWNrIHRvIGRpc2FibGVkIGlucHV0cyAoaXNzdWUgIzYyKVxuXHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRjYXNlICd0ZXh0YXJlYSc6XG5cdFx0XHRpZiAodGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdpbnB1dCc6XG5cblx0XHRcdC8vIEZpbGUgaW5wdXRzIG5lZWQgcmVhbCBjbGlja3Mgb24gaU9TIDYgZHVlIHRvIGEgYnJvd3NlciBidWcgKGlzc3VlICM2OClcblx0XHRcdGlmICgoZGV2aWNlSXNJT1MgJiYgdGFyZ2V0LnR5cGUgPT09ICdmaWxlJykgfHwgdGFyZ2V0LmRpc2FibGVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdsYWJlbCc6XG5cdFx0Y2FzZSAnaWZyYW1lJzogLy8gaU9TOCBob21lc2NyZWVuIGFwcHMgY2FuIHByZXZlbnQgZXZlbnRzIGJ1YmJsaW5nIGludG8gZnJhbWVzXG5cdFx0Y2FzZSAndmlkZW8nOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICgvXFxibmVlZHNjbGlja1xcYi8pLnRlc3QodGFyZ2V0LmNsYXNzTmFtZSk7XG5cdH07XG5cblxuXHQvKipcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBjbGljayBpbnRvIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR8RWxlbWVudH0gdGFyZ2V0IFRhcmdldCBET00gZWxlbWVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbGVtZW50IHJlcXVpcmVzIGEgY2FsbCB0byBmb2N1cyB0byBzaW11bGF0ZSBuYXRpdmUgY2xpY2suXG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm5lZWRzRm9jdXMgPSBmdW5jdGlvbih0YXJnZXQpIHtcblx0XHRzd2l0Y2ggKHRhcmdldC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0Y2FzZSAnc2VsZWN0Jzpcblx0XHRcdHJldHVybiAhZGV2aWNlSXNBbmRyb2lkO1xuXHRcdGNhc2UgJ2lucHV0Jzpcblx0XHRcdHN3aXRjaCAodGFyZ2V0LnR5cGUpIHtcblx0XHRcdGNhc2UgJ2J1dHRvbic6XG5cdFx0XHRjYXNlICdjaGVja2JveCc6XG5cdFx0XHRjYXNlICdmaWxlJzpcblx0XHRcdGNhc2UgJ2ltYWdlJzpcblx0XHRcdGNhc2UgJ3JhZGlvJzpcblx0XHRcdGNhc2UgJ3N1Ym1pdCc6XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gcG9pbnQgaW4gYXR0ZW1wdGluZyB0byBmb2N1cyBkaXNhYmxlZCBpbnB1dHNcblx0XHRcdHJldHVybiAhdGFyZ2V0LmRpc2FibGVkICYmICF0YXJnZXQucmVhZE9ubHk7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHJldHVybiAoL1xcYm5lZWRzZm9jdXNcXGIvKS50ZXN0KHRhcmdldC5jbGFzc05hbWUpO1xuXHRcdH1cblx0fTtcblxuXG5cdC8qKlxuXHQgKiBTZW5kIGEgY2xpY2sgZXZlbnQgdG8gdGhlIHNwZWNpZmllZCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuc2VuZENsaWNrID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCwgZXZlbnQpIHtcblx0XHR2YXIgY2xpY2tFdmVudCwgdG91Y2g7XG5cblx0XHQvLyBPbiBzb21lIEFuZHJvaWQgZGV2aWNlcyBhY3RpdmVFbGVtZW50IG5lZWRzIHRvIGJlIGJsdXJyZWQgb3RoZXJ3aXNlIHRoZSBzeW50aGV0aWMgY2xpY2sgd2lsbCBoYXZlIG5vIGVmZmVjdCAoIzI0KVxuXHRcdGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IHRhcmdldEVsZW1lbnQpIHtcblx0XHRcdGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXHRcdH1cblxuXHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHQvLyBTeW50aGVzaXNlIGEgY2xpY2sgZXZlbnQsIHdpdGggYW4gZXh0cmEgYXR0cmlidXRlIHNvIGl0IGNhbiBiZSB0cmFja2VkXG5cdFx0Y2xpY2tFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xuXHRcdGNsaWNrRXZlbnQuaW5pdE1vdXNlRXZlbnQodGhpcy5kZXRlcm1pbmVFdmVudFR5cGUodGFyZ2V0RWxlbWVudCksIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXHRcdGNsaWNrRXZlbnQuZm9yd2FyZGVkVG91Y2hFdmVudCA9IHRydWU7XG5cdFx0dGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuXHR9O1xuXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZGV0ZXJtaW5lRXZlbnRUeXBlID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXG5cdFx0Ly9Jc3N1ZSAjMTU5OiBBbmRyb2lkIENocm9tZSBTZWxlY3QgQm94IGRvZXMgbm90IG9wZW4gd2l0aCBhIHN5bnRoZXRpYyBjbGljayBldmVudFxuXHRcdGlmIChkZXZpY2VJc0FuZHJvaWQgJiYgdGFyZ2V0RWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRyZXR1cm4gJ21vdXNlZG93bic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICdjbGljayc7XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHZhciBsZW5ndGg7XG5cblx0XHQvLyBJc3N1ZSAjMTYwOiBvbiBpT1MgNywgc29tZSBpbnB1dCBlbGVtZW50cyAoZS5nLiBkYXRlIGRhdGV0aW1lIG1vbnRoKSB0aHJvdyBhIHZhZ3VlIFR5cGVFcnJvciBvbiBzZXRTZWxlY3Rpb25SYW5nZS4gVGhlc2UgZWxlbWVudHMgZG9uJ3QgaGF2ZSBhbiBpbnRlZ2VyIHZhbHVlIGZvciB0aGUgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCBwcm9wZXJ0aWVzLCBidXQgdW5mb3J0dW5hdGVseSB0aGF0IGNhbid0IGJlIHVzZWQgZm9yIGRldGVjdGlvbiBiZWNhdXNlIGFjY2Vzc2luZyB0aGUgcHJvcGVydGllcyBhbHNvIHRocm93cyBhIFR5cGVFcnJvci4gSnVzdCBjaGVjayB0aGUgdHlwZSBpbnN0ZWFkLiBGaWxlZCBhcyBBcHBsZSBidWcgIzE1MTIyNzI0LlxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiB0YXJnZXRFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlICYmIHRhcmdldEVsZW1lbnQudHlwZS5pbmRleE9mKCdkYXRlJykgIT09IDAgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAndGltZScgJiYgdGFyZ2V0RWxlbWVudC50eXBlICE9PSAnbW9udGgnICYmIHRhcmdldEVsZW1lbnQudHlwZSAhPT0gJ2VtYWlsJyAmJiB0YXJnZXRFbGVtZW50LnR5cGUgIT09ICdudW1iZXInKSB7XG5cdFx0XHRsZW5ndGggPSB0YXJnZXRFbGVtZW50LnZhbHVlLmxlbmd0aDtcblx0XHRcdHRhcmdldEVsZW1lbnQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZvY3VzKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyIGFuZCBpZiBzbywgc2V0IGEgZmxhZyBvbiBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldHxFbGVtZW50fSB0YXJnZXRFbGVtZW50XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLnVwZGF0ZVNjcm9sbFBhcmVudCA9IGZ1bmN0aW9uKHRhcmdldEVsZW1lbnQpIHtcblx0XHR2YXIgc2Nyb2xsUGFyZW50LCBwYXJlbnRFbGVtZW50O1xuXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cblx0XHQvLyBBdHRlbXB0IHRvIGRpc2NvdmVyIHdoZXRoZXIgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBzY3JvbGxhYmxlIGxheWVyLiBSZS1jaGVjayBpZiB0aGVcblx0XHQvLyB0YXJnZXQgZWxlbWVudCB3YXMgbW92ZWQgdG8gYW5vdGhlciBwYXJlbnQuXG5cdFx0aWYgKCFzY3JvbGxQYXJlbnQgfHwgIXNjcm9sbFBhcmVudC5jb250YWlucyh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0cGFyZW50RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmIChwYXJlbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IHBhcmVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0KSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50ID0gcGFyZW50RWxlbWVudDtcblx0XHRcdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0fSB3aGlsZSAocGFyZW50RWxlbWVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWx3YXlzIHVwZGF0ZSB0aGUgc2Nyb2xsIHRvcCB0cmFja2VyIGlmIHBvc3NpYmxlLlxuXHRcdGlmIChzY3JvbGxQYXJlbnQpIHtcblx0XHRcdHNjcm9sbFBhcmVudC5mYXN0Q2xpY2tMYXN0U2Nyb2xsVG9wID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcDtcblx0XHR9XG5cdH07XG5cblxuXHQvKipcblx0ICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0RWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxFdmVudFRhcmdldH1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldCA9IGZ1bmN0aW9uKGV2ZW50VGFyZ2V0KSB7XG5cblx0XHQvLyBPbiBzb21lIG9sZGVyIGJyb3dzZXJzIChub3RhYmx5IFNhZmFyaSBvbiBpT1MgNC4xIC0gc2VlIGlzc3VlICM1NikgdGhlIGV2ZW50IHRhcmdldCBtYXkgYmUgYSB0ZXh0IG5vZGUuXG5cdFx0aWYgKGV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuXHRcdFx0cmV0dXJuIGV2ZW50VGFyZ2V0LnBhcmVudE5vZGU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50VGFyZ2V0O1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldEVsZW1lbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmlzVGV4dEZpZWxkID0gZnVuY3Rpb24odGFyZ2V0RWxlbWVudCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0YXJnZXRFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHRhcmVhJ1xuXHRcdFx0fHwgdGV4dEZpZWxkcy5pbmRleE9mKHRhcmdldEVsZW1lbnQudHlwZSkgIT09IC0xXG5cdFx0KTtcblx0fTtcblxuXHQvKipcblx0ICogT24gdG91Y2ggc3RhcnQsIHJlY29yZCB0aGUgcG9zaXRpb24gYW5kIHNjcm9sbCBvZmZzZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5vblRvdWNoU3RhcnQgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB0YXJnZXRFbGVtZW50LCB0b3VjaCwgc2VsZWN0aW9uO1xuXG5cdFx0Ly8gSWdub3JlIG11bHRpcGxlIHRvdWNoZXMsIG90aGVyd2lzZSBwaW5jaC10by16b29tIGlzIHByZXZlbnRlZCBpZiBib3RoIGZpbmdlcnMgYXJlIG9uIHRoZSBGYXN0Q2xpY2sgZWxlbWVudCAoaXNzdWUgIzExMSkuXG5cdFx0aWYgKGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoID4gMSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldChldmVudC50YXJnZXQpO1xuXHRcdHRvdWNoID0gZXZlbnQudGFyZ2V0VG91Y2hlc1swXTtcblxuXHRcdC8vIElnbm9yZSB0b3VjaGVzIG9uIGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50cyB0byBwcmV2ZW50IGNvbmZsaWN0IHdpdGggdGV4dCBzZWxlY3Rpb24uXG5cdFx0Ly8gKEZvciBkZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vZnRsYWJzL2Zhc3RjbGljay9wdWxsLzIxMSApXG5cdFx0aWYgKHRhcmdldEVsZW1lbnQuaXNDb250ZW50RWRpdGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUykge1xuXHRcdFx0Ly8gSWdub3JlIHRvdWNoc3RhcnQgaW4gZm9jdXNlZCB0ZXh0IGZpZWxkXG5cdFx0XHQvLyBBbGxvd3Mgbm9ybWFsIHRleHQgc2VsZWN0aW9uIGFuZCBjb21tYW5kcyAoc2VsZWN0L3Bhc3RlL2N1dCkgd2hlbiBhIGZpZWxkIGhhcyBmb2N1cywgd2hpbGUgc3RpbGwgYWxsb3dpbmcgZmFzdCB0YXAtdG8tZm9jdXMuXG5cdFx0XHQvLyBXaXRob3V0IHRoaXMgZml4LCB1c2VyIG5lZWRzIHRvIHRhcC1hbmQtaG9sZCBhIHRleHQgZmllbGQgZm9yIGNvbnRleHQgbWVudSwgYW5kIGRvdWJsZS10YXAgdG8gc2VsZWN0IHRleHQgZG9lc24ndCB3b3JrIGF0IGFsbC5cblx0XHRcdGlmICh0YXJnZXRFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIHRoaXMuaXNUZXh0RmllbGQodGFyZ2V0RWxlbWVudCkpIHtcblx0XHRcdCAgcmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdFx0Ly8gV2VpcmQgdGhpbmdzIGhhcHBlbiBvbiBpT1Mgd2hlbiBhbiBhbGVydCBvciBjb25maXJtIGRpYWxvZyBpcyBvcGVuZWQgZnJvbSBhIGNsaWNrIGV2ZW50IGNhbGxiYWNrIChpc3N1ZSAjMjMpOlxuXHRcdFx0XHQvLyB3aGVuIHRoZSB1c2VyIG5leHQgdGFwcyBhbnl3aGVyZSBlbHNlIG9uIHRoZSBwYWdlLCBuZXcgdG91Y2hzdGFydCBhbmQgdG91Y2hlbmQgZXZlbnRzIGFyZSBkaXNwYXRjaGVkXG5cdFx0XHRcdC8vIHdpdGggdGhlIHNhbWUgaWRlbnRpZmllciBhcyB0aGUgdG91Y2ggZXZlbnQgdGhhdCBwcmV2aW91c2x5IHRyaWdnZXJlZCB0aGUgY2xpY2sgdGhhdCB0cmlnZ2VyZWQgdGhlIGFsZXJ0LlxuXHRcdFx0XHQvLyBTYWRseSwgdGhlcmUgaXMgYW4gaXNzdWUgb24gaU9TIDQgdGhhdCBjYXVzZXMgc29tZSBub3JtYWwgdG91Y2ggZXZlbnRzIHRvIGhhdmUgdGhlIHNhbWUgaWRlbnRpZmllciBhcyBhblxuXHRcdFx0XHQvLyBpbW1lZGlhdGVseSBwcmVjZWVkaW5nIHRvdWNoIGV2ZW50IChpc3N1ZSAjNTIpLCBzbyB0aGlzIGZpeCBpcyB1bmF2YWlsYWJsZSBvbiB0aGF0IHBsYXRmb3JtLlxuXHRcdFx0XHQvLyBJc3N1ZSAxMjA6IHRvdWNoLmlkZW50aWZpZXIgaXMgMCB3aGVuIENocm9tZSBkZXYgdG9vbHMgJ0VtdWxhdGUgdG91Y2ggZXZlbnRzJyBpcyBzZXQgd2l0aCBhbiBpT1MgZGV2aWNlIFVBIHN0cmluZyxcblx0XHRcdFx0Ly8gd2hpY2ggY2F1c2VzIGFsbCB0b3VjaCBldmVudHMgdG8gYmUgaWdub3JlZC4gQXMgdGhpcyBibG9jayBvbmx5IGFwcGxpZXMgdG8gaU9TLCBhbmQgaU9TIGlkZW50aWZpZXJzIGFyZSBhbHdheXMgbG9uZyxcblx0XHRcdFx0Ly8gcmFuZG9tIGludGVnZXJzLCBpdCdzIHNhZmUgdG8gdG8gY29udGludWUgaWYgdGhlIGlkZW50aWZpZXIgaXMgMCBoZXJlLlxuXHRcdFx0XHRpZiAodG91Y2guaWRlbnRpZmllciAmJiB0b3VjaC5pZGVudGlmaWVyID09PSB0aGlzLmxhc3RUb3VjaElkZW50aWZpZXIpIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMubGFzdFRvdWNoSWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGEgY2hpbGQgb2YgYSBzY3JvbGxhYmxlIGxheWVyICh1c2luZyAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2gpIGFuZDpcblx0XHRcdFx0Ly8gMSkgdGhlIHVzZXIgZG9lcyBhIGZsaW5nIHNjcm9sbCBvbiB0aGUgc2Nyb2xsYWJsZSBsYXllclxuXHRcdFx0XHQvLyAyKSB0aGUgdXNlciBzdG9wcyB0aGUgZmxpbmcgc2Nyb2xsIHdpdGggYW5vdGhlciB0YXBcblx0XHRcdFx0Ly8gdGhlbiB0aGUgZXZlbnQudGFyZ2V0IG9mIHRoZSBsYXN0ICd0b3VjaGVuZCcgZXZlbnQgd2lsbCBiZSB0aGUgZWxlbWVudCB0aGF0IHdhcyB1bmRlciB0aGUgdXNlcidzIGZpbmdlclxuXHRcdFx0XHQvLyB3aGVuIHRoZSBmbGluZyBzY3JvbGwgd2FzIHN0YXJ0ZWQsIGNhdXNpbmcgRmFzdENsaWNrIHRvIHNlbmQgYSBjbGljayBldmVudCB0byB0aGF0IGxheWVyIC0gdW5sZXNzIGEgY2hlY2tcblx0XHRcdFx0Ly8gaXMgbWFkZSB0byBlbnN1cmUgdGhhdCBhIHBhcmVudCBsYXllciB3YXMgbm90IHNjcm9sbGVkIGJlZm9yZSBzZW5kaW5nIGEgc3ludGhldGljIGNsaWNrIChpc3N1ZSAjNDIpLlxuXHRcdFx0XHR0aGlzLnVwZGF0ZVNjcm9sbFBhcmVudCh0YXJnZXRFbGVtZW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSB0cnVlO1xuXHRcdHRoaXMudHJhY2tpbmdDbGlja1N0YXJ0ID0gZXZlbnQudGltZVN0YW1wO1xuXHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IHRhcmdldEVsZW1lbnQ7XG5cblx0XHR0aGlzLnRvdWNoU3RhcnRYID0gdG91Y2gucGFnZVg7XG5cdFx0dGhpcy50b3VjaFN0YXJ0WSA9IHRvdWNoLnBhZ2VZO1xuXG5cdFx0Ly8gUHJldmVudCBwaGFudG9tIGNsaWNrcyBvbiBmYXN0IGRvdWJsZS10YXAgKGlzc3VlICMzNilcblx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPCB0aGlzLnRhcERlbGF5ICYmIChldmVudC50aW1lU3RhbXAgLSB0aGlzLmxhc3RDbGlja1RpbWUpID4gLTEpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblxuXHQvKipcblx0ICogQmFzZWQgb24gYSB0b3VjaG1vdmUgZXZlbnQgb2JqZWN0LCBjaGVjayB3aGV0aGVyIHRoZSB0b3VjaCBoYXMgbW92ZWQgcGFzdCBhIGJvdW5kYXJ5IHNpbmNlIGl0IHN0YXJ0ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS50b3VjaEhhc01vdmVkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSwgYm91bmRhcnkgPSB0aGlzLnRvdWNoQm91bmRhcnk7XG5cblx0XHRpZiAoTWF0aC5hYnModG91Y2gucGFnZVggLSB0aGlzLnRvdWNoU3RhcnRYKSA+IGJvdW5kYXJ5IHx8IE1hdGguYWJzKHRvdWNoLnBhZ2VZIC0gdGhpcy50b3VjaFN0YXJ0WSkgPiBib3VuZGFyeSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSB0aGUgbGFzdCBwb3NpdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hNb3ZlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZiAoIXRoaXMudHJhY2tpbmdDbGljaykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgdGhlIHRvdWNoIGhhcyBtb3ZlZCwgY2FuY2VsIHRoZSBjbGljayB0cmFja2luZ1xuXHRcdGlmICh0aGlzLnRhcmdldEVsZW1lbnQgIT09IHRoaXMuZ2V0VGFyZ2V0RWxlbWVudEZyb21FdmVudFRhcmdldChldmVudC50YXJnZXQpIHx8IHRoaXMudG91Y2hIYXNNb3ZlZChldmVudCkpIHtcblx0XHRcdHRoaXMudHJhY2tpbmdDbGljayA9IGZhbHNlO1xuXHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGZpbmQgdGhlIGxhYmVsbGVkIGNvbnRyb2wgZm9yIHRoZSBnaXZlbiBsYWJlbCBlbGVtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEhUTUxMYWJlbEVsZW1lbnR9IGxhYmVsRWxlbWVudFxuXHQgKiBAcmV0dXJucyB7RWxlbWVudHxudWxsfVxuXHQgKi9cblx0RmFzdENsaWNrLnByb3RvdHlwZS5maW5kQ29udHJvbCA9IGZ1bmN0aW9uKGxhYmVsRWxlbWVudCkge1xuXG5cdFx0Ly8gRmFzdCBwYXRoIGZvciBuZXdlciBicm93c2VycyBzdXBwb3J0aW5nIHRoZSBIVE1MNSBjb250cm9sIGF0dHJpYnV0ZVxuXHRcdGlmIChsYWJlbEVsZW1lbnQuY29udHJvbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gbGFiZWxFbGVtZW50LmNvbnRyb2w7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGJyb3dzZXJzIHVuZGVyIHRlc3QgdGhhdCBzdXBwb3J0IHRvdWNoIGV2ZW50cyBhbHNvIHN1cHBvcnQgdGhlIEhUTUw1IGh0bWxGb3IgYXR0cmlidXRlXG5cdFx0aWYgKGxhYmVsRWxlbWVudC5odG1sRm9yKSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobGFiZWxFbGVtZW50Lmh0bWxGb3IpO1xuXHRcdH1cblxuXHRcdC8vIElmIG5vIGZvciBhdHRyaWJ1dGUgZXhpc3RzLCBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZSBmaXJzdCBsYWJlbGxhYmxlIGRlc2NlbmRhbnQgZWxlbWVudFxuXHRcdC8vIHRoZSBsaXN0IG9mIHdoaWNoIGlzIGRlZmluZWQgaGVyZTogaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNjYXRlZ29yeS1sYWJlbFxuXHRcdHJldHVybiBsYWJlbEVsZW1lbnQucXVlcnlTZWxlY3RvcignYnV0dG9uLCBpbnB1dDpub3QoW3R5cGU9aGlkZGVuXSksIGtleWdlbiwgbWV0ZXIsIG91dHB1dCwgcHJvZ3Jlc3MsIHNlbGVjdCwgdGV4dGFyZWEnKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBPbiB0b3VjaCBlbmQsIGRldGVybWluZSB3aGV0aGVyIHRvIHNlbmQgYSBjbGljayBldmVudCBhdCBvbmNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdEZhc3RDbGljay5wcm90b3R5cGUub25Ub3VjaEVuZCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIGZvckVsZW1lbnQsIHRyYWNraW5nQ2xpY2tTdGFydCwgdGFyZ2V0VGFnTmFtZSwgc2Nyb2xsUGFyZW50LCB0b3VjaCwgdGFyZ2V0RWxlbWVudCA9IHRoaXMudGFyZ2V0RWxlbWVudDtcblxuXHRcdGlmICghdGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBQcmV2ZW50IHBoYW50b20gY2xpY2tzIG9uIGZhc3QgZG91YmxlLXRhcCAoaXNzdWUgIzM2KVxuXHRcdGlmICgoZXZlbnQudGltZVN0YW1wIC0gdGhpcy5sYXN0Q2xpY2tUaW1lKSA8IHRoaXMudGFwRGVsYXkgJiYgKGV2ZW50LnRpbWVTdGFtcCAtIHRoaXMubGFzdENsaWNrVGltZSkgPiAtMSkge1xuXHRcdFx0dGhpcy5jYW5jZWxOZXh0Q2xpY2sgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKChldmVudC50aW1lU3RhbXAgLSB0aGlzLnRyYWNraW5nQ2xpY2tTdGFydCkgPiB0aGlzLnRhcFRpbWVvdXQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFJlc2V0IHRvIHByZXZlbnQgd3JvbmcgY2xpY2sgY2FuY2VsIG9uIGlucHV0IChpc3N1ZSAjMTU2KS5cblx0XHR0aGlzLmNhbmNlbE5leHRDbGljayA9IGZhbHNlO1xuXG5cdFx0dGhpcy5sYXN0Q2xpY2tUaW1lID0gZXZlbnQudGltZVN0YW1wO1xuXG5cdFx0dHJhY2tpbmdDbGlja1N0YXJ0ID0gdGhpcy50cmFja2luZ0NsaWNrU3RhcnQ7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0dGhpcy50cmFja2luZ0NsaWNrU3RhcnQgPSAwO1xuXG5cdFx0Ly8gT24gc29tZSBpT1MgZGV2aWNlcywgdGhlIHRhcmdldEVsZW1lbnQgc3VwcGxpZWQgd2l0aCB0aGUgZXZlbnQgaXMgaW52YWxpZCBpZiB0aGUgbGF5ZXJcblx0XHQvLyBpcyBwZXJmb3JtaW5nIGEgdHJhbnNpdGlvbiBvciBzY3JvbGwsIGFuZCBoYXMgdG8gYmUgcmUtZGV0ZWN0ZWQgbWFudWFsbHkuIE5vdGUgdGhhdFxuXHRcdC8vIGZvciB0aGlzIHRvIGZ1bmN0aW9uIGNvcnJlY3RseSwgaXQgbXVzdCBiZSBjYWxsZWQgKmFmdGVyKiB0aGUgZXZlbnQgdGFyZ2V0IGlzIGNoZWNrZWQhXG5cdFx0Ly8gU2VlIGlzc3VlICM1NzsgYWxzbyBmaWxlZCBhcyByZGFyOi8vMTMwNDg1ODkgLlxuXHRcdGlmIChkZXZpY2VJc0lPU1dpdGhCYWRUYXJnZXQpIHtcblx0XHRcdHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cblx0XHRcdC8vIEluIGNlcnRhaW4gY2FzZXMgYXJndW1lbnRzIG9mIGVsZW1lbnRGcm9tUG9pbnQgY2FuIGJlIG5lZ2F0aXZlLCBzbyBwcmV2ZW50IHNldHRpbmcgdGFyZ2V0RWxlbWVudCB0byBudWxsXG5cdFx0XHR0YXJnZXRFbGVtZW50ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5wYWdlWCAtIHdpbmRvdy5wYWdlWE9mZnNldCwgdG91Y2gucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQpIHx8IHRhcmdldEVsZW1lbnQ7XG5cdFx0XHR0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudCA9IHRoaXMudGFyZ2V0RWxlbWVudC5mYXN0Q2xpY2tTY3JvbGxQYXJlbnQ7XG5cdFx0fVxuXG5cdFx0dGFyZ2V0VGFnTmFtZSA9IHRhcmdldEVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmICh0YXJnZXRUYWdOYW1lID09PSAnbGFiZWwnKSB7XG5cdFx0XHRmb3JFbGVtZW50ID0gdGhpcy5maW5kQ29udHJvbCh0YXJnZXRFbGVtZW50KTtcblx0XHRcdGlmIChmb3JFbGVtZW50KSB7XG5cdFx0XHRcdHRoaXMuZm9jdXModGFyZ2V0RWxlbWVudCk7XG5cdFx0XHRcdGlmIChkZXZpY2VJc0FuZHJvaWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YXJnZXRFbGVtZW50ID0gZm9yRWxlbWVudDtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHRoaXMubmVlZHNGb2N1cyh0YXJnZXRFbGVtZW50KSkge1xuXG5cdFx0XHQvLyBDYXNlIDE6IElmIHRoZSB0b3VjaCBzdGFydGVkIGEgd2hpbGUgYWdvIChiZXN0IGd1ZXNzIGlzIDEwMG1zIGJhc2VkIG9uIHRlc3RzIGZvciBpc3N1ZSAjMzYpIHRoZW4gZm9jdXMgd2lsbCBiZSB0cmlnZ2VyZWQgYW55d2F5LiBSZXR1cm4gZWFybHkgYW5kIHVuc2V0IHRoZSB0YXJnZXQgZWxlbWVudCByZWZlcmVuY2Ugc28gdGhhdCB0aGUgc3Vic2VxdWVudCBjbGljayB3aWxsIGJlIGFsbG93ZWQgdGhyb3VnaC5cblx0XHRcdC8vIENhc2UgMjogV2l0aG91dCB0aGlzIGV4Y2VwdGlvbiBmb3IgaW5wdXQgZWxlbWVudHMgdGFwcGVkIHdoZW4gdGhlIGRvY3VtZW50IGlzIGNvbnRhaW5lZCBpbiBhbiBpZnJhbWUsIHRoZW4gYW55IGlucHV0dGVkIHRleHQgd29uJ3QgYmUgdmlzaWJsZSBldmVuIHRob3VnaCB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIHVwZGF0ZWQgYXMgdGhlIHVzZXIgdHlwZXMgKGlzc3VlICMzNykuXG5cdFx0XHRpZiAoKGV2ZW50LnRpbWVTdGFtcCAtIHRyYWNraW5nQ2xpY2tTdGFydCkgPiAxMDAgfHwgKGRldmljZUlzSU9TICYmIHdpbmRvdy50b3AgIT09IHdpbmRvdyAmJiB0YXJnZXRUYWdOYW1lID09PSAnaW5wdXQnKSkge1xuXHRcdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZm9jdXModGFyZ2V0RWxlbWVudCk7XG5cdFx0XHR0aGlzLnNlbmRDbGljayh0YXJnZXRFbGVtZW50LCBldmVudCk7XG5cblx0XHRcdC8vIFNlbGVjdCBlbGVtZW50cyBuZWVkIHRoZSBldmVudCB0byBnbyB0aHJvdWdoIG9uIGlPUyA0LCBvdGhlcndpc2UgdGhlIHNlbGVjdG9yIG1lbnUgd29uJ3Qgb3Blbi5cblx0XHRcdC8vIEFsc28gdGhpcyBicmVha3Mgb3BlbmluZyBzZWxlY3RzIHdoZW4gVm9pY2VPdmVyIGlzIGFjdGl2ZSBvbiBpT1M2LCBpT1M3IChhbmQgcG9zc2libHkgb3RoZXJzKVxuXHRcdFx0aWYgKCFkZXZpY2VJc0lPUzQgfHwgdGFyZ2V0VGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dGhpcy50YXJnZXRFbGVtZW50ID0gbnVsbDtcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChkZXZpY2VJc0lPUyAmJiAhZGV2aWNlSXNJT1M0KSB7XG5cblx0XHRcdC8vIERvbid0IHNlbmQgYSBzeW50aGV0aWMgY2xpY2sgZXZlbnQgaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGF5ZXIgdGhhdCB3YXMgc2Nyb2xsZWRcblx0XHRcdC8vIGFuZCB0aGlzIHRhcCBpcyBiZWluZyB1c2VkIHRvIHN0b3AgdGhlIHNjcm9sbGluZyAodXN1YWxseSBpbml0aWF0ZWQgYnkgYSBmbGluZyAtIGlzc3VlICM0MikuXG5cdFx0XHRzY3JvbGxQYXJlbnQgPSB0YXJnZXRFbGVtZW50LmZhc3RDbGlja1Njcm9sbFBhcmVudDtcblx0XHRcdGlmIChzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50LmZhc3RDbGlja0xhc3RTY3JvbGxUb3AgIT09IHNjcm9sbFBhcmVudC5zY3JvbGxUb3ApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJldmVudCB0aGUgYWN0dWFsIGNsaWNrIGZyb20gZ29pbmcgdGhvdWdoIC0gdW5sZXNzIHRoZSB0YXJnZXQgbm9kZSBpcyBtYXJrZWQgYXMgcmVxdWlyaW5nXG5cdFx0Ly8gcmVhbCBjbGlja3Mgb3IgaWYgaXQgaXMgaW4gdGhlIHdoaXRlbGlzdCBpbiB3aGljaCBjYXNlIG9ubHkgbm9uLXByb2dyYW1tYXRpYyBjbGlja3MgYXJlIHBlcm1pdHRlZC5cblx0XHRpZiAoIXRoaXMubmVlZHNDbGljayh0YXJnZXRFbGVtZW50KSkge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdHRoaXMuc2VuZENsaWNrKHRhcmdldEVsZW1lbnQsIGV2ZW50KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblxuXHQvKipcblx0ICogT24gdG91Y2ggY2FuY2VsLCBzdG9wIHRyYWNraW5nIHRoZSBjbGljay5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uVG91Y2hDYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYWNraW5nQ2xpY2sgPSBmYWxzZTtcblx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIERldGVybWluZSBtb3VzZSBldmVudHMgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uTW91c2UgPSBmdW5jdGlvbihldmVudCkge1xuXG5cdFx0Ly8gSWYgYSB0YXJnZXQgZWxlbWVudCB3YXMgbmV2ZXIgc2V0IChiZWNhdXNlIGEgdG91Y2ggZXZlbnQgd2FzIG5ldmVyIGZpcmVkKSBhbGxvdyB0aGUgZXZlbnRcblx0XHRpZiAoIXRoaXMudGFyZ2V0RWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmZvcndhcmRlZFRvdWNoRXZlbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIFByb2dyYW1tYXRpY2FsbHkgZ2VuZXJhdGVkIGV2ZW50cyB0YXJnZXRpbmcgYSBzcGVjaWZpYyBlbGVtZW50IHNob3VsZCBiZSBwZXJtaXR0ZWRcblx0XHRpZiAoIWV2ZW50LmNhbmNlbGFibGUpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIERlcml2ZSBhbmQgY2hlY2sgdGhlIHRhcmdldCBlbGVtZW50IHRvIHNlZSB3aGV0aGVyIHRoZSBtb3VzZSBldmVudCBuZWVkcyB0byBiZSBwZXJtaXR0ZWQ7XG5cdFx0Ly8gdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZCwgcHJldmVudCBub24tdG91Y2ggY2xpY2sgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBhY3Rpb25zLFxuXHRcdC8vIHRvIHByZXZlbnQgZ2hvc3QvZG91YmxlY2xpY2tzLlxuXHRcdGlmICghdGhpcy5uZWVkc0NsaWNrKHRoaXMudGFyZ2V0RWxlbWVudCkgfHwgdGhpcy5jYW5jZWxOZXh0Q2xpY2spIHtcblxuXHRcdFx0Ly8gUHJldmVudCBhbnkgdXNlci1hZGRlZCBsaXN0ZW5lcnMgZGVjbGFyZWQgb24gRmFzdENsaWNrIGVsZW1lbnQgZnJvbSBiZWluZyBmaXJlZC5cblx0XHRcdGlmIChldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24pIHtcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIFBhcnQgb2YgdGhlIGhhY2sgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBFdmVudCNzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gKGUuZy4gQW5kcm9pZCAyKVxuXHRcdFx0XHRldmVudC5wcm9wYWdhdGlvblN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDYW5jZWwgdGhlIGV2ZW50XG5cdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGUgbW91c2UgZXZlbnQgaXMgcGVybWl0dGVkLCByZXR1cm4gdHJ1ZSBmb3IgdGhlIGFjdGlvbiB0byBnbyB0aHJvdWdoLlxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIE9uIGFjdHVhbCBjbGlja3MsIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSB0b3VjaC1nZW5lcmF0ZWQgY2xpY2ssIGEgY2xpY2sgYWN0aW9uIG9jY3VycmluZ1xuXHQgKiBuYXR1cmFsbHkgYWZ0ZXIgYSBkZWxheSBhZnRlciBhIHRvdWNoICh3aGljaCBuZWVkcyB0byBiZSBjYW5jZWxsZWQgdG8gYXZvaWQgZHVwbGljYXRpb24pLCBvclxuXHQgKiBhbiBhY3R1YWwgY2xpY2sgd2hpY2ggc2hvdWxkIGJlIHBlcm1pdHRlZC5cblx0ICpcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciBwZXJtaXR0ZWQ7XG5cblx0XHQvLyBJdCdzIHBvc3NpYmxlIGZvciBhbm90aGVyIEZhc3RDbGljay1saWtlIGxpYnJhcnkgZGVsaXZlcmVkIHdpdGggdGhpcmQtcGFydHkgY29kZSB0byBmaXJlIGEgY2xpY2sgZXZlbnQgYmVmb3JlIEZhc3RDbGljayBkb2VzIChpc3N1ZSAjNDQpLiBJbiB0aGF0IGNhc2UsIHNldCB0aGUgY2xpY2stdHJhY2tpbmcgZmxhZyBiYWNrIHRvIGZhbHNlIGFuZCByZXR1cm4gZWFybHkuIFRoaXMgd2lsbCBjYXVzZSBvblRvdWNoRW5kIHRvIHJldHVybiBlYXJseS5cblx0XHRpZiAodGhpcy50cmFja2luZ0NsaWNrKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVsZW1lbnQgPSBudWxsO1xuXHRcdFx0dGhpcy50cmFja2luZ0NsaWNrID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBWZXJ5IG9kZCBiZWhhdmlvdXIgb24gaU9TIChpc3N1ZSAjMTgpOiBpZiBhIHN1Ym1pdCBlbGVtZW50IGlzIHByZXNlbnQgaW5zaWRlIGEgZm9ybSBhbmQgdGhlIHVzZXIgaGl0cyBlbnRlciBpbiB0aGUgaU9TIHNpbXVsYXRvciBvciBjbGlja3MgdGhlIEdvIGJ1dHRvbiBvbiB0aGUgcG9wLXVwIE9TIGtleWJvYXJkIHRoZSBhIGtpbmQgb2YgJ2Zha2UnIGNsaWNrIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkIHdpdGggdGhlIHN1Ym1pdC10eXBlIGlucHV0IGVsZW1lbnQgYXMgdGhlIHRhcmdldC5cblx0XHRpZiAoZXZlbnQudGFyZ2V0LnR5cGUgPT09ICdzdWJtaXQnICYmIGV2ZW50LmRldGFpbCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cGVybWl0dGVkID0gdGhpcy5vbk1vdXNlKGV2ZW50KTtcblxuXHRcdC8vIE9ubHkgdW5zZXQgdGFyZ2V0RWxlbWVudCBpZiB0aGUgY2xpY2sgaXMgbm90IHBlcm1pdHRlZC4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHRoZSBjaGVjayBmb3IgIXRhcmdldEVsZW1lbnQgaW4gb25Nb3VzZSBmYWlscyBhbmQgdGhlIGJyb3dzZXIncyBjbGljayBkb2Vzbid0IGdvIHRocm91Z2guXG5cdFx0aWYgKCFwZXJtaXR0ZWQpIHtcblx0XHRcdHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgY2xpY2tzIGFyZSBwZXJtaXR0ZWQsIHJldHVybiB0cnVlIGZvciB0aGUgYWN0aW9uIHRvIGdvIHRocm91Z2guXG5cdFx0cmV0dXJuIHBlcm1pdHRlZDtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYWxsIEZhc3RDbGljaydzIGV2ZW50IGxpc3RlbmVycy5cblx0ICpcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuXHRGYXN0Q2xpY2sucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLmxheWVyO1xuXG5cdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZSwgdHJ1ZSk7XG5cdFx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlLCB0cnVlKTtcblx0XHR9XG5cblx0XHRsYXllci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljaywgdHJ1ZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Ub3VjaFN0YXJ0LCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblRvdWNoTW92ZSwgZmFsc2UpO1xuXHRcdGxheWVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblRvdWNoRW5kLCBmYWxzZSk7XG5cdFx0bGF5ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uVG91Y2hDYW5jZWwsIGZhbHNlKTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIEZhc3RDbGljayBpcyBuZWVkZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKi9cblx0RmFzdENsaWNrLm5vdE5lZWRlZCA9IGZ1bmN0aW9uKGxheWVyKSB7XG5cdFx0dmFyIG1ldGFWaWV3cG9ydDtcblx0XHR2YXIgY2hyb21lVmVyc2lvbjtcblx0XHR2YXIgYmxhY2tiZXJyeVZlcnNpb247XG5cdFx0dmFyIGZpcmVmb3hWZXJzaW9uO1xuXG5cdFx0Ly8gRGV2aWNlcyB0aGF0IGRvbid0IHN1cHBvcnQgdG91Y2ggZG9uJ3QgbmVlZCBGYXN0Q2xpY2tcblx0XHRpZiAodHlwZW9mIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvLyBDaHJvbWUgdmVyc2lvbiAtIHplcm8gZm9yIG90aGVyIGJyb3dzZXJzXG5cdFx0Y2hyb21lVmVyc2lvbiA9ICsoL0Nocm9tZVxcLyhbMC05XSspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFssMF0pWzFdO1xuXG5cdFx0aWYgKGNocm9tZVZlcnNpb24pIHtcblxuXHRcdFx0aWYgKGRldmljZUlzQW5kcm9pZCkge1xuXHRcdFx0XHRtZXRhVmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cblx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydCkge1xuXHRcdFx0XHRcdC8vIENocm9tZSBvbiBBbmRyb2lkIHdpdGggdXNlci1zY2FsYWJsZT1cIm5vXCIgZG9lc24ndCBuZWVkIEZhc3RDbGljayAoaXNzdWUgIzg5KVxuXHRcdFx0XHRcdGlmIChtZXRhVmlld3BvcnQuY29udGVudC5pbmRleE9mKCd1c2VyLXNjYWxhYmxlPW5vJykgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gQ2hyb21lIDMyIGFuZCBhYm92ZSB3aXRoIHdpZHRoPWRldmljZS13aWR0aCBvciBsZXNzIGRvbid0IG5lZWQgRmFzdENsaWNrXG5cdFx0XHRcdFx0aWYgKGNocm9tZVZlcnNpb24gPiAzMSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGggPD0gd2luZG93Lm91dGVyV2lkdGgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBDaHJvbWUgZGVza3RvcCBkb2Vzbid0IG5lZWQgRmFzdENsaWNrIChpc3N1ZSAjMTUpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGV2aWNlSXNCbGFja0JlcnJ5MTApIHtcblx0XHRcdGJsYWNrYmVycnlWZXJzaW9uID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcLyhbMC05XSopXFwuKFswLTldKikvKTtcblxuXHRcdFx0Ly8gQmxhY2tCZXJyeSAxMC4zKyBkb2VzIG5vdCByZXF1aXJlIEZhc3RjbGljayBsaWJyYXJ5LlxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svaXNzdWVzLzI1MVxuXHRcdFx0aWYgKGJsYWNrYmVycnlWZXJzaW9uWzFdID49IDEwICYmIGJsYWNrYmVycnlWZXJzaW9uWzJdID49IDMpIHtcblx0XHRcdFx0bWV0YVZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPXZpZXdwb3J0XScpO1xuXG5cdFx0XHRcdGlmIChtZXRhVmlld3BvcnQpIHtcblx0XHRcdFx0XHQvLyB1c2VyLXNjYWxhYmxlPW5vIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB3aWR0aD1kZXZpY2Utd2lkdGggKG9yIGxlc3MgdGhhbiBkZXZpY2Utd2lkdGgpIGVsaW1pbmF0ZXMgY2xpY2sgZGVsYXkuXG5cdFx0XHRcdFx0aWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCA8PSB3aW5kb3cub3V0ZXJXaWR0aCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSUUxMCB3aXRoIC1tcy10b3VjaC1hY3Rpb246IG5vbmUgb3IgbWFuaXB1bGF0aW9uLCB3aGljaCBkaXNhYmxlcyBkb3VibGUtdGFwLXRvLXpvb20gKGlzc3VlICM5Nylcblx0XHRpZiAobGF5ZXIuc3R5bGUubXNUb3VjaEFjdGlvbiA9PT0gJ25vbmUnIHx8IGxheWVyLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnbWFuaXB1bGF0aW9uJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZWZveCB2ZXJzaW9uIC0gemVybyBmb3Igb3RoZXIgYnJvd3NlcnNcblx0XHRmaXJlZm94VmVyc2lvbiA9ICsoL0ZpcmVmb3hcXC8oWzAtOV0rKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbLDBdKVsxXTtcblxuXHRcdGlmIChmaXJlZm94VmVyc2lvbiA+PSAyNykge1xuXHRcdFx0Ly8gRmlyZWZveCAyNysgZG9lcyBub3QgaGF2ZSB0YXAgZGVsYXkgaWYgdGhlIGNvbnRlbnQgaXMgbm90IHpvb21hYmxlIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTIyODk2XG5cblx0XHRcdG1ldGFWaWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT12aWV3cG9ydF0nKTtcblx0XHRcdGlmIChtZXRhVmlld3BvcnQgJiYgKG1ldGFWaWV3cG9ydC5jb250ZW50LmluZGV4T2YoJ3VzZXItc2NhbGFibGU9bm8nKSAhPT0gLTEgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFdpZHRoIDw9IHdpbmRvdy5vdXRlcldpZHRoKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJRTExOiBwcmVmaXhlZCAtbXMtdG91Y2gtYWN0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYW5kIGl0J3MgcmVjb21lbmRlZCB0byB1c2Ugbm9uLXByZWZpeGVkIHZlcnNpb25cblx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9hcHBzL0hoNzY3MzEzLmFzcHhcblx0XHRpZiAobGF5ZXIuc3R5bGUudG91Y2hBY3Rpb24gPT09ICdub25lJyB8fCBsYXllci5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ21hbmlwdWxhdGlvbicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBGYXN0Q2xpY2sgb2JqZWN0XG5cdCAqXG5cdCAqIEBwYXJhbSB7RWxlbWVudH0gbGF5ZXIgVGhlIGxheWVyIHRvIGxpc3RlbiBvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0c1xuXHQgKi9cblx0RmFzdENsaWNrLmF0dGFjaCA9IGZ1bmN0aW9uKGxheWVyLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBGYXN0Q2xpY2sobGF5ZXIsIG9wdGlvbnMpO1xuXHR9O1xuXG5cblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gRmFzdENsaWNrO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBGYXN0Q2xpY2suYXR0YWNoO1xuXHRcdG1vZHVsZS5leHBvcnRzLkZhc3RDbGljayA9IEZhc3RDbGljaztcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuRmFzdENsaWNrID0gRmFzdENsaWNrO1xuXHR9XG59KCkpO1xuIiwiLy8gRm9yIEBvbnNlbnVpL2N1c3RvbS1lbGVtZW50c1xuaWYgKHdpbmRvdy5jdXN0b21FbGVtZW50cykgeyAvLyBldmVuIGlmIG5hdGl2ZSBDRTEgaW1wbCBleGlzdHMsIHVzZSBwb2x5ZmlsbFxuICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5mb3JjZVBvbHlmaWxsID0gdHJ1ZTtcbn1cbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMScgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBTUkMgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJyk7XG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciAkdG9TdHJpbmcgPSBGdW5jdGlvbltUT19TVFJJTkddO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuICR0b1N0cmluZy5jYWxsKGl0KTtcbn07XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbCwgc2FmZSkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYgKE9ba2V5XSA9PT0gdmFsKSByZXR1cm47XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYgKE8gPT09IGdsb2JhbCkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIGlmICghc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH0gZWxzZSBpZiAoT1trZXldKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2Uge1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgVE9fU1RSSU5HLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbiAodHlwZSwgbmFtZSwgc291cmNlKSB7XG4gIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GO1xuICB2YXIgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuRztcbiAgdmFyIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlM7XG4gIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7XG4gIHZhciBJU19CSU5EID0gdHlwZSAmICRleHBvcnQuQjtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSk7XG4gIHZhciBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSAob3duID8gdGFyZ2V0IDogc291cmNlKVtrZXldO1xuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgZXhwID0gSVNfQklORCAmJiBvd24gPyBjdHgob3V0LCBnbG9iYWwpIDogSVNfUFJPVE8gJiYgdHlwZW9mIG91dCA9PSAnZnVuY3Rpb24nID8gY3R4KEZ1bmN0aW9uLmNhbGwsIG91dCkgOiBvdXQ7XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIGlmICh0YXJnZXQpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmIChleHBvcnRzW2tleV0gIT0gb3V0KSBoaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZiAoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpIGV4cFByb3RvW2tleV0gPSBvdXQ7XG4gIH1cbn07XG5nbG9iYWwuY29yZSA9IGNvcmU7XG4vLyB0eXBlIGJpdG1hcFxuJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWRcbiRleHBvcnQuRyA9IDI7ICAgLy8gZ2xvYmFsXG4kZXhwb3J0LlMgPSA0OyAgIC8vIHN0YXRpY1xuJGV4cG9ydC5QID0gODsgICAvLyBwcm90b1xuJGV4cG9ydC5CID0gMTY7ICAvLyBiaW5kXG4kZXhwb3J0LlcgPSAzMjsgIC8vIHdyYXBcbiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZVxuJGV4cG9ydC5SID0gMTI4OyAvLyByZWFsIHByb3RvIG1ldGhvZCBmb3IgYGxpYnJhcnlgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChPLCBwcm90bykge1xuICBhbk9iamVjdChPKTtcbiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArIFwiOiBjYW4ndCBzZXQgYXMgcHJvdG90eXBlIVwiKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaCAoZSkgeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmIChidWdneSkgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59O1xuIiwiLy8gMTkuMS4zLjE5IE9iamVjdC5zZXRQcm90b3R5cGVPZihPLCBwcm90bylcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldCB9KTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciB0ZXN0ID0ge307XG50ZXN0W3JlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpXSA9ICd6JztcbmlmICh0ZXN0ICsgJycgIT0gJ1tvYmplY3Qgel0nKSB7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xuICB9LCB0cnVlKTtcbn1cbiIsIi8vIDcuMS40IFRvSW50ZWdlclxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTtcbiIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIi8vIDIyLjEuMy4zMSBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbnZhciBVTlNDT1BBQkxFUyA9IHJlcXVpcmUoJy4vX3drcycpKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b1tVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSByZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvW1VOU0NPUEFCTEVTXVtrZXldID0gdHJ1ZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCJ2YXIgJGl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIHNhZmUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRZUEUpIHtcbiAgaWYgKCFpc09iamVjdChpdCkgfHwgaXQuX3QgIT09IFRZUEUpIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQhJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGNyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgJGl0ZXJEZWZpbmUgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi9fc2V0LXNwZWNpZXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFzdEtleSA9IHJlcXVpcmUoJy4vX21ldGEnKS5mYXN0S2V5O1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFNJWkUgPSBERVNDUklQVE9SUyA/ICdfcycgOiAnc2l6ZSc7XG5cbnZhciBnZXRFbnRyeSA9IGZ1bmN0aW9uICh0aGF0LCBrZXkpIHtcbiAgLy8gZmFzdCBjYXNlXG4gIHZhciBpbmRleCA9IGZhc3RLZXkoa2V5KTtcbiAgdmFyIGVudHJ5O1xuICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHRoYXQuX2lbaW5kZXhdO1xuICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgZm9yIChlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICBpZiAoZW50cnkuayA9PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBjcmVhdGUobnVsbCk7IC8vIGluZGV4XG4gICAgICB0aGF0Ll9mID0gdW5kZWZpbmVkOyAgICAvLyBmaXJzdCBlbnRyeVxuICAgICAgdGhhdC5fbCA9IHVuZGVmaW5lZDsgICAgLy8gbGFzdCBlbnRyeVxuICAgICAgdGhhdFtTSVpFXSA9IDA7ICAgICAgICAgLy8gc2l6ZVxuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4xLjMuMSBNYXAucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIC8vIDIzLjIuMy4yIFNldC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICBmb3IgKHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSksIGRhdGEgPSB0aGF0Ll9pLCBlbnRyeSA9IHRoYXQuX2Y7IGVudHJ5OyBlbnRyeSA9IGVudHJ5Lm4pIHtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucCkgZW50cnkucCA9IGVudHJ5LnAubiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGF0Ll9mID0gdGhhdC5fbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhhdFtTSVpFXSA9IDA7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjMgTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuMi4zLjQgU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm47XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wO1xuICAgICAgICAgIGRlbGV0ZSB0aGF0Ll9pW2VudHJ5LmldO1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnAgPSBwcmV2O1xuICAgICAgICAgIGlmICh0aGF0Ll9mID09IGVudHJ5KSB0aGF0Ll9mID0gbmV4dDtcbiAgICAgICAgICBpZiAodGhhdC5fbCA9PSBlbnRyeSkgdGhhdC5fbCA9IHByZXY7XG4gICAgICAgICAgdGhhdFtTSVpFXS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjIuMy42IFNldC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgLy8gMjMuMS4zLjUgTWFwLnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhbGlkYXRlKHRoaXMsIE5BTUUpO1xuICAgICAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgICAgIHZhciBlbnRyeTtcbiAgICAgICAgd2hpbGUgKGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhpcy5fZikge1xuICAgICAgICAgIGYoZW50cnkudiwgZW50cnkuaywgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy43IE1hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjIuMy43IFNldC5wcm90b3R5cGUuaGFzKHZhbHVlKVxuICAgICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUykgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh0aGlzLCBOQU1FKVtTSVpFXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgZGVmOiBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgdmFyIHByZXYsIGluZGV4O1xuICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgIGlmIChlbnRyeSkge1xuICAgICAgZW50cnkudiA9IHZhbHVlO1xuICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fbCA9IGVudHJ5ID0ge1xuICAgICAgICBpOiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSwgLy8gPC0gaW5kZXhcbiAgICAgICAgazoga2V5LCAgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIGtleVxuICAgICAgICB2OiB2YWx1ZSwgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gdmFsdWVcbiAgICAgICAgcDogcHJldiA9IHRoYXQuX2wsICAgICAgICAgICAgIC8vIDwtIHByZXZpb3VzIGVudHJ5XG4gICAgICAgIG46IHVuZGVmaW5lZCwgICAgICAgICAgICAgICAgICAvLyA8LSBuZXh0IGVudHJ5XG4gICAgICAgIHI6IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSByZW1vdmVkXG4gICAgICB9O1xuICAgICAgaWYgKCF0aGF0Ll9mKSB0aGF0Ll9mID0gZW50cnk7XG4gICAgICBpZiAocHJldikgcHJldi5uID0gZW50cnk7XG4gICAgICB0aGF0W1NJWkVdKys7XG4gICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgIGlmIChpbmRleCAhPT0gJ0YnKSB0aGF0Ll9pW2luZGV4XSA9IGVudHJ5O1xuICAgIH0gcmV0dXJuIHRoYXQ7XG4gIH0sXG4gIGdldEVudHJ5OiBnZXRFbnRyeSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgTkFNRSwgSVNfTUFQKSB7XG4gICAgLy8gYWRkIC5rZXlzLCAudmFsdWVzLCAuZW50cmllcywgW0BAaXRlcmF0b3JdXG4gICAgLy8gMjMuMS4zLjQsIDIzLjEuMy44LCAyMy4xLjMuMTEsIDIzLjEuMy4xMiwgMjMuMi4zLjUsIDIzLjIuMy44LCAyMy4yLjMuMTAsIDIzLjIuMy4xMVxuICAgICRpdGVyRGVmaW5lKEMsIE5BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgdGhpcy5fdCA9IHZhbGlkYXRlKGl0ZXJhdGVkLCBOQU1FKTsgLy8gdGFyZ2V0XG4gICAgICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gICAgICB0aGlzLl9sID0gdW5kZWZpbmVkOyAgICAgICAgICAgICAgICAvLyBwcmV2aW91c1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBraW5kID0gdGhhdC5faztcbiAgICAgIHZhciBlbnRyeSA9IHRoYXQuX2w7XG4gICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCF0aGF0Ll90IHx8ICEodGhhdC5fbCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uIDogdGhhdC5fdC5fZikpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgdGhhdC5fdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHN0ZXAoMSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGVudHJ5LmspO1xuICAgICAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIGVudHJ5LnYpO1xuICAgICAgcmV0dXJuIHN0ZXAoMCwgW2VudHJ5LmssIGVudHJ5LnZdKTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBhZGQgW0BAc3BlY2llc10sIDIzLjEuMi4yLCAyMy4yLjIuMlxuICAgIHNldFNwZWNpZXMoTkFNRSk7XG4gIH1cbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0aGF0LCB0YXJnZXQsIEMpIHtcbiAgdmFyIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIHZhciBQO1xuICBpZiAoUyAhPT0gQyAmJiB0eXBlb2YgUyA9PSAnZnVuY3Rpb24nICYmIChQID0gUy5wcm90b3R5cGUpICE9PSBDLnByb3RvdHlwZSAmJiBpc09iamVjdChQKSAmJiBzZXRQcm90b3R5cGVPZikge1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyICRpdGVyRGV0ZWN0ID0gcmVxdWlyZSgnLi9faXRlci1kZXRlY3QnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG4gIHZhciBCYXNlID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgQyA9IEJhc2U7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBwcm90byA9IEMgJiYgQy5wcm90b3R5cGU7XG4gIHZhciBPID0ge307XG4gIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG4gICAgdmFyIGZuID0gcHJvdG9bS0VZXTtcbiAgICByZWRlZmluZShwcm90bywgS0VZLFxuICAgICAgS0VZID09ICdkZWxldGUnID8gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gZmFsc2UgOiBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gdW5kZWZpbmVkIDogZm4uY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgfSA6IEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZChhKSB7IGZuLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgOiBmdW5jdGlvbiBzZXQoYSwgYikgeyBmbi5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSwgYik7IHJldHVybiB0aGlzOyB9XG4gICAgKTtcbiAgfTtcbiAgaWYgKHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgIC8vIGVhcmx5IGltcGxlbWVudGF0aW9ucyBub3Qgc3VwcG9ydHMgY2hhaW5pbmdcbiAgICB2YXIgSEFTTlRfQ0hBSU5JTkcgPSBpbnN0YW5jZVtBRERFUl0oSVNfV0VBSyA/IHt9IDogLTAsIDEpICE9IGluc3RhbmNlO1xuICAgIC8vIFY4IH4gIENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgIHZhciBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgaW5zdGFuY2UuaGFzKDEpOyB9KTtcbiAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgdmFyIEFDQ0VQVF9JVEVSQUJMRVMgPSAkaXRlckRldGVjdChmdW5jdGlvbiAoaXRlcikgeyBuZXcgQyhpdGVyKTsgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgdmFyIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgQygpO1xuICAgICAgdmFyIGluZGV4ID0gNTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSAkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG4gICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgIH0pO1xuICAgIGlmICghQUNDRVBUX0lURVJBQkxFUykge1xuICAgICAgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRhcmdldCwgaXRlcmFibGUpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKCksIHRhcmdldCwgQyk7XG4gICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIEMucHJvdG90eXBlID0gcHJvdG87XG4gICAgICBwcm90by5jb25zdHJ1Y3RvciA9IEM7XG4gICAgfVxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cbiAgICBpZiAoQlVHR1lfWkVSTyB8fCBIQVNOVF9DSEFJTklORykgZml4TWV0aG9kKEFEREVSKTtcbiAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIHNob3VsZCBub3QgY29udGFpbnMgLmNsZWFyIG1ldGhvZFxuICAgIGlmIChJU19XRUFLICYmIHByb3RvLmNsZWFyKSBkZWxldGUgcHJvdG8uY2xlYXI7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAoQyAhPSBCYXNlKSwgTyk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKEMsIE5BTUUsIElTX01BUCk7XG5cbiAgcmV0dXJuIEM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi9fYXJyYXktZnJvbS1pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICByZXR1cm4gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIGlmIChjbGFzc29mKHRoaXMpICE9IE5BTUUpIHRocm93IFR5cGVFcnJvcihOQU1FICsgXCIjdG9KU09OIGlzbid0IGdlbmVyaWNcIik7XG4gICAgcmV0dXJuIGZyb20odGhpcyk7XG4gIH07XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdTZXQnLCB7IHRvSlNPTjogcmVxdWlyZSgnLi9fY29sbGVjdGlvbi10by1qc29uJykoJ1NldCcpIH0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnU2V0Jyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IGZyb206IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwRm4sIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgbWFwRm4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1hcHBpbmcsIEEsIG4sIGNiO1xuICAgIGFGdW5jdGlvbih0aGlzKTtcbiAgICBtYXBwaW5nID0gbWFwRm4gIT09IHVuZGVmaW5lZDtcbiAgICBpZiAobWFwcGluZykgYUZ1bmN0aW9uKG1hcEZuKTtcbiAgICBpZiAoc291cmNlID09IHVuZGVmaW5lZCkgcmV0dXJuIG5ldyB0aGlzKCk7XG4gICAgQSA9IFtdO1xuICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICBuID0gMDtcbiAgICAgIGNiID0gY3R4KG1hcEZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgZnVuY3Rpb24gKG5leHRJdGVtKSB7XG4gICAgICAgIEEucHVzaChjYihuZXh0SXRlbSwgbisrKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yT2Yoc291cmNlLCBmYWxzZSwgQS5wdXNoLCBBKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1NldCcpO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnNldCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0LnRvLWpzb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0LmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlNldDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdHJvbmcgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXN0cm9uZycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIE1BUCA9ICdNYXAnO1xuXG4vLyAyMy4xIE1hcCBPYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24nKShNQVAsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIE1hcCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCB7XG4gIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gc3Ryb25nLmdldEVudHJ5KHZhbGlkYXRlKHRoaXMsIE1BUCksIGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnY7XG4gIH0sXG4gIC8vIDIzLjEuMy45IE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBNQVApLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZywgdHJ1ZSk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ01hcCcsIHsgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnTWFwJykgfSk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1tYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnTWFwJyk7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYubWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5tYXAudG8tanNvbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcubWFwLm9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5tYXAuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuTWFwO1xuIiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi9faXMtYXJyYXknKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsKSkge1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmIChDID09PSBudWxsKSBDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTtcbiIsIi8vIDkuNC4yLjMgQXJyYXlTcGVjaWVzQ3JlYXRlKG9yaWdpbmFsQXJyYXksIGxlbmd0aClcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07XG4iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGdldFdlYWsgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2VhaztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbnZhciAkaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG52YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbnZhciBpZCA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAodGhhdCkge1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKCkpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX01BUCA9ICdXZWFrTWFwJztcbnZhciBnZXRXZWFrID0gbWV0YS5nZXRXZWFrO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZTtcbnZhciB0bXAgPSB7fTtcbnZhciBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCkpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19NQVApLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfTUFQLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDc7IH0pKSB7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcHJvdG8gPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mKSB0aGlzLl9mID0gbmV3IEludGVybmFsTWFwKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdXZWFrTWFwJyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnV2Vha01hcCcpO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcud2Vhay1tYXAub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLldlYWtNYXA7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4vX2l0ZXItY2FsbCcpO1xudmFyIGlzQXJyYXlJdGVyID0gcmVxdWlyZSgnLi9faXMtYXJyYXktaXRlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuL19jcmVhdGUtcHJvcGVydHknKTtcbnZhciBnZXRJdGVyRm4gPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19pdGVyLWRldGVjdCcpKGZ1bmN0aW9uIChpdGVyKSB7IEFycmF5LmZyb20oaXRlcik7IH0pLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMi4xIEFycmF5LmZyb20oYXJyYXlMaWtlLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgZnJvbTogZnVuY3Rpb24gZnJvbShhcnJheUxpa2UgLyogLCBtYXBmbiA9IHVuZGVmaW5lZCwgdGhpc0FyZyA9IHVuZGVmaW5lZCAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiAgICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gICAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtYXBmbiA9IGFMZW4gPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBpdGVyRm4gPSBnZXRJdGVyRm4oTyk7XG4gICAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgICBpZiAobWFwcGluZykgbWFwZm4gPSBjdHgobWFwZm4sIGFMZW4gPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgICAvLyBpZiBvYmplY3QgaXNuJ3QgaXRlcmFibGUgb3IgaXQncyBhcnJheSB3aXRoIGRlZmF1bHQgaXRlcmF0b3IgLSB1c2Ugc2ltcGxlIGNhc2VcbiAgICBpZiAoaXRlckZuICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXIoaXRlckZuKSkpIHtcbiAgICAgIGZvciAoaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChPKSwgcmVzdWx0ID0gbmV3IEMoKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBjYWxsKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSkgOiBzdGVwLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgICAgZm9yIChyZXN1bHQgPSBuZXcgQyhsZW5ndGgpOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mcm9tO1xuIiwiY29uc3QgcmVzZXJ2ZWRUYWdMaXN0ID0gbmV3IFNldChbXG4gICdhbm5vdGF0aW9uLXhtbCcsXG4gICdjb2xvci1wcm9maWxlJyxcbiAgJ2ZvbnQtZmFjZScsXG4gICdmb250LWZhY2Utc3JjJyxcbiAgJ2ZvbnQtZmFjZS11cmknLFxuICAnZm9udC1mYWNlLWZvcm1hdCcsXG4gICdmb250LWZhY2UtbmFtZScsXG4gICdtaXNzaW5nLWdseXBoJyxcbl0pO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEN1c3RvbUVsZW1lbnROYW1lKGxvY2FsTmFtZSkge1xuICBjb25zdCByZXNlcnZlZCA9IHJlc2VydmVkVGFnTGlzdC5oYXMobG9jYWxOYW1lKTtcbiAgY29uc3QgdmFsaWRGb3JtID0gL15bYS16XVsuMC05X2Etel0qLVtcXC0uMC05X2Etel0qJC8udGVzdChsb2NhbE5hbWUpO1xuICByZXR1cm4gIXJlc2VydmVkICYmIHZhbGlkRm9ybTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29ubmVjdGVkKG5vZGUpIHtcbiAgLy8gVXNlIGBOb2RlI2lzQ29ubmVjdGVkYCwgaWYgZGVmaW5lZC5cbiAgY29uc3QgbmF0aXZlVmFsdWUgPSBub2RlLmlzQ29ubmVjdGVkO1xuICBpZiAobmF0aXZlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuYXRpdmVWYWx1ZTtcbiAgfVxuXG4gIC8qKiBAdHlwZSB7P05vZGV8dW5kZWZpbmVkfSAqL1xuICBsZXQgY3VycmVudCA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50ICYmICEoY3VycmVudC5fX0NFX2lzSW1wb3J0RG9jdW1lbnQgfHwgY3VycmVudCBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgfHwgKHdpbmRvdy5TaGFkb3dSb290ICYmIGN1cnJlbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gY3VycmVudC5ob3N0IDogdW5kZWZpbmVkKTtcbiAgfVxuICByZXR1cm4gISEoY3VycmVudCAmJiAoY3VycmVudC5fX0NFX2lzSW1wb3J0RG9jdW1lbnQgfHwgY3VycmVudCBpbnN0YW5jZW9mIERvY3VtZW50KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICogQHBhcmFtIHshTm9kZX0gc3RhcnRcbiAqIEByZXR1cm4gez9Ob2RlfVxuICovXG5mdW5jdGlvbiBuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nKHJvb3QsIHN0YXJ0KSB7XG4gIGxldCBub2RlID0gc3RhcnQ7XG4gIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHJvb3QgJiYgIW5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiAoIW5vZGUgfHwgbm9kZSA9PT0gcm9vdCkgPyBudWxsIDogbm9kZS5uZXh0U2libGluZztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSByb290XG4gKiBAcGFyYW0geyFOb2RlfSBzdGFydFxuICogQHJldHVybiB7P05vZGV9XG4gKi9cbmZ1bmN0aW9uIG5leHROb2RlKHJvb3QsIHN0YXJ0KSB7XG4gIHJldHVybiBzdGFydC5maXJzdENoaWxkID8gc3RhcnQuZmlyc3RDaGlsZCA6IG5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmcocm9vdCwgc3RhcnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFFbGVtZW50KX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7IVNldDxOb2RlPj19IHZpc2l0ZWRJbXBvcnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhyb290LCBjYWxsYmFjaywgdmlzaXRlZEltcG9ydHMgPSBuZXcgU2V0KCkpIHtcbiAgbGV0IG5vZGUgPSByb290O1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovKG5vZGUpO1xuXG4gICAgICBjYWxsYmFjayhlbGVtZW50KTtcblxuICAgICAgY29uc3QgbG9jYWxOYW1lID0gZWxlbWVudC5sb2NhbE5hbWU7XG4gICAgICBpZiAobG9jYWxOYW1lID09PSAnbGluaycgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlbCcpID09PSAnaW1wb3J0Jykge1xuICAgICAgICAvLyBJZiB0aGlzIGltcG9ydCAocG9seWZpbGxlZCBvciBub3QpIGhhcyBpdCdzIHJvb3Qgbm9kZSBhdmFpbGFibGUsXG4gICAgICAgIC8vIHdhbGsgaXQuXG4gICAgICAgIGNvbnN0IGltcG9ydE5vZGUgPSAvKiogQHR5cGUgeyFOb2RlfSAqLyAoZWxlbWVudC5pbXBvcnQpO1xuICAgICAgICBpZiAoaW1wb3J0Tm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgIXZpc2l0ZWRJbXBvcnRzLmhhcyhpbXBvcnROb2RlKSkge1xuICAgICAgICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgd2Fsa3Mgb2YgdGhlIHNhbWUgaW1wb3J0IHJvb3QuXG4gICAgICAgICAgdmlzaXRlZEltcG9ydHMuYWRkKGltcG9ydE5vZGUpO1xuXG4gICAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBpbXBvcnROb2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICB3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhjaGlsZCwgY2FsbGJhY2ssIHZpc2l0ZWRJbXBvcnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZ25vcmUgZGVzY2VuZGFudHMgb2YgaW1wb3J0IGxpbmtzIHRvIHByZXZlbnQgYXR0ZW1wdGluZyB0byB3YWxrIHRoZVxuICAgICAgICAvLyBlbGVtZW50cyBjcmVhdGVkIGJ5IHRoZSBIVE1MIEltcG9ydHMgcG9seWZpbGwgdGhhdCB3ZSBqdXN0IHdhbGtlZFxuICAgICAgICAvLyBhYm92ZS5cbiAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmcocm9vdCwgZWxlbWVudCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChsb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgLy8gSWdub3JlIGRlc2NlbmRhbnRzIG9mIHRlbXBsYXRlcy4gVGhlcmUgc2hvdWxkbid0IGJlIGFueSBkZXNjZW5kYW50c1xuICAgICAgICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBtb3ZlZCBpbnRvIGAuY29udGVudGAgZHVyaW5nIGNvbnN0cnVjdGlvbiBpblxuICAgICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgdGVtcGxhdGUgYnV0LCBpbiBjYXNlIHRoZXkgZXhpc3QgYW5kIGFyZSBzdGlsbFxuICAgICAgICAvLyB3YWl0aW5nIHRvIGJlIG1vdmVkIGJ5IGEgcG9seWZpbGwsIHRoZXkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAgICBub2RlID0gbmV4dFNpYmxpbmdPckFuY2VzdG9yU2libGluZyhyb290LCBlbGVtZW50KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhbGsgc2hhZG93IHJvb3RzLlxuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuX19DRV9zaGFkb3dSb290O1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBzaGFkb3dSb290LmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMoY2hpbGQsIGNhbGxiYWNrLCB2aXNpdGVkSW1wb3J0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gbmV4dE5vZGUocm9vdCwgbm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBVc2VkIHRvIHN1cHByZXNzIENsb3N1cmUncyBcIk1vZGlmeWluZyB0aGUgcHJvdG90eXBlIGlzIG9ubHkgYWxsb3dlZCBpZiB0aGVcbiAqIGNvbnN0cnVjdG9yIGlzIGluIHRoZSBzYW1lIHNjb3BlXCIgd2FybmluZyB3aXRob3V0IHVzaW5nXG4gKiBgQHN1cHByZXNzIHtuZXdDaGVja1R5cGVzLCBkdXBsaWNhdGV9YCBiZWNhdXNlIGBuZXdDaGVja1R5cGVzYCBpcyB0b28gYnJvYWQuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFByb3BlcnR5VW5jaGVja2VkKGRlc3RpbmF0aW9uLCBuYW1lLCB2YWx1ZSkge1xuICBkZXN0aW5hdGlvbltuYW1lXSA9IHZhbHVlO1xufVxuIiwiLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBDdXN0b21FbGVtZW50U3RhdGUgPSB7XG4gIGN1c3RvbTogMSxcbiAgZmFpbGVkOiAyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ3VzdG9tRWxlbWVudFN0YXRlO1xuIiwiaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4vVXRpbGl0aWVzLmpzJztcbmltcG9ydCBDRVN0YXRlIGZyb20gJy4vQ3VzdG9tRWxlbWVudFN0YXRlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9tRWxlbWVudEludGVybmFscyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7IU1hcDxzdHJpbmcsICFDdXN0b21FbGVtZW50RGVmaW5pdGlvbj59ICovXG4gICAgdGhpcy5fbG9jYWxOYW1lVG9EZWZpbml0aW9uID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqIEB0eXBlIHshTWFwPCFGdW5jdGlvbiwgIUN1c3RvbUVsZW1lbnREZWZpbml0aW9uPn0gKi9cbiAgICB0aGlzLl9jb25zdHJ1Y3RvclRvRGVmaW5pdGlvbiA9IG5ldyBNYXAoKTtcblxuICAgIC8qKiBAdHlwZSB7IUFycmF5PCFmdW5jdGlvbighTm9kZSk+fSAqL1xuICAgIHRoaXMuX3BhdGNoZXMgPSBbXTtcblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLl9oYXNQYXRjaGVzID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgKiBAcGFyYW0geyFDdXN0b21FbGVtZW50RGVmaW5pdGlvbn0gZGVmaW5pdGlvblxuICAgKi9cbiAgc2V0RGVmaW5pdGlvbihsb2NhbE5hbWUsIGRlZmluaXRpb24pIHtcbiAgICB0aGlzLl9sb2NhbE5hbWVUb0RlZmluaXRpb24uc2V0KGxvY2FsTmFtZSwgZGVmaW5pdGlvbik7XG4gICAgdGhpcy5fY29uc3RydWN0b3JUb0RlZmluaXRpb24uc2V0KGRlZmluaXRpb24uY29uc3RydWN0b3IsIGRlZmluaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHJldHVybiB7IUN1c3RvbUVsZW1lbnREZWZpbml0aW9ufHVuZGVmaW5lZH1cbiAgICovXG4gIGxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxOYW1lVG9EZWZpbml0aW9uLmdldChsb2NhbE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjb25zdHJ1Y3RvclxuICAgKiBAcmV0dXJuIHshQ3VzdG9tRWxlbWVudERlZmluaXRpb258dW5kZWZpbmVkfVxuICAgKi9cbiAgY29uc3RydWN0b3JUb0RlZmluaXRpb24oY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0b3JUb0RlZmluaXRpb24uZ2V0KGNvbnN0cnVjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFmdW5jdGlvbighTm9kZSl9IGxpc3RlbmVyXG4gICAqL1xuICBhZGRQYXRjaChsaXN0ZW5lcikge1xuICAgIHRoaXMuX2hhc1BhdGNoZXMgPSB0cnVlO1xuICAgIHRoaXMuX3BhdGNoZXMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKi9cbiAgcGF0Y2hUcmVlKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuX2hhc1BhdGNoZXMpIHJldHVybjtcblxuICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhub2RlLCBlbGVtZW50ID0+IHRoaXMucGF0Y2goZWxlbWVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICovXG4gIHBhdGNoKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuX2hhc1BhdGNoZXMpIHJldHVybjtcblxuICAgIGlmIChub2RlLl9fQ0VfcGF0Y2hlZCkgcmV0dXJuO1xuICAgIG5vZGUuX19DRV9wYXRjaGVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fcGF0Y2hlc1tpXShub2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICAgKi9cbiAgY29ubmVjdFRyZWUocm9vdCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG5cbiAgICBVdGlsaXRpZXMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMocm9vdCwgZWxlbWVudCA9PiBlbGVtZW50cy5wdXNoKGVsZW1lbnQpKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50Ll9fQ0Vfc3RhdGUgPT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQoZWxlbWVudCkpIHtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnVwZ3JhZGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSByb290XG4gICAqL1xuICBkaXNjb25uZWN0VHJlZShyb290KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhyb290LCBlbGVtZW50ID0+IGVsZW1lbnRzLnB1c2goZWxlbWVudCkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKGVsZW1lbnQuX19DRV9zdGF0ZSA9PT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZXMgYWxsIHVuY3VzdG9taXplZCBjdXN0b20gZWxlbWVudHMgYXQgYW5kIGJlbG93IGEgcm9vdCBub2RlIGZvclxuICAgKiB3aGljaCB0aGVyZSBpcyBhIGRlZmluaXRpb24uIFdoZW4gY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb24gY2FsbGJhY2tzIGFyZVxuICAgKiBhc3N1bWVkIHRvIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5ICh3aGljaCwgYnkgdGhlIGN1cnJlbnQgRE9NIC8gSFRNTCBzcGVjXG4gICAqIGRlZmluaXRpb25zLCB0aGV5IGFyZSAqbm90KiksIGNhbGxiYWNrcyBmb3IgYm90aCBlbGVtZW50cyBjdXN0b21pemVkXG4gICAqIHN5bmNocm9ub3VzbHkgYnkgdGhlIHBhcnNlciBhbmQgZWxlbWVudHMgYmVpbmcgdXBncmFkZWQgb2NjdXIgaW4gdGhlIHNhbWVcbiAgICogcmVsYXRpdmUgb3JkZXIuXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgZnVuY3Rpb24sIHdoZW4gdXNlZCB0byBzaW11bGF0ZSB0aGUgY29uc3RydWN0aW9uIG9mIGEgdHJlZSB0aGF0XG4gICAqIGlzIGFscmVhZHkgY3JlYXRlZCBidXQgbm90IGN1c3RvbWl6ZWQgKGkuZS4gYnkgdGhlIHBhcnNlciksIGRvZXMgKm5vdCpcbiAgICogcHJldmVudCB0aGUgZWxlbWVudCBmcm9tIHJlYWRpbmcgdGhlICdmaW5hbCcgKHRydWUpIHN0YXRlIG9mIHRoZSB0cmVlLiBGb3JcbiAgICogZXhhbXBsZSwgdGhlIGVsZW1lbnQsIGR1cmluZyB0cnVseSBzeW5jaHJvbm91cyBwYXJzaW5nIC8gY29uc3RydWN0aW9uIHdvdWxkXG4gICAqIHNlZSB0aGF0IGl0IGNvbnRhaW5zIG5vIGNoaWxkcmVuIGFzIHRoZXkgaGF2ZSBub3QgeWV0IGJlZW4gaW5zZXJ0ZWQuXG4gICAqIEhvd2V2ZXIsIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbW9kaWZ5IHRoZSB0cmVlLCB0aGUgZWxlbWVudCB3aWxsXG4gICAqIChpbmNvcnJlY3RseSkgaGF2ZSBjaGlsZHJlbi4gQWRkaXRpb25hbGx5LCBzZWxmLW1vZGlmaWNhdGlvbiByZXN0cmljdGlvbnNcbiAgICogZm9yIGN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9ycyBpbXBvc2VkIGJ5IHRoZSBET00gc3BlYyBhcmUgKm5vdCogZW5mb3JjZWQuXG4gICAqXG4gICAqXG4gICAqIFRoZSBmb2xsb3dpbmcgbmVzdGVkIGxpc3Qgc2hvd3MgdGhlIHN0ZXBzIGV4dGVuZGluZyBkb3duIGZyb20gdGhlIEhUTUxcbiAgICogc3BlYydzIHBhcnNpbmcgc2VjdGlvbiB0aGF0IGNhdXNlIGVsZW1lbnRzIHRvIGJlIHN5bmNocm9ub3VzbHkgY3JlYXRlZCBhbmRcbiAgICogdXBncmFkZWQ6XG4gICAqXG4gICAqIFRoZSBcImluIGJvZHlcIiBpbnNlcnRpb24gbW9kZTpcbiAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgKiAtIFN3aXRjaCBvbiB0b2tlbjpcbiAgICogICAuLiBvdGhlciBjYXNlcyAuLlxuICAgKiAgIC0+IEFueSBvdGhlciBzdGFydCB0YWdcbiAgICogICAgICAtIFtJbnNlcnQgYW4gSFRNTCBlbGVtZW50XShiZWxvdykgZm9yIHRoZSB0b2tlbi5cbiAgICpcbiAgICogSW5zZXJ0IGFuIEhUTUwgZWxlbWVudDpcbiAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaW5zZXJ0LWFuLWh0bWwtZWxlbWVudFxuICAgKiAtIEluc2VydCBhIGZvcmVpZ24gZWxlbWVudCBmb3IgdGhlIHRva2VuIGluIHRoZSBIVE1MIG5hbWVzcGFjZTpcbiAgICogICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNpbnNlcnQtYS1mb3JlaWduLWVsZW1lbnRcbiAgICogICAtIENyZWF0ZSBhbiBlbGVtZW50IGZvciBhIHRva2VuOlxuICAgKiAgICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjY3JlYXRlLWFuLWVsZW1lbnQtZm9yLXRoZS10b2tlblxuICAgKiAgICAgLSBXaWxsIGV4ZWN1dGUgc2NyaXB0IGZsYWcgaXMgdHJ1ZT9cbiAgICogICAgICAgLSAoRWxlbWVudCBxdWV1ZSBwdXNoZWQgdG8gdGhlIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9ucyBzdGFjay4pXG4gICAqICAgICAtIENyZWF0ZSBhbiBlbGVtZW50OlxuICAgKiAgICAgICBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtY3JlYXRlLWVsZW1lbnRcbiAgICogICAgICAgLSBTeW5jIENFIGZsYWcgaXMgdHJ1ZT9cbiAgICogICAgICAgICAtIENvbnN0cnVjdG9yIGNhbGxlZC5cbiAgICogICAgICAgICAtIFNlbGYtbW9kaWZpY2F0aW9uIHJlc3RyaWN0aW9ucyBlbmZvcmNlZC5cbiAgICogICAgICAgLSBTeW5jIENFIGZsYWcgaXMgZmFsc2U/XG4gICAqICAgICAgICAgLSAoVXBncmFkZSByZWFjdGlvbiBlbnF1ZXVlZC4pXG4gICAqICAgICAtIEF0dHJpYnV0ZXMgYXBwZW5kZWQgdG8gZWxlbWVudC5cbiAgICogICAgICAgKGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgIHJlYWN0aW9ucyBlbnF1ZXVlZC4pXG4gICAqICAgICAtIFdpbGwgZXhlY3V0ZSBzY3JpcHQgZmxhZyBpcyB0cnVlP1xuICAgKiAgICAgICAtIChFbGVtZW50IHF1ZXVlIHBvcHBlZCBmcm9tIHRoZSBjdXN0b20gZWxlbWVudCByZWFjdGlvbnMgc3RhY2suXG4gICAqICAgICAgICAgUmVhY3Rpb25zIGluIHRoZSBwb3BwZWQgc3RhY2sgYXJlIGludm9rZWQuKVxuICAgKiAgIC0gKEVsZW1lbnQgcXVldWUgcHVzaGVkIHRvIHRoZSBjdXN0b20gZWxlbWVudCByZWFjdGlvbnMgc3RhY2suKVxuICAgKiAgIC0gSW5zZXJ0IHRoZSBlbGVtZW50OlxuICAgKiAgICAgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW5vZGUtaW5zZXJ0XG4gICAqICAgICAtIFNoYWRvdy1pbmNsdWRpbmcgZGVzY2VuZGFudHMgYXJlIGNvbm5lY3RlZC4gRHVyaW5nIHBhcnNpbmdcbiAgICogICAgICAgY29uc3RydWN0aW9uLCB0aGVyZSBhcmUgbm8gc2hhZG93LSpleGNsdWRpbmcqIGRlc2NlbmRhbnRzLlxuICAgKiAgICAgICBIb3dldmVyLCB0aGUgY29uc3RydWN0b3IgbWF5IGhhdmUgdmFsaWRseSBhdHRhY2hlZCBhIHNoYWRvd1xuICAgKiAgICAgICB0cmVlIHRvIGl0c2VsZiBhbmQgYWRkZWQgZGVzY2VuZGFudHMgdG8gdGhhdCBzaGFkb3cgdHJlZS5cbiAgICogICAgICAgKGBjb25uZWN0ZWRDYWxsYmFja2AgcmVhY3Rpb25zIGVucXVldWVkLilcbiAgICogICAtIChFbGVtZW50IHF1ZXVlIHBvcHBlZCBmcm9tIHRoZSBjdXN0b20gZWxlbWVudCByZWFjdGlvbnMgc3RhY2suXG4gICAqICAgICBSZWFjdGlvbnMgaW4gdGhlIHBvcHBlZCBzdGFjayBhcmUgaW52b2tlZC4pXG4gICAqXG4gICAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAgICogQHBhcmFtIHshU2V0PE5vZGU+PX0gdmlzaXRlZEltcG9ydHNcbiAgICovXG4gIHBhdGNoQW5kVXBncmFkZVRyZWUocm9vdCwgdmlzaXRlZEltcG9ydHMgPSBuZXcgU2V0KCkpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgY29uc3QgZ2F0aGVyRWxlbWVudHMgPSBlbGVtZW50ID0+IHtcbiAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PT0gJ2xpbmsnICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ2ltcG9ydCcpIHtcbiAgICAgICAgLy8gVGhlIEhUTUwgSW1wb3J0cyBwb2x5ZmlsbCBzZXRzIGEgZGVzY2VuZGFudCBlbGVtZW50IG9mIHRoZSBsaW5rIHRvXG4gICAgICAgIC8vIHRoZSBgaW1wb3J0YCBwcm9wZXJ0eSwgc3BlY2lmaWNhbGx5IHRoaXMgaXMgKm5vdCogYSBEb2N1bWVudC5cbiAgICAgICAgY29uc3QgaW1wb3J0Tm9kZSA9IC8qKiBAdHlwZSB7P05vZGV9ICovIChlbGVtZW50LmltcG9ydCk7XG5cbiAgICAgICAgaWYgKGltcG9ydE5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIGltcG9ydE5vZGUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgIGltcG9ydE5vZGUuX19DRV9pc0ltcG9ydERvY3VtZW50ID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIENvbm5lY3RlZCBsaW5rcyBhcmUgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfaGFzUmVnaXN0cnkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoaXMgbGluaydzIGltcG9ydCByb290IGlzIG5vdCBhdmFpbGFibGUsIGl0cyBjb250ZW50cyBjYW4ndCBiZVxuICAgICAgICAgIC8vIHdhbGtlZC4gV2FpdCBmb3IgJ2xvYWQnIGFuZCB3YWxrIGl0IHdoZW4gaXQncyByZWFkeS5cbiAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnROb2RlID0gLyoqIEB0eXBlIHshTm9kZX0gKi8gKGVsZW1lbnQuaW1wb3J0KTtcblxuICAgICAgICAgICAgaWYgKGltcG9ydE5vZGUuX19DRV9kb2N1bWVudExvYWRIYW5kbGVkKSByZXR1cm47XG4gICAgICAgICAgICBpbXBvcnROb2RlLl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGltcG9ydE5vZGUuX19DRV9pc0ltcG9ydERvY3VtZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQ29ubmVjdGVkIGxpbmtzIGFyZSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2hhc1JlZ2lzdHJ5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQ2xvbmUgdGhlIGB2aXNpdGVkSW1wb3J0c2Agc2V0IHRoYXQgd2FzIHBvcHVsYXRlZCBzeW5jIGR1cmluZ1xuICAgICAgICAgICAgLy8gdGhlIGBwYXRjaEFuZFVwZ3JhZGVUcmVlYCBjYWxsIHRoYXQgY2F1c2VkIHRoaXMgJ2xvYWQnIGhhbmRsZXIgdG9cbiAgICAgICAgICAgIC8vIGJlIGFkZGVkLiBUaGVuLCByZW1vdmUgKnRoaXMqIGxpbmsncyBpbXBvcnQgbm9kZSBzbyB0aGF0IHdlIGNhblxuICAgICAgICAgICAgLy8gd2FsayB0aGF0IGltcG9ydCBhZ2FpbiwgZXZlbiBpZiBpdCB3YXMgcGFydGlhbGx5IHdhbGtlZCBsYXRlclxuICAgICAgICAgICAgLy8gZHVyaW5nIHRoZSBzYW1lIGBwYXRjaEFuZFVwZ3JhZGVUcmVlYCBjYWxsLlxuICAgICAgICAgICAgY29uc3QgY2xvbmVkVmlzaXRlZEltcG9ydHMgPSBuZXcgU2V0KHZpc2l0ZWRJbXBvcnRzKTtcbiAgICAgICAgICAgIHZpc2l0ZWRJbXBvcnRzLmRlbGV0ZShpbXBvcnROb2RlKTtcblxuICAgICAgICAgICAgdGhpcy5wYXRjaEFuZFVwZ3JhZGVUcmVlKGltcG9ydE5vZGUsIHZpc2l0ZWRJbXBvcnRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYHdhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzYCBwb3B1bGF0ZXMgKGFuZCBpbnRlcm5hbGx5IGNoZWNrcyBhZ2FpbnN0KVxuICAgIC8vIGB2aXNpdGVkSW1wb3J0c2Agd2hlbiB0cmF2ZXJzaW5nIGEgbG9hZGVkIGltcG9ydC5cbiAgICBVdGlsaXRpZXMud2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMocm9vdCwgZ2F0aGVyRWxlbWVudHMsIHZpc2l0ZWRJbXBvcnRzKTtcblxuICAgIGlmICh0aGlzLl9oYXNQYXRjaGVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucGF0Y2goZWxlbWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMudXBncmFkZUVsZW1lbnQoZWxlbWVudHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICB1cGdyYWRlRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gZWxlbWVudC5fX0NFX3N0YXRlO1xuICAgIGlmIChjdXJyZW50U3RhdGUgIT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGVsZW1lbnQubG9jYWxOYW1lKTtcbiAgICBpZiAoIWRlZmluaXRpb24pIHJldHVybjtcblxuICAgIGRlZmluaXRpb24uY29uc3RydWN0aW9uU3RhY2sucHVzaChlbGVtZW50KTtcblxuICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZGVmaW5pdGlvbi5jb25zdHJ1Y3RvcjtcbiAgICB0cnkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyAoY29uc3RydWN0b3IpKCk7XG4gICAgICAgIGlmIChyZXN1bHQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvciBkaWQgbm90IHByb2R1Y2UgdGhlIGVsZW1lbnQgYmVpbmcgdXBncmFkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRlZmluaXRpb24uY29uc3RydWN0aW9uU3RhY2sucG9wKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZWxlbWVudC5fX0NFX3N0YXRlID0gQ0VTdGF0ZS5mYWlsZWQ7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX19DRV9zdGF0ZSA9IENFU3RhdGUuY3VzdG9tO1xuICAgIGVsZW1lbnQuX19DRV9kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcblxuICAgIGlmIChkZWZpbml0aW9uLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaykge1xuICAgICAgY29uc3Qgb2JzZXJ2ZWRBdHRyaWJ1dGVzID0gZGVmaW5pdGlvbi5vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9ic2VydmVkQXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuYW1lID0gb2JzZXJ2ZWRBdHRyaWJ1dGVzW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhlbGVtZW50LCBuYW1lLCBudWxsLCB2YWx1ZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKGVsZW1lbnQpKSB7XG4gICAgICB0aGlzLmNvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBjb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGVsZW1lbnQuX19DRV9kZWZpbml0aW9uO1xuICAgIGlmIChkZWZpbml0aW9uLmNvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICBkZWZpbml0aW9uLmNvbm5lY3RlZENhbGxiYWNrLmNhbGwoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5fX0NFX2lzQ29ubmVjdGVkQ2FsbGJhY2tDYWxsZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQuX19DRV9pc0Nvbm5lY3RlZENhbGxiYWNrQ2FsbGVkKSB7XG4gICAgICB0aGlzLmNvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmluaXRpb24gPSBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbjtcbiAgICBpZiAoZGVmaW5pdGlvbi5kaXNjb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgZGVmaW5pdGlvbi5kaXNjb25uZWN0ZWRDYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX19DRV9pc0Nvbm5lY3RlZENhbGxiYWNrQ2FsbGVkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGRWYWx1ZVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IG5ld1ZhbHVlXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG4gICAqL1xuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZWxlbWVudCwgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gZWxlbWVudC5fX0NFX2RlZmluaXRpb247XG4gICAgaWYgKFxuICAgICAgZGVmaW5pdGlvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgJiZcbiAgICAgIGRlZmluaXRpb24ub2JzZXJ2ZWRBdHRyaWJ1dGVzLmluZGV4T2YobmFtZSkgPiAtMVxuICAgICkge1xuICAgICAgZGVmaW5pdGlvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2suY2FsbChlbGVtZW50LCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoaW50ZXJuYWxzLCBkb2MpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9XG4gICAgICovXG4gICAgdGhpcy5faW50ZXJuYWxzID0gaW50ZXJuYWxzO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFEb2N1bWVudH1cbiAgICAgKi9cbiAgICB0aGlzLl9kb2N1bWVudCA9IGRvYztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNdXRhdGlvbk9ic2VydmVyfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLl9vYnNlcnZlciA9IHVuZGVmaW5lZDtcblxuXG4gICAgLy8gU2ltdWxhdGUgdHJlZSBjb25zdHJ1Y3Rpb24gZm9yIGFsbCBjdXJyZW50bHkgYWNjZXNzaWJsZSBub2RlcyBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC5cbiAgICB0aGlzLl9pbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZSh0aGlzLl9kb2N1bWVudCk7XG5cbiAgICBpZiAodGhpcy5fZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX2hhbmRsZU11dGF0aW9ucy5iaW5kKHRoaXMpKTtcblxuICAgICAgLy8gTm9kZXMgY3JlYXRlZCBieSB0aGUgcGFyc2VyIGFyZSBnaXZlbiB0byB0aGUgb2JzZXJ2ZXIgKmJlZm9yZSogdGhlIG5leHRcbiAgICAgIC8vIHRhc2sgcnVucy4gSW5saW5lIHNjcmlwdHMgYXJlIHJ1biBpbiBhIG5ldyB0YXNrLiBUaGlzIG1lYW5zIHRoYXQgdGhlXG4gICAgICAvLyBvYnNlcnZlciB3aWxsIGJlIGFibGUgdG8gaGFuZGxlIHRoZSBuZXdseSBwYXJzZWQgbm9kZXMgYmVmb3JlIHRoZSBpbmxpbmVcbiAgICAgIC8vIHNjcmlwdCBpcyBydW4uXG4gICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RvY3VtZW50LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IG11dGF0aW9uc1xuICAgKi9cbiAgX2hhbmRsZU11dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICAvLyBPbmNlIHRoZSBkb2N1bWVudCdzIGByZWFkeVN0YXRlYCBpcyAnaW50ZXJhY3RpdmUnIG9yICdjb21wbGV0ZScsIGFsbCBuZXdcbiAgICAvLyBub2RlcyBjcmVhdGVkIHdpdGhpbiB0aGF0IGRvY3VtZW50IHdpbGwgYmUgdGhlIHJlc3VsdCBvZiBzY3JpcHQgYW5kXG4gICAgLy8gc2hvdWxkIGJlIGhhbmRsZWQgYnkgcGF0Y2hpbmcuXG4gICAgY29uc3QgcmVhZHlTdGF0ZSA9IHRoaXMuX2RvY3VtZW50LnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgfHwgcmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGFkZGVkTm9kZXMgPSBtdXRhdGlvbnNbaV0uYWRkZWROb2RlcztcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYWRkZWROb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBub2RlID0gYWRkZWROb2Rlc1tqXTtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmVycmVkIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7VHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5fdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5fcmVzb2x2ZSA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFQcm9taXNlPFQ+fVxuICAgICAqL1xuICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuXG4gICAgICBpZiAodGhpcy5fdmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh0aGlzLl92YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSB2YWx1ZVxuICAgKi9cbiAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgIGlmICh0aGlzLl92YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbHJlYWR5IHJlc29sdmVkLicpO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAodGhpcy5fcmVzb2x2ZSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFQcm9taXNlPFQ+fVxuICAgKi9cbiAgdG9Qcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xuICB9XG59XG4iLCJpbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0IERvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIgZnJvbSAnLi9Eb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyLmpzJztcbmltcG9ydCBEZWZlcnJlZCBmcm9tICcuL0RlZmVycmVkLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuL1V0aWxpdGllcy5qcyc7XG5cbi8qKlxuICogQHVucmVzdHJpY3RlZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21FbGVtZW50UmVnaXN0cnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGludGVybmFscykge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fZWxlbWVudERlZmluaXRpb25Jc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfVxuICAgICAqL1xuICAgIHRoaXMuX2ludGVybmFscyA9IGludGVybmFscztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFNYXA8c3RyaW5nLCAhRGVmZXJyZWQ8dW5kZWZpbmVkPj59XG4gICAgICovXG4gICAgdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZCA9IG5ldyBNYXAoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZsdXNoIGNhbGxiYWNrIHRyaWdnZXJzIHRoZSBkb2N1bWVudCB3YWxrIHN5bmNocm9ub3VzbHkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2sgPSBmbiA9PiBmbigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9mbHVzaFBlbmRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuX3VuZmx1c2hlZExvY2FsTmFtZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIgPSBuZXcgRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlcihpbnRlcm5hbHMsIGRvY3VtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZGVmaW5lKGxvY2FsTmFtZSwgY29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3JzIG11c3QgYmUgZnVuY3Rpb25zLicpO1xuICAgIH1cblxuICAgIGlmICghVXRpbGl0aWVzLmlzVmFsaWRDdXN0b21FbGVtZW50TmFtZShsb2NhbE5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBlbGVtZW50IG5hbWUgJyR7bG9jYWxOYW1lfScgaXMgbm90IHZhbGlkLmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQSBjdXN0b20gZWxlbWVudCB3aXRoIG5hbWUgJyR7bG9jYWxOYW1lfScgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbGVtZW50RGVmaW5pdGlvbklzUnVubmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGN1c3RvbSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgZGVmaW5lZC4nKTtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudERlZmluaXRpb25Jc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgbGV0IGNvbm5lY3RlZENhbGxiYWNrO1xuICAgIGxldCBkaXNjb25uZWN0ZWRDYWxsYmFjaztcbiAgICBsZXQgYWRvcHRlZENhbGxiYWNrO1xuICAgIGxldCBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s7XG4gICAgbGV0IG9ic2VydmVkQXR0cmlidXRlcztcbiAgICB0cnkge1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgY29uc3QgcHJvdG90eXBlID0gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgICAgaWYgKCEocHJvdG90eXBlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3JcXCdzIHByb3RvdHlwZSBpcyBub3QgYW4gb2JqZWN0LicpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRDYWxsYmFjayhuYW1lKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrVmFsdWUgPSBwcm90b3R5cGVbbmFtZV07XG4gICAgICAgIGlmIChjYWxsYmFja1ZhbHVlICE9PSB1bmRlZmluZWQgJiYgIShjYWxsYmFja1ZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJyR7bmFtZX0nIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2tWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgY29ubmVjdGVkQ2FsbGJhY2sgPSBnZXRDYWxsYmFjaygnY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrID0gZ2V0Q2FsbGJhY2soJ2Rpc2Nvbm5lY3RlZENhbGxiYWNrJyk7XG4gICAgICBhZG9wdGVkQ2FsbGJhY2sgPSBnZXRDYWxsYmFjaygnYWRvcHRlZENhbGxiYWNrJyk7XG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBnZXRDYWxsYmFjaygnYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJyk7XG4gICAgICBvYnNlcnZlZEF0dHJpYnV0ZXMgPSBjb25zdHJ1Y3Rvclsnb2JzZXJ2ZWRBdHRyaWJ1dGVzJ10gfHwgW107XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9lbGVtZW50RGVmaW5pdGlvbklzUnVubmluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmluaXRpb24gPSB7XG4gICAgICBsb2NhbE5hbWUsXG4gICAgICBjb25zdHJ1Y3RvcixcbiAgICAgIGNvbm5lY3RlZENhbGxiYWNrLFxuICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2ssXG4gICAgICBhZG9wdGVkQ2FsbGJhY2ssXG4gICAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2ssXG4gICAgICBvYnNlcnZlZEF0dHJpYnV0ZXMsXG4gICAgICBjb25zdHJ1Y3Rpb25TdGFjazogW10sXG4gICAgfTtcblxuICAgIHRoaXMuX2ludGVybmFscy5zZXREZWZpbml0aW9uKGxvY2FsTmFtZSwgZGVmaW5pdGlvbik7XG5cbiAgICB0aGlzLl91bmZsdXNoZWRMb2NhbE5hbWVzLnB1c2gobG9jYWxOYW1lKTtcblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgY2FsbGVkIHRoZSBmbHVzaCBjYWxsYmFjayBhbmQgaXQgaGFzbid0IGNhbGxlZCBiYWNrIHlldCxcbiAgICAvLyBkb24ndCBjYWxsIGl0IGFnYWluLlxuICAgIGlmICghdGhpcy5fZmx1c2hQZW5kaW5nKSB7XG4gICAgICB0aGlzLl9mbHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fZmx1c2hDYWxsYmFjaygoKSA9PiB0aGlzLl9mbHVzaCgpKTtcbiAgICB9XG4gIH1cblxuICBfZmx1c2goKSB7XG4gICAgLy8gSWYgbm8gbmV3IGRlZmluaXRpb25zIHdlcmUgZGVmaW5lZCwgZG9uJ3QgYXR0ZW1wdCB0byBmbHVzaC4gVGhpcyBjb3VsZFxuICAgIC8vIGhhcHBlbiBpZiBhIGZsdXNoIGNhbGxiYWNrIGtlZXBzIHRoZSBmdW5jdGlvbiBpdCBpcyBnaXZlbiBhbmQgY2FsbHMgaXRcbiAgICAvLyBtdWx0aXBsZSB0aW1lcy5cbiAgICBpZiAodGhpcy5fZmx1c2hQZW5kaW5nID09PSBmYWxzZSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fZmx1c2hQZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5faW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUoZG9jdW1lbnQpO1xuXG4gICAgd2hpbGUgKHRoaXMuX3VuZmx1c2hlZExvY2FsTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbG9jYWxOYW1lID0gdGhpcy5fdW5mbHVzaGVkTG9jYWxOYW1lcy5zaGlmdCgpO1xuICAgICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLl93aGVuRGVmaW5lZERlZmVycmVkLmdldChsb2NhbE5hbWUpO1xuICAgICAgaWYgKGRlZmVycmVkKSB7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxvY2FsTmFtZVxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbnx1bmRlZmluZWR9XG4gICAqL1xuICBnZXQobG9jYWxOYW1lKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHRoaXMuX2ludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKTtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgcmV0dXJuIGRlZmluaXRpb24uY29uc3RydWN0b3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHVuZGVmaW5lZD59XG4gICAqL1xuICB3aGVuRGVmaW5lZChsb2NhbE5hbWUpIHtcbiAgICBpZiAoIVV0aWxpdGllcy5pc1ZhbGlkQ3VzdG9tRWxlbWVudE5hbWUobG9jYWxOYW1lKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBTeW50YXhFcnJvcihgJyR7bG9jYWxOYW1lfScgaXMgbm90IGEgdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZS5gKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJpb3IgPSB0aGlzLl93aGVuRGVmaW5lZERlZmVycmVkLmdldChsb2NhbE5hbWUpO1xuICAgIGlmIChwcmlvcikge1xuICAgICAgcmV0dXJuIHByaW9yLnRvUHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZC5zZXQobG9jYWxOYW1lLCBkZWZlcnJlZCk7XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5faW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpO1xuICAgIC8vIFJlc29sdmUgaW1tZWRpYXRlbHkgb25seSBpZiB0aGUgZ2l2ZW4gbG9jYWwgbmFtZSBoYXMgYSBkZWZpbml0aW9uICphbmQqXG4gICAgLy8gdGhlIGZ1bGwgZG9jdW1lbnQgd2FsayB0byB1cGdyYWRlIGVsZW1lbnRzIHdpdGggdGhhdCBsb2NhbCBuYW1lIGhhc1xuICAgIC8vIGFscmVhZHkgaGFwcGVuZWQuXG4gICAgaWYgKGRlZmluaXRpb24gJiYgdGhpcy5fdW5mbHVzaGVkTG9jYWxOYW1lcy5pbmRleE9mKGxvY2FsTmFtZSkgPT09IC0xKSB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmVycmVkLnRvUHJvbWlzZSgpO1xuICB9XG5cbiAgcG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayhvdXRlcikge1xuICAgIHRoaXMuX2RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZmx1c2hDYWxsYmFjaztcbiAgICB0aGlzLl9mbHVzaENhbGxiYWNrID0gZmx1c2ggPT4gb3V0ZXIoKCkgPT4gaW5uZXIoZmx1c2gpKTtcbiAgfVxufVxuXG4vLyBDbG9zdXJlIGNvbXBpbGVyIGV4cG9ydHMuXG53aW5kb3dbJ0N1c3RvbUVsZW1lbnRSZWdpc3RyeSddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5O1xuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZVsnZGVmaW5lJ10gPSBDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmRlZmluZTtcbkN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGVbJ2dldCddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5nZXQ7XG5DdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlWyd3aGVuRGVmaW5lZCddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS53aGVuRGVmaW5lZDtcbkN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGVbJ3BvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2snXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjaztcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgRG9jdW1lbnRfY3JlYXRlRWxlbWVudDogd2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50LFxuICBEb2N1bWVudF9jcmVhdGVFbGVtZW50TlM6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudE5TLFxuICBEb2N1bWVudF9pbXBvcnROb2RlOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGUsXG4gIERvY3VtZW50X3ByZXBlbmQ6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGVbJ3ByZXBlbmQnXSxcbiAgRG9jdW1lbnRfYXBwZW5kOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlWydhcHBlbmQnXSxcbiAgTm9kZV9jbG9uZU5vZGU6IHdpbmRvdy5Ob2RlLnByb3RvdHlwZS5jbG9uZU5vZGUsXG4gIE5vZGVfYXBwZW5kQ2hpbGQ6IHdpbmRvdy5Ob2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCxcbiAgTm9kZV9pbnNlcnRCZWZvcmU6IHdpbmRvdy5Ob2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUsXG4gIE5vZGVfcmVtb3ZlQ2hpbGQ6IHdpbmRvdy5Ob2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCxcbiAgTm9kZV9yZXBsYWNlQ2hpbGQ6IHdpbmRvdy5Ob2RlLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQsXG4gIE5vZGVfdGV4dENvbnRlbnQ6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93Lk5vZGUucHJvdG90eXBlLCAndGV4dENvbnRlbnQnKSxcbiAgRWxlbWVudF9hdHRhY2hTaGFkb3c6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnYXR0YWNoU2hhZG93J10sXG4gIEVsZW1lbnRfaW5uZXJIVE1MOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZSwgJ2lubmVySFRNTCcpLFxuICBFbGVtZW50X2dldEF0dHJpYnV0ZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSxcbiAgRWxlbWVudF9zZXRBdHRyaWJ1dGU6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUsXG4gIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlLFxuICBFbGVtZW50X2dldEF0dHJpYnV0ZU5TOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTlMsXG4gIEVsZW1lbnRfc2V0QXR0cmlidXRlTlM6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUyxcbiAgRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUzogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZU5TLFxuICBFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudDogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydpbnNlcnRBZGphY2VudEVsZW1lbnQnXSxcbiAgRWxlbWVudF9wcmVwZW5kOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ3ByZXBlbmQnXSxcbiAgRWxlbWVudF9hcHBlbmQ6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnYXBwZW5kJ10sXG4gIEVsZW1lbnRfYmVmb3JlOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2JlZm9yZSddLFxuICBFbGVtZW50X2FmdGVyOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2FmdGVyJ10sXG4gIEVsZW1lbnRfcmVwbGFjZVdpdGg6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsncmVwbGFjZVdpdGgnXSxcbiAgRWxlbWVudF9yZW1vdmU6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsncmVtb3ZlJ10sXG4gIEhUTUxFbGVtZW50OiB3aW5kb3cuSFRNTEVsZW1lbnQsXG4gIEhUTUxFbGVtZW50X2lubmVySFRNTDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5uZXJIVE1MJyksXG4gIEhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudDogd2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZVsnaW5zZXJ0QWRqYWNlbnRFbGVtZW50J10sXG59O1xuIiwiLyoqXG4gKiBUaGlzIGNsYXNzIGV4aXN0cyBvbmx5IHRvIHdvcmsgYXJvdW5kIENsb3N1cmUncyBsYWNrIG9mIGEgd2F5IHRvIGRlc2NyaWJlXG4gKiBzaW5nbGV0b25zLiBJdCByZXByZXNlbnRzIHRoZSAnYWxyZWFkeSBjb25zdHJ1Y3RlZCBtYXJrZXInIHVzZWQgaW4gY3VzdG9tXG4gKiBlbGVtZW50IGNvbnN0cnVjdGlvbiBzdGFja3MuXG4gKlxuICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1hbHJlYWR5LWNvbnN0cnVjdGVkLW1hcmtlclxuICovXG5jbGFzcyBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIge31cblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlcigpO1xuIiwiaW1wb3J0IE5hdGl2ZSBmcm9tICcuL05hdGl2ZS5qcyc7XG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCBDRVN0YXRlIGZyb20gJy4uL0N1c3RvbUVsZW1lbnRTdGF0ZS5qcyc7XG5pbXBvcnQgQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyIGZyb20gJy4uL0FscmVhZHlDb25zdHJ1Y3RlZE1hcmtlci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVybmFscykge1xuICB3aW5kb3dbJ0hUTUxFbGVtZW50J10gPSAoZnVuY3Rpb24oKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKG5ldzogSFRNTEVsZW1lbnQpOiAhSFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gSFRNTEVsZW1lbnQoKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCByZWFsbHkgYmUgYG5ldy50YXJnZXRgIGJ1dCBgbmV3LnRhcmdldGAgY2FuJ3QgYmUgZW11bGF0ZWRcbiAgICAgIC8vIGluIEVTNS4gQXNzdW1pbmcgdGhlIHVzZXIga2VlcHMgdGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIGNvbnN0cnVjdG9yJ3NcbiAgICAgIC8vIHByb3RvdHlwZSdzIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHksIHRoaXMgaXMgZXF1aXZhbGVudC5cbiAgICAgIC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqL1xuICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gaW50ZXJuYWxzLmNvbnN0cnVjdG9yVG9EZWZpbml0aW9uKGNvbnN0cnVjdG9yKTtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjdXN0b20gZWxlbWVudCBiZWluZyBjb25zdHJ1Y3RlZCB3YXMgbm90IHJlZ2lzdGVyZWQgd2l0aCBgY3VzdG9tRWxlbWVudHNgLicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb25zdHJ1Y3Rpb25TdGFjayA9IGRlZmluaXRpb24uY29uc3RydWN0aW9uU3RhY2s7XG5cbiAgICAgIGlmIChjb25zdHJ1Y3Rpb25TdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IE5hdGl2ZS5Eb2N1bWVudF9jcmVhdGVFbGVtZW50LmNhbGwoZG9jdW1lbnQsIGRlZmluaXRpb24ubG9jYWxOYW1lKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGVsZW1lbnQsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgIGVsZW1lbnQuX19DRV9zdGF0ZSA9IENFU3RhdGUuY3VzdG9tO1xuICAgICAgICBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG4gICAgICAgIGludGVybmFscy5wYXRjaChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGNvbnN0cnVjdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gY29uc3RydWN0aW9uU3RhY2tbbGFzdEluZGV4XTtcbiAgICAgIGlmIChlbGVtZW50ID09PSBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgSFRNTEVsZW1lbnQgY29uc3RydWN0b3Igd2FzIGVpdGhlciBjYWxsZWQgcmVlbnRyYW50bHkgZm9yIHRoaXMgY29uc3RydWN0b3Igb3IgY2FsbGVkIG11bHRpcGxlIHRpbWVzLicpO1xuICAgICAgfVxuICAgICAgY29uc3RydWN0aW9uU3RhY2tbbGFzdEluZGV4XSA9IEFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlcjtcblxuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGVsZW1lbnQsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICBpbnRlcm5hbHMucGF0Y2goLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovIChlbGVtZW50KSk7XG5cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZSA9IE5hdGl2ZS5IVE1MRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgICByZXR1cm4gSFRNTEVsZW1lbnQ7XG4gIH0pKCk7XG59O1xuIiwiaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi4vLi4vVXRpbGl0aWVzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBwcmVwZW5kOiAhZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpLFxuICAqICBhcHBlbmQ6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG4gKiB9fVxuICovXG5sZXQgUGFyZW50Tm9kZU5hdGl2ZU1ldGhvZHM7XG5cbi8qKlxuICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gKiBAcGFyYW0geyFPYmplY3R9IGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0geyFQYXJlbnROb2RlTmF0aXZlTWV0aG9kc30gYnVpbHRJblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMsIGRlc3RpbmF0aW9uLCBidWlsdEluKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuICAgKi9cbiAgZGVzdGluYXRpb25bJ3ByZXBlbmQnXSA9IGZ1bmN0aW9uKC4uLm5vZGVzKSB7XG4gICAgLy8gVE9ETzogRml4IHRoaXMgZm9yIHdoZW4gb25lIG9mIGBub2Rlc2AgaXMgYSBEb2N1bWVudEZyYWdtZW50IVxuICAgIGNvbnN0IGNvbm5lY3RlZEJlZm9yZSA9IC8qKiBAdHlwZSB7IUFycmF5PCFOb2RlPn0gKi8gKG5vZGVzLmZpbHRlcihub2RlID0+IHtcbiAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGFyZSBub3QgY29ubmVjdGVkIGFuZCB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgbGlzdC5cbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgTm9kZSAmJiBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgfSkpO1xuXG4gICAgYnVpbHRJbi5wcmVwZW5kLmFwcGx5KHRoaXMsIG5vZGVzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29ubmVjdGVkQmVmb3JlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoY29ubmVjdGVkQmVmb3JlW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuICAgKi9cbiAgZGVzdGluYXRpb25bJ2FwcGVuZCddID0gZnVuY3Rpb24oLi4ubm9kZXMpIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBmb3Igd2hlbiBvbmUgb2YgYG5vZGVzYCBpcyBhIERvY3VtZW50RnJhZ21lbnQhXG4gICAgY29uc3QgY29ubmVjdGVkQmVmb3JlID0gLyoqIEB0eXBlIHshQXJyYXk8IU5vZGU+fSAqLyAobm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlIG5vdCBjb25uZWN0ZWQgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICB9KSk7XG5cbiAgICBidWlsdEluLmFwcGVuZC5hcHBseSh0aGlzLCBub2Rlcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGNvbm5lY3RlZEJlZm9yZVtpXSk7XG4gICAgfVxuXG4gICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG4iLCJpbXBvcnQgTmF0aXZlIGZyb20gJy4vTmF0aXZlLmpzJztcbmltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4uL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uL1V0aWxpdGllcy5qcyc7XG5cbmltcG9ydCBQYXRjaFBhcmVudE5vZGUgZnJvbSAnLi9JbnRlcmZhY2UvUGFyZW50Tm9kZS5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVybmFscykge1xuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRG9jdW1lbnQucHJvdG90eXBlLCAnY3JlYXRlRWxlbWVudCcsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0RvY3VtZW50fVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICAgKiBAcmV0dXJuIHshRWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihsb2NhbE5hbWUpIHtcbiAgICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGRvY3VtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICBpZiAodGhpcy5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBpbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSk7XG4gICAgICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyAoZGVmaW5pdGlvbi5jb25zdHJ1Y3RvcikoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL1xuICAgICAgICAoTmF0aXZlLkRvY3VtZW50X2NyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBsb2NhbE5hbWUpKTtcbiAgICAgIGludGVybmFscy5wYXRjaChyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRG9jdW1lbnQucHJvdG90eXBlLCAnaW1wb3J0Tm9kZScsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0RvY3VtZW50fVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWVwXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24obm9kZSwgZGVlcCkge1xuICAgICAgY29uc3QgY2xvbmUgPSBOYXRpdmUuRG9jdW1lbnRfaW1wb3J0Tm9kZS5jYWxsKHRoaXMsIG5vZGUsIGRlZXApO1xuICAgICAgLy8gT25seSBjcmVhdGUgY3VzdG9tIGVsZW1lbnRzIGlmIHRoaXMgZG9jdW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgIGlmICghdGhpcy5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG4gICAgICAgIGludGVybmFscy5wYXRjaFRyZWUoY2xvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUoY2xvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0pO1xuXG4gIGNvbnN0IE5TX0hUTUwgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRG9jdW1lbnQucHJvdG90eXBlLCAnY3JlYXRlRWxlbWVudE5TJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7RG9jdW1lbnR9XG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAgICogQHJldHVybiB7IUVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24obmFtZXNwYWNlLCBsb2NhbE5hbWUpIHtcbiAgICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGRvY3VtZW50IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICBpZiAodGhpcy5fX0NFX2hhc1JlZ2lzdHJ5ICYmIChuYW1lc3BhY2UgPT09IG51bGwgfHwgbmFtZXNwYWNlID09PSBOU19IVE1MKSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gaW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgIHJldHVybiBuZXcgKGRlZmluaXRpb24uY29uc3RydWN0b3IpKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi9cbiAgICAgICAgKE5hdGl2ZS5Eb2N1bWVudF9jcmVhdGVFbGVtZW50TlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIGxvY2FsTmFtZSkpO1xuICAgICAgaW50ZXJuYWxzLnBhdGNoKHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gIFBhdGNoUGFyZW50Tm9kZShpbnRlcm5hbHMsIERvY3VtZW50LnByb3RvdHlwZSwge1xuICAgIHByZXBlbmQ6IE5hdGl2ZS5Eb2N1bWVudF9wcmVwZW5kLFxuICAgIGFwcGVuZDogTmF0aXZlLkRvY3VtZW50X2FwcGVuZCxcbiAgfSk7XG59O1xuIiwiaW1wb3J0IE5hdGl2ZSBmcm9tICcuL05hdGl2ZS5qcyc7XG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuLi9VdGlsaXRpZXMuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMpIHtcbiAgLy8gYE5vZGUjbm9kZVZhbHVlYCBpcyBpbXBsZW1lbnRlZCBvbiBgQXR0cmAuXG4gIC8vIGBOb2RlI3RleHRDb250ZW50YCBpcyBpbXBsZW1lbnRlZCBvbiBgQXR0cmAsIGBFbGVtZW50YC5cblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdpbnNlcnRCZWZvcmUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSByZWZOb2RlXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24obm9kZSwgcmVmTm9kZSkge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGluc2VydGVkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkobm9kZS5jaGlsZE5vZGVzKTtcbiAgICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfaW5zZXJ0QmVmb3JlLmNhbGwodGhpcywgbm9kZSwgcmVmTm9kZSk7XG5cbiAgICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgY2FuJ3QgYmUgY29ubmVjdGVkLCBzbyBgZGlzY29ubmVjdFRyZWVgIHdpbGwgbmV2ZXJcbiAgICAgICAgLy8gbmVlZCB0byBiZSBjYWxsZWQgb24gYSBEb2N1bWVudEZyYWdtZW50J3MgY2hpbGRyZW4gYWZ0ZXIgaW5zZXJ0aW5nIGl0LlxuXG4gICAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc2VydGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShpbnNlcnRlZE5vZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlV2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfaW5zZXJ0QmVmb3JlLmNhbGwodGhpcywgbm9kZSwgcmVmTm9kZSk7XG5cbiAgICAgIGlmIChub2RlV2FzQ29ubmVjdGVkKSB7XG4gICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKE5vZGUucHJvdG90eXBlLCAnYXBwZW5kQ2hpbGQnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0ZWROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkTm9kZXMpO1xuICAgICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9hcHBlbmRDaGlsZC5jYWxsKHRoaXMsIG5vZGUpO1xuXG4gICAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGNhbid0IGJlIGNvbm5lY3RlZCwgc28gYGRpc2Nvbm5lY3RUcmVlYCB3aWxsIG5ldmVyXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgY2FsbGVkIG9uIGEgRG9jdW1lbnRGcmFnbWVudCdzIGNoaWxkcmVuIGFmdGVyIGluc2VydGluZyBpdC5cblxuICAgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnNlcnRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUoaW5zZXJ0ZWROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZVdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX2FwcGVuZENoaWxkLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICAgIGlmIChub2RlV2FzQ29ubmVjdGVkKSB7XG4gICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKE5vZGUucHJvdG90eXBlLCAnY2xvbmVOb2RlJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Tm9kZX1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWVwXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24oZGVlcCkge1xuICAgICAgY29uc3QgY2xvbmUgPSBOYXRpdmUuTm9kZV9jbG9uZU5vZGUuY2FsbCh0aGlzLCBkZWVwKTtcbiAgICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGVsZW1lbnQncyBvd25lciBkb2N1bWVudCBpc1xuICAgICAgLy8gYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgIGlmICghdGhpcy5vd25lckRvY3VtZW50Ll9fQ0VfaGFzUmVnaXN0cnkpIHtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoVHJlZShjbG9uZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZShjbG9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKE5vZGUucHJvdG90eXBlLCAncmVtb3ZlQ2hpbGQnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICBjb25zdCBub2RlV2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfcmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLCBub2RlKTtcblxuICAgICAgaWYgKG5vZGVXYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ3JlcGxhY2VDaGlsZCcsXG4gICAgLyoqXG4gICAgICogQHRoaXMge05vZGV9XG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVRvSW5zZXJ0XG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVRvUmVtb3ZlXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24obm9kZVRvSW5zZXJ0LCBub2RlVG9SZW1vdmUpIHtcbiAgICAgIGlmIChub2RlVG9JbnNlcnQgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIGNvbnN0IGluc2VydGVkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkobm9kZVRvSW5zZXJ0LmNoaWxkTm9kZXMpO1xuICAgICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9yZXBsYWNlQ2hpbGQuY2FsbCh0aGlzLCBub2RlVG9JbnNlcnQsIG5vZGVUb1JlbW92ZSk7XG5cbiAgICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgY2FuJ3QgYmUgY29ubmVjdGVkLCBzbyBgZGlzY29ubmVjdFRyZWVgIHdpbGwgbmV2ZXJcbiAgICAgICAgLy8gbmVlZCB0byBiZSBjYWxsZWQgb24gYSBEb2N1bWVudEZyYWdtZW50J3MgY2hpbGRyZW4gYWZ0ZXIgaW5zZXJ0aW5nIGl0LlxuXG4gICAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZVRvUmVtb3ZlKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc2VydGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShpbnNlcnRlZE5vZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlVG9JbnNlcnRXYXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZVRvSW5zZXJ0KTtcbiAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX3JlcGxhY2VDaGlsZC5jYWxsKHRoaXMsIG5vZGVUb0luc2VydCwgbm9kZVRvUmVtb3ZlKTtcbiAgICAgIGNvbnN0IHRoaXNJc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKTtcblxuICAgICAgaWYgKHRoaXNJc0Nvbm5lY3RlZCkge1xuICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZVRvUmVtb3ZlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVUb0luc2VydFdhc0Nvbm5lY3RlZCkge1xuICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUobm9kZVRvSW5zZXJ0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNJc0Nvbm5lY3RlZCkge1xuICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZVRvSW5zZXJ0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICB9KTtcblxuXG4gIGZ1bmN0aW9uIHBhdGNoX3RleHRDb250ZW50KGRlc3RpbmF0aW9uLCBiYXNlRGVzY3JpcHRvcikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXN0aW5hdGlvbiwgJ3RleHRDb250ZW50Jywge1xuICAgICAgZW51bWVyYWJsZTogYmFzZURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogYmFzZURlc2NyaXB0b3IuZ2V0LFxuICAgICAgc2V0OiAvKiogQHRoaXMge05vZGV9ICovIGZ1bmN0aW9uKGFzc2lnbmVkVmFsdWUpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRleHQgbm9kZSB0aGVuIHRoZXJlIGFyZSBubyBub2RlcyB0byBkaXNjb25uZWN0LlxuICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICBiYXNlRGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCBhc3NpZ25lZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVtb3ZlZE5vZGVzID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBDaGVja2luZyBmb3IgYGZpcnN0Q2hpbGRgIGlzIGZhc3RlciB0aGFuIHJlYWRpbmcgYGNoaWxkTm9kZXMubGVuZ3RoYFxuICAgICAgICAvLyB0byBjb21wYXJlIHdpdGggMC5cbiAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIC8vIFVzaW5nIGBjaGlsZE5vZGVzYCBpcyBmYXN0ZXIgdGhhbiBgY2hpbGRyZW5gLCBldmVuIHRob3VnaCB3ZSBvbmx5XG4gICAgICAgICAgLy8gY2FyZSBhYm91dCBlbGVtZW50cy5cbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gdGhpcy5jaGlsZE5vZGVzO1xuICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZXNMZW5ndGggPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoY2hpbGROb2Rlc0xlbmd0aCA+IDAgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgICAvLyBDb3B5aW5nIGFuIGFycmF5IGJ5IGl0ZXJhdGluZyBpcyBmYXN0ZXIgdGhhbiB1c2luZyBzbGljZS5cbiAgICAgICAgICAgIHJlbW92ZWROb2RlcyA9IG5ldyBBcnJheShjaGlsZE5vZGVzTGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGROb2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHJlbW92ZWROb2Rlc1tpXSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYmFzZURlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgYXNzaWduZWRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZWROb2Rlcykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUocmVtb3ZlZE5vZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBpZiAoTmF0aXZlLk5vZGVfdGV4dENvbnRlbnQgJiYgTmF0aXZlLk5vZGVfdGV4dENvbnRlbnQuZ2V0KSB7XG4gICAgcGF0Y2hfdGV4dENvbnRlbnQoTm9kZS5wcm90b3R5cGUsIE5hdGl2ZS5Ob2RlX3RleHRDb250ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBpbnRlcm5hbHMuYWRkUGF0Y2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcGF0Y2hfdGV4dENvbnRlbnQoZWxlbWVudCwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaW1wbGVtZW50YXRpb24gb2YgdGhlIGB0ZXh0Q29udGVudGAgZ2V0dGVyIGFzc3VtZXMgdGhhdFxuICAgICAgICAvLyB0ZXh0IG5vZGVzJyBgdGV4dENvbnRlbnRgIGdldHRlciB3aWxsIG5vdCBiZSBwYXRjaGVkLlxuICAgICAgICBnZXQ6IC8qKiBAdGhpcyB7Tm9kZX0gKi8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5jaGlsZE5vZGVzW2ldLnRleHRDb250ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogLyoqIEB0aGlzIHtOb2RlfSAqLyBmdW5jdGlvbihhc3NpZ25lZFZhbHVlKSB7XG4gICAgICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgTmF0aXZlLk5vZGVfcmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBOYXRpdmUuTm9kZV9hcHBlbmRDaGlsZC5jYWxsKHRoaXMsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGFzc2lnbmVkVmFsdWUpKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuIiwiaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi4vLi4vVXRpbGl0aWVzLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBiZWZvcmU6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG4gKiAgIGFmdGVyOiAhZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpLFxuICogICByZXBsYWNlV2l0aDogIWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKSxcbiAqICAgcmVtb3ZlOiAhZnVuY3Rpb24oKSxcbiAqIH19XG4gKi9cbmxldCBDaGlsZE5vZGVOYXRpdmVNZXRob2RzO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICogQHBhcmFtIHshT2JqZWN0fSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHshQ2hpbGROb2RlTmF0aXZlTWV0aG9kc30gYnVpbHRJblxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMsIGRlc3RpbmF0aW9uLCBidWlsdEluKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuICAgKi9cbiAgZGVzdGluYXRpb25bJ2JlZm9yZSddID0gZnVuY3Rpb24oLi4ubm9kZXMpIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBmb3Igd2hlbiBvbmUgb2YgYG5vZGVzYCBpcyBhIERvY3VtZW50RnJhZ21lbnQhXG4gICAgY29uc3QgY29ubmVjdGVkQmVmb3JlID0gLyoqIEB0eXBlIHshQXJyYXk8IU5vZGU+fSAqLyAobm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlIG5vdCBjb25uZWN0ZWQgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICB9KSk7XG5cbiAgICBidWlsdEluLmJlZm9yZS5hcHBseSh0aGlzLCBub2Rlcyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEJlZm9yZS5sZW5ndGg7IGkrKykge1xuICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGNvbm5lY3RlZEJlZm9yZVtpXSk7XG4gICAgfVxuXG4gICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHsuLi4oIU5vZGV8c3RyaW5nKX0gbm9kZXNcbiAgICovXG4gIGRlc3RpbmF0aW9uWydhZnRlciddID0gZnVuY3Rpb24oLi4ubm9kZXMpIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBmb3Igd2hlbiBvbmUgb2YgYG5vZGVzYCBpcyBhIERvY3VtZW50RnJhZ21lbnQhXG4gICAgY29uc3QgY29ubmVjdGVkQmVmb3JlID0gLyoqIEB0eXBlIHshQXJyYXk8IU5vZGU+fSAqLyAobm9kZXMuZmlsdGVyKG5vZGUgPT4ge1xuICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgYXJlIG5vdCBjb25uZWN0ZWQgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBOb2RlICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICB9KSk7XG5cbiAgICBidWlsdEluLmFmdGVyLmFwcGx5KHRoaXMsIG5vZGVzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29ubmVjdGVkQmVmb3JlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUoY29ubmVjdGVkQmVmb3JlW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuICAgKi9cbiAgZGVzdGluYXRpb25bJ3JlcGxhY2VXaXRoJ10gPSBmdW5jdGlvbiguLi5ub2Rlcykge1xuICAgIC8vIFRPRE86IEZpeCB0aGlzIGZvciB3aGVuIG9uZSBvZiBgbm9kZXNgIGlzIGEgRG9jdW1lbnRGcmFnbWVudCFcbiAgICBjb25zdCBjb25uZWN0ZWRCZWZvcmUgPSAvKiogQHR5cGUgeyFBcnJheTwhTm9kZT59ICovIChub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmUgbm90IGNvbm5lY3RlZCBhbmQgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgIH0pKTtcblxuICAgIGNvbnN0IHdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKTtcblxuICAgIGJ1aWx0SW4ucmVwbGFjZVdpdGguYXBwbHkodGhpcywgbm9kZXMpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25uZWN0ZWRCZWZvcmUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShjb25uZWN0ZWRCZWZvcmVbaV0pO1xuICAgIH1cblxuICAgIGlmICh3YXNDb25uZWN0ZWQpIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZSh0aGlzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZGVzdGluYXRpb25bJ3JlbW92ZSddID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc3Qgd2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpO1xuXG4gICAgYnVpbHRJbi5yZW1vdmUuY2FsbCh0aGlzKTtcblxuICAgIGlmICh3YXNDb25uZWN0ZWQpIHtcbiAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZSh0aGlzKTtcbiAgICB9XG4gIH07XG59O1xuIiwiaW1wb3J0IE5hdGl2ZSBmcm9tICcuL05hdGl2ZS5qcyc7XG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCBDRVN0YXRlIGZyb20gJy4uL0N1c3RvbUVsZW1lbnRTdGF0ZS5qcyc7XG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi4vVXRpbGl0aWVzLmpzJztcblxuaW1wb3J0IFBhdGNoUGFyZW50Tm9kZSBmcm9tICcuL0ludGVyZmFjZS9QYXJlbnROb2RlLmpzJztcbmltcG9ydCBQYXRjaENoaWxkTm9kZSBmcm9tICcuL0ludGVyZmFjZS9DaGlsZE5vZGUuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMpIHtcbiAgaWYgKE5hdGl2ZS5FbGVtZW50X2F0dGFjaFNoYWRvdykge1xuICAgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ2F0dGFjaFNoYWRvdycsXG4gICAgICAvKipcbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICogQHBhcmFtIHshe21vZGU6IHN0cmluZ319IGluaXRcbiAgICAgICAqIEByZXR1cm4ge1NoYWRvd1Jvb3R9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uKGluaXQpIHtcbiAgICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IE5hdGl2ZS5FbGVtZW50X2F0dGFjaFNoYWRvdy5jYWxsKHRoaXMsIGluaXQpO1xuICAgICAgICB0aGlzLl9fQ0Vfc2hhZG93Um9vdCA9IHNoYWRvd1Jvb3Q7XG4gICAgICAgIHJldHVybiBzaGFkb3dSb290O1xuICAgICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gRWxlbWVudHM6IGBFbGVtZW50I2F0dGFjaFNoYWRvd2Agd2FzIG5vdCBwYXRjaGVkLicpO1xuICB9XG5cblxuICBmdW5jdGlvbiBwYXRjaF9pbm5lckhUTUwoZGVzdGluYXRpb24sIGJhc2VEZXNjcmlwdG9yKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3RpbmF0aW9uLCAnaW5uZXJIVE1MJywge1xuICAgICAgZW51bWVyYWJsZTogYmFzZURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogYmFzZURlc2NyaXB0b3IuZ2V0LFxuICAgICAgc2V0OiAvKiogQHRoaXMge0VsZW1lbnR9ICovIGZ1bmN0aW9uKGh0bWxTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcyk7XG5cbiAgICAgICAgLy8gTk9URTogSW4gSUUxMSwgd2hlbiB1c2luZyB0aGUgbmF0aXZlIGBpbm5lckhUTUxgIHNldHRlciwgYWxsIG5vZGVzXG4gICAgICAgIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlc2NlbmRhbnRzIG9mIHRoZSBjb250ZXh0IGVsZW1lbnQgaGF2ZSBhbGwgb2ZcbiAgICAgICAgLy8gdGhlaXIgY2hpbGRyZW4gcmVtb3ZlZCBhcyBwYXJ0IG9mIHRoZSBzZXQgLSB0aGUgZW50aXJlIHN1YnRyZWUgaXNcbiAgICAgICAgLy8gJ2Rpc2Fzc2VtYmxlZCcuIFRoaXMgd29yayBhcm91bmQgd2Fsa3MgdGhlIHN1YnRyZWUgKmJlZm9yZSogdXNpbmcgdGhlXG4gICAgICAgIC8vIG5hdGl2ZSBzZXR0ZXIuXG4gICAgICAgIC8qKiBAdHlwZSB7IUFycmF5PCFFbGVtZW50Pnx1bmRlZmluZWR9ICovXG4gICAgICAgIGxldCByZW1vdmVkRWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RlZCkge1xuICAgICAgICAgIHJlbW92ZWRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyh0aGlzLCBlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIHJlbW92ZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFzZURlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgaHRtbFN0cmluZyk7XG5cbiAgICAgICAgaWYgKHJlbW92ZWRFbGVtZW50cykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVtb3ZlZEVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuX19DRV9zdGF0ZSA9PT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGVsZW1lbnQncyBvd25lciBkb2N1bWVudCBpc1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgICBpZiAoIXRoaXMub3duZXJEb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG4gICAgICAgICAgaW50ZXJuYWxzLnBhdGNoVHJlZSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbFN0cmluZztcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBpZiAoTmF0aXZlLkVsZW1lbnRfaW5uZXJIVE1MICYmIE5hdGl2ZS5FbGVtZW50X2lubmVySFRNTC5nZXQpIHtcbiAgICBwYXRjaF9pbm5lckhUTUwoRWxlbWVudC5wcm90b3R5cGUsIE5hdGl2ZS5FbGVtZW50X2lubmVySFRNTCk7XG4gIH0gZWxzZSBpZiAoTmF0aXZlLkhUTUxFbGVtZW50X2lubmVySFRNTCAmJiBOYXRpdmUuSFRNTEVsZW1lbnRfaW5uZXJIVE1MLmdldCkge1xuICAgIHBhdGNoX2lubmVySFRNTChIVE1MRWxlbWVudC5wcm90b3R5cGUsIE5hdGl2ZS5IVE1MRWxlbWVudF9pbm5lckhUTUwpO1xuICB9IGVsc2Uge1xuXG4gICAgLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH0gKi9cbiAgICBjb25zdCByYXdEaXYgPSBOYXRpdmUuRG9jdW1lbnRfY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCAnZGl2Jyk7XG5cbiAgICBpbnRlcm5hbHMuYWRkUGF0Y2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcGF0Y2hfaW5uZXJIVE1MKGVsZW1lbnQsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAvLyBJbXBsZW1lbnRzIGdldHRpbmcgYGlubmVySFRNTGAgYnkgcGVyZm9ybWluZyBhbiB1bnBhdGNoZWQgYGNsb25lTm9kZWBcbiAgICAgICAgLy8gb2YgdGhlIGVsZW1lbnQgYW5kIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIGVsZW1lbnQncyBgaW5uZXJIVE1MYC5cbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyB0b28gZXhwZW5zaXZlP1xuICAgICAgICBnZXQ6IC8qKiBAdGhpcyB7RWxlbWVudH0gKi8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIE5hdGl2ZS5Ob2RlX2Nsb25lTm9kZS5jYWxsKHRoaXMsIHRydWUpLmlubmVySFRNTDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gSW1wbGVtZW50cyBzZXR0aW5nIGBpbm5lckhUTUxgIGJ5IGNyZWF0aW5nIGFuIHVucGF0Y2hlZCBlbGVtZW50LFxuICAgICAgICAvLyBzZXR0aW5nIGBpbm5lckhUTUxgIG9mIHRoYXQgZWxlbWVudCBhbmQgcmVwbGFjaW5nIHRoZSB0YXJnZXRcbiAgICAgICAgLy8gZWxlbWVudCdzIGNoaWxkcmVuIHdpdGggdGhvc2Ugb2YgdGhlIHVucGF0Y2hlZCBlbGVtZW50LlxuICAgICAgICBzZXQ6IC8qKiBAdGhpcyB7RWxlbWVudH0gKi8gZnVuY3Rpb24oYXNzaWduZWRWYWx1ZSkge1xuICAgICAgICAgIC8vIE5PVEU6IHJlLXJvdXRlIHRvIGBjb250ZW50YCBmb3IgYHRlbXBsYXRlYCBlbGVtZW50cy5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYmVjYXVzZSBgdGVtcGxhdGUuYXBwZW5kQ2hpbGRgIGRvZXMgbm90XG4gICAgICAgICAgLy8gcm91dGUgaW50byBgdGVtcGxhdGUuY29udGVudGAuXG4gICAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi9cbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScgPyAoLyoqIEB0eXBlIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKHRoaXMpKS5jb250ZW50IDogdGhpcztcbiAgICAgICAgICByYXdEaXYuaW5uZXJIVE1MID0gYXNzaWduZWRWYWx1ZTtcblxuICAgICAgICAgIHdoaWxlIChjb250ZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgTmF0aXZlLk5vZGVfcmVtb3ZlQ2hpbGQuY2FsbChjb250ZW50LCBjb250ZW50LmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAocmF3RGl2LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgTmF0aXZlLk5vZGVfYXBwZW5kQ2hpbGQuY2FsbChjb250ZW50LCByYXdEaXYuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ3NldEF0dHJpYnV0ZScsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lLCBuZXdWYWx1ZSkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgcmV0dXJuIE5hdGl2ZS5FbGVtZW50X3NldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIE5hdGl2ZS5FbGVtZW50X3NldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIG5ld1ZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICBpbnRlcm5hbHMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbnVsbCk7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAnc2V0QXR0cmlidXRlTlMnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lc3BhY2UsIG5hbWUsIG5ld1ZhbHVlKSB7XG4gICAgICAvLyBGYXN0IHBhdGggZm9yIG5vbi1jdXN0b20gZWxlbWVudHMuXG4gICAgICBpZiAodGhpcy5fX0NFX3N0YXRlICE9PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICByZXR1cm4gTmF0aXZlLkVsZW1lbnRfc2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICBOYXRpdmUuRWxlbWVudF9zZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSwgbmV3VmFsdWUpO1xuICAgICAgbmV3VmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICBpbnRlcm5hbHMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbmFtZXNwYWNlKTtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRWxlbWVudC5wcm90b3R5cGUsICdyZW1vdmVBdHRyaWJ1dGUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24obmFtZSkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgcmV0dXJuIE5hdGl2ZS5FbGVtZW50X3JlbW92ZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgTmF0aXZlLkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICBpZiAob2xkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbnVsbCwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAncmVtb3ZlQXR0cmlidXRlTlMnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lc3BhY2UsIG5hbWUpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3Igbm9uLWN1c3RvbSBlbGVtZW50cy5cbiAgICAgIGlmICh0aGlzLl9fQ0Vfc3RhdGUgIT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIHJldHVybiBOYXRpdmUuRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgTmF0aXZlLkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgLy8gSW4gb2xkZXIgYnJvd3NlcnMsIGBFbGVtZW50I2dldEF0dHJpYnV0ZU5TYCBtYXkgcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAgIC8vIGluc3RlYWQgb2YgbnVsbCBpZiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0LiBGb3IgZGV0YWlscywgc2VlO1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0QXR0cmlidXRlTlMjTm90ZXNcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICBpbnRlcm5hbHMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuXG4gIGZ1bmN0aW9uIHBhdGNoX2luc2VydEFkamFjZW50RWxlbWVudChkZXN0aW5hdGlvbiwgYmFzZU1ldGhvZCkge1xuICAgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChkZXN0aW5hdGlvbiwgJ2luc2VydEFkamFjZW50RWxlbWVudCcsXG4gICAgICAvKipcbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdoZXJlXG4gICAgICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAgICAgKiBAcmV0dXJuIHs/RWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24od2hlcmUsIGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qgd2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBpbnNlcnRlZEVsZW1lbnQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL1xuICAgICAgICAgIChiYXNlTWV0aG9kLmNhbGwodGhpcywgd2hlcmUsIGVsZW1lbnQpKTtcblxuICAgICAgICBpZiAod2FzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZChpbnNlcnRlZEVsZW1lbnQpKSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNlcnRlZEVsZW1lbnQ7XG4gICAgICB9KTtcbiAgfVxuXG4gIGlmIChOYXRpdmUuSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KSB7XG4gICAgcGF0Y2hfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgTmF0aXZlLkhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCk7XG4gIH0gZWxzZSBpZiAoTmF0aXZlLkVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KSB7XG4gICAgcGF0Y2hfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KEVsZW1lbnQucHJvdG90eXBlLCBOYXRpdmUuRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIEVsZW1lbnRzOiBgRWxlbWVudCNpbnNlcnRBZGphY2VudEVsZW1lbnRgIHdhcyBub3QgcGF0Y2hlZC4nKTtcbiAgfVxuXG5cbiAgUGF0Y2hQYXJlbnROb2RlKGludGVybmFscywgRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICBwcmVwZW5kOiBOYXRpdmUuRWxlbWVudF9wcmVwZW5kLFxuICAgIGFwcGVuZDogTmF0aXZlLkVsZW1lbnRfYXBwZW5kLFxuICB9KTtcblxuICBQYXRjaENoaWxkTm9kZShpbnRlcm5hbHMsIEVsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgYmVmb3JlOiBOYXRpdmUuRWxlbWVudF9iZWZvcmUsXG4gICAgYWZ0ZXI6IE5hdGl2ZS5FbGVtZW50X2FmdGVyLFxuICAgIHJlcGxhY2VXaXRoOiBOYXRpdmUuRWxlbWVudF9yZXBsYWNlV2l0aCxcbiAgICByZW1vdmU6IE5hdGl2ZS5FbGVtZW50X3JlbW92ZSxcbiAgfSk7XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbmltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IGZyb20gJy4vQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LmpzJztcblxuaW1wb3J0IFBhdGNoSFRNTEVsZW1lbnQgZnJvbSAnLi9QYXRjaC9IVE1MRWxlbWVudC5qcyc7XG5pbXBvcnQgUGF0Y2hEb2N1bWVudCBmcm9tICcuL1BhdGNoL0RvY3VtZW50LmpzJztcbmltcG9ydCBQYXRjaE5vZGUgZnJvbSAnLi9QYXRjaC9Ob2RlLmpzJztcbmltcG9ydCBQYXRjaEVsZW1lbnQgZnJvbSAnLi9QYXRjaC9FbGVtZW50LmpzJztcblxuY29uc3QgcHJpb3JDdXN0b21FbGVtZW50cyA9IHdpbmRvd1snY3VzdG9tRWxlbWVudHMnXTtcblxuaWYgKCFwcmlvckN1c3RvbUVsZW1lbnRzIHx8XG4gICAgIHByaW9yQ3VzdG9tRWxlbWVudHNbJ2ZvcmNlUG9seWZpbGwnXSB8fFxuICAgICAodHlwZW9mIHByaW9yQ3VzdG9tRWxlbWVudHNbJ2RlZmluZSddICE9ICdmdW5jdGlvbicpIHx8XG4gICAgICh0eXBlb2YgcHJpb3JDdXN0b21FbGVtZW50c1snZ2V0J10gIT0gJ2Z1bmN0aW9uJykpIHtcbiAgLyoqIEB0eXBlIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gKi9cbiAgY29uc3QgaW50ZXJuYWxzID0gbmV3IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMoKTtcblxuICBQYXRjaEhUTUxFbGVtZW50KGludGVybmFscyk7XG4gIFBhdGNoRG9jdW1lbnQoaW50ZXJuYWxzKTtcbiAgUGF0Y2hOb2RlKGludGVybmFscyk7XG4gIFBhdGNoRWxlbWVudChpbnRlcm5hbHMpO1xuXG4gIC8vIFRoZSBtYWluIGRvY3VtZW50IGlzIGFsd2F5cyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICBkb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5ID0gdHJ1ZTtcblxuICAvKiogQHR5cGUgeyFDdXN0b21FbGVtZW50UmVnaXN0cnl9ICovXG4gIGNvbnN0IGN1c3RvbUVsZW1lbnRzID0gbmV3IEN1c3RvbUVsZW1lbnRSZWdpc3RyeShpbnRlcm5hbHMpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdjdXN0b21FbGVtZW50cycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogY3VzdG9tRWxlbWVudHMsXG4gIH0pO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vLyBAdmVyc2lvbiAwLjcuMjJcblxuKGZ1bmN0aW9uKGdsb2JhbCkge1xuICBpZiAoZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlcikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVnaXN0cmF0aW9uc1RhYmxlID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIHNldEltbWVkaWF0ZTtcbiAgaWYgKC9UcmlkZW50fEVkZ2UvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSBzZXRUaW1lb3V0O1xuICB9IGVsc2UgaWYgKHdpbmRvdy5zZXRJbW1lZGlhdGUpIHtcbiAgICBzZXRJbW1lZGlhdGUgPSB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzZXRJbW1lZGlhdGVRdWV1ZSA9IFtdO1xuICAgIHZhciBzZW50aW5lbCA9IFN0cmluZyhNYXRoLnJhbmRvbSgpKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuZGF0YSA9PT0gc2VudGluZWwpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gc2V0SW1tZWRpYXRlUXVldWU7XG4gICAgICAgIHNldEltbWVkaWF0ZVF1ZXVlID0gW107XG4gICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIGZ1bmMoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgc2V0SW1tZWRpYXRlUXVldWUucHVzaChmdW5jKTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShzZW50aW5lbCwgXCIqXCIpO1xuICAgIH07XG4gIH1cbiAgdmFyIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhvYnNlcnZlcikge1xuICAgIHNjaGVkdWxlZE9ic2VydmVycy5wdXNoKG9ic2VydmVyKTtcbiAgICBpZiAoIWlzU2NoZWR1bGVkKSB7XG4gICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRJbW1lZGlhdGUoZGlzcGF0Y2hDYWxsYmFja3MpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3cmFwSWZOZWVkZWQobm9kZSkge1xuICAgIHJldHVybiB3aW5kb3cuU2hhZG93RE9NUG9seWZpbGwgJiYgd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsLndyYXBJZk5lZWRlZChub2RlKSB8fCBub2RlO1xuICB9XG4gIGZ1bmN0aW9uIGRpc3BhdGNoQ2FsbGJhY2tzKCkge1xuICAgIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdmFyIG9ic2VydmVycyA9IHNjaGVkdWxlZE9ic2VydmVycztcbiAgICBzY2hlZHVsZWRPYnNlcnZlcnMgPSBbXTtcbiAgICBvYnNlcnZlcnMuc29ydChmdW5jdGlvbihvMSwgbzIpIHtcbiAgICAgIHJldHVybiBvMS51aWRfIC0gbzIudWlkXztcbiAgICB9KTtcbiAgICB2YXIgYW55Tm9uRW1wdHkgPSBmYWxzZTtcbiAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbihvYnNlcnZlcikge1xuICAgICAgdmFyIHF1ZXVlID0gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcik7XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIG9ic2VydmVyLmNhbGxiYWNrXyhxdWV1ZSwgb2JzZXJ2ZXIpO1xuICAgICAgICBhbnlOb25FbXB0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGFueU5vbkVtcHR5KSBkaXNwYXRjaENhbGxiYWNrcygpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZVRyYW5zaWVudE9ic2VydmVyc0ZvcihvYnNlcnZlcikge1xuICAgIG9ic2VydmVyLm5vZGVzXy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgIGlmICghcmVnaXN0cmF0aW9ucykgcmV0dXJuO1xuICAgICAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICBpZiAocmVnaXN0cmF0aW9uLm9ic2VydmVyID09PSBvYnNlcnZlcikgcmVnaXN0cmF0aW9uLnJlbW92ZVRyYW5zaWVudE9ic2VydmVycygpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBub2RlID0gdGFyZ2V0OyBub2RlOyBub2RlID0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IHJlZ2lzdHJhdGlvbnNUYWJsZS5nZXQobm9kZSk7XG4gICAgICBpZiAocmVnaXN0cmF0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc1tqXTtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHJlZ2lzdHJhdGlvbi5vcHRpb25zO1xuICAgICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQgJiYgIW9wdGlvbnMuc3VidHJlZSkgY29udGludWU7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGNhbGxiYWNrKG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChyZWNvcmQpIHJlZ2lzdHJhdGlvbi5lbnF1ZXVlKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIHVpZENvdW50ZXIgPSAwO1xuICBmdW5jdGlvbiBKc011dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgIHRoaXMubm9kZXNfID0gW107XG4gICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIHRoaXMudWlkXyA9ICsrdWlkQ291bnRlcjtcbiAgfVxuICBKc011dGF0aW9uT2JzZXJ2ZXIucHJvdG90eXBlID0ge1xuICAgIG9ic2VydmU6IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgdGFyZ2V0ID0gd3JhcElmTmVlZGVkKHRhcmdldCk7XG4gICAgICBpZiAoIW9wdGlvbnMuY2hpbGRMaXN0ICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSB8fCBvcHRpb25zLmF0dHJpYnV0ZU9sZFZhbHVlICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmICFvcHRpb25zLmF0dHJpYnV0ZXMgfHwgb3B0aW9ucy5jaGFyYWN0ZXJEYXRhT2xkVmFsdWUgJiYgIW9wdGlvbnMuY2hhcmFjdGVyRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldCh0YXJnZXQpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KHRhcmdldCwgcmVnaXN0cmF0aW9ucyA9IFtdKTtcbiAgICAgIHZhciByZWdpc3RyYXRpb247XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbnNbaV0ub2JzZXJ2ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICByZWdpc3RyYXRpb24gPSByZWdpc3RyYXRpb25zW2ldO1xuICAgICAgICAgIHJlZ2lzdHJhdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICByZWdpc3RyYXRpb24ub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHJlZ2lzdHJhdGlvbiA9IG5ldyBSZWdpc3RyYXRpb24odGhpcywgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgICAgcmVnaXN0cmF0aW9ucy5wdXNoKHJlZ2lzdHJhdGlvbik7XG4gICAgICAgIHRoaXMubm9kZXNfLnB1c2godGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHJlZ2lzdHJhdGlvbi5hZGRMaXN0ZW5lcnMoKTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ub2Rlc18uZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gcmVnaXN0cmF0aW9uc1RhYmxlLmdldChub2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHJlZ2lzdHJhdGlvbnNbaV07XG4gICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5vYnNlcnZlciA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9uLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgIH0sXG4gICAgdGFrZVJlY29yZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHlPZlJlY29yZHMgPSB0aGlzLnJlY29yZHNfO1xuICAgICAgdGhpcy5yZWNvcmRzXyA9IFtdO1xuICAgICAgcmV0dXJuIGNvcHlPZlJlY29yZHM7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xuICAgIHRoaXMucmVtb3ZlZE5vZGVzID0gW107XG4gICAgdGhpcy5wcmV2aW91c1NpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMubmV4dFNpYmxpbmcgPSBudWxsO1xuICAgIHRoaXMuYXR0cmlidXRlTmFtZSA9IG51bGw7XG4gICAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBudWxsO1xuICAgIHRoaXMub2xkVmFsdWUgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGNvcHlNdXRhdGlvblJlY29yZChvcmlnaW5hbCkge1xuICAgIHZhciByZWNvcmQgPSBuZXcgTXV0YXRpb25SZWNvcmQob3JpZ2luYWwudHlwZSwgb3JpZ2luYWwudGFyZ2V0KTtcbiAgICByZWNvcmQuYWRkZWROb2RlcyA9IG9yaWdpbmFsLmFkZGVkTm9kZXMuc2xpY2UoKTtcbiAgICByZWNvcmQucmVtb3ZlZE5vZGVzID0gb3JpZ2luYWwucmVtb3ZlZE5vZGVzLnNsaWNlKCk7XG4gICAgcmVjb3JkLnByZXZpb3VzU2libGluZyA9IG9yaWdpbmFsLnByZXZpb3VzU2libGluZztcbiAgICByZWNvcmQubmV4dFNpYmxpbmcgPSBvcmlnaW5hbC5uZXh0U2libGluZztcbiAgICByZWNvcmQuYXR0cmlidXRlTmFtZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWU7XG4gICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG9yaWdpbmFsLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICByZWNvcmQub2xkVmFsdWUgPSBvcmlnaW5hbC5vbGRWYWx1ZTtcbiAgICByZXR1cm4gcmVjb3JkO1xuICB9XG4gIHZhciBjdXJyZW50UmVjb3JkLCByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIGZ1bmN0aW9uIGdldFJlY29yZCh0eXBlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gY3VycmVudFJlY29yZCA9IG5ldyBNdXRhdGlvblJlY29yZCh0eXBlLCB0YXJnZXQpO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJlY29yZFdpdGhPbGRWYWx1ZShvbGRWYWx1ZSkge1xuICAgIGlmIChyZWNvcmRXaXRoT2xkVmFsdWUpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmVjb3JkV2l0aE9sZFZhbHVlID0gY29weU11dGF0aW9uUmVjb3JkKGN1cnJlbnRSZWNvcmQpO1xuICAgIHJlY29yZFdpdGhPbGRWYWx1ZS5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJSZWNvcmRzKCkge1xuICAgIGN1cnJlbnRSZWNvcmQgPSByZWNvcmRXaXRoT2xkVmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb3JkUmVwcmVzZW50c0N1cnJlbnRNdXRhdGlvbihyZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkID09PSByZWNvcmRXaXRoT2xkVmFsdWUgfHwgcmVjb3JkID09PSBjdXJyZW50UmVjb3JkO1xuICB9XG4gIGZ1bmN0aW9uIHNlbGVjdFJlY29yZChsYXN0UmVjb3JkLCBuZXdSZWNvcmQpIHtcbiAgICBpZiAobGFzdFJlY29yZCA9PT0gbmV3UmVjb3JkKSByZXR1cm4gbGFzdFJlY29yZDtcbiAgICBpZiAocmVjb3JkV2l0aE9sZFZhbHVlICYmIHJlY29yZFJlcHJlc2VudHNDdXJyZW50TXV0YXRpb24obGFzdFJlY29yZCkpIHJldHVybiByZWNvcmRXaXRoT2xkVmFsdWU7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gUmVnaXN0cmF0aW9uKG9ic2VydmVyLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9ic2VydmVyID0gb2JzZXJ2ZXI7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgfVxuICBSZWdpc3RyYXRpb24ucHJvdG90eXBlID0ge1xuICAgIGVucXVldWU6IGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgdmFyIHJlY29yZHMgPSB0aGlzLm9ic2VydmVyLnJlY29yZHNfO1xuICAgICAgdmFyIGxlbmd0aCA9IHJlY29yZHMubGVuZ3RoO1xuICAgICAgaWYgKHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgbGFzdFJlY29yZCA9IHJlY29yZHNbbGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciByZWNvcmRUb1JlcGxhY2VMYXN0ID0gc2VsZWN0UmVjb3JkKGxhc3RSZWNvcmQsIHJlY29yZCk7XG4gICAgICAgIGlmIChyZWNvcmRUb1JlcGxhY2VMYXN0KSB7XG4gICAgICAgICAgcmVjb3Jkc1tsZW5ndGggLSAxXSA9IHJlY29yZFRvUmVwbGFjZUxhc3Q7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrKHRoaXMub2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgICAgcmVjb3Jkc1tsZW5ndGhdID0gcmVjb3JkO1xuICAgIH0sXG4gICAgYWRkTGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyh0aGlzLnRhcmdldCk7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcnNfOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmIChvcHRpb25zLmF0dHJpYnV0ZXMpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUF0dHJNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoYXJhY3RlckRhdGEpIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLCB0cnVlKTtcbiAgICAgIGlmIChvcHRpb25zLmNoaWxkTGlzdCkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZUluc2VydGVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0IHx8IG9wdGlvbnMuc3VidHJlZSkgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnNfKHRoaXMudGFyZ2V0KTtcbiAgICB9LFxuICAgIHJlbW92ZUxpc3RlbmVyc186IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcykgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQXR0ck1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YSkgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMsIHRydWUpO1xuICAgICAgaWYgKG9wdGlvbnMuY2hpbGRMaXN0KSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlSW5zZXJ0ZWRcIiwgdGhpcywgdHJ1ZSk7XG4gICAgICBpZiAob3B0aW9ucy5jaGlsZExpc3QgfHwgb3B0aW9ucy5zdWJ0cmVlKSBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJET01Ob2RlUmVtb3ZlZFwiLCB0aGlzLCB0cnVlKTtcbiAgICB9LFxuICAgIGFkZFRyYW5zaWVudE9ic2VydmVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy50YXJnZXQpIHJldHVybjtcbiAgICAgIHRoaXMuYWRkTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgIHRoaXMudHJhbnNpZW50T2JzZXJ2ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFyZWdpc3RyYXRpb25zKSByZWdpc3RyYXRpb25zVGFibGUuc2V0KG5vZGUsIHJlZ2lzdHJhdGlvbnMgPSBbXSk7XG4gICAgICByZWdpc3RyYXRpb25zLnB1c2godGhpcyk7XG4gICAgfSxcbiAgICByZW1vdmVUcmFuc2llbnRPYnNlcnZlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXM7XG4gICAgICB0aGlzLnRyYW5zaWVudE9ic2VydmVkTm9kZXMgPSBbXTtcbiAgICAgIHRyYW5zaWVudE9ic2VydmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzXyhub2RlKTtcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbnMgPSByZWdpc3RyYXRpb25zVGFibGUuZ2V0KG5vZGUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uc1tpXSA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG4gICAgaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgIGNhc2UgXCJET01BdHRyTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIG5hbWUgPSBlLmF0dHJOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gZS5yZWxhdGVkTm9kZS5uYW1lc3BhY2VVUkk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHJlY29yZCA9IG5ldyBnZXRSZWNvcmQoXCJhdHRyaWJ1dGVzXCIsIHRhcmdldCk7XG4gICAgICAgIHJlY29yZC5hdHRyaWJ1dGVOYW1lID0gbmFtZTtcbiAgICAgICAgcmVjb3JkLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZS5hdHRyQ2hhbmdlID09PSBNdXRhdGlvbkV2ZW50LkFERElUSU9OID8gbnVsbCA6IGUucHJldlZhbHVlO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQodGFyZ2V0LCBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmF0dHJpYnV0ZXMpIHJldHVybjtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIgJiYgb3B0aW9ucy5hdHRyaWJ1dGVGaWx0ZXIubGVuZ3RoICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZSkgPT09IC0xICYmIG9wdGlvbnMuYXR0cmlidXRlRmlsdGVyLmluZGV4T2YobmFtZXNwYWNlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlT2xkVmFsdWUpIHJldHVybiBnZXRSZWNvcmRXaXRoT2xkVmFsdWUob2xkVmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWRcIjpcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hhcmFjdGVyRGF0YVwiLCB0YXJnZXQpO1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSBlLnByZXZWYWx1ZTtcbiAgICAgICAgZm9yRWFjaEFuY2VzdG9yQW5kT2JzZXJ2ZXJFbnF1ZXVlUmVjb3JkKHRhcmdldCwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGFyYWN0ZXJEYXRhKSByZXR1cm47XG4gICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcmFjdGVyRGF0YU9sZFZhbHVlKSByZXR1cm4gZ2V0UmVjb3JkV2l0aE9sZFZhbHVlKG9sZFZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZVJlbW92ZWRcIjpcbiAgICAgICAgdGhpcy5hZGRUcmFuc2llbnRPYnNlcnZlcihlLnRhcmdldCk7XG5cbiAgICAgICBjYXNlIFwiRE9NTm9kZUluc2VydGVkXCI6XG4gICAgICAgIHZhciBjaGFuZ2VkTm9kZSA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgYWRkZWROb2RlcywgcmVtb3ZlZE5vZGVzO1xuICAgICAgICBpZiAoZS50eXBlID09PSBcIkRPTU5vZGVJbnNlcnRlZFwiKSB7XG4gICAgICAgICAgYWRkZWROb2RlcyA9IFsgY2hhbmdlZE5vZGUgXTtcbiAgICAgICAgICByZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlZE5vZGVzID0gW107XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzID0gWyBjaGFuZ2VkTm9kZSBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBjaGFuZ2VkTm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHZhciBuZXh0U2libGluZyA9IGNoYW5nZWROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICB2YXIgcmVjb3JkID0gZ2V0UmVjb3JkKFwiY2hpbGRMaXN0XCIsIGUudGFyZ2V0LnBhcmVudE5vZGUpO1xuICAgICAgICByZWNvcmQuYWRkZWROb2RlcyA9IGFkZGVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5yZW1vdmVkTm9kZXMgPSByZW1vdmVkTm9kZXM7XG4gICAgICAgIHJlY29yZC5wcmV2aW91c1NpYmxpbmcgPSBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIHJlY29yZC5uZXh0U2libGluZyA9IG5leHRTaWJsaW5nO1xuICAgICAgICBmb3JFYWNoQW5jZXN0b3JBbmRPYnNlcnZlckVucXVldWVSZWNvcmQoZS5yZWxhdGVkTm9kZSwgZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5jaGlsZExpc3QpIHJldHVybjtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNsZWFyUmVjb3JkcygpO1xuICAgIH1cbiAgfTtcbiAgZ2xvYmFsLkpzTXV0YXRpb25PYnNlcnZlciA9IEpzTXV0YXRpb25PYnNlcnZlcjtcbiAgaWYgKCFnbG9iYWwuTXV0YXRpb25PYnNlcnZlcikge1xuICAgIGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyID0gSnNNdXRhdGlvbk9ic2VydmVyO1xuICAgIEpzTXV0YXRpb25PYnNlcnZlci5faXNQb2x5ZmlsbGVkID0gdHJ1ZTtcbiAgfVxufSkoc2VsZik7XG4iLCIvKlxuQ29weXJpZ2h0IChjKSAyMDEyIEJhcm5lc2FuZG5vYmxlLmNvbSwgbGxjLCBEb25hdm9uIFdlc3QsIGFuZCBEb21lbmljIERlbmljb2xhXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbk5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbkxJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbk9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciBzZXRJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3MpIHtcbiAgICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHBhcnRpYWxseUFwcGxpZWQuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHNldEltbWVkaWF0ZSwgYnV0XG4gICAgLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmVxdWlyZXMgbm8gYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIHBhcnRpYWxseUFwcGxpZWQoaGFuZGxlcikge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIChuZXcgRnVuY3Rpb24oXCJcIiArIGhhbmRsZXIpKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocGFydGlhbGx5QXBwbGllZChydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFzaygpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHBhcnRpYWxseUFwcGxpZWQocnVuSWZQcmVzZW50LCBoYW5kbGUpKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBzZXRJbW1lZGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBhZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgc2V0VGltZW91dChwYXJ0aWFsbHlBcHBsaWVkKHJ1bklmUHJlc2VudCwgaGFuZGxlKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0oc2VsZikpO1xuIiwiLy8gQ2F1dGlvbjpcbi8vIERvIG5vdCByZXBsYWNlIHRoaXMgaW1wb3J0IHN0YXRlbWVudCB3aXRoIGNvZGVzLlxuLy9cbi8vIElmIHlvdSByZXBsYWNlIHRoaXMgaW1wb3J0IHN0YXRlbWVudCB3aXRoIGNvZGVzLFxuLy8gdGhlIGNvZGVzIHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGZvbGxvd2luZyBwb2x5ZmlsbHMgYXJlIGltcG9ydGVkXG4vLyBiZWNhdXNlIGltcG9ydCBzdGF0ZW1lbnRzIGFyZSBob2lzdGVkIGR1cmluZyBjb21waWxhdGlvbi5cbmltcG9ydCAnLi9wb2x5ZmlsbC1zd2l0Y2hlcyc7XG5cbi8vIFBvbHlmaWxsIEVDTUFTY3JpcHQgc3RhbmRhcmQgZmVhdHVyZXMgd2l0aCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvblxuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mJztcbmltcG9ydCAnY29yZS1qcy9mbi9zZXQnO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL21hcCc7XG5pbXBvcnQgJ2NvcmUtanMvZm4vd2Vhay1tYXAnO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL2FycmF5L2Zyb20nO1xuXG4vLyBQb2x5ZmlsbCBDdXN0b20gRWxlbWVudHMgdjEgd2l0aCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvblxuaW1wb3J0ICdAb25zZW51aS9jdXN0b20tZWxlbWVudHMvc3JjL2N1c3RvbS1lbGVtZW50cyc7XG5cbi8vIFBvbHlmaWxsIE11dGF0aW9uT2JzZXJ2ZXIgd2l0aCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvblxuaW1wb3J0ICcuL011dGF0aW9uT2JzZXJ2ZXJAMC43LjIyL011dGF0aW9uT2JzZXJ2ZXIuanMnO1xuXG4vLyBQb2x5ZmlsbCBzZXRJbW1lZGlhdGUgd2l0aCBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvblxuaW1wb3J0ICcuL3NldEltbWVkaWF0ZUAxLjAuMittb2Qvc2V0SW1tZWRpYXRlLmpzJztcbiIsIihmdW5jdGlvbigpIHtcbiAgdmFyIERFRkFVTFRfVklFV1BPUlQgPSAnd2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSxtYXhpbXVtLXNjYWxlPTEsbWluaW11bS1zY2FsZT0xLHVzZXItc2NhbGFibGU9bm8nO1xuXG4gIHZhciBWaWV3cG9ydCA9IHsgXG4gICAgZW5zdXJlVmlld3BvcnRFbGVtZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2aWV3cG9ydEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9dmlld3BvcnRdJyk7XG5cbiAgICAgIGlmICghdmlld3BvcnRFbGVtZW50KSB7XG4gICAgICAgIHZpZXdwb3J0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICAgICAgdmlld3BvcnRFbGVtZW50Lm5hbWUgPSAndmlld3BvcnQnO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHZpZXdwb3J0RWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2aWV3cG9ydEVsZW1lbnQ7XG4gICAgfSxcblxuICAgIHNldHVwOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2aWV3cG9ydEVsZW1lbnQgPSBWaWV3cG9ydC5lbnN1cmVWaWV3cG9ydEVsZW1lbnQoKTtcblxuICAgICAgaWYgKCF2aWV3cG9ydEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZpZXdwb3J0RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnQnKSkge1xuICAgICAgICB2aWV3cG9ydEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgREVGQVVMVF9WSUVXUE9SVCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdpbmRvdy5WaWV3cG9ydCA9IFZpZXdwb3J0O1xufSkoKTtcbiIsImltcG9ydCB7IEZhc3RDbGljayB9IGZyb20gJ0BvbnNlbnVpL2Zhc3RjbGljayc7XG5pbXBvcnQgJy4vb25zL3BsYXRmb3JtJzsgLy8gVGhpcyBmaWxlIG11c3QgYmUgbG9hZGVkIGJlZm9yZSBDdXN0b20gRWxlbWVudHMgcG9seWZpbGxzLlxuaW1wb3J0ICcuL3BvbHlmaWxscy9pbmRleC5qcyc7XG5pbXBvcnQgJy4vdmVuZG9yL2luZGV4LmpzJztcbmltcG9ydCAnLi9vbnMvbWljcm9ldmVudC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldHVwKG9ucykge1xuICBpZiAod2luZG93Ll9vbnNMb2FkZWQpIHtcbiAgICBvbnMuX3V0aWwud2FybignT25zZW4gVUkgaXMgbG9hZGVkIG1vcmUgdGhhbiBvbmNlLicpO1xuICB9XG4gIHdpbmRvdy5fb25zTG9hZGVkID0gdHJ1ZTtcblxuICAvLyBmYXN0Y2xpY2tcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgb25zLmZhc3RDbGljayA9IEZhc3RDbGljay5hdHRhY2goZG9jdW1lbnQuYm9keSk7XG5cbiAgICBjb25zdCBzdXBwb3J0VG91Y2hBY3Rpb24gPSAndG91Y2gtYWN0aW9uJyBpbiBkb2N1bWVudC5ib2R5LnN0eWxlO1xuXG4gICAgb25zLnBsYXRmb3JtLl9ydW5PbkFjdHVhbFBsYXRmb3JtKCgpID0+IHtcbiAgICAgIGlmIChvbnMucGxhdGZvcm0uaXNBbmRyb2lkKCkpIHtcbiAgICAgICAgLy8gSW4gQW5kcm9pZDQuNCssIGNvcnJlY3Qgdmlld3BvcnQgc2V0dGluZ3MgY2FuIHJlbW92ZSBjbGljayBkZWxheS5cbiAgICAgICAgLy8gU28gZGlzYWJsZSBGYXN0Q2xpY2sgb24gQW5kcm9pZC5cbiAgICAgICAgb25zLmZhc3RDbGljay5kZXN0cm95KCk7XG4gICAgICB9IGVsc2UgaWYgKG9ucy5wbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICAgIGlmIChzdXBwb3J0VG91Y2hBY3Rpb24gJiYgKG9ucy5wbGF0Zm9ybS5pc0lPU1NhZmFyaSgpIHx8IG9ucy5wbGF0Zm9ybS5pc1dLV2ViVmlldygpKSkge1xuICAgICAgICAgIC8vIElmICd0b3VjaC1hY3Rpb24nIHN1cHBvcnRlZCBpbiBpT1MgU2FmYXJpIG9yIFdLV2ViVmlldywgZGlzYWJsZSBGYXN0Q2xpY2suXG4gICAgICAgICAgb25zLmZhc3RDbGljay5kZXN0cm95KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRG8gbm90aGluZy4gJ3RvdWNoLWFjdGlvbjogbWFuaXB1bGF0aW9uJyBoYXMgbm8gZWZmZWN0IG9uIFVJV2ViVmlldy5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LCBmYWxzZSk7XG5cbiAgb25zLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgIG9ucy5lbmFibGVEZXZpY2VCYWNrQnV0dG9uSGFuZGxlcigpO1xuICAgIG9ucy5fZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyID0gb25zLl9pbnRlcm5hbC5kYmJEaXNwYXRjaGVyLmNyZWF0ZUhhbmRsZXIod2luZG93LmRvY3VtZW50LmJvZHksICgpID0+IHtcbiAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChuYXZpZ2F0b3IsICdhcHAnKSkge1xuICAgICAgICBuYXZpZ2F0b3IuYXBwLmV4aXRBcHAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGNsb3NlIHRoZSBhcHAuIElzIFxcJ2NvcmRvdmEuanNcXCcgaW5jbHVkZWQ/XFxuRXJyb3I6IFxcJ3dpbmRvdy5uYXZpZ2F0b3IuYXBwXFwnIGlzIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBkb2N1bWVudC5ib2R5Ll9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgb25zLkdlc3R1cmVEZXRlY3Rvcihkb2N1bWVudC5ib2R5LCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgICAvLyBTaW11bGF0ZSBEZXZpY2UgQmFjayBCdXR0b24gb24gRVNDIHByZXNzXG4gICAgaWYgKCFvbnMucGxhdGZvcm0uaXNXZWJWaWV3KCkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgICAgIG9ucy5maXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gc2V0dXAgbG9hZGluZyBwbGFjZWhvbGRlclxuICAgIG9ucy5fc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzKCk7XG4gIH0pO1xuXG4gIC8vIHZpZXdwb3J0LmpzXG4gIFZpZXdwb3J0LnNldHVwKCk7XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5mdW5jdGlvbiBnZXRFbGVtZW50Q2xhc3MoKSB7XG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICdmdW5jdGlvbicpIHsgLy8gY2FzZSBvZiBTYWZhcmlcbiAgICBjb25zdCBCYXNlRWxlbWVudCA9ICgpID0+IHt9O1xuICAgIEJhc2VFbGVtZW50LnByb3RvdHlwZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldHVybiBCYXNlRWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSFRNTEVsZW1lbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUVsZW1lbnQgZXh0ZW5kcyBnZXRFbGVtZW50Q2xhc3MoKSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10ZW1wbGF0ZVxuICogQGNhdGVnb3J5IHV0aWxcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGVmaW5lIGEgc2VwYXJhdGUgSFRNTCBmcmFnbWVudCBhbmQgdXNlIGFzIGEgdGVtcGxhdGUuIFRoZXNlIHRlbXBsYXRlcyBjYW4gYmUgbG9hZGVkIGFzIHBhZ2VzIGluIGA8b25zLW5hdmlnYXRvcj5gLCBgPG9ucy10YWJiYXI+YCBhbmQgYDxvbnMtc3BsaXR0ZXI+YC4gVGhleSBjYW4gYWxzbyBiZSB1c2VkIHRvIGdlbmVyYXRlIGRpYWxvZ3MuIFNpbmNlIE9uc2VuIFVJIDIuNC4wLCB0aGUgbmF0aXZlIGA8dGVtcGxhdGU+YCBlbGVtZW50IGNhbiBiZSB1c2VkIGluc3RlYWQgb2YgYDxvbnMtdGVtcGxhdGU+YCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlIGFuZCBmZWF0dXJlcy4gYDxvbnMtdGVtcGxhdGU+YCBpcyBzdGlsbCBzdXBwb3J0ZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jg4bjg7Pjg5fjg6zjg7zjg4jjgajjgZfjgabkvb/nlKjjgZnjgovjgZ/jgoHjga5IVE1M44OV44Op44Kw44Oh44Oz44OI44KS5a6a576p44GX44G+44GZ44CC44GT44Gu6KaB57Sg44GnSFRNTOOCkuWuo+iogOOBmeOCi+OBqOOAgWlk5bGe5oCn44Gr5oyH5a6a44GX44Gf5ZCN5YmN44KScGFnZeOBrlVSTOOBqOOBl+OBpm9ucy1uYXZpZ2F0b3Ljgarjganjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgYvjgonlj4LnhafjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLW5hdmlnYXRvclxuICogICBbZW5dVGhlIGA8b25zLW5hdmlnYXRvcj5gIGNvbXBvbmVudCBlbmFibGVzIHN0YWNrIGJhc2VkIG5hdmlnYXRpb24uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdGFiYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtdGFiYmFyPmAgY29tcG9uZW50IGlzIHVzZWQgdG8gYWRkIHRhYiBuYXZpZ2F0aW9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgZHJhZ2dhYmxlIG1lbnUgb3IgY29sdW1uIGJhc2VkIGxheW91dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRlbXBsYXRlIGlkPVwiZm9vYmFyLmh0bWxcIj5cbiAqICAgPG9ucy1wYWdlPlxuICogICAgIFBhZ2UgY29udGVudFxuICogICA8L29ucy1wYWdlPlxuICogPC9vbnMtdGVtcGxhdGU+XG4gKlxuICogPG9ucy1uYXZpZ2F0b3IgcGFnZT1cImZvb2Jhci5odG1sXCI+PC9vbnMtbmF2aWdhdG9yPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZW1wbGF0ZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB0ZW1wbGF0ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UZW1wbGF0ZSBjb250ZW50LiBUaGlzIHByb3BlcnR5IGNhbiBub3QgYmUgdXNlZCB3aXRoIEFuZ3VsYXJKUyBiaW5kaW5ncy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLnRlbXBsYXRlID0gdGhpcy5pbm5lckhUTUw7XG5cbiAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZSkgeyAvLyBOb3RlOiB0aGlzLnBhcmVudE5vZGUgaXMgbm90IHNldCBpbiBzb21lIENFMC9DRTEgcG9seWZpbGxzLlxuICAgICAgLy8gU2hvdyB3YXJuaW5nIHdoZW4gdGhlIG9ucy10ZW1wbGF0ZSBpcyBub3QgbG9jYXRlZCBqdXN0IHVuZGVyIGRvY3VtZW50LmJvZHlcbiAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHsgLy8gaWYgdGhlIHBhcmVudCBpcyBub3QgZG9jdW1lbnQuYm9keVxuICAgICAgICB1dGlsLndhcm4oYG9ucy10ZW1wbGF0ZSAoaWQgPSAke3RoaXMuZ2V0QXR0cmlidXRlKCdpZCcpfSkgbXVzdCBiZSBsb2NhdGVkIGp1c3QgdW5kZXIgZG9jdW1lbnQuYm9keSR7IHRoaXMucGFyZW50Tm9kZS5vdXRlckhUTUwgPyBgOlxcblxcbiR7dGhpcy5wYXJlbnROb2RlLm91dGVySFRNTH1gIDogJy4nIH1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ190ZW1wbGF0ZWxvYWRlZCcsIHtidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlfSk7XG4gICAgZXZlbnQudGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlO1xuICAgIGV2ZW50LnRlbXBsYXRlSWQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWQnKTtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cbn1cblxub25zRWxlbWVudHMuVGVtcGxhdGUgPSBUZW1wbGF0ZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10ZW1wbGF0ZScsIFRlbXBsYXRlRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICcuLi9vbnMvb3JpZW50YXRpb24nO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtaWZcbiAqIEBjYXRlZ29yeSBjb25kaXRpb25hbFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2lmXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbmRpdGlvbmFsbHkgZGlzcGxheSBjb250ZW50IGRlcGVuZGluZyBvbiB0aGUgcGxhdGZvcm0sIGRldmljZSBvcmllbnRhdGlvbiBvciBib3RoLlxuICpcbiAqICAgICBTb21ldGltZXMgaXQgaXMgdXNlZnVsIHRvIGNvbmRpdGlvbmFsbHkgaGlkZSBvciBzaG93IGNlcnRhaW4gY29tcG9uZW50cyBiYXNlZCBvbiBwbGF0Zm9ybS4gV2hlbiBydW5uaW5nIG9uIGlPUyB0aGUgYDxvbnMtaWY+YCBlbGVtZW50IGNhbiBiZSB1c2VkIHRvIGhpZGUgdGhlIGA8b25zLWZhYj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLWlmIG9yaWVudGF0aW9uPVwibGFuZHNjYXBlXCI+XG4gKiAgICAgTGFuZHNjYXBlIHZpZXchXG4gKiAgIDwvb25zLWlmPlxuICogICA8b25zLWlmIHBsYXRmb3JtPVwiYW5kcm9pZFwiPlxuICogICAgIFRoaXMgaXMgQW5kcm9pZC5cbiAqICAgPC9vbnMtaWY+XG4gKiAgIDxvbnMtaWYgcGxhdGZvcm09XCJpb3Mgb3RoZXJcIj5cbiAqICAgICBUaGlzIGlzIG5vdCBBbmRyb2lkLlxuICogICA8L29ucy1pZj5cbiAqIDwvb25zLXBhZ2U+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElmRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwbGF0Zm9ybVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BhY2Utc2VwYXJhdGVkIHBsYXRmb3JtIG5hbWVzLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGBcImlvc1wiYCwgYFwiYW5kcm9pZFwiYCwgYFwid2luZG93c1wiYCBhbmQgYFwib3RoZXJcImAuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvcmllbnRhdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1FaXRoZXIgYFwicG9ydHJhaXRcImAgb3IgYFwibGFuZHNjYXBlXCJgLlsvZW5dXG4gICAqICBbamFdcG9ydHJhaXTjgoLjgZfjgY/jga9sYW5kc2NhcGXjgpLmjIflrprjgZfjgb7jgZlbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmIChwbGF0Zm9ybS5fZ2V0U2VsZWN0ZWRQbGF0Zm9ybSgpICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtVXBkYXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc0FsbG93ZWRQbGF0Zm9ybSgpKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgICB0aGlzLmNoaWxkTm9kZXNbMF0ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGxhdGZvcm1VcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UoKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIG9yaWVudGF0aW9uLm9uKCdjaGFuZ2UnLCB0aGlzLl9vbk9yaWVudGF0aW9uQ2hhbmdlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnb3JpZW50YXRpb24nXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09ICdvcmllbnRhdGlvbicpIHtcbiAgICAgIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UoKTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBvcmllbnRhdGlvbi5vZmYoJ2NoYW5nZScsIHRoaXMuX29uT3JpZW50YXRpb25DaGFuZ2UpO1xuICB9XG5cbiAgX3BsYXRmb3JtVXBkYXRlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IHRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkgPyAnJyA6ICdub25lJztcbiAgfVxuXG4gIF9pc0FsbG93ZWRQbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZ2V0QXR0cmlidXRlKCdwbGF0Zm9ybScpIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdwbGF0Zm9ybScpLnNwbGl0KC9cXHMrLykuaW5kZXhPZihwbGF0Zm9ybS5nZXRNb2JpbGVPUygpKSA+PSAwO1xuICB9XG5cbiAgX29uT3JpZW50YXRpb25DaGFuZ2UoKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdvcmllbnRhdGlvbicpICYmIHRoaXMuX2lzQWxsb3dlZFBsYXRmb3JtKCkpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbmFsT3JpZW50YXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgnb3JpZW50YXRpb24nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgY3VycmVudE9yaWVudGF0aW9uID0gb3JpZW50YXRpb24uaXNQb3J0cmFpdCgpID8gJ3BvcnRyYWl0JyA6ICdsYW5kc2NhcGUnO1xuXG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAoY29uZGl0aW9uYWxPcmllbnRhdGlvbiA9PT0gY3VycmVudE9yaWVudGF0aW9uKSA/ICcnIDogJ25vbmUnO1xuICAgIH1cbiAgfVxufVxuXG5vbnNFbGVtZW50cy5JZiA9IElmRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWlmJywgSWZFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VBbmltYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy50aW1pbmcgPSBvcHRpb25zLnRpbWluZyB8fCAnbGluZWFyJztcbiAgICB0aGlzLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCAwO1xuICAgIHRoaXMuZGVsYXkgPSBvcHRpb25zLmRlbGF5IHx8IDA7XG5cbiAgICB0aGlzLmRlZiA9IHtcbiAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsXG4gICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgIGRlbGF5OiB0aGlzLmRlbGF5XG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBleHRlbmQocHJvcGVydGllcyA9IHt9KSB7XG4gICAgY29uc3QgZXh0ZW5kZWRBbmltYXRvciA9IHRoaXM7XG4gICAgY29uc3QgbmV3QW5pbWF0b3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIGV4dGVuZGVkQW5pbWF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH07XG5cbiAgICBuZXdBbmltYXRvci5wcm90b3R5cGUgPSB0aGlzLnByb3RvdHlwZTtcbiAgICByZXR1cm4gbmV3QW5pbWF0b3I7XG4gIH1cbn1cblxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuLy8gVGhpcyBvYmplY3Qgc2hvdWxkIG5vdCBiZSBleHBvc2VkIHRvIHVzZXJzLiBQbGVhc2Uga2VlcCB0aGlzIHByaXZhdGUuXG5jb25zdCBpUGhvbmVYUGF0Y2ggPSB7fTtcblxuaVBob25lWFBhdGNoLmlzSVBob25lWFBvcnRyYWl0UGF0Y2hBY3RpdmUgPSAoKSA9PiB7XG4gIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdvbnNmbGFnLWlwaG9uZXgtcG9ydHJhaXQnKSAhPSBudWxsICYmIHdpbmRvdy5pbm5lcldpZHRoIDwgd2luZG93LmlubmVySGVpZ2h0O1xufVxuXG5pUGhvbmVYUGF0Y2guaXNJUGhvbmVYTGFuZHNjYXBlUGF0Y2hBY3RpdmUgPSAoKSA9PiB7XG4gIC8vIElmIHdpZHRoID09PSBoZWlnaHQsIHRyZWF0IGl0IGFzIGxhbmRzY2FwZVxuICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZSgnb25zZmxhZy1pcGhvbmV4LWxhbmRzY2FwZScpICE9IG51bGwgJiYgd2luZG93LmlubmVyV2lkdGggPj0gd2luZG93LmlubmVySGVpZ2h0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNhZmUgYXJlYSBsZW5ndGhzIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzYWZlIGFyZWFzLlxuICovXG5pUGhvbmVYUGF0Y2guZ2V0U2FmZUFyZWFMZW5ndGhzID0gKCkgPT4ge1xuICBsZXQgc2FmZUFyZWFMZW5ndGhzO1xuICBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWFBvcnRyYWl0UGF0Y2hBY3RpdmUoKSkge1xuICAgIHNhZmVBcmVhTGVuZ3RocyA9IHtcbiAgICAgIHRvcDogNDQsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMzQsXG4gICAgICBsZWZ0OiAwXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYTGFuZHNjYXBlUGF0Y2hBY3RpdmUoKSkge1xuICAgIHNhZmVBcmVhTGVuZ3RocyA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiA0NCxcbiAgICAgIGJvdHRvbTogMjEsXG4gICAgICBsZWZ0OiA0NFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2FmZUFyZWFMZW5ndGhzID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICBsZWZ0OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBzYWZlQXJlYUxlbmd0aHM7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2FmZSBhcmVhIHJlY3QgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNhZmUgYXJlYXMuXG4gKi9cbmlQaG9uZVhQYXRjaC5nZXRTYWZlQXJlYURPTVJlY3QgPSAoKSA9PiB7XG4gIGxldCBzYWZlQXJlYVJlY3Q7XG4gIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgc2FmZUFyZWFSZWN0ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDQ0LCAvKiAwICsgNDQgKHRvcCBzYWZlIGFyZWEpICovXG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCAtIDc4IC8qIGhlaWdodCAtIDQ0ICh0b3Agc2FmZSBhcmVhKSAtIDM0IChib3R0b20gc2FmZSBhcmVhKSAqL1xuICAgIH07XG4gIH0gZWxzZSBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlKCkpIHtcbiAgICBzYWZlQXJlYVJlY3QgPSB7XG4gICAgICB4OiA0NCwgLyogMCArIDQ0IChsZWZ0IHNhZmUgYXJlYSkgKi9cbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGggLSA4OCwgLyogd2lkdGggLSA0NCAobGVmdCBzYWZlIGFyZWEpIC0gMzQgKHJpZ2h0IHNhZmUgYXJlYSkgKi9cbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0IC0gMjEgLyogaGVpZ2h0IC0gMjEgKGJvdHRvbSBzYWZlIGFyZWEpICovXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzYWZlQXJlYVJlY3QgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uc2FmZUFyZWFSZWN0LFxuICAgIGxlZnQ6IHNhZmVBcmVhUmVjdC54LFxuICAgIHRvcDogc2FmZUFyZWFSZWN0LnksXG4gICAgcmlnaHQ6IHNhZmVBcmVhUmVjdC54ICsgc2FmZUFyZWFSZWN0LndpZHRoLFxuICAgIGJvdHRvbTogc2FmZUFyZWFSZWN0LnkgKyBzYWZlQXJlYVJlY3QuaGVpZ2h0XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlQaG9uZVhQYXRjaDtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgQmFzZUFuaW1hdG9yIGZyb20gJy4uLy4uL29ucy9iYXNlLWFuaW1hdG9yJ1xuaW1wb3J0IGlQaG9uZVhQYXRjaCBmcm9tICcuLi8uLi9vbnMvaXBob25leC1wYXRjaCc7XG5cbmV4cG9ydCBjbGFzcyBBY3Rpb25TaGVldEFuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIEFjdGlvbiBTaGVldC5cbiAqL1xuZXhwb3J0IGNsYXNzIE1EQWN0aW9uU2hlZXRBbmltYXRvciBleHRlbmRzIEFjdGlvblNoZWV0QW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgdGltaW5nID0gJ2Vhc2UnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC40IH0gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuXG4gICAgdGhpcy5tYXNrVGltaW5nID0gJ2xpbmVhcic7XG4gICAgdGhpcy5tYXNrRHVyYXRpb24gPSAwLjI7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgICAgLnF1ZXVlKHsgb3BhY2l0eTogMCB9KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoeyBvcGFjaXR5OiAxLjAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLm1hc2tEdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6IHRoaXMubWFza1RpbWluZ1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fc2hlZXQsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDgwJSwgMClgLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IDEgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2spXG4gICAgICAgIC5xdWV1ZSh7IG9wYWNpdHk6IDEgfSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHsgb3BhY2l0eTogMCB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMubWFza0R1cmF0aW9uLFxuICAgICAgICAgIHRpbWluZzogdGhpcy5tYXNrVGltaW5nXG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9zaGVldCwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCA4MCUsIDApYCwgb3BhY2l0eTogMCB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0FjdGlvblNoZWV0QW5pbWF0b3IgZXh0ZW5kcyBBY3Rpb25TaGVldEFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7IHRpbWluZyA9ICdlYXNlJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMyB9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMubWFza1RpbWluZyA9ICdsaW5lYXInO1xuICAgIHRoaXMubWFza0R1cmF0aW9uID0gMC4yO1xuICAgIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICB0aGlzLmxpZnRBbW91bnQgPSAnY2FsYygxMDAlICsgNDhweCknO1xuICAgIH0gZWxzZSBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9ICdjYWxjKDEwMCUgKyAzM3B4KSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0IC8gMi4wIC0gMSArICdweCc7IC8vIGF2b2lkIEZvcmNlZCBTeW5jaHJvbm91cyBMYXlvdXRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaylcbiAgICAgIC5xdWV1ZSh7IG9wYWNpdHk6IDAgfSlcbiAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAucXVldWUoeyBvcGFjaXR5OiAxIH0sIHtcbiAgICAgICAgZHVyYXRpb246IHRoaXMubWFza0R1cmF0aW9uLFxuICAgICAgICB0aW1pbmc6IHRoaXMubWFza1RpbWluZ1xuICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX3NoZWV0LCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgwLCAke3RoaXMubGlmdEFtb3VudH0sIDApYCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrKVxuICAgICAgLnF1ZXVlKHsgb3BhY2l0eTogMSB9KVxuICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgIC5xdWV1ZSh7IG9wYWNpdHk6IDAgfSwge1xuICAgICAgICBkdXJhdGlvbjogdGhpcy5tYXNrRHVyYXRpb24sXG4gICAgICAgIHRpbWluZzogdGhpcy5tYXNrVGltaW5nXG4gICAgICB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fc2hlZXQsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLmxpZnRBbW91bnR9LCAwKWAgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi8uLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZURpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICB1dGlsLnRocm93TWVtYmVyKCk7XG4gIH1cblxuICBfdG9nZ2xlU3R5bGUoc2hvdWxkU2hvdykge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IHNob3VsZFNob3cgPyAnYmxvY2snIDogJ25vbmUnO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlRGlhbG9nRWxlbWVudCkge1xuICAgICAgdXRpbC50aHJvd0Fic3RyYWN0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuX2Rvb3JMb2NrID0gbmV3IERvb3JMb2NrKCk7XG4gICAgdGhpcy5fY2FuY2VsID0gdGhpcy5fY2FuY2VsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fc2VsZkNhbWVsTmFtZSA9IHV0aWwuY2FtZWxpemUodGhpcy50YWdOYW1lLnNsaWNlKDQpKTtcbiAgICB0aGlzLl9kZWZhdWx0REJCID0gZSA9PiB0aGlzLmNhbmNlbGFibGUgPyB0aGlzLl9jYW5jZWwoKSA6IGUuY2FsbFBhcmVudEhhbmRsZXIoKTtcbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgfVxuXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBfY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGFibGUgJiYgIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgLnRoZW4oXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdkaWFsb2ctY2FuY2VsJyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiB0aGlzLl9ydW5uaW5nID0gZmFsc2VcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBzaG93KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0VmlzaWJsZSh0cnVlLCAuLi5hcmdzKTtcbiAgfVxuXG4gIGhpZGUoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLl9zZXRWaXNpYmxlKGZhbHNlLCAuLi5hcmdzKTtcbiAgfVxuXG4gIHRvZ2dsZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldFZpc2libGUoIXRoaXMudmlzaWJsZSwgLi4uYXJncyk7XG4gIH1cblxuICBfc2V0VmlzaWJsZShzaG91bGRTaG93LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhY3Rpb24gPSBzaG91bGRTaG93ID8gJ3Nob3cnIDogJ2hpZGUnO1xuXG4gICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucyB9O1xuICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyA9IHV0aWwuZXh0ZW5kKFxuICAgICAgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9LFxuICAgICAgQW5pbWF0b3JGYWN0b3J5LnBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyh0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSlcbiAgICApO1xuXG4gICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIGBwcmUke2FjdGlvbn1gLCB7IC8vIHByZXNob3cgcHJlaGlkZVxuICAgICAgW3RoaXMuX3NlbGZDYW1lbE5hbWVdOiB0aGlzLFxuICAgICAgY2FuY2VsOiAoKSA9PiBjYW5jZWxlZCA9IHRydWVcbiAgICB9KTtcblxuICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW5jZWxlZCBpbiBwcmUke2FjdGlvbn0gZXZlbnQuYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fZG9vckxvY2sud2FpdFVubG9jaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHRoaXMuX2Rvb3JMb2NrLmxvY2soKTtcbiAgICAgICAgY29uc3QgYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRvckZhY3RvcnkubmV3QW5pbWF0b3Iob3B0aW9ucyk7XG5cbiAgICAgICAgc2hvdWxkU2hvdyAmJiB0aGlzLl90b2dnbGVTdHlsZSh0cnVlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHNob3VsZFNob3c7XG4gICAgICAgIHV0aWwuaW9zUGFnZVNjcm9sbEZpeChzaG91bGRTaG93KTtcblxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgIGFuaW1hdG9yW2FjdGlvbl0odGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgIXNob3VsZFNob3cgJiYgdGhpcy5fdG9nZ2xlU3R5bGUoZmFsc2UsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB1bmxvY2soKTtcblxuICAgICAgICAgICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ18nICsgYWN0aW9uKTtcbiAgICAgICAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAncG9zdCcgKyBhY3Rpb24sIHtbdGhpcy5fc2VsZkNhbWVsTmFtZV06IHRoaXN9KTsgLy8gcG9zdHNob3cgcG9zdGhpZGVcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXNvbHZlKHRoaXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgc2V0IGNhbmNlbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2NhbmNlbGFibGUnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgY2FuY2VsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2NhbmNlbGFibGUnKTtcbiAgfVxuXG4gIF91cGRhdGVNYXNrKCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fbWFzayAmJiB0aGlzLmdldEF0dHJpYnV0ZSgnbWFzay1jb2xvcicpKSB7XG4gICAgICAgIHRoaXMuX21hc2suc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hc2stY29sb3InKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMub25EZXZpY2VCYWNrQnV0dG9uID0gdGhpcy5fZGVmYXVsdERCQi5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICAgIHRoaXMuX21hc2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9jYW5jZWwsIGZhbHNlKTtcbiAgICAgICAgdXRpbC5pb3NNYXNrU2Nyb2xsRml4KHRoaXMuX21hc2ssIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICB0aGlzLl9tYXNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fY2FuY2VsLCBmYWxzZSk7XG4gICAgICB1dGlsLmlvc01hc2tTY3JvbGxGaXgodGhpcy5fbWFzaywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ21vZGlmaWVyJywgJ2FuaW1hdGlvbicsICdtYXNrLWNvbG9yJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhbmltYXRpb24nOlxuICAgICAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtYXNrLWNvbG9yJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlTWFzaygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwcmVzaG93JywgJ3Bvc3RzaG93JywgJ3ByZWhpZGUnLCAncG9zdGhpZGUnLCAnZGlhbG9nLWNhbmNlbCddO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHsgQWN0aW9uU2hlZXRBbmltYXRvciwgSU9TQWN0aW9uU2hlZXRBbmltYXRvciwgTURBY3Rpb25TaGVldEFuaW1hdG9yIH0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBCYXNlRGlhbG9nRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZGlhbG9nJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcuYWN0aW9uLXNoZWV0JzogJ2FjdGlvbi1zaGVldC0tKicsXG4gICcuYWN0aW9uLXNoZWV0LW1hc2snOiAnYWN0aW9uLXNoZWV0LW1hc2stLSonLFxuICAnLmFjdGlvbi1zaGVldC10aXRsZSc6ICdhY3Rpb24tc2hlZXQtdGl0bGUtLSonXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURBY3Rpb25TaGVldEFuaW1hdG9yIDogSU9TQWN0aW9uU2hlZXRBbmltYXRvcixcbiAgJ25vbmUnOiBBY3Rpb25TaGVldEFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hY3Rpb24tc2hlZXRcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQWN0aW9uL2JvdHRvbSBzaGVldCB0aGF0IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgY3VycmVudCBzY3JlZW4uXG4gKlxuICogICAgIFRoaXMgZWxlbWVudCBjYW4gZWl0aGVyIGJlIGF0dGFjaGVkIGRpcmVjdGx5IHRvIHRoZSBgPGJvZHk+YCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVFbGVtZW50KHRlbXBsYXRlLCB7IGFwcGVuZDogdHJ1ZSB9KWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8dGVtcGxhdGU+YCB0YWcuXG4gKlxuICogICAgIFRoZSBhY3Rpb24gc2hlZXQgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIGEgbGlzdCBvZiBvcHRpb25zIGFuZCBhc2tpbmcgdGhlIHVzZXIgdG8gbWFrZSBhIGRlY2lzaW9uLiBBIGBvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbmAgaXMgcHJvdmlkZWQgZm9yIHRoaXMgcHVycG9zZSwgYWx0aG91Z2ggaXQgY2FuIGNvbnRhaW4gYW55IHR5cGUgb2YgY29udGVudC5cbiAqXG4gKiAgICAgSXQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIGRpc3BsYXllZCBhcyBNYXRlcmlhbCBEZXNpZ24gKGJvdHRvbSBzaGVldCkgd2hlbiBydW5uaW5nIG9uIGFuIEFuZHJvaWQgZGV2aWNlLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg44Ki44Kv44K344On44Oz44K344O844OI44CB44KC44GX44GP44Gv44Oc44OI44Og44K344O844OI44KS54++5Zyo44Gu44K544Kv44Oq44O844Oz5LiK44Gr6KGo56S644GX44G+44GZ44CCXG4gKlxuICogICAgIOOBk+OBruimgee0oOOBr+OAgWA8Ym9keT5g6KaB57Sg44Gr55u05o6l44Ki44K/44OD44OB44GV44KM44KL44GL44CB44KC44GX44GP44GvYG9ucy5jcmVhdGVFbGVtZW50KHRlbXBsYXRlLCB7IGFwcGVuZDogdHJ1ZSB9KWDjgahgPHRlbXBsYXRlPmDjgr/jgrDjgpLkvb/jgaPjgabjg4bjg7Pjg5fjg6zjg7zjg4jjgYvjgonli5XnmoTjgavnlJ/miJDjgZXjgozjgb7jgZnjgIJcbiAqXG4gKiAgICAg44Ki44Kv44K344On44Oz44K344O844OI44Gv44CB6YG45oqe6IKi44Gu44Oq44K544OI44KS6KGo56S644GX44Gm44Om44O844K244O844Gr5bCL44Gt44KL44Gu44Gr5L6/5Yip44Gn44GZ44CCYG9ucy1hY3Rpb24tc2hlZXQtYnV0dG9uYOOBr+OAgeOBk+OBruimgee0oOOBruS4reOBq+e9ruOBj+OBn+OCgeOBq+aPkOS+m+OBleOCjOOBpuOBhOOBvuOBmeOBjOOAgeOBneOCjOS7peWkluOBq+OCguS7luOBruOBqeOBruOCiOOBhuOBquimgee0oOOCkuWQq+OCgOOBk+OBqOOBjOOBp+OBjeOBvuOBmeOAglxuICpcbiAqICAgICBBbmRyb2lk44OH44OQ44Kk44K544Gn5a6f6KGM44GV44KM44KL44Go44GN44Gr44Gv44CB6Ieq5YuV55qE44Gr44Oe44OG44Oq44Ki44Or44OH44K244Kk44OzKOODnOODiOODoOOCt+ODvOODiCnjgajjgZfjgabooajnpLrjgZXjgozjgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBib3R0b20gc2hlZXQuWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODnOODiOODoOOCt+ODvOODiOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9yZWZlcmVuY2UvYWN0aW9uLXNoZWV0XG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1gPG9ucy1wb3BvdmVyPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1wb3BvdmVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1tb2RhbFxuICogICBbZW5dYDxvbnMtbW9kYWw+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLW1vZGFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWFjdGlvbi1zaGVldCBpZD1cInNoZWV0XCI+XG4gKiAgIDxvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbj5MYWJlbDwvb25zLWFjdGlvbi1zaGVldC1idXR0b24+XG4gKiAgIDxvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbj5MYWJlbDwvb25zLWFjdGlvbi1zaGVldC1idXR0b24+XG4gKiA8L29ucy1hY3Rpb24tc2hlZXQ+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NoZWV0Jykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjdGlvblNoZWV0RWxlbWVudCBleHRlbmRzIEJhc2VEaWFsb2dFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZXNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgYWN0aW9uIHNoZWV0IGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFjdGlvblNoZWV0XG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUV4ZWN1dGUgdGhpcyBmdW5jdGlvbiB0byBzdG9wIHRoZSBhY3Rpb24gc2hlZXQgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgYWN0aW9uIHNoZWV0IGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM44Gf55u05b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFjdGlvblNoZWV0XG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGFjdGlvbiBzaGVldCBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hY3Rpb25TaGVldFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgYWN0aW9uIHNoZWV0IGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBrumdnuihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBhY3Rpb24gc2hlZXQgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzpmqDjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWN0aW9uU2hlZXRcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB0aXRsZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1PcHRpb25hbCB0aXRsZSBvZiB0aGUgYWN0aW9uIHNoZWV0LiBBIG5ldyBlbGVtZW50IHdpbGwgYmUgY3JlYXRlZCBjb250YWluaW5nIHRoaXMgc3RyaW5nLlsvZW5dXG4gICAqICBbamFd44Ki44Kv44K344On44Oz44K344O844OI44Gu44K/44Kk44OI44Or44KS5oyH5a6a44GX44G+44GZ44CC44GT44GT44Gn5oyH5a6a44GX44Gf5paH5a2X5YiX44KS5ZCr44KA5paw44GX44GE6KaB57Sg44GM5L2c5oiQ44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGFjdGlvbiBzaGVldC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNhbmNlbGFibGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBhY3Rpb24gc2hlZXQgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgovjgajjgIHjgqLjgq/jgrfjg6fjg7Pjgrfjg7zjg4jjga7og4zmma/jgoRBbmRyb2lk44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44KS5o6o44GZ44GT44Go44Gn44Ki44Kv44K344On44Oz44K344O844OI44GM6ZaJ44GY44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBhY3Rpb24gc2hlZXQgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgYWN0aW9uIHNoZWV0LiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJkZWZhdWx0XCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmFjdGlvbi1zaGVldC1tYXNrJyk7XG4gIH1cblxuICBnZXQgX3NoZWV0KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmFjdGlvbi1zaGVldCcpO1xuICB9XG5cbiAgZ2V0IF90aXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcuYWN0aW9uLXNoZWV0LXRpdGxlJyk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogQWN0aW9uU2hlZXRBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdBY3Rpb25TaGVldEFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5zdHlsZS56SW5kZXggPSAxMDAwMTtcblxuICAgIC8qIEV4cGVjdGVkIHJlc3VsdDpcbiAgICAgKiAgIDxvbnMtYWN0aW9uLXNoZWV0PlxuICAgICAqICAgICA8ZGl2IGNsYXNzPVwiYWN0aW9uLXNoZWV0LW1hc2tcIj48L2Rpdj5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImFjdGlvbi1zaGVldFwiPlxuICAgICAqICAgICAgIDxkaXYgY2xhc3M9XCJhY3Rpb24tc2hlZXQtdGl0bGU+PC9kaXY+XG4gICAgICogICAgICAgLi4uXG4gICAgICogICAgIDwvZGl2PlxuICAgICAqICAgPC9vbnMtYWN0aW9uLXNoZWV0PlxuICAgICAqL1xuXG4gICAgaWYgKCF0aGlzLl9zaGVldCkge1xuICAgICAgY29uc3Qgc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHNoZWV0LmNsYXNzTGlzdC5hZGQoJ2FjdGlvbi1zaGVldCcpO1xuXG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIHNoZWV0LmFwcGVuZENoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc2hlZXQpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdGl0bGUgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ3RpdGxlJykpIHtcbiAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aXRsZS5pbm5lckhUTUwgPSB0aGlzLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICAgIHRpdGxlLmNsYXNzTGlzdC5hZGQoJ2FjdGlvbi1zaGVldC10aXRsZScpO1xuICAgICAgdGhpcy5fc2hlZXQuaW5zZXJ0QmVmb3JlKHRpdGxlLCB0aGlzLl9zaGVldC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIG1hc2suY2xhc3NMaXN0LmFkZCgnYWN0aW9uLXNoZWV0LW1hc2snKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKG1hc2ssIHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2hlZXQuc3R5bGUuekluZGV4ID0gMjAwMDE7XG4gICAgdGhpcy5fbWFzay5zdHlsZS56SW5kZXggPSAyMDAwMDtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIF91cGRhdGVUaXRsZSgpIHtcbiAgICBpZiAodGhpcy5fdGl0bGUpIHtcbiAgICAgIHRoaXMuX3RpdGxlLmlubmVySFRNTCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0aXRsZScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGFjdGlvbiBzaGVldCBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TaG93IHRoZSBhY3Rpb24gc2hlZXQuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGFjdGlvbiBzaGVldCBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGFjdGlvbiBzaGVldC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV3pmqDjgozjgZ/opoHntKDjgpLop6PmsbrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgYWN0aW9uIHNoZWV0IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBhY3Rpb24gc2hlZXQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGFjdGlvbiBzaGVldCBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gQSBjYW5jZWxhYmxlIGFjdGlvbiBzaGVldCBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jgrfjg6fjg7Pjgrfjg7zjg4jjgYzjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgYvjganjgYbjgYvjgpLoqK3lrprjgZfjgb7jgZnjgILjgq3jg6Pjg7Pjgrvjg6vlj6/og73jgarjgqLjgq/jgrfjg6fjg7Pjgrfjg7zjg4jjga/jgIHog4zmma/jgpLjgr/jg4Pjg5fjgZfjgZ/jgopBbmRyb2lk44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44KS5o6o44GZ44GT44Go44Gn6ZaJ44GY44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsICd0aXRsZSddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgdGhpcy5fdXBkYXRlVGl0bGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0FjdGlvblNoZWV0QW5pbWF0b3J9IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIEFjdGlvblNoZWV0QW5pbWF0b3IpKSB7XG4gICAgICB1dGlsLnRocm93QW5pbWF0b3IoJ0FjdGlvblNoZWV0Jyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBBY3Rpb25TaGVldEFuaW1hdG9yKCkge1xuICAgIHJldHVybiBBY3Rpb25TaGVldEFuaW1hdG9yO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkFjdGlvblNoZWV0ID0gQWN0aW9uU2hlZXRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYWN0aW9uLXNoZWV0JywgQWN0aW9uU2hlZXRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlLWVsZW1lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICB1dGlsLnRocm93TWVtYmVyKCk7XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgZ2V0IF9yaXBwbGVPcHQoKSB7XG4gICAgcmV0dXJuIFt0aGlzXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUJ1dHRvbkVsZW1lbnQpIHtcbiAgICAgIHV0aWwudGhyb3dBYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBnZXQgX2ljb24oKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtaWNvbicpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQodGhpcy5fZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBpZiAoIXRoaXMuX2ljb24gJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2ljb24nKSkge1xuICAgICAgdXRpbC5jaGVja01pc3NpbmdJbXBvcnQoJ0ljb24nKTtcbiAgICAgIGNvbnN0IGljb24gPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYDxvbnMtaWNvbiBpY29uPVwiJHt0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpfVwiPjwvb25zLWljb24+YCk7XG4gICAgICBpY29uLmNsYXNzTGlzdC5hZGQodGhpcy5fZGVmYXVsdENsYXNzTmFtZS5yZXBsYWNlKCdidXR0b24nLCAnaWNvbicpKTtcbiAgICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGljb24sIHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICBfdXBkYXRlSWNvbigpIHtcbiAgICBpZiAodGhpcy5faWNvbikge1xuICAgICAgdGhpcy5faWNvbi5zZXRBdHRyaWJ1dGUoJ2ljb24nLCB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHRoaXMuX3JpcHBsZU9wdCAmJiB1dGlsLnVwZGF0ZVJpcHBsZSguLi50aGlzLl9yaXBwbGVPcHQpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnLCAnaWNvbicsICdyaXBwbGUnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIHRoaXMuX2RlZmF1bHRDbGFzc05hbWUsIHRoaXMuX3NjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpY29uJzpcbiAgICAgICAgdGhpcy5fdXBkYXRlSWNvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuX2RlZmF1bHRDbGFzc05hbWUpICYmIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VCdXR0b25FbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWJ1dHRvbic7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWFjdGlvbi1zaGVldC1idXR0b25cbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBtb2RpZmllciBkZXN0cnVjdGl2ZVxuICogICBbZW5dU2hvd3MgYSBcImRlc3RydWN0aXZlXCIgYnV0dG9uIChvbmx5IGZvciBpT1MpLlsvZW5dXG4gKiAgIFtqYV1cImRlc3RydWN0aXZlXCLjgarjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZkoaU9T44Gn44Gu44G/5pyJ5Yq5KeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUNvbXBvbmVudCB0aGF0IHJlcHJlc2VudCBlYWNoIGJ1dHRvbiBvZiB0aGUgYWN0aW9uIHNoZWV0LlsvZW5dXG4gKiAgIFtqYV3jgqLjgq/jgrfjg6fjg7Pjgrfjg7zjg4jjgavooajnpLrjgZXjgozjgovlkITjg5zjgr/jg7PjgpLooajnj77jgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWFjdGlvbi1zaGVldFxuICogICBbZW5dVGhlIGA8b25zLWFjdGlvbi1zaGVldD5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtYWN0aW9uLXNoZWV044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0LWl0ZW0+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaWNvblxuICogICBbZW5dVGhlIGA8b25zLWljb24+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWljb27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2FjdGlvbi1zaGVldFxuICogQGd1aWRlIGFwcHNpemUuaHRtbCNyZW1vdmluZy1pY29uLXBhY2tzIFtlbl1SZW1vdmluZyBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAZ3VpZGUgZmFxLmh0bWwjaG93LWNhbi1pLXVzZS1jdXN0b20taWNvbi1wYWNrcyBbZW5dQWRkaW5nIGN1c3RvbSBpY29uIHBhY2tzLlsvZW5dW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gYWN0aW9uIHNoZWV0IGJ1dHRvbi5bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Ki44Kv44K344On44Oz44K344O844OI55So44Gu44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWFjdGlvbi1zaGVldCBpZD1cInNoZWV0XCI+XG4gKiAgIDxvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbj5MYWJlbDwvb25zLWFjdGlvbi1zaGVldC1idXR0b24+XG4gKiAgIDxvbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbj5MYWJlbDwvb25zLWFjdGlvbi1zaGVldC1idXR0b24+XG4gKiA8L29ucy1hY3Rpb24tc2hlZXQ+XG4gKlxuICogPHNjcmlwdD5cbiAqICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NoZWV0Jykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjdGlvblNoZWV0QnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VCdXR0b25FbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpY29uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUNyZWF0ZXMgYW4gYG9ucy1pY29uYCBjb21wb25lbnQgd2l0aCB0aGlzIHN0cmluZy4gT25seSB2aXNpYmxlIG9uIEFuZHJvaWQuIENoZWNrIFtTZWUgYWxzb10oI3NlZWFsc28pIHNlY3Rpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uWy9lbl1cbiAgICogIFtqYV1gb25zLWljb25g44Kz44Oz44Od44O844ON44Oz44OI44KS5oKq5oCn44GX44G+44GZ44CCQW5kcm9pZOOBp+OBruOBv+ihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYWN0aW9uIHNoZWV0IGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgq/jgrfjg6fjg7Pjgrfjg7zjg4jjg5zjgr/jg7Pjga7opovjgZ/nm67jgpLoqK3lrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJyc6ICdhY3Rpb24tc2hlZXQtYnV0dG9uLS0qJyxcbiAgICAgICcuYWN0aW9uLXNoZWV0LWljb24nOiAnYWN0aW9uLXNoZWV0LWljb24tLSonXG4gICAgfTtcbiAgfVxuXG4gIGdldCBfZGVmYXVsdENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gJ2FjdGlvbi1zaGVldC1idXR0b24nO1xuICB9XG5cbiAgZ2V0IF9yaXBwbGVPcHQoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5BY3Rpb25TaGVldEJ1dHRvbiA9IEFjdGlvblNoZWV0QnV0dG9uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFjdGlvbi1zaGVldC1idXR0b24nLCBBY3Rpb25TaGVldEJ1dHRvbkVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBCYXNlQW5pbWF0b3IgZnJvbSAnLi4vLi4vb25zL2Jhc2UtYW5pbWF0b3InO1xuXG5leHBvcnQgY2xhc3MgQWxlcnREaWFsb2dBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgc2hvdyhkaWFsb2csIGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG59XG5cbi8qKlxuICogQW5kcm9pZCBzdHlsZSBhbmltYXRvciBmb3IgYWxlcnQgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgQW5kcm9pZEFsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGR1cmF0aW9uID0gMC4yLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7ZHVyYXRpb24sIHRpbWluZywgZGVsYXl9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCguOSwgLjksIDEpJywgb3BhY2l0eTogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCgxLCAxLCAxKScsIG9wYWNpdHk6IDEgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAxIH0sIHsgb3BhY2l0eTogMCB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEsIDEsIDEpJywgb3BhY2l0eTogMSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMCkgc2NhbGUzZCguOSwgLjksIDEpJywgb3BhY2l0eTogMCB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBpT1Mgc3R5bGUgYW5pbWF0b3IgZm9yIGFsZXJ0IGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBBbGVydERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGR1cmF0aW9uID0gMC4yLCBkZWxheSA9IDB9ID0ge30pIHtcbiAgICBzdXBlcih7ZHVyYXRpb24sIHRpbWluZywgZGVsYXl9KTtcbiAgfVxuXG4gIC8qXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKSBzY2FsZTNkKDEuMywgMS4zLCAxKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApIHNjYWxlM2QoMSwgMSwgMSknLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEFuaW1hdG9yRmFjdG9yeSBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvYW5pbWF0b3ItZmFjdG9yeSc7XG5pbXBvcnQgeyBBbGVydERpYWxvZ0FuaW1hdG9yLCBJT1NBbGVydERpYWxvZ0FuaW1hdG9yLCBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvciB9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZURpYWxvZ0VsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWRpYWxvZyc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLmFsZXJ0LWRpYWxvZyc6ICdhbGVydC1kaWFsb2ctLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1jb250YWluZXInOiAnYWxlcnQtZGlhbG9nLWNvbnRhaW5lci0tKicsXG4gICcuYWxlcnQtZGlhbG9nLXRpdGxlJzogJ2FsZXJ0LWRpYWxvZy10aXRsZS0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWNvbnRlbnQnOiAnYWxlcnQtZGlhbG9nLWNvbnRlbnQtLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1mb290ZXInOiAnYWxlcnQtZGlhbG9nLWZvb3Rlci0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWZvb3Rlci0tcm93Zm9vdGVyJzogJ2FsZXJ0LWRpYWxvZy1mb290ZXItLXJvd2Zvb3Rlci0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcm93Zm9vdGVyJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLXJvd2Zvb3Rlci0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWJ1dHRvbi0tcHJpbWFsJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLXByaW1hbC0tKicsXG4gICcuYWxlcnQtZGlhbG9nLWJ1dHRvbic6ICdhbGVydC1kaWFsb2ctYnV0dG9uLS0qJyxcbiAgJ29ucy1hbGVydC1kaWFsb2ctYnV0dG9uJzogJ2FsZXJ0LWRpYWxvZy1idXR0b24tLSonLFxuICAnLmFsZXJ0LWRpYWxvZy1tYXNrJzogJ2FsZXJ0LWRpYWxvZy1tYXNrLS0qJyxcbiAgJy50ZXh0LWlucHV0JzogJ3RleHQtaW5wdXQtLSonXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnbm9uZSc6IEFsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICdkZWZhdWx0JzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvciA6IElPU0FsZXJ0RGlhbG9nQW5pbWF0b3IsXG4gICdmYWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvciA6IElPU0FsZXJ0RGlhbG9nQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWFsZXJ0LWRpYWxvZ1xuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBBbGVydCBkaWFsb2cgdGhhdCBpcyBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBjdXJyZW50IHNjcmVlbi4gVXNlZnVsIGZvciBkaXNwbGF5aW5nIHF1ZXN0aW9ucywgd2FybmluZ3Mgb3IgZXJyb3IgbWVzc2FnZXMgdG8gdGhlIHVzZXIuIFRoZSB0aXRsZSwgY29udGVudCBhbmQgYnV0dG9ucyBjYW4gYmUgZWFzaWx5IGN1c3RvbWl6ZWQgYW5kIGl0IHdpbGwgYXV0b21hdGljYWxseSBzd2l0Y2ggc3R5bGUgYmFzZWQgb24gdGhlIHBsYXRmb3JtLlxuICpcbiAqICAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVBbGVydERpYWxvZyh0ZW1wbGF0ZSlgIHV0aWxpdHkgZnVuY3Rpb24gYW5kIHRoZSBgPHRlbXBsYXRlPmAgdGFnLlxuICogICBbL2VuXVxuICogICBbamFdXG4gKiAgICAg54++5Zyo44Gu44K544Kv44Oq44O844Oz44Gu5LiK44Gr6KGo56S644GZ44KL44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gn44GZ44CC44Om44O844K244Gr5a++44GZ44KL5ZWP44GE44GL44GR44CB6K2m5ZGK44CB44Ko44Op44O844Oh44OD44K744O844K444KS6KGo56S644GZ44KL44Gu44Gr5Yip55So44Gn44GN44G+44GZ44CC44K/44Kk44OI44Or44KE44Kz44Oz44OG44Oz44OE44KE44Oc44K/44Oz44Gv57Ch5Y2Y44Gr44Kr44K544K/44Oe44Kk44K644Gn44GN44CB5a6f6KGM44GX44Gm44GE44KL44OX44Op44OD44OI44OV44Kp44O844Og44Gr5L2144Gb44Gm44K544K/44Kk44Or44GM6Ieq5YuV55qE44Gr5YiH44KK5pu/44KP44KK44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAY29kZXBlbiBRd3d4eXBcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9hbGVydC1kaWFsb2dcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN0eWxlWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruOCueOCv+OCpOODq1svamFdXG4gKiBAbW9kaWZpZXIgcm93Zm9vdGVyXG4gKiAgIFtlbl1Ib3Jpem9udGFsbHkgYWxpZ25zIHRoZSBmb290ZXIgYnV0dG9ucy5bL2VuXVxuICogICBbamFd44OV44OD44K/44O844Gu6KSH5pWw44Gu44Oc44K/44Oz44KS5rC05bmz44Gr6YWN572uWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1kaWFsb2dcbiAqICAgW2VuXW9ucy1kaWFsb2cgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBvcG92ZXJcbiAqICAgW2VuXW9ucy1wb3BvdmVyIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy5ub3RpZmljYXRpb25cbiAqICAgW2VuXVVzaW5nIG9ucy5ub3RpZmljYXRpb24gdXRpbGl0eSBmdW5jdGlvbnMuWy9lbl1cbiAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+OBq+OBr+OAgW9ucy5ub3RpZmljYXRpb27jgqrjg5bjgrjjgqfjgq/jg4jjga7jg6Hjgr3jg4Pjg4njgpLkvb/jgYbjgZPjgajjgoLjgafjgY3jgb7jgZnjgIJbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtYWxlcnQtZGlhbG9nIGlkPVwiYWxlcnQtZGlhbG9nXCI+XG4gKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctdGl0bGVcIj5XYXJuaW5nITwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWNvbnRlbnRcIj5cbiAqICAgICBBbiBlcnJvciBoYXMgb2NjdXJyZWQhXG4gKiAgIDwvZGl2PlxuICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLWZvb3RlclwiPlxuICogICAgIDxidXR0b24gaWQ9XCJhbGVydC1kaWFsb2ctYnV0dG9uXCIgY2xhc3M9XCJhbGVydC1kaWFsb2ctYnV0dG9uXCI+T0s8L2J1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiA8L29ucy1hbGVydC1kaWFsb2c+XG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWxlcnQtZGlhbG9nJykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFsZXJ0RGlhbG9nRWxlbWVudCBleHRlbmRzIEJhc2VEaWFsb2dFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZXNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBhbGVydCBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIHNob3dpbmcuWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5a6f6KGM44GZ44KL44Go44CB44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu6KGo56S644KS5q2i44KB44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0c2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgYWxlcnQgZGlhbG9nIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuYWxlcnREaWFsb2dcbiAgICogICBbZW5dQWxlcnQgZGlhbG9nIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZWhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBhbGVydCBkaWFsb2cgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5hbGVydERpYWxvZ1xuICAgKiAgIFtlbl1BbGVydCBkaWFsb2cgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCouODqeODvOODiOODgOOCpOOCouODreOCsOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGhpZGluZy5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjgYzplonjgZjjgojjgYbjgajjgZnjgovjga7jgpLmraLjgoHjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgYWxlcnQgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmFsZXJ0RGlhbG9nXG4gICAqICAgW2VuXUFsZXJ0IGRpYWxvZyBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Ki44Op44O844OI44OA44Kk44Ki44Ot44Kw44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOBruimi+OBn+ebruOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNhbmNlbGFibGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgY2FuIGJlIGNsb3NlZCBieSB0YXBwaW5nIHRoZSBiYWNrZ3JvdW5kIG9yIGJ5IHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbiBvbiBBbmRyb2lkIGRldmljZXMuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgpLoqK3lrprjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7og4zmma/jgpLjgr/jg4Pjg5fjgZfjgZ/jgopBbmRyb2lk44OH44OQ44Kk44K544Gu44OQ44OD44Kv44Oc44K/44Oz44KS5oq844GZ44Go44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjgqLjg6njg7zjg4jjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZGlhbG9nLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBp+OBr1wibm9uZVwi44GLXCJkZWZhdWx0XCLjgYzmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgILkvovvvJp7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1hc2stY29sb3JcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgcmdiYSgwLCAwLCAwLCAwLjIpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIG1hc2suIERlZmF1bHQgaXMgXCJyZ2JhKDAsIDAsIDAsIDAuMilcIi5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgX21hc2soKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYWxlcnQtZGlhbG9nLW1hc2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF9kaWFsb2coKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcuYWxlcnQtZGlhbG9nJyk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF90aXRsZUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX2RpYWxvZy5jaGlsZHJlblswXSwgJy5hbGVydC1kaWFsb2ctdGl0bGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IF9jb250ZW50RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLCAnLmFsZXJ0LWRpYWxvZy1jb250ZW50Jyk7XG4gIH1cblxuICBfdXBkYXRlQW5pbWF0b3JGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogX2FuaW1hdG9yRGljdCxcbiAgICAgIGJhc2VDbGFzczogQWxlcnREaWFsb2dBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdBbGVydERpYWxvZ0FuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgdGhpcy5zdHlsZS56SW5kZXggPSAxMDAwMTtcblxuICAgIC8qKlxuICAgICAqIEV4cGVjdGVkIHJlc3VsdCBhZnRlciBjb21waWxlOlxuICAgICAqXG4gICAgICogPG9ucy1hbGVydC1kaWFsb2cgc3R5bGU9XCJub25lXCI+XG4gICAgICogICA8ZGl2IGNsYXNzPVwiYWxlcnQtZGlhbG9nLW1hc2tcIj48L2Rpdj5cbiAgICAgKiAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2dcIj5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250YWluZXJcIj4uLi48L2Rpdj5cbiAgICAgKiAgIDwvZGl2PlxuICAgICAqIDwvb25zLWFsZXJ0LWRpYWxvZz5cbiAgICAgKi9cblxuICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICBpZiAoIXRoaXMuX21hc2sgJiYgIXRoaXMuX2RpYWxvZykge1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2FsZXJ0LWRpYWxvZy1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmNoaWxkcmVuWzBdKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2RpYWxvZykge1xuICAgICAgY29uc3QgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaWFsb2cuY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShkaWFsb2csIG51bGwpO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcy5fZGlhbG9nLCAnLmFsZXJ0LWRpYWxvZy1jb250YWluZXInKSkge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnYWxlcnQtZGlhbG9nLWNvbnRhaW5lcicpO1xuICAgICAgdGhpcy5fZGlhbG9nLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlhbG9nLmNoaWxkcmVuWzBdLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuXG4gICAgdGhpcy5fZGlhbG9nLnN0eWxlLnpJbmRleCA9IDIwMDAxO1xuICAgIHRoaXMuX21hc2suc3R5bGUuekluZGV4ID0gMjAwMDA7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHRoaXMuX3NjaGVtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjYW5jZWxhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIGNhbmNlbGFibGUgb3Igbm90LiBBIGNhbmNlbGFibGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICAgW2phXeOBneOBruODgOOCpOOCouODreOCsOOBjOOCreODo+ODs+OCu+ODq+WPr+iDveOBi+OBqeOBhuOBi+OCkuihqOOBl+OBvuOBmeOAguOCreODo+ODs+OCu+ODq+WPr+iDveOBquODgOOCpOOCouODreOCsOOBr+OAgeiDjOaZr+OCkuOCv+ODg+ODl+OBmeOCi+OBi0FuZHJvaWTjg4fjg5DjgqTjgrnjga7jg5Djg4Pjgq/jg5zjgr/jg7PjgpLmirzjgZnjgZPjgajjgafplonjgZjjgovjgZPjgajjgYzlh7rmnaXjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93XG4gICAqIEBzaWduYXR1cmUgc2hvdyhbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CC5oyH5a6a44Gn44GN44KL44Gu44Gv44CBXCJmYWRlXCIsIFwibm9uZVwi44Gu44GE44Ga44KM44GL44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuICBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIDxjb2RlPntkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+IFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0byBleGVjdXRlIGFmdGVyIHRoZSBkaWFsb2cgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL44Kz44O844Or44OQ44OD44Kv44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIGFsZXJ0IGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1BIGBQcm9taXNlYCBvYmplY3QgdGhhdCByZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd6KGo56S644GV44KM44KL6KaB57Sg44KS6Kej5rG644GZ44KLYFByb21pc2Vg44Kq44OW44K444Kn44Kv44OI44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwiZmFkZVwiLCBcIm5vbmVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT4gWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu44OA44Kk44Ki44Ot44Kw44GM6ZaJ44GY44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL44Kz44O844Or44OQ44OD44Kv44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGFsZXJ0IGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV3pmqDjgozjgZ/opoHntKDjgpLop6PmsbrjgZnjgotgUHJvbWlzZWDjgqrjg5bjgrjjgqfjgq/jg4jjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0RpYWxvZ0FuaW1hdG9yfSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBBbGVydERpYWxvZ0FuaW1hdG9yKSkge1xuICAgICAgdXRpbC50aHJvd0FuaW1hdG9yKCdBbGVydERpYWxvZycpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgQWxlcnREaWFsb2dBbmltYXRvcigpIHtcbiAgICByZXR1cm4gQWxlcnREaWFsb2dBbmltYXRvcjtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5BbGVydERpYWxvZyA9IEFsZXJ0RGlhbG9nRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWFsZXJ0LWRpYWxvZycsIEFsZXJ0RGlhbG9nRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlQnV0dG9uRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1idXR0b24nO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1hbGVydC1kaWFsb2ctYnV0dG9uXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBhbGVydC1kaWFsb2cgYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXVRoZSBgPG9ucy1hbGVydC1kaWFsb2c+YCBjb21wb25lbnQgZGlzcGxheXMgYSBhbGVydCBkaWFsb2cuWy9lbl1cbiAqICAgW2phXW9ucy1hbGVydC1kaWFsb2fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqICA8b25zLWFsZXJ0LWRpYWxvZz5cbiAqICAgIDxkaXYgY2xhc3M9XCJhbGVydC1kaWFsb2ctdGl0bGVcIj5XYXJuaW5nITwvZGl2PlxuICogICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1jb250ZW50XCI+XG4gKiAgICAgIEFuIGVycm9yIGhhcyBvY2N1cnJlZCFcbiAqICAgIDwvZGl2PlxuICogICAgPGRpdiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1mb290ZXJcIj5cbiAqICAgICAgPGFsZXJ0LWRpYWxvZy1idXR0b24gb25jbGljaz1cImFwcC5jbG9zZSgpXCI+Q2FuY2VsPC9hbGVydC1kaWFsb2ctYnV0dG9uPlxuICogICAgICA8YWxlcnQtZGlhbG9nLWJ1dHRvbiBjbGFzcz1cImFsZXJ0LWRpYWxvZy1idXR0b25cIiBvbmNsaWNrPVwiYXBwLmNsb3NlKClcIj5PSzwvYWxlcnQtZGlhbG9nLWJ1dHRvbj5cbiAqICAgIDwvZGl2PlxuICogIDwvb25zLWFsZXJ0LWRpYWxvZz5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWxlcnREaWFsb2dCdXR0b25FbGVtZW50IGV4dGVuZHMgQmFzZUJ1dHRvbkVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiB7ICcnOiAnYWxlcnQtZGlhbG9nLWJ1dHRvbi0tKicgfTtcbiAgfVxuXG4gIGdldCBfZGVmYXVsdENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gJ2FsZXJ0LWRpYWxvZy1idXR0b24nO1xuICB9XG5cbiAgZ2V0IF9yaXBwbGVPcHQoKSB7XG4gICAgcmV0dXJuIFt0aGlzLCB1bmRlZmluZWQsIHsgJ21vZGlmaWVyJzogJ2xpZ2h0LWdyYXknIH1dO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkFsZXJ0RGlhbG9nQnV0dG9uID0gQWxlcnREaWFsb2dCdXR0b25FbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYWxlcnQtZGlhbG9nLWJ1dHRvbicsIEFsZXJ0RGlhbG9nQnV0dG9uRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IGlvc0JhY2tCdXR0b25JY29uIGZyb20gJy4uLy4uL2ltYWdlcy9pb3MtYmFjay1idXR0b24taWNvbi5zdmcnO1xuaW1wb3J0IG1kQmFja0J1dHRvbkljb24gZnJvbSAnLi4vLi4vaW1hZ2VzL21kLWJhY2stYnV0dG9uLWljb24uc3ZnJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdiYWNrLWJ1dHRvbic7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdiYWNrLWJ1dHRvbi0tKicsXG4gICcuYmFjay1idXR0b25fX2ljb24nOiAnYmFjay1idXR0b24tLSpfX2ljb24nLFxuICAnLmJhY2stYnV0dG9uX19sYWJlbCc6ICdiYWNrLWJ1dHRvbi0tKl9fbGFiZWwnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1iYWNrLWJ1dHRvblxuICogQGNhdGVnb3J5IG5hdmlnYXRpb25cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQmFjayBidXR0b24gY29tcG9uZW50IGZvciBgPG9ucy10b29sYmFyPmAuIFB1dCBpdCBpbiB0aGUgbGVmdCBwYXJ0IG9mIHRoZSBgPG9ucy10b29sYmFyPmAuXG4gKlxuICogICAgIEl0IHdpbGwgZmluZCB0aGUgcGFyZW50IGA8b25zLW5hdmlnYXRvcj5gIGVsZW1lbnQgYW5kIHBvcCBhIHBhZ2Ugd2hlbiBjbGlja2VkLiBUaGlzIGJlaGF2aW9yIGNhbiBiZSBvdmVycmlkZW4gYnkgc3BlY2lmeWluZyB0aGUgYG9uQ2xpY2tgIHByb3BlcnR5LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvYmFjay1idXR0b25cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHN0eWxlWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICogICBbZW5db25zLXRvb2xiYXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1uYXZpZ2F0b3JcbiAqICAgW2VuXW9ucy1uYXZpZ2F0b3IgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1uYXZpZ2F0b3LjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtdG9vbGJhcj5cbiAqICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICA8b25zLWJhY2stYnV0dG9uPkJhY2s8L29ucy1iYWNrLWJ1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICBUaXRsZVxuICogICA8ZGl2PlxuICogPC9vbnMtdG9vbGJhcj5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYWNrQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJhY2sgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44OQ44OD44Kv44Oc44K/44Oz44Gu6KaL44Gf55uu44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vcHRpb25zID0ge307XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgX3VwZGF0ZUljb24oaWNvbiA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgIGljb24uaW5uZXJIVE1MID0gYXV0b1N0eWxlLmdldFBsYXRmb3JtKHRoaXMpID09PSAnYW5kcm9pZCcgfHwgdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKSA/IG1kQmFja0J1dHRvbkljb24gOiBpb3NCYWNrQnV0dG9uSWNvbjtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmJhY2stYnV0dG9uX19sYWJlbCcpKSB7XG4gICAgICBjb25zdCBsYWJlbCA9IHV0aWwuY3JlYXRlKCdzcGFuLmJhY2stYnV0dG9uX19sYWJlbCcpO1xuXG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIGxhYmVsLmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcuYmFjay1idXR0b25fX2ljb24nKSkge1xuICAgICAgY29uc3QgaWNvbiA9IHV0aWwuY3JlYXRlKCdzcGFuLmJhY2stYnV0dG9uX19pY29uJyk7XG4gICAgICB0aGlzLl91cGRhdGVJY29uKGljb24pO1xuXG4gICAgICB0aGlzLmluc2VydEJlZm9yZShpY29uLCB0aGlzLmNoaWxkcmVuWzBdKTtcbiAgICB9XG5cbiAgICB1dGlsLnVwZGF0ZVJpcHBsZSh0aGlzLCB1bmRlZmluZWQsIHtjZW50ZXI6ICcnLCAnc2l6ZSc6ICdjb250YWluJywgJ2JhY2tncm91bmQnOiAndHJhbnNwYXJlbnQnfSk7XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wdGlvbnMgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgXCJzbGlkZVwiLCBcImxpZnRcIiwgXCJmYWRlXCIgYW5kIFwibm9uZVwiLlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgXCItaW9zXCIgb3IgXCItbWRcIlxuICAgKiAgICAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBcImxpZnQtaW9zXCIsIFwibGlmdC1tZFwiLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIFwic2xpZGUtaW9zXCIgYW5kIFwiZmFkZS1tZFwiLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiAgYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnMuY2FsbGJhY2tcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHRyYW5zaXRpb24gaGFzIGVuZGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruODoeOCveODg+ODieOBq+OCiOOCi+eUu+mdoumBt+enu+OBjOe1guS6huOBl+OBn+mam+OBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25DbGlja1xuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Vc2VkIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhY2sgYnV0dG9uIGJlaGF2aW9yLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBfb25DbGljaygpIHtcbiAgICBpZiAodGhpcy5vbkNsaWNrKSB7XG4gICAgICB0aGlzLm9uQ2xpY2suYXBwbHkodGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbmF2aWdhdG9yID0gdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtbmF2aWdhdG9yJyk7XG4gICAgICBpZiAobmF2aWdhdG9yKSB7XG4gICAgICAgIG5hdmlnYXRvci5wb3BQYWdlKHRoaXMub3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljaywgZmFsc2UpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtb2RpZmllcic6IHtcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSkgJiYgdGhpcy5fdXBkYXRlSWNvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cbn1cblxub25zRWxlbWVudHMuQmFja0J1dHRvbiA9IEJhY2tCdXR0b25FbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtYmFjay1idXR0b24nLCBCYWNrQnV0dG9uRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdib3R0b20tYmFyJztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2JvdHRvbS1iYXItLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtYm90dG9tLXRvb2xiYXJcbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVRvb2xiYXIgY29tcG9uZW50IHRoYXQgaXMgcG9zaXRpb25lZCBhdCB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLiBTaW5jZSBib3R0b20gdG9vbGJhcnMgYXJlIHZlcnkgdmVyc2F0aWxlIGVsZW1lbnRzLCBgb25zLWJvdHRvbS10b29sYmFyYCBkb2VzIG5vdCBwcm92aWRlIGFueSBzcGVjaWZpYyBsYXlvdXQgc3ludGF4IGZvciBpdHMgY2hpbGRyZW4uIE1vZGlmaWVycyBvciBjdXN0b20gQ1NTIG11c3QgYmUgdXNlZC5bL2VuXVxuICogICBbamFd44Oa44O844K45LiL6YOo44Gr6YWN572u44GV44KM44KL44OE44O844Or44OQ44O855So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogICBbZW5dTWFrZSB0aGUgdG9vbGJhciB0cmFuc3BhcmVudC5bL2VuXVxuICogICBbamFd44OE44O844Or44OQ44O844Gu6IOM5pmv44KS6YCP5piO44Gr44GX44Gm6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBhbGlnbmVkXG4gKiAgIFtlbl1WZXJ0aWNhbGx5IGFsaWducyBpdHMgY2hpbGRyZW4gYW5kIGFwcGxpZXMgZmxleGJveCBmb3IgYmxvY2sgZWxlbWVudHMuIGBqdXN0aWZ5LWNvbnRlbnRgIENTUyBydWxlIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSBob3Jpem9udGFsIGFsaWduLlsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7og4zmma/jgpLpgI/mmI7jgavjgZfjgabooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXIgW2VuXW9ucy10b29sYmFyIGNvbXBvbmVudFsvZW5dW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWJvdHRvbS10b29sYmFyPlxuICogICBDb250ZW50XG4gKiA8L29ucy1ib3R0b20tdG9vbGJhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQm90dG9tVG9vbGJhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgdG9vbGJhci5bL2VuXVxuICAgKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7opovjgZ/nm67jga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1wYWdlJykpIHtcbiAgICAgIHRoaXMucGFyZW50Tm9kZS5jbGFzc0xpc3QuYWRkKCdwYWdlLXdpdGgtYm90dG9tLXRvb2xiYXInKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxufVxuXG5vbnNFbGVtZW50cy5Cb3R0b21Ub29sYmFyID0gQm90dG9tVG9vbGJhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1ib3R0b20tdG9vbGJhcicsIEJvdHRvbVRvb2xiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VCdXR0b25FbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWJ1dHRvbic7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWJ1dHRvblxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBvdXRsaW5lXG4gKiAgIFtlbl1CdXR0b24gd2l0aCBvdXRsaW5lIGFuZCB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kWy9lbl1cbiAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuaMgeOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGlnaHRcbiAqICAgW2VuXUJ1dHRvbiB0aGF0IGRvZXNuJ3Qgc3RhbmQgb3V0LlsvZW5dXG4gKiAgIFtqYV3nm67nq4vjgZ/jgarjgYTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIHF1aWV0XG4gKiAgIFtlbl1CdXR0b24gd2l0aCBubyBvdXRsaW5lIGFuZCBvciBiYWNrZ3JvdW5kLi5bL2VuXVxuICogICBbamFd5p6g57ea44KE6IOM5pmv44GM54Sh44GE5paH5a2X44Gg44GR44Gu44Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBjdGFcbiAqICAgW2VuXUJ1dHRvbiB0aGF0IHJlYWxseSBzdGFuZHMgb3V0LlsvZW5dXG4gKiAgIFtqYV3nm67nq4vjgaTjg5zjgr/jg7PjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQG1vZGlmaWVyIGxhcmdlXG4gKiAgIFtlbl1MYXJnZSBidXR0b24gdGhhdCBjb3ZlcnMgdGhlIHdpZHRoIG9mIHRoZSBzY3JlZW4uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi+Wkp+OBjeOBquODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbGFyZ2UtLXF1aWV0XG4gKiAgIFtlbl1MYXJnZSBxdWlldCBidXR0b24uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi3F1aWV044Oc44K/44Oz44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBsYXJnZS0tY3RhXG4gKiAgIFtlbl1MYXJnZSBjYWxsIHRvIGFjdGlvbiBidXR0b24uWy9lbl1cbiAqICAgW2phXeaoquOBhOOBo+OBseOBhOOBq+W6g+OBjOOCi2N0YeODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBidXR0b25bL2VuXVxuICogICBbamFd44Oe44OG44Oq44Ki44Or44OH44K244Kk44Oz44Gu44Oc44K/44OzWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbC0tZmxhdFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIGZsYXQgYnV0dG9uWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODleODqeODg+ODiOODnOOCv+ODs1svamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEJ1dHRvbiBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIHBsYWNlIGEgYnV0dG9uIGluIGEgdG9vbGJhciwgdXNlIGA8b25zLXRvb2xiYXItYnV0dG9uPmAgb3IgYDxvbnMtYmFjay1idXR0b24+YCBpbnN0ZWFkLlxuICpcbiAqICAgICBXaWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheSBhcyBhIE1hdGVyaWFsIERlc2lnbiBidXR0b24gd2l0aCBhIHJpcHBsZSBlZmZlY3Qgb24gQW5kcm9pZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODnOOCv+ODs+eUqOOCs+ODs+ODneODvOODjeODs+ODiOOAguODhOODvOODq+ODkOODvOOBq+ODnOOCv+ODs+OCkuioree9ruOBmeOCi+WgtOWQiOOBr+OAgW9ucy10b29sYmFyLWJ1dHRvbuOCguOBl+OBj+OBr29ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiOOCkuS9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2J1dHRvblxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWJ1dHRvbiBtb2RpZmllcj1cImxhcmdlLS1jdGFcIj5cbiAqICAgVGFwIE1lXG4gKiA8L29ucy1idXR0b24+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnV0dG9uRWxlbWVudCBleHRlbmRzIEJhc2VCdXR0b25FbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHsgJyc6ICdidXR0b24tLSonIH07XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICdidXR0b24nO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkJ1dHRvbiA9IEJ1dHRvbkVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1idXR0b24nLCBCdXR0b25FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnY2FyZCc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnY2FyZC0tKicsXG4gICcuY2FyZF9fdGl0bGUnOiAnY2FyZC0tKl9fdGl0bGUnLFxuICAnLmNhcmRfX2NvbnRlbnQnOiAnY2FyZC0tKl9fY29udGVudCdcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcmRcbiAqIEBjYXRlZ29yeSB2aXN1YWxcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dQSBjYXJkIHdpdGggbWF0ZXJpYWwgZGVzaWduLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjga7kuIrkuIvjga7jg5zjg7zjg4Djg7zjgYznhKHjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgIENvbXBvbmVudCB0byBjcmVhdGUgYSBjYXJkIHRoYXQgZGlzcGxheXMgc29tZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiAgICBUaGUgY2FyZCBtYXkgYmUgY29tcG9zZWQgYnkgZGl2cyB3aXRoIHNwZWNpYWxseSBwcmVwYXJlZCBjbGFzc2VzIGB0aXRsZWAgYW5kL29yIGBjb250ZW50YC4gWW91IGNhbiBhbHNvIGFkZCB5b3VyIG93biBjb250ZW50IGFzIHlvdSBwbGVhc2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2FyZFxuICogQGV4YW1wbGVcbiAqIDxvbnMtY2FyZD5cbiAqICAgPHA+U29tZSBjb250ZW50PC9wPlxuICogPC9vbnMtY2FyZD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FyZEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjYXJkLlsvZW5dXG4gICAqICAgW2phXeODquOCueODiOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgbGV0IHRpdGxlLCBjb250ZW50O1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3RpdGxlJykpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnY2FyZF9fdGl0bGUnKTtcbiAgICAgICAgdGl0bGUgPSBlbDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnY29udGVudCcpKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2NhcmRfX2NvbnRlbnQnKTtcbiAgICAgICAgY29udGVudCA9IGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuQ2FyZCA9IENhcmRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2FyZCcsIENhcmRFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdjYXJvdXNlbC1pdGVtLS0qJ307XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNhcm91c2VsLWl0ZW1cbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBpdGVtIGNvbXBvbmVudC4gVXNlZCBhcyBhIGNoaWxkIG9mIHRoZSBgPG9ucy1jYXJvdXNlbD5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geGJiek9RXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2Fyb3VzZWxcbiAqIEBzZWVhbHNvIG9ucy1jYXJvdXNlbFxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWw+YCBjb21wb25lbnRzWy9lbl1cbiAqICAgW2phXTxvbnMtY2Fyb3VzZWw+44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWNhcm91c2VsIHN0eWxlPVwid2lkdGg6IDEwMCU7IGhlaWdodDogMjAwcHhcIj5cbiAqICAgPG9ucy1jYXJvdXNlbC1pdGVtPlxuICogICAgLi4uXG4gKiAgIDwvb25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogPC9vbnMtY2Fyb3VzZWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhcm91c2VsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInXVxuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgcmV0dXJuIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgIH1cbiAgfVxufVxuXG5vbnNFbGVtZW50cy5DYXJvdXNlbEl0ZW0gPSBDYXJvdXNlbEl0ZW1FbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2Fyb3VzZWwtaXRlbScsIENhcm91c2VsSXRlbUVsZW1lbnQpO1xuIiwiaW1wb3J0IHV0aWwgZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vcGxhdGZvcm0nO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi9hbmltaXQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9nZXN0dXJlLWRldGVjdG9yJztcblxuY29uc3QgZGlyZWN0aW9uTWFwID0ge1xuICB2ZXJ0aWNhbDoge1xuICAgIGF4aXM6ICdZJyxcbiAgICBzaXplOiAnSGVpZ2h0JyxcbiAgICBkaXI6IFsndXAnLCAnZG93biddLFxuICAgIHQzZDogWycwcHgsICcsICdweCwgMHB4J11cbiAgfSxcbiAgaG9yaXpvbnRhbDoge1xuICAgIGF4aXM6ICdYJyxcbiAgICBzaXplOiAnV2lkdGgnLFxuICAgIGRpcjogWydsZWZ0JywgJ3JpZ2h0J10sXG4gICAgdDNkOiBbJycsICdweCwgMHB4LCAwcHgnXVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2lwZXIge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAvLyBQYXJhbWV0ZXJzXG4gICAgY29uc3QgRkFMU0UgPSAoKCkgPT4gZmFsc2UpO1xuICAgIGBnZXRJbml0aWFsSW5kZXggZ2V0QnViYmxlV2lkdGggaXNWZXJ0aWNhbCBpc092ZXJTY3JvbGxhYmxlIGlzQ2VudGVyZWRcbiAgICBpc0F1dG9TY3JvbGxhYmxlIHJlZnJlc2hIb29rIHByZUNoYW5nZUhvb2sgcG9zdENoYW5nZUhvb2sgb3ZlclNjcm9sbEhvb2tgXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLmZvckVhY2goa2V5ID0+IHRoaXNba2V5XSA9IHBhcmFtc1trZXldIHx8IEZBTFNFKTtcblxuICAgIHRoaXMuZ2V0RWxlbWVudCA9IHBhcmFtcy5nZXRFbGVtZW50OyAvLyBSZXF1aXJlZFxuICAgIHRoaXMuc2Nyb2xsSG9vayA9IHBhcmFtcy5zY3JvbGxIb29rOyAvLyBPcHRpb25hbFxuICAgIHRoaXMuaXRlbVNpemUgPSBwYXJhbXMuaXRlbVNpemUgfHwgJzEwMCUnO1xuXG4gICAgdGhpcy5nZXRBdXRvU2Nyb2xsUmF0aW8gPSAoLi4uYXJncykgPT4ge1xuICAgICAgbGV0IHJhdGlvID0gcGFyYW1zLmdldEF1dG9TY3JvbGxSYXRpbyAmJiBwYXJhbXMuZ2V0QXV0b1Njcm9sbFJhdGlvKC4uLmFyZ3MpO1xuICAgICAgcmF0aW8gPSB0eXBlb2YgcmF0aW8gPT09ICdudW1iZXInICYmIHJhdGlvID09PSByYXRpbyA/IHJhdGlvIDogLjU7XG4gICAgICBpZiAocmF0aW8gPCAwLjAgfHwgcmF0aW8gPiAxLjApIHtcbiAgICAgICAgdXRpbC50aHJvdygnSW52YWxpZCBhdXRvLXNjcm9sbC1yYXRpbyAnICsgcmF0aW8gKyAnLiBNdXN0IGJlIGJldHdlZW4gMCBhbmQgMScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJhdGlvO1xuICAgIH07XG5cbiAgICAvLyBQcmV2ZW50IGNsaWNrcyBvbmx5IG9uIGRlc2t0b3BcbiAgICB0aGlzLnNob3VsZEJsb2NrID0gdXRpbC5nbG9iYWxzLmFjdHVhbE1vYmlsZU9TID09PSAnb3RoZXInO1xuXG4gICAgLy8gQmluZCBoYW5kbGVyc1xuICAgIHRoaXMub25EcmFnU3RhcnQgPSB0aGlzLm9uRHJhZ1N0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbkRyYWcgPSB0aGlzLm9uRHJhZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25EcmFnRW5kID0gdGhpcy5vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uUmVzaXplID0gdGhpcy5vblJlc2l6ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fc2hvdWxkRml4U2Nyb2xsID0gdXRpbC5nbG9iYWxzLmFjdHVhbE1vYmlsZU9TID09PSAnaW9zJztcbiAgfVxuXG4gIGluaXQoeyBzd2lwZWFibGUsIGF1dG9SZWZyZXNoIH0gPSB7fSkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGhpcy5nZXRFbGVtZW50KCkuY2hpbGRyZW5bMF07XG4gICAgdGhpcy5ibG9ja2VyID0gdGhpcy5nZXRFbGVtZW50KCkuY2hpbGRyZW5bMV07XG4gICAgaWYgKCF0aGlzLnRhcmdldCB8fCAhdGhpcy5ibG9ja2VyKSB7XG4gICAgICB1dGlsLnRocm93KCdFeHBlY3RlZCBcInRhcmdldFwiIGFuZCBcImJsb2NrZXJcIiBlbGVtZW50cyB0byBleGlzdCBiZWZvcmUgaW5pdGlhbGl6aW5nIFN3aXBlcicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zaG91bGRCbG9jaykge1xuICAgICAgdGhpcy5ibG9ja2VyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgLy8gQWRkIGNsYXNzZXNcbiAgICB0aGlzLmdldEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKCdvbnMtc3dpcGVyJyk7XG4gICAgdGhpcy50YXJnZXQuY2xhc3NMaXN0LmFkZCgnb25zLXN3aXBlci10YXJnZXQnKTtcbiAgICB0aGlzLmJsb2NrZXIuY2xhc3NMaXN0LmFkZCgnb25zLXN3aXBlci1ibG9ja2VyJyk7XG5cbiAgICAvLyBTZXR1cCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMuZ2V0RWxlbWVudCgpLFxuICAgICAgeyBkcmFnTWluRGlzdGFuY2U6IDEsIGRyYWdMb2NrVG9BeGlzOiB0cnVlLCBwYXNzaXZlOiAhdGhpcy5fc2hvdWxkRml4U2Nyb2xsIH1cbiAgICApO1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB0aGlzLnJlZnJlc2goKSk7XG4gICAgdGhpcy51cGRhdGVTd2lwZWFibGUoc3dpcGVhYmxlKTtcbiAgICB0aGlzLnVwZGF0ZUF1dG9SZWZyZXNoKGF1dG9SZWZyZXNoKTtcblxuICAgIC8vIFNldHVwIGluaXRpYWwgbGF5b3V0XG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fb2Zmc2V0ID0gdGhpcy5fbGFzdEFjdGl2ZUluZGV4ID0gMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQoKTtcbiAgICB0aGlzLl9zZXR1cEluaXRpYWxJbmRleCgpO1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmluaXRpYWxpemVkICYmIHRoaXMuX3NldHVwSW5pdGlhbEluZGV4KCkpO1xuXG4gICAgLy8gRml4IHJlbmRlcmluZyBnbGl0Y2ggb24gQW5kcm9pZCA0LjFcbiAgICAvLyBGaXggZm9yIGlmcmFtZXMgd2hlcmUgdGhlIHdpZHRoIGlzIGluY29uc2lzdGVudCBhdCB0aGUgYmVnaW5uaW5nXG4gICAgaWYgKHdpbmRvdyAhPT0gd2luZG93LnBhcmVudCB8fCB0aGlzLm9mZnNldEhlaWdodCA9PT0gMCkge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmluaXRpYWxpemVkICYmIHRoaXMub25SZXNpemUoKSk7XG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGVTd2lwZWFibGUoZmFsc2UpO1xuICAgIHRoaXMudXBkYXRlQXV0b1JlZnJlc2goZmFsc2UpO1xuXG4gICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yICYmIHRoaXMuX2dlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgdGhpcy50YXJnZXQgPSB0aGlzLmJsb2NrZXIgPSB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSB0aGlzLl9tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcblxuICAgIHRoaXMuc2V0dXBSZXNpemUoZmFsc2UpO1xuICB9XG5cbiAgb25SZXNpemUoKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3Njcm9sbCAvIHRoaXMudGFyZ2V0U2l6ZTtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoaSk7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gIH1cblxuICBnZXQgaXRlbUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldC5jaGlsZHJlbi5sZW5ndGg7XG4gIH1cblxuICBnZXQgaXRlbU51bVNpemUoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9pdGVtTnVtU2l6ZSAhPT0gJ251bWJlcicgfHwgdGhpcy5faXRlbU51bVNpemUgIT09IHRoaXMuX2l0ZW1OdW1TaXplKSB7XG4gICAgICB0aGlzLl9pdGVtTnVtU2l6ZSA9IHRoaXMuX2NhbGN1bGF0ZUl0ZW1TaXplKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pdGVtTnVtU2l6ZTtcbiAgfVxuXG4gIGdldCBtYXhTY3JvbGwoKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5pdGVtQ291bnQgKiB0aGlzLml0ZW1OdW1TaXplIC0gdGhpcy50YXJnZXRTaXplO1xuICAgIHJldHVybiBNYXRoLmNlaWwobWF4IDwgMCA/IDAgOiBtYXgpOyAvLyBOZWVkIHRvIHJldHVybiBhbiBpbnRlZ2VyIHZhbHVlLlxuICB9XG5cbiAgX2NhbGN1bGF0ZUl0ZW1TaXplKCkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLml0ZW1TaXplLm1hdGNoKC9eKFxcZCspKHB4fCUpLyk7XG5cbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHV0aWwudGhyb3coYEludmFsaWQgc3RhdGU6IHN3aXBlcidzIHNpemUgdW5pdCBtdXN0IGJlICclJyBvciAncHgnYCk7XG4gICAgfVxuXG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgcmV0dXJuIG1hdGNoZXNbMl0gPT09ICclJyA/IE1hdGgucm91bmQodmFsdWUgLyAxMDAgKiB0aGlzLnRhcmdldFNpemUpIDogdmFsdWU7XG4gIH1cblxuICBfc2V0dXBJbml0aWFsSW5kZXgoKSB7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBNYXRoLm1heChNYXRoLm1pbihOdW1iZXIodGhpcy5nZXRJbml0aWFsSW5kZXgoKSksIHRoaXMuaXRlbUNvdW50KSwgMCk7XG4gICAgdGhpcy5fc2Nyb2xsID0gdGhpcy5fb2Zmc2V0ICsgdGhpcy5pdGVtTnVtU2l6ZSAqIHRoaXMuX2xhc3RBY3RpdmVJbmRleDtcbiAgICB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwpO1xuICB9XG5cbiAgX3NldFN3aXBpbmcodG9nZ2xlKSB7XG4gICAgdGhpcy50YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgnc3dpcGluZycsIHRvZ2dsZSk7IC8vIEhpZGVzIGV2ZXJ5dGhpbmcgZXhjZXB0IHNob3duIHBhZ2VzXG4gIH1cblxuICBzZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fc2V0U3dpcGluZyh0cnVlKTtcbiAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCB0aGlzLml0ZW1Db3VudCAtIDEpKTtcbiAgICBjb25zdCBzY3JvbGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLm1heFNjcm9sbCwgdGhpcy5fb2Zmc2V0ICsgdGhpcy5pdGVtTnVtU2l6ZSAqIGluZGV4KSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNVSVdlYlZpZXcoKSkge1xuICAgICAgLyogRGlydHkgZml4IGZvciAjMjIzMShodHRwczovL2dpdGh1Yi5jb20vT25zZW5VSS9PbnNlblVJL2lzc3Vlcy8yMjMxKS4gYmVnaW4gKi9cbiAgICAgIGNvbnN0IGNvbmNhdCA9IGFycmF5T2ZBcnJheSA9PiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnJheU9mQXJyYXkpO1xuICAgICAgY29uc3QgY29udGVudHMgPSBjb25jYXQoXG4gICAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMudGFyZ2V0LmNoaWxkcmVuKS5tYXAocGFnZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKHBhZ2UuY2hpbGRyZW4pXG4gICAgICAgICAgICAuZmlsdGVyKGNoaWxkID0+IGNoaWxkLmNsYXNzTGlzdC5jb250YWlucygncGFnZV9fY29udGVudCcpKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIGNvbnRlbnRzLmZvckVhY2goY29udGVudCA9PiB7XG4gICAgICAgICAgICBtYXAuc2V0KGNvbnRlbnQsIGNvbnRlbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpKTtcbiAgICAgICAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgncGFnZV9fY29udGVudC0tc3VwcHJlc3MtbGF5ZXItY3JlYXRpb24nKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXNvbHZlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5fY2hhbmdlVG8oc2Nyb2xsLCBvcHRpb25zKSlcbiAgICAgICAgLnRoZW4oKCkgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgY29udGVudHMuZm9yRWFjaChjb250ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIG1hcC5nZXQoY29udGVudCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZXNvbHZlKTtcbiAgICAgICAgfSkpXG4gICAgICApO1xuICAgICAgLyogZW5kICovXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VUbyhzY3JvbGwsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGdldEFjdGl2ZUluZGV4KHNjcm9sbCA9IHRoaXMuX3Njcm9sbCkge1xuICAgIHNjcm9sbCAtPSB0aGlzLl9vZmZzZXQ7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLml0ZW1Db3VudCxcbiAgICAgIHNpemUgPSB0aGlzLml0ZW1OdW1TaXplO1xuXG4gICAgaWYgKHRoaXMuaXRlbU51bVNpemUgPT09IDAgfHwgIXV0aWwuaXNJbnRlZ2VyKHNjcm9sbCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXN0QWN0aXZlSW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbCA8PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIGlmIChzaXplICogaSA8PSBzY3JvbGwgJiYgc2l6ZSAqIChpICsgMSkgPiBzY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50IC0gMTtcbiAgfVxuXG4gIHNldHVwUmVzaXplKGFkZCkge1xuICAgIHdpbmRvd1soYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnRXZlbnRMaXN0ZW5lciddKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplLCB0cnVlKTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgdGhpcy5zZXR1cFJlc2l6ZSh0cnVlKTtcbiAgICB0aGlzLm9uUmVzaXplKCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRhcmdldCAmJiB0aGlzLnRhcmdldC5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKSwgMTAwMC82MCk7IC8vIEhpZGUgZWxlbWVudHMgYWZ0ZXIgYW5pbWF0aW9uc1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICB0aGlzLnNldHVwUmVzaXplKGZhbHNlKTtcbiAgICB0aGlzLnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTsgLy8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW9uc1xuICB9XG5cbiAgdXBkYXRlU3dpcGVhYmxlKHNob3VsZFVwZGF0ZSkge1xuICAgIGlmICh0aGlzLl9nZXN0dXJlRGV0ZWN0b3IpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IHNob3VsZFVwZGF0ZSA/ICdvbicgOiAnb2ZmJztcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnJywgdGhpcy5vbkRyYWcpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWdzdGFydCcsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWdlbmQnLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQXV0b1JlZnJlc2goc2hvdWxkV2F0Y2gpIHtcbiAgICBpZiAodGhpcy5fbXV0YXRpb25PYnNlcnZlcikge1xuICAgICAgc2hvdWxkV2F0Y2hcbiAgICAgICAgPyB0aGlzLl9tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy50YXJnZXQsIHsgY2hpbGRMaXN0OiB0cnVlIH0pXG4gICAgICAgIDogdGhpcy5fbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlSXRlbVNpemUobmV3U2l6ZSkge1xuICAgIHRoaXMuaXRlbVNpemUgPSBuZXdTaXplIHx8ICcxMDAlJztcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfVxuXG4gIHRvZ2dsZUJsb2NrZXIoYmxvY2spIHtcbiAgICB0aGlzLmJsb2NrZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IGJsb2NrID8gJ2F1dG8nIDogJ25vbmUnO1xuICB9XG5cbiAgX2NhbkNvbnN1bWVHZXN0dXJlKGdlc3R1cmUpIHtcbiAgICBjb25zdCBkID0gZ2VzdHVyZS5kaXJlY3Rpb247XG4gICAgY29uc3QgaXNGaXJzdCA9IHRoaXMuX3Njcm9sbCA9PT0gMCAmJiAhdGhpcy5pc092ZXJTY3JvbGxhYmxlKCk7XG4gICAgY29uc3QgaXNMYXN0ID0gdGhpcy5fc2Nyb2xsID09PSB0aGlzLm1heFNjcm9sbCAmJiAhdGhpcy5pc092ZXJTY3JvbGxhYmxlKCk7XG5cbiAgICByZXR1cm4gdGhpcy5pc1ZlcnRpY2FsKClcbiAgICAgID8gKChkID09PSAnZG93bicgJiYgIWlzRmlyc3QpIHx8IChkID09PSAndXAnICYmICFpc0xhc3QpKVxuICAgICAgOiAoKGQgPT09ICdyaWdodCcgJiYgIWlzRmlyc3QpIHx8IChkID09PSAnbGVmdCcgJiYgIWlzTGFzdCkpO1xuICB9XG5cbiAgb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICB0aGlzLl9pZ25vcmVEcmFnID0gZXZlbnQuY29uc3VtZWQgfHwgIXV0aWwuaXNWYWxpZEdlc3R1cmUoZXZlbnQpO1xuXG4gICAgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICBjb25zdCBjb25zdW1lID0gZXZlbnQuY29uc3VtZTtcbiAgICAgIGV2ZW50LmNvbnN1bWUgPSAoKSA9PiB7IGNvbnN1bWUgJiYgY29uc3VtZSgpOyB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTsgfTtcblxuICAgICAgaWYgKHRoaXMuX2NhbkNvbnN1bWVHZXN0dXJlKGV2ZW50Lmdlc3R1cmUpKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0WCA9IGV2ZW50Lmdlc3R1cmUuY2VudGVyICYmIGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFggfHwgMCxcbiAgICAgICAgICBkaXN0RnJvbUVkZ2UgPSB0aGlzLmdldEJ1YmJsZVdpZHRoKCkgfHwgMCxcbiAgICAgICAgICBzdGFydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN1bWUgJiYgY29uc3VtZSgpO1xuICAgICAgICAgICAgZXZlbnQuY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7IC8vIEF2b2lkIHN0YXJ0aW5nIGRyYWcgZnJvbSBvdXRzaWRlXG4gICAgICAgICAgICB0aGlzLnNob3VsZEJsb2NrICYmIHRoaXMudG9nZ2xlQmxvY2tlcih0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFN3aXBpbmcodHJ1ZSk7XG4gICAgICAgICAgICB1dGlsLmlvc1ByZXZlbnRTY3JvbGwodGhpcy5fZ2VzdHVyZURldGVjdG9yKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgIC8vIExldCBwYXJlbnQgZWxlbWVudHMgY29uc3VtZSB0aGUgZ2VzdHVyZSBvciBjb25zdW1lIGl0IHJpZ2h0IGF3YXlcbiAgICAgICAgc3RhcnRYIDwgZGlzdEZyb21FZGdlIHx8IHN0YXJ0WCA+ICh0aGlzLnRhcmdldFNpemUgLSBkaXN0RnJvbUVkZ2UpXG4gICAgICAgICAgPyBzZXRJbW1lZGlhdGUoKCkgPT4gIXRoaXMuX2lnbm9yZURyYWcgJiYgc3RhcnQoKSlcbiAgICAgICAgICA6IHN0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25EcmFnKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5nZXN0dXJlIHx8IHRoaXMuX2lnbm9yZURyYWcgfHwgIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250aW51ZWQgPSB0cnVlOyAvLyBGaXggZm9yIHJhbmRvbSAnZHJhZ2VuZCcgd2l0aG91dCAnZHJhZydcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMuX3Njcm9sbCAtIHRoaXMuX2dldERlbHRhKGV2ZW50KSwgeyB0aHJvdHRsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIG9uRHJhZ0VuZChldmVudCkge1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIWV2ZW50Lmdlc3R1cmUgfHwgdGhpcy5faWdub3JlRHJhZyB8fCAhdGhpcy5fY29udGludWVkKSB7XG4gICAgICB0aGlzLl9pZ25vcmVEcmFnID0gdHJ1ZTsgLy8gb25EcmFnRW5kIG1pZ2h0IGZpcmUgYmVmb3JlIG9uRHJhZ1N0YXJ0J3Mgc2V0SW1tZWRpYXRlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGludWVkID0gZmFsc2U7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9zY3JvbGwgLSB0aGlzLl9nZXREZWx0YShldmVudCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFNjcm9sbCA9IHRoaXMuX25vcm1hbGl6ZVNjcm9sbChzY3JvbGwpO1xuICAgIHNjcm9sbCA9PT0gbm9ybWFsaXplZFNjcm9sbCA/IHRoaXMuX3N0YXJ0TW9tZW50dW1TY3JvbGwoc2Nyb2xsLCBldmVudCkgOiB0aGlzLl9raWxsT3ZlclNjcm9sbChub3JtYWxpemVkU2Nyb2xsKTtcbiAgICB0aGlzLnNob3VsZEJsb2NrICYmIHRoaXMudG9nZ2xlQmxvY2tlcihmYWxzZSk7XG4gIH1cblxuICBfc3RhcnRNb21lbnR1bVNjcm9sbChzY3JvbGwsIGV2ZW50KSB7XG4gICAgY29uc3QgdmVsb2NpdHkgPSB0aGlzLl9nZXRWZWxvY2l0eShldmVudCksXG4gICAgICBtYXRjaGVzRGlyZWN0aW9uID0gZXZlbnQuZ2VzdHVyZS5pbnRlcmltRGlyZWN0aW9uID09PSB0aGlzLmRNLmRpclt0aGlzLl9nZXREZWx0YShldmVudCkgPCAwID8gMCA6IDFdO1xuXG4gICAgY29uc3QgbmV4dFNjcm9sbCA9IHRoaXMuX2dldEF1dG9TY3JvbGwoc2Nyb2xsLCB2ZWxvY2l0eSwgbWF0Y2hlc0RpcmVjdGlvbik7XG4gICAgbGV0IGR1cmF0aW9uID0gTWF0aC5hYnMobmV4dFNjcm9sbCAtIHNjcm9sbCkgLyAodmVsb2NpdHkgKyAwLjAxKSAvIDEwMDA7XG4gICAgZHVyYXRpb24gPSBNYXRoLm1pbiguMjUsIE1hdGgubWF4KC4xLCBkdXJhdGlvbikpO1xuXG4gICAgdGhpcy5fY2hhbmdlVG8obmV4dFNjcm9sbCwgeyBzd2lwZTogdHJ1ZSwgYW5pbWF0aW9uT3B0aW9uczogeyBkdXJhdGlvbiwgdGltaW5nOiAnY3ViaWMtYmV6aWVyKC40LCAuNywgLjUsIDEpJyB9IH0pO1xuICB9XG5cbiAgX2tpbGxPdmVyU2Nyb2xsKHNjcm9sbCkge1xuICAgIHRoaXMuX3Njcm9sbCA9IHNjcm9sbDtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmRNLmRpcltOdW1iZXIoc2Nyb2xsID4gMCldO1xuICAgIGNvbnN0IGtpbGxPdmVyU2Nyb2xsID0gKCkgPT4gdGhpcy5fY2hhbmdlVG8oc2Nyb2xsLCB7IGFuaW1hdGlvbk9wdGlvbnM6IHsgZHVyYXRpb246IC40LCB0aW1pbmc6ICdjdWJpYy1iZXppZXIoLjEsIC40LCAuMSwgMSknIH0gfSk7XG4gICAgdGhpcy5vdmVyU2Nyb2xsSG9vayh7IGRpcmVjdGlvbiwga2lsbE92ZXJTY3JvbGwgfSkgfHwga2lsbE92ZXJTY3JvbGwoKTtcbiAgfVxuXG4gIF9jaGFuZ2VUbyhzY3JvbGwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGUgPSB7IGFjdGl2ZUluZGV4OiB0aGlzLmdldEFjdGl2ZUluZGV4KHNjcm9sbCksIGxhc3RBY3RpdmVJbmRleDogdGhpcy5fbGFzdEFjdGl2ZUluZGV4LCBzd2lwZTogb3B0aW9ucy5zd2lwZSB8fCBmYWxzZSB9O1xuICAgIGNvbnN0IGNoYW5nZSA9IGUuYWN0aXZlSW5kZXggIT09IGUubGFzdEFjdGl2ZUluZGV4O1xuICAgIGNvbnN0IGNhbmNlbGVkID0gY2hhbmdlID8gdGhpcy5wcmVDaGFuZ2VIb29rKGUpIDogZmFsc2U7XG5cbiAgICB0aGlzLl9zY3JvbGwgPSBjYW5jZWxlZCA/IHRoaXMuX29mZnNldCArIGUubGFzdEFjdGl2ZUluZGV4ICogdGhpcy5pdGVtTnVtU2l6ZSA6IHNjcm9sbDtcbiAgICB0aGlzLl9sYXN0QWN0aXZlSW5kZXggPSBjYW5jZWxlZCA/IGUubGFzdEFjdGl2ZUluZGV4IDogZS5hY3RpdmVJbmRleDtcblxuICAgIHJldHVybiB0aGlzLl9zY3JvbGxUbyh0aGlzLl9zY3JvbGwsIG9wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHNjcm9sbCA9PT0gdGhpcy5fc2Nyb2xsICYmICFjYW5jZWxlZCkge1xuICAgICAgICB0aGlzLl9zZXRTd2lwaW5nKGZhbHNlKTtcbiAgICAgICAgY2hhbmdlICYmIHRoaXMucG9zdENoYW5nZUhvb2soZSk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucmVqZWN0KSB7XG4gICAgICAgIHRoaXMuX3NldFN3aXBpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfc2Nyb2xsVG8oc2Nyb2xsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy50aHJvdHRsZSkge1xuICAgICAgY29uc3QgcmF0aW8gPSAwLjM1O1xuICAgICAgaWYgKHNjcm9sbCA8IDApIHtcbiAgICAgICAgc2Nyb2xsID0gdGhpcy5pc092ZXJTY3JvbGxhYmxlKCkgPyBNYXRoLnJvdW5kKHNjcm9sbCAqIHJhdGlvKSA6IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXhTY3JvbGwgPSB0aGlzLm1heFNjcm9sbDtcbiAgICAgICAgaWYgKG1heFNjcm9sbCA8IHNjcm9sbCkge1xuICAgICAgICAgIHNjcm9sbCA9IHRoaXMuaXNPdmVyU2Nyb2xsYWJsZSgpID8gbWF4U2Nyb2xsICsgTWF0aC5yb3VuZCgoc2Nyb2xsIC0gbWF4U2Nyb2xsKSAqIHJhdGlvKSA6IG1heFNjcm9sbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnMuYW5pbWF0aW9uICA9PT0gJ25vbmUnID8ge30gOiBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnM7XG4gICAgdGhpcy5zY3JvbGxIb29rICYmIHRoaXMuaXRlbU51bVNpemUgPiAwICYmIHRoaXMuc2Nyb2xsSG9vaygoc2Nyb2xsIC8gdGhpcy5pdGVtTnVtU2l6ZSkudG9GaXhlZCgyKSwgb3B0aW9ucy5hbmltYXRpb25PcHRpb25zIHx8IHt9KTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+XG4gICAgICBhbmltaXQodGhpcy50YXJnZXQpXG4gICAgICAgIC5xdWV1ZSh7IHRyYW5zZm9ybTogdGhpcy5fZ2V0VHJhbnNmb3JtKHNjcm9sbCkgfSwgb3B0KVxuICAgICAgICAucGxheShyZXNvbHZlKVxuICAgICk7XG4gIH1cblxuICBfZ2V0QXV0b1Njcm9sbChzY3JvbGwsIHZlbG9jaXR5LCBtYXRjaGVzRGlyZWN0aW9uKSB7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXhTY3JvbGwsXG4gICAgICBvZmZzZXQgPSB0aGlzLl9vZmZzZXQsXG4gICAgICBzaXplID0gdGhpcy5pdGVtTnVtU2l6ZTtcblxuICAgIGlmICghdGhpcy5pc0F1dG9TY3JvbGxhYmxlKCkpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHNjcm9sbCkpO1xuICAgIH1cblxuICAgIGxldCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBzID0gb2Zmc2V0OyBzIDwgbWF4OyBzICs9IHNpemUpIHtcbiAgICAgIGFyci5wdXNoKHMpO1xuICAgIH1cbiAgICBhcnIucHVzaChtYXgpO1xuXG4gICAgYXJyID0gYXJyXG4gICAgICAuc29ydCgobGVmdCwgcmlnaHQpID0+IE1hdGguYWJzKGxlZnQgLSBzY3JvbGwpIC0gTWF0aC5hYnMocmlnaHQgLSBzY3JvbGwpKVxuICAgICAgLmZpbHRlcigoaXRlbSwgcG9zKSA9PiAhcG9zIHx8IGl0ZW0gIT09IGFycltwb3MgLSAxXSk7XG5cbiAgICBsZXQgcmVzdWx0ID0gYXJyWzBdO1xuICAgIGNvbnN0IGxhc3RTY3JvbGwgPSB0aGlzLl9sYXN0QWN0aXZlSW5kZXggKiBzaXplICsgb2Zmc2V0O1xuICAgIGNvbnN0IHNjcm9sbFJhdGlvID0gTWF0aC5hYnMoc2Nyb2xsIC0gbGFzdFNjcm9sbCkgLyBzaXplO1xuXG4gICAgaWYgKHNjcm9sbFJhdGlvIDw9IHRoaXMuZ2V0QXV0b1Njcm9sbFJhdGlvKG1hdGNoZXNEaXJlY3Rpb24sIHZlbG9jaXR5LCBzaXplKSkge1xuICAgICAgcmVzdWx0ID0gbGFzdFNjcm9sbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNjcm9sbFJhdGlvIDwgMS4wICYmIGFyclswXSA9PT0gbGFzdFNjcm9sbCAmJiBhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICByZXN1bHQgPSBhcnJbMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihtYXgsIHJlc3VsdCkpO1xuICB9XG5cbiAgX3Jlc2V0KCkge1xuICAgIHRoaXMuX3RhcmdldFNpemUgPSB0aGlzLl9pdGVtTnVtU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIF9ub3JtYWxpemVTY3JvbGwoc2Nyb2xsKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KCBNYXRoLm1pbihzY3JvbGwsIHRoaXMubWF4U2Nyb2xsKSwgMClcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgdGhpcy5fcmVzZXQoKTtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQoKTtcblxuICAgIGlmICh1dGlsLmlzSW50ZWdlcih0aGlzLl9zY3JvbGwpKSB7XG4gICAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9ub3JtYWxpemVTY3JvbGwodGhpcy5fc2Nyb2xsKTtcbiAgICAgIHNjcm9sbCAhPT0gdGhpcy5fc2Nyb2xsID8gdGhpcy5fa2lsbE92ZXJTY3JvbGwoc2Nyb2xsKSA6IHRoaXMuX2NoYW5nZVRvKHNjcm9sbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NldHVwSW5pdGlhbEluZGV4KCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoSG9vaygpO1xuICB9XG5cbiAgZ2V0IHRhcmdldFNpemUoKSB7XG4gICAgaWYgKCF0aGlzLl90YXJnZXRTaXplKSB7XG4gICAgICB0aGlzLl90YXJnZXRTaXplID0gdGhpcy50YXJnZXRbYG9mZnNldCR7dGhpcy5kTS5zaXplfWBdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0U2l6ZTtcbiAgfVxuXG4gIF9nZXREZWx0YShldmVudCkge1xuICAgIHJldHVybiBldmVudC5nZXN0dXJlW2BkZWx0YSR7dGhpcy5kTS5heGlzfWBdO1xuICB9XG5cbiAgX2dldFZlbG9jaXR5KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdlc3R1cmVbYHZlbG9jaXR5JHt0aGlzLmRNLmF4aXN9YF07XG4gIH1cblxuICBfZ2V0VHJhbnNmb3JtKHNjcm9sbCkge1xuICAgIHJldHVybiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRNLnQzZFswXX0key1zY3JvbGx9JHt0aGlzLmRNLnQzZFsxXX0pYDtcbiAgfVxuXG4gIF91cGRhdGVMYXlvdXQoKSB7XG4gICAgdGhpcy5kTSA9IGRpcmVjdGlvbk1hcFt0aGlzLmlzVmVydGljYWwoKSA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCddO1xuICAgIHRoaXMudGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUoJ29ucy1zd2lwZXItdGFyZ2V0LS12ZXJ0aWNhbCcsIHRoaXMuaXNWZXJ0aWNhbCgpKTtcblxuICAgIGZvciAobGV0IGMgPSB0aGlzLnRhcmdldC5jaGlsZHJlblswXTsgYzsgYyA9IGMubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICBjLnN0eWxlW3RoaXMuZE0uc2l6ZS50b0xvd2VyQ2FzZSgpXSA9IHRoaXMuaXRlbVNpemU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDZW50ZXJlZCgpKSB7XG4gICAgICB0aGlzLl9vZmZzZXQgPSAodGhpcy50YXJnZXRTaXplIC0gdGhpcy5pdGVtTnVtU2l6ZSkgLyAtMiB8fCAwO1xuICAgIH1cbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IFN3aXBlciBmcm9tICcuLi9vbnMvaW50ZXJuYWwvc3dpcGVyJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtY2Fyb3VzZWxcbiAqIEBjYXRlZ29yeSBjYXJvdXNlbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDYXJvdXNlbCBjb21wb25lbnQuIEEgY2Fyb3VzZWwgY2FuIGJlIHVzZWQgdG8gZGlzcGxheSBzZXZlcmFsIGl0ZW1zIGluIHRoZSBzYW1lIHNwYWNlLlxuICpcbiAqICAgICBUaGUgY29tcG9uZW50IHN1cHBvcnRzIGRpc3BsYXlpbmcgY29udGVudCBib3RoIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseS4gVGhlIHVzZXIgY2FuIHNjcm9sbCB0aHJvdWdoIHRoZSBpdGVtcyBieSBkcmFnZ2luZyBhbmQgaXQgY2FuIGFsc28gYmUgY29udHJvbGxlciBwcm9ncmFtbWF0aWNhbGx5LlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHhiYnpPUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2Nhcm91c2VsXG4gKiBAc2VlYWxzbyBvbnMtY2Fyb3VzZWwtaXRlbVxuICogICBbZW5dYDxvbnMtY2Fyb3VzZWwtaXRlbT5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1jYXJvdXNlbCBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDIwMHB4XCI+XG4gKiAgIDxvbnMtY2Fyb3VzZWwtaXRlbT5cbiAqICAgIC4uLlxuICogICA8L29ucy1jYXJvdXNlbC1pdGVtPlxuICogICA8b25zLWNhcm91c2VsLWl0ZW0+XG4gKiAgICAuLi5cbiAqICAgPC9vbnMtY2Fyb3VzZWwtaXRlbT5cbiAqIDwvb25zLWNhcm91c2VsPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYXJvdXNlbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaGFzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or44Gu6KaB57Sg44GM5aSJ44KP44Gj44Gf5pmC44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY2Fyb3VzZWxcbiAgICogICBbZW5dQ2Fyb3VzZWwgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn0Nhcm91c2Vs44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGV2ZW50LmFjdGl2ZUluZGV4XG4gICAqICAgW2VuXUN1cnJlbnQgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOCouOCr+ODhuOCo+ODluOBq+OBquOBo+OBpuOBhOOCi+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBldmVudC5sYXN0QWN0aXZlSW5kZXhcbiAgICogICBbZW5dUHJldmlvdXMgYWN0aXZlIGluZGV4LlsvZW5dXG4gICAqICAgW2phXeS7peWJjeOCouOCr+ODhuOCo+ODluOBoOOBo+OBn+imgee0oOOBruOCpOODs+ODh+ODg+OCr+OCueOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcmVmcmVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gcmVmcmVzaGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOabtOaWsOOBleOCjOOBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUNhcm91c2VsIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgYznmbrngavjgZfjgZ9DYXJvdXNlbOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgb3ZlcnNjcm9sbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgY2Fyb3VzZWwgaGFzIGJlZW4gb3ZlcnNjcm9sbGVkLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBjOOCquODvOODkOODvOOCueOCr+ODreODvOODq+OBl+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNhcm91c2VsXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIGNhcm91c2VsIGhhcyBiZWVuIHJlZnJlc2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqvjg6vjg7zjgrvjg6vjgYzmm7TmlrDjgZXjgozjgZ/mmYLjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuYWN0aXZlSW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBhY3RpdmUgaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LmRpcmVjdGlvblxuICAgKiAgIFtlbl1DYW4gYmUgb25lIG9mIGVpdGhlciBcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiBvciBcInJpZ2h0XCIuWy9lbl1cbiAgICogICBbamFd44Kq44O844OQ44O844K544Kv44Ot44O844Or44GV44KM44Gf5pa55ZCR44GM5b6X44KJ44KM44G+44GZ44CCXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIuOBruOBhOOBmuOCjOOBi+OBruaWueWQkeOBjOa4oeOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LndhaXRUb1JldHVyblxuICAgKiAgIFtlbl1UYWtlcyBhIDxjb2RlPlByb21pc2U8L2NvZGU+IG9iamVjdCBhcyBhbiBhcmd1bWVudC4gVGhlIGNhcm91c2VsIHdpbGwgbm90IHNjcm9sbCBiYWNrIHVudGlsIHRoZSBwcm9taXNlIGhhcyBiZWVuIHJlc29sdmVkIG9yIHJlamVjdGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOBr1Byb21pc2Xjgqrjg5bjgrjjgqfjgq/jg4jjgpLlvJXmlbDjgajjgZfjgablj5fjgZHlj5bjgorjgb7jgZnjgILmuKHjgZfjgZ9Qcm9taXNl44Kq44OW44K444Kn44Kv44OI44GMcmVzb2x2ZeOBleOCjOOCi+OBi3JlamVjdOOBleOCjOOCi+OBvuOBp+OAgeOCq+ODq+ODvOOCu+ODq+OBr+OCueOCr+ODreODvOODq+ODkOODg+OCr+OBl+OBvuOBm+OCk+OAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGRpcmVjdGlvbiBvZiB0aGUgY2Fyb3VzZWwuIENhbiBiZSBlaXRoZXIgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLiBEZWZhdWx0IGlzIFwiaG9yaXpvbnRhbFwiLlsvZW5dXG4gICAqICAgW2phXeOCq+ODq+ODvOOCu+ODq+OBruaWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAglwiaG9yaXpvbnRhbFwi44GLXCJ2ZXJ0aWNhbFwi44KS5oyH5a6a44Gn44GN44G+44GZ44CCXCJob3Jpem9udGFsXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmdWxsc2NyZWVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgY292ZXIgdGhlIHdob2xlIHNjcmVlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovjgajjgIFhYnNvbHV0ZeODneOCuOOCt+ODp+ODs+OCkuS9v+OBo+OBpuOCq+ODq+ODvOOCu+ODq+OBjOiHquWLleeahOOBq+eUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG92ZXJzY3JvbGxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgc2Nyb2xsYWJsZSBvdmVyIHRoZSBlZGdlLiBJdCB3aWxsIGJvdW5jZSBiYWNrIHdoZW4gcmVsZWFzZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OD44OB44KE44OJ44Op44OD44Kw44Gn56uv44G+44Gn44K544Kv44Ot44O844Or44GX44Gf5pmC44Gr44CB44OQ44Km44Oz44OJ44GZ44KL44KI44GG44Gq5Yq55p6c44GM5b2T44Gf44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2VudGVyZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgdGhlbiB0aGUgc2VsZWN0ZWQgaXRlbSB3aWxsIGJlIGluIHRoZSBjZW50ZXIgb2YgdGhlIGNhcm91c2VsIGluc3RlYWQgb2YgdGhlIGJlZ2lubmluZy4gVXNlZnVsIG9ubHkgd2hlbiB0aGUgaXRlbXMgYXJlIHNtYWxsZXIgdGhhbiB0aGUgY2Fyb3VzZWwuIFsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgemBuOOCk+OBp+OBhOOCi29ucy1jYXJvdXNlbC1pdGVt44Gv44Kr44Or44O844K744Or44Gu55yf44KT5Lit44G46KGM44GN44G+44GZ44CC6aCF55uu44GM44Kr44Or44O844K744Or44KI44KK44KC5bCP44GV44GE5aC05ZCI44Gr44Gu44G/44CB44GT44KM44Gv5L6/5Yip44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaXRlbS13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXW9ucy1jYXJvdXNlbC1pdGVtJ3Mgd2lkdGguIE9ubHkgd29ya3Mgd2hlbiB0aGUgZGlyZWN0aW9uIGlzIHNldCB0byBcImhvcml6b250YWxcIi5bL2VuXVxuICAgKiAgICBbamFdb25zLWNhcm91c2VsLWl0ZW3jga7luYXjgpLmjIflrprjgZfjgb7jgZnjgILjgZPjga7lsZ7mgKfjga/jgIFkaXJlY3Rpb27lsZ7mgKfjgatcImhvcml6b250YWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGl0ZW0taGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1vbnMtY2Fyb3VzZWwtaXRlbSdzIGhlaWdodC4gT25seSB3b3JrcyB3aGVuIHRoZSBkaXJlY3Rpb24gaXMgc2V0IHRvIFwidmVydGljYWxcIi5bL2VuXVxuICAgKiAgIFtqYV1vbnMtY2Fyb3VzZWwtaXRlbeOBrumrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWxnuaAp+OBr+OAgWRpcmVjdGlvbuWxnuaAp+OBq1widmVydGljYWxcIuOCkuaMh+WumuOBl+OBn+aZguOBruOBv+acieWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGF1dG8tc2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIHdpbGwgYmUgYXV0b21hdGljYWxseSBzY3JvbGxlZCB0byB0aGUgY2xvc2VzdCBpdGVtIGJvcmRlciB3aGVuIHJlbGVhc2VkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeS4gOeVqui/keOBhGNhcm91c2VsLWl0ZW3jga7looPnlYzjgb7jgafoh6rli5XnmoTjgavjgrnjgq/jg63jg7zjg6vjgZnjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhdXRvLXNjcm9sbC1yYXRpb1xuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICAgW2VuXUEgbnVtYmVyIGJldHdlZW4gMC4wIGFuZCAxLjAgdGhhdCBzcGVjaWZpZXMgaG93IG11Y2ggdGhlIHVzZXIgbXVzdCBkcmFnIHRoZSBjYXJvdXNlbCBpbiBvcmRlciBmb3IgaXQgdG8gYXV0byBzY3JvbGwgdG8gdGhlIG5leHQgaXRlbS5bL2VuXVxuICAgKiAgICBbamFdMC4w44GL44KJMS4w44G+44Gn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CC44Kr44Or44O844K744Or44Gu6KaB57Sg44KS44Gp44KM44GQ44KJ44GE44Gu5Ymy5ZCI44G+44Gn44OJ44Op44OD44Kw44GZ44KL44Go5qyh44Gu6KaB57Sg44Gr6Ieq5YuV55qE44Gr44K544Kv44Ot44O844Or44GZ44KL44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGNhbiBiZSBzY3JvbGxlZCBieSBkcmFnIG9yIHN3aXBlLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgeOCq+ODq+ODvOOCu+ODq+OCkuOCueODr+OCpOODl+OChOODieODqeODg+OCsOOBp+enu+WLleOBp+OBjeOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgWRyYWfjgoR0b3VjaOOChHN3aXBl44KS5Y+X44GR5LuY44GR44Gq44GP44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5pdGlhbC1pbmRleFxuICAgKiBAaW5pdG9ubHlcbiAgICogQGRlZmF1bHQgMFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaW5kZXggb2YgdGhlIG9ucy1jYXJvdXNlbC1pdGVtIHRvIHNob3cgaW5pdGlhbGx5LiBEZWZhdWx0IGlzIDAuWy9lbl1cbiAgICogICBbamFd5pyA5Yid44Gr6KGo56S644GZ44KLb25zLWNhcm91c2VsLWl0ZW3jgpIw5aeL44G+44KK44Gu44Kk44Oz44OH44OD44Kv44K544Gn5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI5YCk44GvIDAg44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0by1yZWZyZXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGVuIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgY2Fyb3VzZWwgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZnJlc2ggd2hlbiB0aGUgbnVtYmVyIG9mIGNoaWxkIG5vZGVzIGNoYW5nZS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHlrZDopoHntKDjga7mlbDjgYzlpInjgo/jgovjgajjgqvjg6vjg7zjgrvjg6vjga/oh6rli5XnmoTjgavmm7TmlrDjgZXjgozjgovjgojjgYbjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAguS+i++8mntkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5jaGlsZHJlblswXSAmJiB0aGlzLmNoaWxkcmVuWzBdLnRhZ05hbWUgIT09ICdPTlMtQ0FST1VTRUwtSVRFTScgJiYgdGhpcy5jaGlsZHJlblswXSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpZiAoIXRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0YXJnZXQpO1xuICAgIH1cblxuICAgICF0aGlzLmNoaWxkcmVuWzFdICYmIHRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZCA9IHRoaXMuYXBwZW5kQ2hpbGQuYmluZCh0YXJnZXQpO1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlID0gdGhpcy5pbnNlcnRCZWZvcmUuYmluZCh0YXJnZXQpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF0aGlzLl9zd2lwZXIpIHtcbiAgICAgIHRoaXMuX3N3aXBlciA9IG5ldyBTd2lwZXIoe1xuICAgICAgICBnZXRFbGVtZW50OiAoKSA9PiB0aGlzLFxuICAgICAgICBnZXRJbml0aWFsSW5kZXg6ICgpID0+IHRoaXMuZ2V0QXR0cmlidXRlKCdpbml0aWFsLWluZGV4JyksXG4gICAgICAgIGdldEF1dG9TY3JvbGxSYXRpbzogKCkgPT4gdGhpcy5hdXRvU2Nyb2xsUmF0aW8sXG4gICAgICAgIGlzVmVydGljYWw6ICgpID0+IHRoaXMudmVydGljYWwsXG4gICAgICAgIGlzT3ZlclNjcm9sbGFibGU6ICgpID0+IHRoaXMub3ZlcnNjcm9sbGFibGUsXG4gICAgICAgIGlzQ2VudGVyZWQ6ICgpID0+IHRoaXMuY2VudGVyZWQsXG4gICAgICAgIGlzQXV0b1Njcm9sbGFibGU6ICgpID0+IHRoaXMuYXV0b1Njcm9sbCxcbiAgICAgICAgaXRlbVNpemU6IHRoaXMuaXRlbVNpemUsXG4gICAgICAgIG92ZXJTY3JvbGxIb29rOiB0aGlzLl9vbk92ZXJTY3JvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgcHJlQ2hhbmdlSG9vazogdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzLCAncHJlY2hhbmdlJyksXG4gICAgICAgIHBvc3RDaGFuZ2VIb29rOiB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMsICdwb3N0Y2hhbmdlJyksXG4gICAgICAgIHJlZnJlc2hIb29rOiB0aGlzLl9vblJlZnJlc2guYmluZCh0aGlzKSxcbiAgICAgICAgc2Nyb2xsSG9vazogKC4uLmFyZ3MpID0+IHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZSguLi5hcmdzKVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9zd2lwZXIuaW5pdCh7XG4gICAgICAgIHN3aXBlYWJsZTogdGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpLFxuICAgICAgICBhdXRvUmVmcmVzaDogdGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tcmVmcmVzaCcpXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuX3N3aXBlciAmJiB0aGlzLl9zd2lwZXIuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuX3N3aXBlci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9zd2lwZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3N3aXBlYWJsZScsICdhdXRvLXJlZnJlc2gnLCAnZGlyZWN0aW9uJywgJ2l0ZW0taGVpZ2h0JywgJ2l0ZW0td2lkdGgnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgaWYgKCF0aGlzLl9zd2lwZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ3N3aXBlYWJsZSc6XG4gICAgICAgIHRoaXMuX3N3aXBlci51cGRhdGVTd2lwZWFibGUodGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdhdXRvLXJlZnJlc2gnOlxuICAgICAgICB0aGlzLl9zd2lwZXIudXBkYXRlQXV0b1JlZnJlc2godGhpcy5oYXNBdHRyaWJ1dGUoJ2F1dG8tcmVmcmVzaCcpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpdGVtLWhlaWdodCc6XG4gICAgICAgIHRoaXMudmVydGljYWwgJiYgdGhpcy5fc3dpcGVyLnVwZGF0ZUl0ZW1TaXplKHRoaXMuaXRlbVNpemUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2l0ZW0td2lkdGgnOlxuICAgICAgICB0aGlzLnZlcnRpY2FsIHx8IHRoaXMuX3N3aXBlci51cGRhdGVJdGVtU2l6ZSh0aGlzLml0ZW1TaXplKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkaXJlY3Rpb24nOlxuICAgICAgICB0aGlzLl9zd2lwZXIucmVmcmVzaCgpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHRoaXMuX3N3aXBlci5zaG93KCk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLl9zd2lwZXIuaGlkZSgpO1xuICB9XG5cbiAgX29uT3ZlclNjcm9sbCh7IGRpcmVjdGlvbiwga2lsbE92ZXJTY3JvbGwgfSkge1xuICAgIGxldCB3YWl0Rm9yQWN0aW9uID0gZmFsc2U7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdvdmVyc2Nyb2xsJywge1xuICAgICAgY2Fyb3VzZWw6IHRoaXMsXG4gICAgICBhY3RpdmVJbmRleDogdGhpcy5nZXRBY3RpdmVJbmRleCgpLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgd2FpdFRvUmV0dXJuOiBwcm9taXNlID0+IHtcbiAgICAgICAgd2FpdEZvckFjdGlvbiA9IHRydWU7XG4gICAgICAgIHByb21pc2UudGhlbihraWxsT3ZlclNjcm9sbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gd2FpdEZvckFjdGlvbjtcbiAgfVxuXG4gIF9vbkNoYW5nZShldmVudE5hbWUsIHsgYWN0aXZlSW5kZXgsIGxhc3RBY3RpdmVJbmRleCB9KSB7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIGV2ZW50TmFtZSwgeyBjYXJvdXNlbDogdGhpcywgYWN0aXZlSW5kZXgsIGxhc3RBY3RpdmVJbmRleCB9KTtcbiAgfVxuXG4gIF9vblJlZnJlc2goKSB7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdyZWZyZXNoJywgeyBjYXJvdXNlbDogdGhpcyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB0aGF0IHRoZSBjYXJvdXNlbCBzaG91bGQgYmUgc2V0IHRvLlsvZW5dXG4gICAqICAgW2phXWNhcm91c2Vs6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1BIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYFwibm9uZVwiYCB0aGUgdHJhbnNpdGlvbnMgd2lsbCBub3QgYmUgYW5pbWF0ZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXUFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgaW5kZXggb2YgdGhlIGA8b25zLWNhcm91c2VsLWl0ZW0+YCB0byBzaG93LlsvZW5dXG4gICAqICAgW2phXeihqOekuuOBmeOCi29ucy1jYXJvdXNlbC1pdGVt44KSaW5kZXjjgafmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0QWN0aXZlSW5kZXgoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBhbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSxcbiAgICAgIGFuaW1hdGlvbk9wdGlvbnM6IHRoaXMuaGFzQXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpXG4gICAgICAgID8gdXRpbC5hbmltYXRpb25PcHRpb25zUGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpXG4gICAgICAgIDogeyBkdXJhdGlvbjogLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguNCwgLjcsIC41LCAxKScgfSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5zZXRBY3RpdmVJbmRleChpbmRleCwgb3B0aW9ucylcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9wdGlvbnMuY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZUluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBjdXJyZW50IGNhcm91c2VsIGl0ZW0gaW5kZXguWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GX44Gm44GE44KL44Kr44Or44O844K744Or6KaB57Sg44Gu44Kk44Oz44OH44OD44Kv44K544GM6L+U44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBgPG9ucy1jYXJvdXNlbC1pdGVtPmAuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S644GV44KM44Gm44GE44KLb25zLWNhcm91c2VsLWl0ZW3opoHntKDjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5nZXRBY3RpdmVJbmRleCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmV4dFxuICAgKiBAc2lnbmF0dXJlIG5leHQoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IG5leHQgYDxvbnMtY2Fyb3VzZWwtaXRlbT5gLlsvZW5dXG4gICAqICAgW2phXeasoeOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIG5leHQob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldEFjdGl2ZUluZGV4KHRoaXMuZ2V0QWN0aXZlSW5kZXgoKSArIDEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcHJldlxuICAgKiBAc2lnbmF0dXJlIHByZXYoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0byBgXCJub25lXCJgIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IHByZXZpb3VzIGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3liY3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBwcmV2KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBY3RpdmVJbmRleCh0aGlzLmdldEFjdGl2ZUluZGV4KCkgLSAxLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGZpcnN0XG4gICAqIEBzaWduYXR1cmUgZmlyc3QoKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIGZpbmlzaGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgaXMgc2V0IHRvIGBcIm5vbmVcImAsIHRoZSB0cmFuc2l0aW9ucyB3aWxsIG5vdCBiZSBhbmltYXRlZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dQW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB0aGUgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcgZnVuY3Rpb24gb2YgdGhlIGFuaW1hdGlvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgY2Fyb3VzZWwgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IGZpcnN0IGA8b25zLWNhcm91c2VsLWl0ZW0+YC5bL2VuXVxuICAgKiAgIFtqYV3mnIDliJ3jga5vbnMtY2Fyb3VzZWwtaXRlbeOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBmaXJzdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlSW5kZXgoMCwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsYXN0XG4gICAqIEBzaWduYXR1cmUgbGFzdCgpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1BbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHRoZSBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZyBmdW5jdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBjYXJvdXNlbCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdUmVzb2x2ZXMgdG8gdGhlIGNhcm91c2VsIGVsZW1lbnRbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyBsYXN0IG9ucy1jYXJvdXNlbCBpdGVtLlsvZW5dXG4gICAqICAgW2phXeacgOW+jOOBrm9ucy1jYXJvdXNlbC1pdGVt44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGxhc3Qob3B0aW9ucykge1xuICAgIHRoaXMuc2V0QWN0aXZlSW5kZXgoTWF0aC5tYXgodGhpcy5pdGVtQ291bnQgLSAxLCAwKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1VcGRhdGUgdGhlIGxheW91dCBvZiB0aGUgY2Fyb3VzZWwuIFVzZWQgd2hlbiBhZGRpbmcgYDxvbnMtY2Fyb3VzZWwtaXRlbXM+YCBkeW5hbWljYWxseSBvciB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB0aGUgc2l6ZS5bL2VuXVxuICAgKiAgIFtqYV3jg6zjgqTjgqLjgqbjg4jjgoTlhoXpg6jjga7nirbmhYvjgpLmnIDmlrDjga7jgoLjga7jgavmm7TmlrDjgZfjgb7jgZnjgIJvbnMtY2Fyb3VzZWwtaXRlbeOCkuWLleeahOOBq+Wil+OChOOBl+OBn+OCiuOAgW9ucy1jYXJvdXNlbOOBruWkp+OBjeOBleOCkuWLleeahOOBq+WkieOBiOOCi+mam+OBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZWZyZXNoKCkge1xuICAgIHRoaXMuX3N3aXBlci5yZWZyZXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGl0ZW1Db3VudFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBudW1iZXIgb2YgY2Fyb3VzZWwgaXRlbXMuWy9lbl1cbiAgICogICBbamFd44Kr44Or44O844K744Or6KaB57Sg44Gu5pWw44Gn44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBpdGVtQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N3aXBlci5pdGVtQ291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgdGhlIGNhcm91c2VsIGlzIHN3aXBlYWJsZS5bL2VuXVxuICAgKiAgIFtqYV1zd2lwZWFibGXjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBzd2lwZWFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKTtcbiAgfVxuXG4gIHNldCBzd2lwZWFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N3aXBlYWJsZScsIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25Td2lwZVxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib29rIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBzbGlkZXMgdGhlIGNhcm91c2VsLiBJdCBnZXRzIGEgZGVjaW1hbCBpbmRleCBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25Td2lwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25Td2lwZTtcbiAgfVxuXG4gIHNldCBvblN3aXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHV0aWwudGhyb3coYFwib25Td2lwZVwiIG11c3QgYmUgYSBmdW5jdGlvbmApXG4gICAgfVxuICAgIHRoaXMuX29uU3dpcGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgYXV0b1Njcm9sbFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXXRydWUgaWYgYXV0byBzY3JvbGwgaXMgZW5hYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg7zjg4jjgrnjgq/jg63jg7zjg6vjgYzmnInlirnjgafjgYLjgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBhdXRvU2Nyb2xsKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnYXV0by1zY3JvbGwnKTtcbiAgfVxuXG4gIHNldCBhdXRvU2Nyb2xsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdhdXRvLXNjcm9sbCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCB2ZXJ0aWNhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnO1xuICB9XG5cbiAgZ2V0IGl0ZW1TaXplKCkge1xuICAgIGNvbnN0IGl0ZW1TaXplQXR0ciA9ICh0aGlzLmdldEF0dHJpYnV0ZShgaXRlbS0ke3RoaXMudmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCd9YCkgfHwgJycpLnRyaW0oKTtcbiAgICByZXR1cm4gaXRlbVNpemVBdHRyLm1hdGNoKC9eXFxkKyhweHwlKSQvKSA/IGl0ZW1TaXplQXR0ciA6ICcxMDAlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgYXV0b1Njcm9sbFJhdGlvXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCBhdXRvIHNjcm9sbCByYXRpby4gWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Kq44O844OI44K544Kv44Ot44O844Or44GucmF0aW/lgKTjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGF1dG9TY3JvbGxSYXRpbygpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmdldEF0dHJpYnV0ZSgnYXV0by1zY3JvbGwtcmF0aW8nKSk7XG4gIH1cblxuICBzZXQgYXV0b1Njcm9sbFJhdGlvKHJhdGlvKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2F1dG8tc2Nyb2xsLXJhdGlvJywgcmF0aW8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG92ZXJzY3JvbGxhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2Fyb3VzZWwgaXMgb3ZlcnNjcm9sbGFibGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXW92ZXJzY3JvbGzjgafjgY3jgozjgbB0cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBvdmVyc2Nyb2xsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ292ZXJzY3JvbGxhYmxlJyk7XG4gIH1cblxuICBzZXQgb3ZlcnNjcm9sbGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ292ZXJzY3JvbGxhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBjZW50ZXJlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGNlbnRlcmVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1jZW50ZXJlZOeKtuaFi+OBq+OBquOBo+OBpuOBhOOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IGNlbnRlcmVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnY2VudGVyZWQnKTtcbiAgfVxuXG4gIHNldCBjZW50ZXJlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnY2VudGVyZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwb3N0Y2hhbmdlJywgJ3JlZnJlc2gnLCAnb3ZlcnNjcm9sbCddO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkNhcm91c2VsID0gQ2Fyb3VzZWxFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY2Fyb3VzZWwnLCBDYXJvdXNlbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgc3R5bGVyIGZyb20gJy4uL29ucy9zdHlsZXInO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1jb2xcbiAqIEBjYXRlZ29yeSBncmlkXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSBjb2x1bW4gaW4gdGhlIGdyaWQgc3lzdGVtLiBVc2Ugd2l0aCBgPG9ucy1yb3c+YCB0byBsYXlvdXQgY29tcG9uZW50cy5bL2VuXVxuICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm5YiX44KS5a6a576p44GX44G+44GZ44CCb25zLXJvd+OBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBruODrOOCpOOCouOCpuODiOOBq+WIqeeUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAbm90ZVxuICogICBbZW5dRm9yIEFuZHJvaWQgNC4zIGFuZCBlYXJsaWVyLCBhbmQgaU9TNiBhbmQgZWFybGllciwgd2hlbiB1c2luZyBtaXhlZCBhbGlnbm1lbnQgd2l0aCBvbnMtcm93IGFuZCBvbnMtY29sdW1uLCB0aGV5IG1heSBub3QgYmUgZGlzcGxheWVkIGNvcnJlY3RseS4gWW91IGNhbiB1c2Ugb25seSBvbmUgYWxpZ25tZW50LlsvZW5dXG4gKiAgIFtqYV1BbmRyb2lkIDQuM+S7peWJjeOAgeOCguOBl+OBj+OBr2lPUyA25Lul5YmN44GuT1Pjga7loLTlkIjjgIFvbnMtcm9344Gob25zLWNvbHVtbuOCkue1hOOBv+WQiOOCj+OBm+OBn+WgtOWQiOOBq+aPj+eUu+OBjOW0qeOCjOOCi+WgtOWQiOOBjOOBguOCiuOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBHZ3VqQyB7d2lkZX1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwgW2VuXUxheW91dGluZyBndWlkZVsvZW5dW2phXeODrOOCpOOCouOCpuODiOapn+iDvVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcm93XG4gKiAgIFtlbl1UaGUgYDxvbnMtcm93PmAgY29tcG9uZW50IGlzIHRoZSBwYXJlbnQgb2YgYDxvbnMtY29sPmAuWy9lbl1cbiAqICAgW2phXW9ucy1yb3fjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcm93PlxuICogICA8b25zLWNvbCB3aWR0aD1cIjUwcHhcIj48b25zLWljb24gaWNvbj1cImZhLXR3aXR0ZXJcIj48L29ucy1pY29uPjwvb25zLWNvbD5cbiAqICAgPG9ucy1jb2w+VGV4dDwvb25zLWNvbD5cbiAqIDwvb25zLXJvdz5cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgdmVydGljYWwtYWxpZ25cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVZlcnRpY2FsIGFsaWdubWVudCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIFwidG9wXCIsIFwiY2VudGVyXCIsIGFuZCBcImJvdHRvbVwiLlsvZW5dXG4gKiAgIFtqYV3nuKbjga7phY3nva7jgpLmjIflrprjgZnjgovjgIJcInRvcFwiLCBcImNlbnRlclwiLCBcImJvdHRvbVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAqL1xuXG4vKipcbiAqIEBhdHRyaWJ1dGUgd2lkdGhcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVRoZSB3aWR0aCBvZiB0aGUgY29sdW1uLiBWYWxpZCB2YWx1ZXMgYXJlIGNzcyB3aWR0aCB2YWx1ZXMgKFwiMTAlXCIsIFwiNTBweFwiKS5bL2VuXVxuICogICBbamFd44Kr44Op44Og44Gu5qiq5bmF44KS5oyH5a6a44GZ44KL44CC44OR44O844K744Oz44OI44KC44GX44GP44Gv44OU44Kv44K744Or44Gn5oyH5a6a44GX44G+44GZ77yIMTAl44KENTBweO+8ieOAglsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWyd3aWR0aCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ3dpZHRoJykge1xuICAgICAgdGhpcy5fdXBkYXRlV2lkdGgoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlV2lkdGgoKSB7XG4gICAgbGV0IHdpZHRoID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgaWYgKCF3aWR0aCkge1xuICAgICAgc3R5bGVyLmNsZWFyKHRoaXMsICdmbGV4IG1heFdpZHRoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gd2lkdGgudHJpbSgpLm1hdGNoKC9eXFxkKyQvKSA/IHdpZHRoICsgJyUnIDogd2lkdGg7XG5cbiAgICAgIHN0eWxlcih0aGlzLCB7XG4gICAgICAgIGZsZXg6ICcwIDAgJyArIHdpZHRoLFxuICAgICAgICBtYXhXaWR0aDogd2lkdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5vbnNFbGVtZW50cy5Db2wgPSBDb2xFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtY29sJywgQ29sRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcidcblxuZXhwb3J0IGNsYXNzIERpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgQmFzZUFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIHNob3coZGlhbG9nLCBkb25lKSB7XG4gICAgZG9uZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBoaWRlKGRpYWxvZywgZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEFuZHJvaWQgc3R5bGUgYW5pbWF0b3IgZm9yIGRpYWxvZy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFuZHJvaWREaWFsb2dBbmltYXRvciBleHRlbmRzIERpYWxvZ0FuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2Vhc2UtaW4tb3V0JywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuM30gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3coZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNjAlLCAwKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJywgb3BhY2l0eTogMSB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJywgb3BhY2l0eTogMSB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTUwJSwgLTYwJSwgMCknLCBvcGFjaXR5OiAwIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgY2xhc3MgSU9TRGlhbG9nQW5pbWF0b3IgZXh0ZW5kcyBEaWFsb2dBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdlYXNlLWluLW91dCcsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMuYm9keUhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKC01MCUsICR7dGhpcy5ib2R5SGVpZ2h0IC8gMi4wIC0gMX1weCwgMClgIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkaWFsb2dcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUoZGlhbG9nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9tYXNrLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAxIH0sIHsgb3BhY2l0eTogMCB9KSxcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fZGlhbG9nLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKC01MCUsICR7dGhpcy5ib2R5SGVpZ2h0IC8gMi4wIC0gMX1weCwgMClgIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFNsaWRlIGFuaW1hdG9yIGZvciBkaWFsb2cuXG4gKi9cbmV4cG9ydCBjbGFzcyBTbGlkZURpYWxvZ0FuaW1hdG9yIGV4dGVuZHMgRGlhbG9nQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjQsIDEpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuXG4gICAgdGhpcy5ib2R5SGVpZ2h0ID0gZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7IC8vIGF2b2lkIEZvcmNlZCBTeW5jaHJvbm91cyBMYXlvdXRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGlhbG9nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KGRpYWxvZywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID8gY2FsbGJhY2sgOiBmdW5jdGlvbigpIHt9O1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGRpYWxvZy5fbWFzaywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSksXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX2RpYWxvZywgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGRpYWxvZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZShkaWFsb2csIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChkaWFsb2cuX21hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDEgfSwgeyBvcGFjaXR5OiAwIH0pLFxuXG4gICAgICBhbmltaXQoZGlhbG9nLl9kaWFsb2csIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKC01MCUsIC01MCUsIDApJyB9LFxuICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHNob3VsZCBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0LiBPdGhlcndpc2UsIGZhZGUgYW5pbWF0aW9uIG9mIG1hc2sgd2lsbCBiZSBicm9rZW4uXG4gICAgICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtNTAlLCAkey0gKHRoaXMuYm9keUhlaWdodCAvIDIuMCkgKyAxIC0gZGlhbG9nLl9kaWFsb2cuY2xpZW50SGVpZ2h0fXB4LCAwKWAgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IHsgRGlhbG9nQW5pbWF0b3IsIElPU0RpYWxvZ0FuaW1hdG9yLCBBbmRyb2lkRGlhbG9nQW5pbWF0b3IsIFNsaWRlRGlhbG9nQW5pbWF0b3IgfSBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5kaWFsb2cnOiAnZGlhbG9nLS0qJyxcbiAgJy5kaWFsb2ctY29udGFpbmVyJzogJ2RpYWxvZy1jb250YWluZXItLSonLFxuICAnLmRpYWxvZy1tYXNrJzogJ2RpYWxvZy1tYXNrLS0qJ1xufTtcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IEFuZHJvaWREaWFsb2dBbmltYXRvciA6IElPU0RpYWxvZ0FuaW1hdG9yLFxuICAnc2xpZGUnOiBTbGlkZURpYWxvZ0FuaW1hdG9yLFxuICAnbm9uZSc6IERpYWxvZ0FuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1kaWFsb2dcbiAqIEBjYXRlZ29yeSBkaWFsb2dcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgRGlhbG9nIHRoYXQgaXMgZGlzcGxheWVkIG9uIHRvcCBvZiBjdXJyZW50IHNjcmVlbi4gQXMgb3Bwb3NlZCB0byB0aGUgYDxvbnMtYWxlcnQtZGlhbG9nPmAgZWxlbWVudCwgdGhpcyBjb21wb25lbnQgY2FuIGNvbnRhaW4gYW55IGtpbmQgb2YgY29udGVudC5cbiAqXG4gKiAgICAgVG8gdXNlIHRoZSBlbGVtZW50IGl0IGNhbiBlaXRoZXIgYmUgYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIGA8Ym9keT5gIGVsZW1lbnQgb3IgZHluYW1pY2FsbHkgY3JlYXRlZCBmcm9tIGEgdGVtcGxhdGUgdXNpbmcgdGhlIGBvbnMuY3JlYXRlRGlhbG9nKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8dGVtcGxhdGU+YCB0YWcuXG4gKlxuICogICAgIFRoZSBkaWFsb2cgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIG1lbnVzLCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIHRvIGFzayB0aGUgdXNlciB0byBtYWtlIGEgZGVjaXNpb24uXG4gKlxuICogICAgIEl0IHdpbGwgYXV0b21hdGljYWxseSBiZSBkaXNwbGF5ZWQgYXMgTWF0ZXJpYWwgRGVzaWduIHdoZW4gcnVubmluZyBvbiBhbiBBbmRyb2lkIGRldmljZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jg4DjgqTjgqLjg63jgrDjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGNvZGVwZW4genh4YUdhXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvZGlhbG9nXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1hbGVydC1kaWFsb2dcbiAqICAgW2VuXWA8b25zLWFsZXJ0LWRpYWxvZz5gIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtYWxlcnQtZGlhbG9n44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1wb3BvdmVyXG4gKiAgIFtlbl1gPG9ucy1wb3BvdmVyPmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1wb3BvdmVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1tb2RhbFxuICogICBbZW5dYDxvbnMtbW9kYWw+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLW1vZGFs44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWRpYWxvZyBpZD1cImRpYWxvZ1wiPlxuICogICA8cD5UaGlzIGlzIGEgZGlhbG9nITwvcD5cbiAqIDwvb25zLWRpYWxvZz5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGlhbG9nJykuc2hvdygpO1xuICogPC9zY3JpcHQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpYWxvZ0VsZW1lbnQgZXh0ZW5kcyBCYXNlRGlhbG9nRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBkaWFsb2cgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGlhbG9nXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBiZWZvcmUgdGhlIGRpYWxvZyBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODgOOCpOOCouODreOCsOOBjOmaoOOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5kaWFsb2dcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIGRpYWxvZyBmcm9tIGJlaW5nIGhpZGRlbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7pnZ7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgZGlhbG9nIGlzIGhpZGRlbi5bL2VuXVxuICAgKiBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmRpYWxvZ1xuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjga7ooajnj77jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBjYW5jZWxhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgZGlhbG9nIGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQuWy9lbl1cbiAgICogIFtqYV3jgZPjga7lsZ7mgKfjgYzjgYLjgovmmYLjgIHjg4DjgqTjgqLjg63jgrDjga9kaXNhYmxlZOeKtuaFi+OBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZGlhbG9nLiBDYW4gYmUgZWl0aGVyIGBcIm5vbmVcImAgb3IgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgW2phXeODgOOCpOOCouODreOCsOOCkuihqOekuuOBmeOCi+mam+OBruOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwi44KC44GX44GP44GvXCJkZWZhdWx0XCLjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtYXNrLWNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZWZhdWx0IHJnYmEoMCwgMCwgMCwgMC4yKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxuICAgKiAgW2phXeiDjOaZr+OBruODnuOCueOCr+OBruiJsuOCkuaMh+WumuOBl+OBvuOBmeOAglwicmdiYSgwLCAwLCAwLCAwLjIpXCLjgYzjg4fjg5Xjgqnjg6vjg4jlgKTjgafjgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9tYXNrKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmRpYWxvZy1tYXNrJyk7XG4gIH1cblxuICBnZXQgX2RpYWxvZygpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5kaWFsb2cnKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBEaWFsb2dBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdEaWFsb2dBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDE7XG5cbiAgICAvKiBFeHBlY3RlZCByZXN1bHQ6XG4gICAgICogICA8b25zLWRpYWxvZz5cbiAgICAgKiAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1tYXNrXCI+PC9kaXY+XG4gICAgICogICAgIDxkaXYgY2xhc3M9XCJkaWFsb2dcIj5cbiAgICAgKiAgICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLWNvbnRhaW5lclwiPi4uLjwvZGl2PlxuICAgICAqICAgICA8L2Rpdj5cbiAgICAgKiAgIDwvb25zLWRpYWxvZz5cbiAgICAgKi9cblxuICAgIGlmICghdGhpcy5fZGlhbG9nKSB7XG4gICAgICBjb25zdCBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRpYWxvZy5jbGFzc0xpc3QuYWRkKCdkaWFsb2cnKTtcblxuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnZGlhbG9nLWNvbnRhaW5lcicpO1xuICAgICAgd2hpbGUgKHRoaXMuZmlyc3RDaGlsZCkge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIGRpYWxvZy5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGRpYWxvZyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXNrKSB7XG4gICAgICBjb25zdCBtYXNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ2RpYWxvZy1tYXNrJyk7XG4gICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIHRoaXMuX2RpYWxvZy5zdHlsZS56SW5kZXggPSAyMDAwMTtcbiAgICB0aGlzLl9tYXNrLnN0eWxlLnpJbmRleCA9IDIwMDAwO1xuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcsICcnKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YCBbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TaG93IHRoZSBkaWFsb2cuWy9lbl1cbiAgICogIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwic2xpZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwic2xpZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGRpYWxvZyBoYXMgYmVlbiBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44OA44Kk44Ki44Ot44Kw44GM6Zqg44KM44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdGhlIGRpYWxvZy5bL2VuXVxuICAgKiAgIFtqYV3jg4DjgqTjgqLjg63jgrDjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZGlhbG9nIGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBkaWFsb2cgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2FuY2VsYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGRpYWxvZyBpcyBjYW5jZWxhYmxlIG9yIG5vdC4gQSBjYW5jZWxhYmxlIGRpYWxvZyBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uIG9uIEFuZHJvaWQgZGV2aWNlcy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtEaWFsb2dBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgRGlhbG9nQW5pbWF0b3IpKSB7XG4gICAgICB1dGlsLnRocm93QW5pbWF0b3IoJ0RpYWxvZycpO1xuICAgIH1cbiAgICBfYW5pbWF0b3JEaWN0W25hbWVdID0gQW5pbWF0b3I7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGFuaW1hdG9ycygpIHtcbiAgICByZXR1cm4gX2FuaW1hdG9yRGljdDtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGlhbG9nQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIERpYWxvZ0FuaW1hdG9yO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkRpYWxvZyA9IERpYWxvZ0VsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1kaWFsb2cnLCBEaWFsb2dFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi4vb25zL3N0eWxlcic7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdmYWInO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAnZmFiLS0qJyxcbiAgJy5mYWJfX2ljb24nOiAnZmFiLS0qX19pY29uJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtZmFiXG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGUgRmxvYXRpbmcgYWN0aW9uIGJ1dHRvbiBpcyBhIGNpcmN1bGFyIGJ1dHRvbiBkZWZpbmVkIGluIHRoZSBbTWF0ZXJpYWwgRGVzaWduIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vZGVzaWduL3NwZWMvY29tcG9uZW50cy9idXR0b25zLWZsb2F0aW5nLWFjdGlvbi1idXR0b24uaHRtbCkuIFRoZXkgYXJlIG9mdGVuIHVzZWQgdG8gcHJvbW90ZSB0aGUgcHJpbWFyeSBhY3Rpb24gb2YgdGhlIGFwcC5cbiAqXG4gKiAgICAgSXQgY2FuIGJlIGRpc3BsYXllZCBlaXRoZXIgYXMgYW4gaW5saW5lIGVsZW1lbnQgb3IgaW4gb25lIG9mIHRoZSBjb3JuZXJzLiBOb3JtYWxseSBpdCB3aWxsIGJlIHBvc2l0aW9uZWQgaW4gdGhlIGxvd2VyIHJpZ2h0IGNvcm5lciBvZiB0aGUgc2NyZWVuLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9mYWJcbiAqIEBtb2RpZmllciBtaW5pXG4gKiAgIFtlbl1NYWtlcyB0aGUgYG9ucy1mYWJgIHNtYWxsZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbD5gIGNvbXBvbmVudCBpcyBhIEZsb2F0aW5nIGFjdGlvbiBidXR0b24gdGhhdCBkaXNwbGF5cyBhIG1lbnUgd2hlbiB0YXBwZWQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhYkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXeODnOOCv+ODs+OBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHJpcHBsZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBkZWZpbmVkLCB0aGUgYnV0dG9uIHdpbGwgaGF2ZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiB0YXBwZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgcG9zaXRpb24gb2YgdGhlIGJ1dHRvbi4gU2hvdWxkIGJlIGEgc3RyaW5nIGxpa2UgYFwiYm90dG9tIHJpZ2h0XCJgIG9yIGBcInRvcCBsZWZ0XCJgLiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyBub3QgZGVmaW5lZCBpdCB3aWxsIGJlIGRpc3BsYXllZCBhcyBhbiBpbmxpbmUgZWxlbWVudC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gv5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgc3RhdGVtZW50cyBjYW4gYmUgZXhlY3V0ZWQgYmVmb3JlIGNvbnRlbnRSZWFkeVxuICAgIC8vIHNpbmNlIHRoZXNlIGRvIG5vdCBhY2Nlc3MgdGhlIGNoaWxkcmVuXG4gICAgdGhpcy5oaWRlKCk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLmZhYl9faWNvbicpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdmYWJfX2ljb24nKTtcblxuICAgICAgdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZE5vZGVzKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAoIWVsZW1lbnQudGFnTmFtZSB8fCBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1yaXBwbGUnKSB7XG4gICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLnNob3coKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdyaXBwbGUnLCAncG9zaXRpb24nLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIGRlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwb3NpdGlvbic6XG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHRoaXMuc2hvdygpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuaGlkZSgpKTtcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgdXRpbC51cGRhdGVSaXBwbGUodGhpcyk7XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmdldEF0dHJpYnV0ZSgncG9zaXRpb24nKTtcbiAgICB0aGlzLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAnZmFiLS10b3BfX2xlZnQnLFxuICAgICAgJ2ZhYi0tYm90dG9tX19yaWdodCcsXG4gICAgICAnZmFiLS1ib3R0b21fX2xlZnQnLFxuICAgICAgJ2ZhYi0tdG9wX19yaWdodCcsXG4gICAgICAnZmFiLS10b3BfX2NlbnRlcicsXG4gICAgICAnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgIGNhc2UgJ3RvcCByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCB0b3AnOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcCBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSByaWdodCc6XG4gICAgICBjYXNlICdyaWdodCBib3R0b20nOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19yaWdodCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSBsZWZ0JzpcbiAgICAgIGNhc2UgJ2xlZnQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fbGVmdCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciB0b3AnOlxuICAgICAgY2FzZSAndG9wIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NlbnRlciBib3R0b20nOlxuICAgICAgY2FzZSAnYm90dG9tIGNlbnRlcic6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2NlbnRlcicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU2hvdyB0aGUgZmxvYXRpbmcgYWN0aW9uIGJ1dHRvbi5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuICBzaG93KCkge1xuICAgIHRoaXMudG9nZ2xlKHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaGlkZVxuICAgKiBAc2lnbmF0dXJlIGhpZGUoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1IaWRlIHRoZSBmbG9hdGluZyBhY3Rpb24gYnV0dG9uLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG4gIGhpZGUoKSB7XG4gICAgdGhpcy50b2dnbGUoZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdG9nZ2xlXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlKClcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICB0b2dnbGUoYWN0aW9uID0gIXRoaXMudmlzaWJsZSkge1xuICAgIGNvbnN0IGlzQm90dG9tID0gKHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpIHx8ICcnKS5pbmRleE9mKCdib3R0b20nKSA+PSAwO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGlzQm90dG9tID8gYHRyYW5zbGF0ZTNkKDBweCwgLSR7dXRpbC5nbG9iYWxzLmZhYk9mZnNldCB8fCAwfXB4LCAwcHgpYCA6ICcnO1xuXG4gICAgc3R5bGVyKHRoaXMsIHsgdHJhbnNmb3JtOiBgJHt0cmFuc2xhdGV9IHNjYWxlKCR7TnVtYmVyKGFjdGlvbil9KWAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnN0eWxlLnRyYW5zZm9ybS5pbmRleE9mKCdzY2FsZSgwKScpID09PSAtMSAmJiB0aGlzLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5GYWIgPSBGYWJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtZmFiJywgRmFiRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBHZXN0dXJlRGV0ZWN0b3IgZnJvbSAnLi4vb25zL2dlc3R1cmUtZGV0ZWN0b3InO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1nZXN0dXJlLWRldGVjdG9yXG4gKiBAY2F0ZWdvcnkgZ2VzdHVyZVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBDb21wb25lbnQgdG8gZGV0ZWN0IGZpbmdlciBnZXN0dXJlcyB3aXRoaW4gdGhlIHdyYXBwZWQgZWxlbWVudC4gRm9sbG93aW5nIGdlc3R1cmVzIGFyZSBzdXBwb3J0ZWQ6XG4gKiAgICAgLSBEcmFnIGdlc3R1cmVzOiBgZHJhZ2AsIGBkcmFnbGVmdGAsIGBkcmFncmlnaHRgLCBgZHJhZ3VwYCwgYGRyYWdkb3duYFxuICogICAgIC0gSG9sZCBnZXN0dXJlczogYGhvbGRgLCBgcmVsZWFzZWBcbiAqICAgICAtIFN3aXBlIGdlc3R1cmVzOiBgc3dpcGVgLCBgc3dpcGVsZWZ0YCwgYHN3aXBlcmlnaHRgLCBgc3dpcGV1cGAsIGBzd2lwZWRvd25gXG4gKiAgICAgLSBUYXAgZ2VzdHVyZXM6IGB0YXBgLCBgZG91YmxldGFwYFxuICogICAgIC0gUGluY2ggZ2VzdHVyZXM6IGBwaW5jaGAsIGBwaW5jaGluYCwgYHBpbmNob3V0YFxuICogICAgIC0gT3RoZXIgZ2VzdHVyZXM6IGB0b3VjaGAsIGB0cmFuc2Zvcm1gLCBgcm90YXRlYFxuICogICBbL2VuXVxuICogICBbamFd6KaB57Sg5YaF44Gu44K444Kn44K544OB44Oj44O85pON5L2c44KS5qSc55+l44GX44G+44GZ44CC6Kmz44GX44GP44Gv44Ks44Kk44OJ44KS5Y+C54Wn44GX44Gm44GP44Gg44GV44GE44CCWy9qYV1cbiAqIEBndWlkZSBmZWF0dXJlcy5odG1sI2dlc3R1cmUtZGV0ZWN0aW9uXG4gKiAgIFtlbl1EZXRlY3RpbmcgZmluZ2VyIGdlc3R1cmVzWy9lbl1cbiAqICAgW2phXeOCuOOCp+OCueODgeODo+ODvOaTjeS9nOOBruaknOefpVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1nZXN0dXJlLWRldGVjdG9yPlxuICogICA8ZGl2IGlkPVwiZGV0ZWN0LWFyZWFcIiBzdHlsZT1cIndpZHRoOiAxMDBweDsgaGVpZ2h0OiAxMDBweDtcIj5cbiAqICAgICBTd2lwZSBIZXJlXG4gKiAgIDwvZGl2PlxuICogPC9vbnMtZ2VzdHVyZS1kZXRlY3Rvcj5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzd2lwZWxlZnQnLCBmdW5jdGlvbihldmVudCkge1xuICogICAgIGlmIChldmVudC50YXJnZXQubWF0Y2hlcygnI2RldGVjdC1hcmVhJykpIHtcbiAqICAgICAgIGNvbnNvbGUubG9nKCdTd2lwZSBsZWZ0IGlzIGRldGVjdGVkLicpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR2VzdHVyZURldGVjdG9yRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkdlc3R1cmVEZXRlY3RvciA9IEdlc3R1cmVEZXRlY3RvckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1nZXN0dXJlLWRldGVjdG9yJywgR2VzdHVyZURldGVjdG9yRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5cbmxldCBhdXRvUHJlZml4ID0gJ2ZhJzsgLy8gRklYTUU6IFRvIGJlIHJlbW92ZWQgaW4gdjNcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtaWNvblxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBEaXNwbGF5cyBhbiBpY29uLiBUaGUgZm9sbG93aW5nIGljb24gc3VpdGVzIGFyZSBhdmFpbGFibGU6XG4gKlxuICogICAgICogW0ZvbnQgQXdlc29tZV0oaHR0cHM6Ly9mb3J0YXdlc29tZS5naXRodWIuaW8vRm9udC1Bd2Vzb21lLylcbiAqICAgICAqIFtJb25pY29uc10oaHR0cDovL2lvbmljb25zLmNvbS8pXG4gKiAgICAgKiBbTWF0ZXJpYWwgRGVzaWduIEljb25pYyBGb250XShodHRwOi8vemF2b2xva2xvbS5naXRodWIuaW8vbWF0ZXJpYWwtZGVzaWduLWljb25pYy1mb250LylcbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiB4QWh2Z1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2ljb25cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjY3Jvc3MtcGxhdGZvcm0tc3R5bGluZy1hdXRvc3R5bGluZyBbZW5dSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svZW5dW2phXVsvamFdXG4gKiBAZ3VpZGUgYXBwc2l6ZS5odG1sI3JlbW92aW5nLWljb24tcGFja3MgW2VuXVJlbW92aW5nIGljb24gcGFja3MuWy9lbl1bamFdWy9qYV1cbiAqIEBndWlkZSBmYXEuaHRtbCNob3ctY2FuLWktdXNlLWN1c3RvbS1pY29uLXBhY2tzIFtlbl1BZGRpbmcgY3VzdG9tIGljb24gcGFja3MuWy9lbl1bamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWljb25cbiAqICAgaWNvbj1cIm1kLWNhclwiXG4gKiAgIHNpemU9XCIyMHB4XCJcbiAqICAgc3R5bGU9XCJjb2xvcjogcmVkXCI+XG4gKiA8L29ucy1pY29uPlxuICpcbiAqIDxvbnMtYnV0dG9uPlxuICogICA8b25zLWljb24gaWNvbj1cIm1kLWNhclwiPjwvb25zLWljb24+XG4gKiAgIENhclxuICogPC9vbnMtYnV0dG9uPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJY29uRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpY29uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSBpY29uIG5hbWUuIGBcIm1kLVwiYCBwcmVmaXggZm9yIE1hdGVyaWFsIEljb25zLCBgXCJmYS1cImAgZm9yIEZvbnQgQXdlc29tZSBhbmQgYFwiaW9uLVwiYCBwcmVmaXggZm9yIElvbmljb25zLlxuICAgKlxuICAgKiAgICAgU2VlIGFsbCBhdmFpbGFibGUgaWNvbnMgb24gdGhlIGVsZW1lbnQgZGVzY3JpcHRpb24gKGF0IHRoZSB0b3ApLlxuICAgKlxuICAgKiAgICAgSWNvbnMgY2FuIGFsc28gYmUgc3R5bGVkIGJhc2VkIG9uIG1vZGlmaWVyIHByZXNlbmNlLiBBZGQgY29tbWEtc2VwYXJhdGVkIGljb25zIHdpdGggYFwibW9kaWZpZXJOYW1lOlwiYCBwcmVmaXguXG4gICAqXG4gICAqICAgICBUaGUgY29kZSBgPG9ucy1pY29uIGljb249XCJpb24tZWRpdCwgbWF0ZXJpYWw6bWQtZWRpdFwiPjwvb25zLWljb24+YCB3aWxsIGRpc3BsYXkgYFwibWQtZWRpdFwiYCBmb3IgTWF0ZXJpYWwgRGVzaWduIGFuZCBgXCJpb24tZWRpdFwiYCBhcyB0aGUgZGVmYXVsdCBpY29uLlxuICAgKlxuICAgKiAgICAgYGZhLWAgcHJlZml4IGlzIGFkZGVkIGF1dG9tYXRpY2FsbHkgaWYgbm9uZSBpcyBwcm92aWRlZC4gQ2hlY2sgW1NlZSBhbHNvXSgjc2VlYWxzbykgc2VjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaXplXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoZSBzaXplcyBvZiB0aGUgaWNvbi4gVmFsaWQgdmFsdWVzIGFyZSBsZywgMngsIDN4LCA0eCwgNXgsIG9yIGluIHRoZSBzaXplIGluIHBpeGVscy5cbiAgICogICAgIEljb25zIGNhbiBhbHNvIGJlIHN0eWxlZCBiYXNlZCBvbiBtb2RpZmllciBwcmVzZW5jZS4gQWRkIGNvbW1hLXNlcGFyYXRlZCBpY29ucyB3aXRoIGBcIm1vZGlmaWVyTmFtZTpcImAgcHJlZml4LlxuICAgKlxuICAgKiAgICAgVGhlIGNvZGU6XG4gICAqXG4gICAqICAgICBgYGBcbiAgICogICAgIDxvbnMtaWNvblxuICAgKiAgICAgICBpY29uPVwiaW9uLWVkaXRcIlxuICAgKiAgICAgICBzaXplPVwiMzJweCwgbWF0ZXJpYWw6MjRweFwiPlxuICAgKiAgICAgPC9vbnMtaWNvbj5cbiAgICogICAgIGBgYFxuICAgKlxuICAgKiAgICAgd2lsbCByZW5kZXIgYXMgYSBgMjRweGAgaWNvbiBpZiB0aGUgYFwibWF0ZXJpYWxcImAgbW9kaWZpZXIgaXMgcHJlc2VudCBhbmQgYDMycHhgIG90aGVyd2lzZS5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSByb3RhdGVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU51bWJlciBvZiBkZWdyZWVzIHRvIHJvdGF0ZSB0aGUgaWNvbi4gVmFsaWQgdmFsdWVzIGFyZSA5MCwgMTgwIGFuZCAyNzAuWy9lbl1cbiAgICogICBbamFd44Ki44Kk44Kz44Oz44KS5Zue6Lui44GX44Gm6KGo56S644GX44G+44GZ44CCOTAsIDE4MCwgMjcw44GL44KJ5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZml4ZWQtd2lkdGhcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVdoZW4gdXNlZCBpbiBhIGxpc3QsIHlvdSB3YW50IHRoZSBpY29ucyB0byBoYXZlIHRoZSBzYW1lIHdpZHRoIHNvIHRoYXQgdGhleSBhbGlnbiB2ZXJ0aWNhbGx5IGJ5IGRlZmluaW5nIHRoaXMgYXR0cmlidXRlLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3BpblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB3aGV0aGVyIHRoZSBpY29uIHNob3VsZCBiZSBzcGlubmluZy5bL2VuXVxuICAgKiAgIFtqYV3jgqLjgqTjgrPjg7PjgpLlm57ou6LjgZnjgovjgYvjganjgYbjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fY29tcGlsZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnaWNvbicsICdzaXplJywgJ21vZGlmaWVyJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHRoaXMuX2NsZWFuQ2xhc3NBdHRyaWJ1dGUobmFtZSA9PT0gJ2ljb24nID8gbGFzdCA6IHRoaXMuZ2V0QXR0cmlidXRlKCdpY29uJyksIG5hbWUgPT09ICdtb2RpZmllcicgPyBsYXN0IDogdW5kZWZpbmVkKTtcbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICB9XG5cbiAgX3VwZGF0ZSgpIHtcbiAgICBjb25zdCB7Y2xhc3NMaXN0LCBzdHlsZX0gPSB0aGlzLl9idWlsZENsYXNzQW5kU3R5bGUodGhpcy5fcGFyc2VBdHRyKCdpY29uJyksIHRoaXMuX3BhcnNlQXR0cignc2l6ZScpKTtcbiAgICB1dGlsLmV4dGVuZCh0aGlzLnN0eWxlLCBzdHlsZSk7XG5cbiAgICBjbGFzc0xpc3QuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSkpO1xuICB9XG5cbiAgX3BhcnNlQXR0cihhdHRyTmFtZSwgbW9kaWZpZXIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kaWZpZXInKSB8fCAnJykge1xuICAgIGNvbnN0IGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgfHwgYXR0ck5hbWUgfHwgJydcbiAgICBjb25zdCBwYXJ0cyA9IGF0dHIuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgIGNvbnN0IGRlZiA9IHBhcnRzWzBdO1xuICAgIGxldCBtZCA9IHBhcnRzWzFdO1xuICAgIG1kID0gKG1kIHx8ICcnKS5zcGxpdCgvXFxzKjpcXHMqLyk7XG5cbiAgICByZXR1cm4gKG1vZGlmaWVyICYmIChSZWdFeHAoYChefFxcXFxzKykke21kWzBdfSgkfFxcXFxzKylgLCAnaScpLnRlc3QobW9kaWZpZXIpKSA/IG1kWzFdIDogZGVmKSB8fCAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdW5uZWVkZWQgY2xhc3MgdmFsdWUuXG4gICAqL1xuICBfY2xlYW5DbGFzc0F0dHJpYnV0ZShsYXN0SWNvbiwgbGFzdE1vZGlmaWVyKSB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUsIHByZWZpeCB9ID0gdGhpcy5fcHJlZml4SWNvbih0aGlzLl9wYXJzZUF0dHIobGFzdEljb24sIGxhc3RNb2RpZmllcikpO1xuICAgIGNvbnN0IGN1c3RvbVByZWZpeFJFID0gY2xhc3NOYW1lICE9PSBwcmVmaXggPyBgfCR7cHJlZml4fSR8JHtwcmVmaXh9LWAgOiBgfCR7Y2xhc3NOYW1lfSRgIHx8ICcnO1xuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgXihmYSR8ZmEtfGlvbi18em1kaSR8em1kaS18b25zLWljb24tLSR7Y3VzdG9tUHJlZml4UkV9KWApO1xuXG4gICAgdXRpbC5hcnJheUZyb20odGhpcy5jbGFzc0xpc3QpXG4gICAgICAuZmlsdGVyKGNsYXNzTmFtZSA9PiByZS50ZXN0KGNsYXNzTmFtZSkpXG4gICAgICAuZm9yRWFjaChjbGFzc05hbWUgPT4gdGhpcy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSkpO1xuICB9XG5cbiAgX3ByZWZpeEljb24oaWNvbk5hbWUpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBhdXRvUHJlZml4ICsgKGF1dG9QcmVmaXggPyAnLScgOiAnJykgKyBpY29uTmFtZTtcbiAgICByZXR1cm4geyBjbGFzc05hbWUsIHByZWZpeDogY2xhc3NOYW1lLnNwbGl0KCctJylbMF0gfTtcbiAgfVxuXG4gIF9idWlsZENsYXNzQW5kU3R5bGUoaWNvbk5hbWUsIHNpemUpIHtcbiAgICBjb25zdCBjbGFzc0xpc3QgPSBbJ29ucy1pY29uJ107XG4gICAgY29uc3Qgc3R5bGUgPSB7fTtcblxuICAgIC8vIEljb25cbiAgICBpZiAoaWNvbk5hbWUuaW5kZXhPZignaW9uLScpID09PSAwKSB7XG4gICAgICBjbGFzc0xpc3QucHVzaChpY29uTmFtZSk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnb25zLWljb24tLWlvbicpO1xuICAgIH0gZWxzZSBpZiAoaWNvbk5hbWUuaW5kZXhPZignZmEtJykgPT09IDApIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKGljb25OYW1lKTtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCdmYScpO1xuICAgIH0gZWxzZSBpZihpY29uTmFtZS5pbmRleE9mKCdtZC0nKSA9PT0gMCkgIHtcbiAgICAgIGNsYXNzTGlzdC5wdXNoKCd6bWRpJyk7XG4gICAgICBjbGFzc0xpc3QucHVzaCgnem1kaS0nICsgaWNvbk5hbWUuc3BsaXQoLy0oLispPy8pWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBjbGFzc05hbWUsIHByZWZpeCB9ID0gdGhpcy5fcHJlZml4SWNvbihpY29uTmFtZSk7XG4gICAgICBwcmVmaXggJiYgY2xhc3NMaXN0LnB1c2gocHJlZml4KTtcbiAgICAgIGNsYXNzTmFtZSAmJiBjbGFzc0xpc3QucHVzaChjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIC8vIFNpemVcbiAgICBpZiAoc2l6ZS5tYXRjaCgvXlsxLTVdeHxsZyQvKSkge1xuICAgICAgY2xhc3NMaXN0LnB1c2goJ29ucy1pY29uLS0nICsgc2l6ZSk7XG4gICAgICB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdmb250LXNpemUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuZm9udFNpemUgPSBzaXplO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjbGFzc0xpc3Q6IGNsYXNzTGlzdCxcbiAgICAgIHN0eWxlOiBzdHlsZVxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgc2V0QXV0b1ByZWZpeChwcmVmaXgpIHtcbiAgICBhdXRvUHJlZml4ID0gcHJlZml4ID8gKHR5cGVvZiBwcmVmaXggPT09ICdzdHJpbmcnICYmIHByZWZpeCB8fCAnZmEnKSA6ICcnO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLkljb24gPSBJY29uRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWljb24nLCBJY29uRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi91dGlsJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9wbGF0Zm9ybSc7XG5cbmV4cG9ydCBjbGFzcyBMYXp5UmVwZWF0RGVsZWdhdGUge1xuXG4gIGNvbnN0cnVjdG9yKHVzZXJEZWxlZ2F0ZSwgdGVtcGxhdGVFbGVtZW50ID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdXNlckRlbGVnYXRlICE9PSAnb2JqZWN0JyB8fCB1c2VyRGVsZWdhdGUgPT09IG51bGwpIHtcbiAgICAgIHV0aWwudGhyb3coJ1wiZGVsZWdhdGVcIiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgdGhpcy5fdXNlckRlbGVnYXRlID0gdXNlckRlbGVnYXRlO1xuXG4gICAgaWYgKCEodGVtcGxhdGVFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkgJiYgdGVtcGxhdGVFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICB1dGlsLnRocm93KCdcInRlbXBsYXRlRWxlbWVudFwiIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEVsZW1lbnQgb3IgbnVsbCcpO1xuICAgIH1cbiAgICB0aGlzLl90ZW1wbGF0ZUVsZW1lbnQgPSB0ZW1wbGF0ZUVsZW1lbnQ7XG4gIH1cblxuICBnZXQgaXRlbUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXNlckRlbGVnYXRlLml0ZW1IZWlnaHQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGhhc1JlbmRlckZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl91c2VyRGVsZWdhdGUuX3JlbmRlciBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBfcmVuZGVyKCkge1xuICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5fcmVuZGVyLmFwcGx5KHRoaXMuX3VzZXJEZWxlZ2F0ZSwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSBBIGZ1bmN0aW9uIHRoYXQgdGFrZSBpdGVtIG9iamVjdCBhcyBwYXJhbWV0ZXIuXG4gICAqL1xuICBsb2FkSXRlbUVsZW1lbnQoaW5kZXgsIGRvbmUpIHtcbiAgICBpZiAodGhpcy5fdXNlckRlbGVnYXRlLmxvYWRJdGVtRWxlbWVudCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50KGluZGV4LCBkb25lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX3VzZXJEZWxlZ2F0ZS5jcmVhdGVJdGVtQ29udGVudChpbmRleCwgdGhpcy5fdGVtcGxhdGVFbGVtZW50KTtcbiAgICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICB1dGlsLnRocm93KCdcImNyZWF0ZUl0ZW1Db250ZW50XCIgbXVzdCByZXR1cm4gYW4gaW5zdGFuY2Ugb2YgRWxlbWVudCcpO1xuICAgICAgfVxuXG4gICAgICBkb25lKHtlbGVtZW50fSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIGNvdW50SXRlbXMoKSB7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl91c2VyRGVsZWdhdGUuY291bnRJdGVtcygpO1xuICAgIGlmICh0eXBlb2YgY291bnQgIT09ICdudW1iZXInKSB7XG4gICAgICB1dGlsLnRocm93KCdcImNvdW50SXRlbXNcIiBtdXN0IHJldHVybiBhIG51bWJlcicpO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gaXRlbS5lbGVtZW50XG4gICAqL1xuICB1cGRhdGVJdGVtKGluZGV4LCBpdGVtKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS51cGRhdGVJdGVtQ29udGVudCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLl91c2VyRGVsZWdhdGUudXBkYXRlSXRlbUNvbnRlbnQoaW5kZXgsIGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICBjYWxjdWxhdGVJdGVtSGVpZ2h0KGluZGV4KSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuX3VzZXJEZWxlZ2F0ZS5jYWxjdWxhdGVJdGVtSGVpZ2h0KGluZGV4KTtcblxuICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHV0aWwudGhyb3coJ1wiY2FsY3VsYXRlSXRlbUhlaWdodFwiIG11c3QgcmV0dXJuIGEgbnVtYmVyJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtXG4gICAqL1xuICBkZXN0cm95SXRlbShpbmRleCwgaXRlbSkge1xuICAgIGlmICh0aGlzLl91c2VyRGVsZWdhdGUuZGVzdHJveUl0ZW0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5fdXNlckRlbGVnYXRlLmRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuX3VzZXJEZWxlZ2F0ZS5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdXNlckRlbGVnYXRlID0gdGhpcy5fdGVtcGxhdGVFbGVtZW50ID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZSBjb3JlIGZ1bmN0aW9ucyBmb3Igb25zLWxhenktcmVwZWF0LlxuICovXG5leHBvcnQgY2xhc3MgTGF6eVJlcGVhdFByb3ZpZGVyIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSB3cmFwcGVyRWxlbWVudFxuICAgKiBAcGFyYW0ge0xhenlSZXBlYXREZWxlZ2F0ZX0gZGVsZWdhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdyYXBwZXJFbGVtZW50LCBkZWxlZ2F0ZSkge1xuICAgIGlmICghKGRlbGVnYXRlIGluc3RhbmNlb2YgTGF6eVJlcGVhdERlbGVnYXRlKSkge1xuICAgICAgdXRpbC50aHJvdygnXCJkZWxlZ2F0ZVwiIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIExhenlSZXBlYXREZWxlZ2F0ZScpO1xuICAgIH1cblxuICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50ID0gd3JhcHBlckVsZW1lbnQ7XG4gICAgdGhpcy5fZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICB0aGlzLl9pbnNlcnRJbmRleCA9ICh0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlblswXSAmJiB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlblswXS50YWdOYW1lID09PSAnT05TLUxBWlktUkVQRUFUJykgPyAxIDogMDtcblxuICAgIGlmICh3cmFwcGVyRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvbnMtbGlzdCcpIHtcbiAgICAgIHdyYXBwZXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xhenktbGlzdCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhZ2VDb250ZW50ID0gdGhpcy5fZmluZFBhZ2VDb250ZW50RWxlbWVudCh3cmFwcGVyRWxlbWVudCk7XG5cbiAgICBpZiAoIXRoaXMuX3BhZ2VDb250ZW50KSB7XG4gICAgICB1dGlsLnRocm93KCdMYXp5UmVwZWF0IG11c3QgYmUgZGVzY2VuZGFudCBvZiBhIFBhZ2UgZWxlbWVudCcpO1xuICAgIH1cblxuICAgIHRoaXMubGFzdFNjcm9sbFRvcCA9IHRoaXMuX3BhZ2VDb250ZW50LnNjcm9sbFRvcDtcbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICAgIHRoaXMuX3RvcFBvc2l0aW9ucyA9IFswXTtcbiAgICB0aGlzLl9yZW5kZXJlZEl0ZW1zID0ge307XG5cbiAgICBpZiAoIXRoaXMuX2RlbGVnYXRlLml0ZW1IZWlnaHQgJiYgIXRoaXMuX2RlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHQoMCkpIHtcbiAgICAgIHRoaXMuX3Vua25vd25JdGVtSGVpZ2h0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gIH1cblxuICBnZXQgcGFkZGluZygpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUucGFkZGluZ1RvcCwgMTApO1xuICB9XG5cbiAgc2V0IHBhZGRpbmcobmV3VmFsdWUpIHtcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS5wYWRkaW5nVG9wID0gbmV3VmFsdWUgKyAncHgnO1xuICB9XG5cbiAgX2ZpbmRQYWdlQ29udGVudEVsZW1lbnQod3JhcHBlckVsZW1lbnQpIHtcbiAgICBjb25zdCBwYWdlQ29udGVudCA9IHV0aWwuZmluZFBhcmVudCh3cmFwcGVyRWxlbWVudCwgJy5wYWdlX19jb250ZW50Jyk7XG5cbiAgICBpZiAocGFnZUNvbnRlbnQpIHtcbiAgICAgIHJldHVybiBwYWdlQ29udGVudDtcbiAgICB9XG5cbiAgICBjb25zdCBwYWdlID0gdXRpbC5maW5kUGFyZW50KHdyYXBwZXJFbGVtZW50LCAnb25zLXBhZ2UnKTtcbiAgICBpZiAocGFnZSkge1xuICAgICAgY29uc3QgY29udGVudCA9IHV0aWwuZmluZENoaWxkKHBhZ2UsICcuY29udGVudCcpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBfY2hlY2tJdGVtSGVpZ2h0KGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZGVsZWdhdGUubG9hZEl0ZW1FbGVtZW50KDAsIGl0ZW0gPT4ge1xuICAgICAgaWYgKCF0aGlzLl91bmtub3duSXRlbUhlaWdodCkge1xuICAgICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3dyYXBwZXJFbGVtZW50LmFwcGVuZENoaWxkKGl0ZW0uZWxlbWVudCk7XG5cbiAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lJdGVtKDAsIGl0ZW0pO1xuICAgICAgICBpdGVtLmVsZW1lbnQgJiYgaXRlbS5lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fdW5rbm93bkl0ZW1IZWlnaHQ7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9pdGVtSGVpZ2h0ID0gaXRlbS5lbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICAgICAgaWYgKHRoaXMuX2l0ZW1IZWlnaHQgPiAwKSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyByZXRyeSB0byBtZWFzdXJlIG9mZnNldCBoZWlnaHRcbiAgICAgIC8vIGRpcnR5IGZpeCBmb3IgYW5ndWxhcjIgZGlyZWN0aXZlXG4gICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICBpdGVtLmVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICB0aGlzLl9pdGVtSGVpZ2h0ID0gaXRlbS5lbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1IZWlnaHQgPT0gMCkge1xuICAgICAgICAgIHV0aWwudGhyb3coJ0ludmFsaWQgc3RhdGU6IFwiaXRlbUhlaWdodFwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHN0YXRpY0l0ZW1IZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLml0ZW1IZWlnaHQgfHwgdGhpcy5faXRlbUhlaWdodDtcbiAgfVxuICBfY291bnRJdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVsZWdhdGUuY291bnRJdGVtcygpO1xuICB9XG5cbiAgX2dldEl0ZW1IZWlnaHQoaSkge1xuICAgIC8vIEl0ZW0gaXMgcmVuZGVyZWRcbiAgICBpZiAodGhpcy5fcmVuZGVyZWRJdGVtcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlZEl0ZW1zW2ldLmhhc093blByb3BlcnR5KCdoZWlnaHQnKSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlZEl0ZW1zW2ldLmhlaWdodCA9IHRoaXMuX3JlbmRlcmVkSXRlbXNbaV0uZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZWRJdGVtc1tpXS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgLy8gSXRlbSBpcyBub3QgcmVuZGVyZWQsIHNjcm9sbCB1cFxuICAgIGlmICh0aGlzLl90b3BQb3NpdGlvbnNbaSArIDFdICYmIHRoaXMuX3RvcFBvc2l0aW9uc1tpXSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RvcFBvc2l0aW9uc1tpICsgMV0gLSB0aGlzLl90b3BQb3NpdGlvbnNbaV07XG4gICAgfVxuICAgIC8vIEl0ZW0gaXMgbm90IHJlbmRlcmVkLCBzY3JvbGwgZG93blxuICAgIHJldHVybiB0aGlzLnN0YXRpY0l0ZW1IZWlnaHQgfHwgdGhpcy5fZGVsZWdhdGUuY2FsY3VsYXRlSXRlbUhlaWdodChpKTtcbiAgfVxuXG4gIF9jYWxjdWxhdGVSZW5kZXJlZEhlaWdodCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fcmVuZGVyZWRJdGVtcykucmVkdWNlKChhLCBiKSA9PiBhICsgdGhpcy5fZ2V0SXRlbUhlaWdodCgrKGIpKSwgMClcbiAgfVxuXG4gIF9vbkNoYW5nZSgpIHtcbiAgICB0aGlzLl9yZW5kZXIoKTtcbiAgfVxuXG4gIF9sYXN0SXRlbVJlbmRlcmVkKCkge1xuICAgIHJldHVybiBNYXRoLm1heCguLi5PYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKSk7XG4gIH1cblxuICBfZmlyc3RJdGVtUmVuZGVyZWQoKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKC4uLk9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpKTtcbiAgfVxuXG4gIHJlZnJlc2goKSB7XG4gICAgY29uc3QgZm9yY2VSZW5kZXIgPSB7IGZvcmNlU2Nyb2xsRG93bjogdHJ1ZSB9O1xuICAgIGNvbnN0IGxhc3RJdGVtSW5kZXggPSBNYXRoLm1pbih0aGlzLl9sYXN0SXRlbVJlbmRlcmVkKCksIHRoaXMuX2NvdW50SXRlbXMoKSAtIDEpO1xuICAgIGNvbnN0IGZpcnN0SXRlbUluZGV4ID0gdGhpcy5fZmlyc3RJdGVtUmVuZGVyZWQoKTtcblxuICAgIGlmICh1dGlsLmlzSW50ZWdlcihsYXN0SXRlbUluZGV4KSkge1xuICAgICAgZm9yY2VSZW5kZXIuZm9yY2VMYXN0SW5kZXggPSBsYXN0SXRlbUluZGV4XG4gICAgfVxuXG4gICAgaWYgKHV0aWwuaXNJbnRlZ2VyKGZpcnN0SXRlbUluZGV4KSkge1xuICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fdG9wUG9zaXRpb25zW2ZpcnN0SXRlbUluZGV4XSArIHRoaXMuX2NhbGN1bGF0ZVJlbmRlcmVkSGVpZ2h0KCkgKyAncHgnO1xuICAgICAgdGhpcy5wYWRkaW5nID0gdGhpcy5fdG9wUG9zaXRpb25zW2ZpcnN0SXRlbUluZGV4XTtcbiAgICAgIGZvcmNlUmVuZGVyLmZvcmNlRmlyc3RJbmRleCA9IGZpcnN0SXRlbUluZGV4O1xuICAgIH1cblxuICAgIHRoaXMuX3JlbW92ZUFsbEVsZW1lbnRzKCk7XG4gICAgdGhpcy5fcmVuZGVyKGZvcmNlUmVuZGVyKTtcbiAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5zdHlsZS5oZWlnaHQgPSAnaW5oZXJpdCc7XG4gIH1cblxuICBfcmVuZGVyKHtmb3JjZVNjcm9sbERvd24gPSBmYWxzZSwgZm9yY2VGaXJzdEluZGV4LCBmb3JjZUxhc3RJbmRleH0gPSB7fSkge1xuICAgIGlmICh0aGlzLl91bmtub3duSXRlbUhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NoZWNrSXRlbUhlaWdodCh0aGlzLl9yZW5kZXIuYmluZCh0aGlzLCBhcmd1bWVudHNbMF0pKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1Njcm9sbFVwID0gIWZvcmNlU2Nyb2xsRG93biAmJiB0aGlzLmxhc3RTY3JvbGxUb3AgPiB0aGlzLl9wYWdlQ29udGVudC5zY3JvbGxUb3A7XG4gICAgdGhpcy5sYXN0U2Nyb2xsVG9wID0gdGhpcy5fcGFnZUNvbnRlbnQuc2Nyb2xsVG9wO1xuICAgIGNvbnN0IGtlZXAgPSB7fTtcblxuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX3dyYXBwZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICBjb25zdCBsaW1pdCA9IDQgKiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBvZmZzZXQ7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9jb3VudEl0ZW1zKCk7XG5cbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHN0YXJ0ID0gZm9yY2VGaXJzdEluZGV4IHx8IE1hdGgubWF4KDAsIHRoaXMuX2NhbGN1bGF0ZVN0YXJ0SW5kZXgob2Zmc2V0KSAtIDMwKTsgLy8gUmVjYWxjdWxhdGUgZm9yIDAgb3IgdW5kZWZpbmVkXG4gICAgbGV0IGkgPSBzdGFydDtcblxuICAgIGZvcihsZXQgdG9wID0gdGhpcy5fdG9wUG9zaXRpb25zW2ldOyBpIDwgY291bnQgJiYgdG9wIDwgbGltaXQ7IGkrKykge1xuICAgICAgaWYgKGkgPj0gdGhpcy5fdG9wUG9zaXRpb25zLmxlbmd0aCkgeyAvLyBwZXJmIG9wdGltaXphdGlvblxuICAgICAgICB0aGlzLl90b3BQb3NpdGlvbnMubGVuZ3RoICs9IDEwMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdG9wUG9zaXRpb25zW2ldID0gdG9wO1xuICAgICAgdG9wICs9IHRoaXMuX2dldEl0ZW1IZWlnaHQoaSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uICYmIHRoaXMuX2RlbGVnYXRlLmhhc1JlbmRlckZ1bmN0aW9uKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWxlZ2F0ZS5fcmVuZGVyKHN0YXJ0LCBpLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucGFkZGluZyA9IHRoaXMuX3RvcFBvc2l0aW9uc1tzdGFydF07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNTY3JvbGxVcCkge1xuICAgICAgZm9yIChsZXQgaiA9IGkgLSAxOyBqID49IHN0YXJ0OyBqLS0pIHtcbiAgICAgICAga2VlcFtqXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlbmRlckVsZW1lbnQoaiwgaXNTY3JvbGxVcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGZvcmNlTGFzdEluZGV4IHx8IE1hdGgubWF4KGkgLSAxLCAuLi5PYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKSk7IC8vIFJlY2FsY3VsYXRlIGZvciAwIG9yIHVuZGVmaW5lZFxuICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0OyBqIDw9IGxhc3RJbmRleDsgaisrKSB7XG4gICAgICAgIGtlZXBbal0gPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZW5kZXJFbGVtZW50KGosIGlzU2Nyb2xsVXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlbmRlcmVkSXRlbXMpLmZvckVhY2goa2V5ID0+IGtlZXBba2V5XSB8fCB0aGlzLl9yZW1vdmVFbGVtZW50KGtleSwgaXNTY3JvbGxVcCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2Nyb2xsVXBcbiAgICovXG4gIF9yZW5kZXJFbGVtZW50KGluZGV4LCBpc1Njcm9sbFVwKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB0aGlzLl9kZWxlZ2F0ZS51cGRhdGVJdGVtKGluZGV4LCBpdGVtKTsgLy8gdXBkYXRlIGlmIGl0IGV4aXN0c1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RlbGVnYXRlLmxvYWRJdGVtRWxlbWVudChpbmRleCwgaXRlbSA9PiB7XG4gICAgICBpZiAoaXNTY3JvbGxVcCkge1xuICAgICAgICB0aGlzLl93cmFwcGVyRWxlbWVudC5pbnNlcnRCZWZvcmUoaXRlbS5lbGVtZW50LCB0aGlzLl93cmFwcGVyRWxlbWVudC5jaGlsZHJlblt0aGlzLl9pbnNlcnRJbmRleF0pXG4gICAgICAgIHRoaXMucGFkZGluZyA9IHRoaXMuX3RvcFBvc2l0aW9uc1tpbmRleF07XG4gICAgICAgIGl0ZW0uaGVpZ2h0ID0gdGhpcy5fdG9wUG9zaXRpb25zW2luZGV4ICsgMV0gLSB0aGlzLl90b3BQb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbS5lbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyZWRJdGVtc1tpbmRleF0gPSBpdGVtO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzU2Nyb2xsVXBcbiAgICovXG4gIF9yZW1vdmVFbGVtZW50KGluZGV4LCBpc1Njcm9sbFVwID0gdHJ1ZSkge1xuICAgIGluZGV4ID0gKyhpbmRleCk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX3JlbmRlcmVkSXRlbXNbaW5kZXhdO1xuICAgIHRoaXMuX2RlbGVnYXRlLmRlc3Ryb3lJdGVtKGluZGV4LCBpdGVtKTtcblxuICAgIGlmIChpc1Njcm9sbFVwKSB7XG4gICAgICB0aGlzLl90b3BQb3NpdGlvbnNbaW5kZXggKyAxXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYWRkaW5nID0gdGhpcy5wYWRkaW5nICsgdGhpcy5fZ2V0SXRlbUhlaWdodChpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0uZWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBpdGVtLmVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpdGVtLmVsZW1lbnQpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9yZW5kZXJlZEl0ZW1zW2luZGV4XTtcbiAgfVxuXG4gIF9yZW1vdmVBbGxFbGVtZW50cygpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9yZW5kZXJlZEl0ZW1zKS5mb3JFYWNoKGtleSA9PiB0aGlzLl9yZW1vdmVFbGVtZW50KGtleSkpO1xuICB9XG5cbiAgX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zKHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICAgIHRoaXMuX3RvcFBvc2l0aW9uc1tpICsgMV0gPSB0aGlzLl90b3BQb3NpdGlvbnNbaV0gKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KGkpO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVTdGFydEluZGV4KGN1cnJlbnQpIHtcbiAgICBjb25zdCBmaXJzdEl0ZW1JbmRleCA9IHRoaXMuX2ZpcnN0SXRlbVJlbmRlcmVkKCk7XG4gICAgY29uc3QgbGFzdEl0ZW1JbmRleCA9IHRoaXMuX2xhc3RJdGVtUmVuZGVyZWQoKTtcblxuICAgIC8vIEZpeCBmb3IgU2FmYXJpIHNjcm9sbCBhbmQgQW5ndWxhciAyXG4gICAgdGhpcy5fcmVjYWxjdWxhdGVUb3BQb3NpdGlvbnMoZmlyc3RJdGVtSW5kZXgsIGxhc3RJdGVtSW5kZXgpO1xuXG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gdGhpcy5fY291bnRJdGVtcygpIC0gMTtcblxuICAgIC8vIEJpbmFyeSBzZWFyY2ggZm9yIGluZGV4IGF0IHRvcCBvZiBzY3JlZW4gc28gd2UgY2FuIHNwZWVkIHVwIHJlbmRlcmluZy5cbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBtaWRkbGUgPSBNYXRoLmZsb29yKChzdGFydCArIGVuZCkgLyAyKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudCArIHRoaXMuX3RvcFBvc2l0aW9uc1ttaWRkbGVdO1xuXG4gICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlIDw9IDAgJiYgdmFsdWUgKyB0aGlzLl9nZXRJdGVtSGVpZ2h0KG1pZGRsZSkgPiAwKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA+PSAwKSB7XG4gICAgICAgIGVuZCA9IG1pZGRsZSAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2RlYm91bmNlKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIGxldCB0aW1lb3V0O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCB3YWl0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgX2RvdWJsZUZpcmVPblRvdWNoZW5kKCkge1xuICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIHRoaXMuX2RlYm91bmNlKHRoaXMuX3JlbmRlci5iaW5kKHRoaXMpLCAxMDApO1xuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHV0aWwuYmluZExpc3RlbmVycyh0aGlzLCBbJ19vbkNoYW5nZScsICdfZG91YmxlRmlyZU9uVG91Y2hlbmQnXSk7XG5cbiAgICBpZiAocGxhdGZvcm0uaXNJT1MoKSkge1xuICAgICAgdGhpcy5fYm91bmRPbkNoYW5nZSA9IHRoaXMuX2RlYm91bmNlKHRoaXMuX2JvdW5kT25DaGFuZ2UsIDMwKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB1dGlsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fcGFnZUNvbnRlbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIF9yZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcblxuICAgIGlmIChwbGF0Zm9ybS5pc0lPUygpKSB7XG4gICAgICB1dGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fcGFnZUNvbnRlbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICB0aGlzLl9wYWdlQ29udGVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQsIHRydWUpO1xuICAgIH1cblxuICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCB0cnVlKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVtb3ZlQWxsRWxlbWVudHMoKTtcbiAgICB0aGlzLl9kZWxlZ2F0ZS5kZXN0cm95KCk7XG4gICAgdGhpcy5fcGFyZW50RWxlbWVudCA9IHRoaXMuX2RlbGVnYXRlID0gdGhpcy5fcmVuZGVyZWRJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxufVxuXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCB7IExhenlSZXBlYXREZWxlZ2F0ZSwgTGF6eVJlcGVhdFByb3ZpZGVyIH0gZnJvbSAnLi4vb25zL2ludGVybmFsL2xhenktcmVwZWF0JztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGF6eS1yZXBlYXRcbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFVzaW5nIHRoaXMgY29tcG9uZW50IGEgbGlzdCB3aXRoIG1pbGxpb25zIG9mIGl0ZW1zIGNhbiBiZSByZW5kZXJlZCB3aXRob3V0IGEgZHJvcCBpbiBwZXJmb3JtYW5jZS5cbiAqICAgICBJdCBkb2VzIHRoYXQgYnkgXCJsYXppbHlcIiBsb2FkaW5nIGVsZW1lbnRzIGludG8gdGhlIERPTSB3aGVuIHRoZXkgY29tZSBpbnRvIHZpZXcgYW5kXG4gKiAgICAgcmVtb3ZpbmcgaXRlbXMgZnJvbSB0aGUgRE9NIHdoZW4gdGhleSBhcmUgbm90IHZpc2libGUuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jlhoXjgafmj4/nlLvjgZXjgozjgovjgqLjgqTjg4bjg6Djga5ET03opoHntKDjga7oqq3jgb/ovrzjgb/jga/jgIHnlLvpnaLjgavopovjgYjjgZ3jgYbjgavjgarjgaPjgZ/mmYLjgb7jgafoh6rli5XnmoTjgavpgYXlu7bjgZXjgozjgIFcbiAqICAgICDnlLvpnaLjgYvjgonopovjgYjjgarjgY/jgarjgaPjgZ/loLTlkIjjgavjga/jgZ3jga7opoHntKDjga/li5XnmoTjgavjgqLjg7Pjg63jg7zjg4njgZXjgozjgb7jgZnjgIJcbiAqICAgICDjgZPjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgpLkvb/jgYbjgZPjgajjgafjgIHjg5Hjg5Xjgqnjg7zjg57jg7PjgrnjgpLliqPljJbjgZXjgZvjgovjgZPjgajnhKHjgZfjgavlt6jlpKfjgarmlbDjga7opoHntKDjgpLmj4/nlLvjgafjgY3jgb7jgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIFF3ckdCbVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xhenktcmVwZWF0XG4gKiBAc2VlYWxzbyBvbnMtbGlzdFxuICogICBbZW5dVGhlIGA8b25zLWxpc3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gcmVuZGVyIGEgbGlzdC5bL2VuXVxuICogICBbamFdYDxvbnMtbGlzdD5g6KaB57Sg44Gv44Oq44K544OI44KS5o+P55S744GZ44KL44Gu44Gr5L2/44KP44KM44G+44GZ44CCWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8c2NyaXB0PlxuICogICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKCkge1xuICogICAgIHZhciBsYXp5UmVwZWF0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2xpc3QnKTtcbiAqICAgICBsYXp5UmVwZWF0LmRlbGVnYXRlID0ge1xuICogICAgICBjcmVhdGVJdGVtQ29udGVudDogZnVuY3Rpb24oaSwgdGVtcGxhdGUpIHtcbiAqICAgICAgICB2YXIgZG9tID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICogICAgICAgIGRvbS5pbm5lclRleHQgPSBpO1xuICpcbiAqICAgICAgICByZXR1cm4gZG9tO1xuICogICAgICB9LFxuICogICAgICBjb3VudEl0ZW1zOiBmdW5jdGlvbigpIHtcbiAqICAgICAgICByZXR1cm4gMTAwMDAwMDA7XG4gKiAgICAgIH0sXG4gKiAgICAgIGRlc3Ryb3lJdGVtOiBmdW5jdGlvbihpbmRleCwgaXRlbSkge1xuICogICAgICAgIGNvbnNvbGUubG9nKCdEZXN0cm95ZWQgaXRlbSB3aXRoIGluZGV4OiAnICsgaW5kZXgpO1xuICogICAgICB9XG4gKiAgICAgfTtcbiAqICAgfSk7XG4gKiA8L3NjcmlwdD5cbiAqXG4gKiA8b25zLWxpc3QgaWQ9XCJsaXN0XCI+XG4gKiAgIDxvbnMtbGF6eS1yZXBlYXQ+XG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+PC9vbnMtbGlzdC1pdGVtPlxuICogICA8L29ucy1sYXp5LXJlcGVhdD5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhenlSZXBlYXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIC8vIG5vdCB2ZXJ5IGdvb2QgaWRlYSBhbmQgYWxzbyBub3QgZG9jdW1lbnRlZFxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnZGVsZWdhdGUnKSkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHdpbmRvd1t0aGlzLmdldEF0dHJpYnV0ZSgnZGVsZWdhdGUnKV07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IGEgZGVsZWdhdGUgb2JqZWN0IHRvIGxvYWQgYW5kIHVubG9hZCBpdGVtIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFd6KaB57Sg44Gu44Ot44O844OJ44CB44Ki44Oz44Ot44O844OJ44Gq44Gp44Gu5Yem55CG44KS5aeU6K2y44GZ44KL44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jcmVhdGVJdGVtQ29udGVudFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIGBIVE1MRWxlbWVudGAuXG4gICAqXG4gICAqICAgICBUbyBoZWxwIHJlbmRlcmluZyB0aGUgZWxlbWVudCwgdGhlIGN1cnJlbnQgaW5kZXggYW5kIGEgdGVtcGxhdGUgaXMgc3VwcGxpZWQgYXMgYXJndW1lbnRzLiBUaGUgdGVtcGxhdGUgaXMgdGhlIGluaXRpYWwgY29udGVudCBvZiB0aGUgYDxvbnMtbGF6eS1yZXBlYXQ+YCBlbGVtZW50LlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44GvYEhUTUxFbGVtZW50YOOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAglxuICAgKiAgICAg6KaB57Sg44KS55Sf5oiQ44GX44KE44GZ44GP44GZ44KL44Gf44KB44Gr44CB54++5Zyo44Gu44Ki44Kk44OG44Og44Gu44Kk44Oz44OH44OD44Kv44K544Go44OG44Oz44OX44Os44O844OI44GM5byV5pWw44Gr5rih44GV44KM44G+44GZ44CCXG4gICAqICAgICDjgZPjga7jg4bjg7Pjg5fjg6zjg7zjg4jjga/jgIFgPG9ucy1sYXp5LXJlcGVhdD5g6KaB57Sg44Gu44Kz44Oz44OG44Oz44OE44GM5rih44GV44KM44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkZWxlZ2F0ZS5jb3VudEl0ZW1zXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgbGlzdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jlhoXjga7jgqLjgqTjg4bjg6DmlbDjgpLov5TjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRlbGVnYXRlLmNhbGN1bGF0ZUl0ZW1IZWlnaHRcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBTaG91bGQgcmV0dXJuIHRoZSBoZWlnaHQgb2YgYW4gaXRlbS4gVGhlIGluZGV4IGlzIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50LlxuICAgKlxuICAgKiAgICAgVGhpcyBpcyBpbXBvcnRhbnQgd2hlbiByZW5kZXJpbmcgbGlzdHMgd2hlcmUgdGhlIGl0ZW1zIGhhdmUgZGlmZmVyZW50IGhlaWdodC5cbiAgICpcbiAgICogICAgIFRoZSBmdW5jdGlvbiBpcyBvcHRpb25hbCBhbmQgaWYgaXQgaXNuJ3QgcHJlc2VudCB0aGUgaGVpZ2h0IG9mIHRoZSBmaXJzdCBpdGVtIHdpbGwgYmUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVkIGFuZCB1c2VkIGZvciBhbGwgb3RoZXIgaXRlbXMuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7pq5jjgZUo44OU44Kv44K744OrKeOCkui/lOOBl+OBpuOBj+OBoOOBleOBhOOAguOCouOCpOODhuODoOOBruOCpOODs+ODh+ODg+OCr+OCueWApOOBr+W8leaVsOOBp+a4oeOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44Gd44KM44Ge44KM44Gu44Ki44Kk44Og44GM6YGV44Gj44Gf6auY44GV44KS5oyB44Gk44Oq44K544OI44KS44Os44Oz44OA44Oq44Oz44Kw44GZ44KL6Zqb44Gr6YeN6KaB44Gn44GZ44CCXG4gICAqICAgICDjgZPjga7plqLmlbDjga/jgqrjg5fjgrfjg6fjg4rjg6vjgafjgZnjgILjgoLjgZfjgZPjga7plqLmlbDjgYznhKHjgYTloLTlkIjjgavjga/jgIFcbiAgICogICAgIOacgOWIneOBruOCouOCpOODhuODoOOBrumrmOOBleOBjOS7luOBruOBmeOBueOBpuOBruOCouOCpOODhuODoOOBrumrmOOBleOBqOOBl+OBpuWIqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGVsZWdhdGUuZGVzdHJveUl0ZW1cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgY2FsbGVkIHdoZW4gYW4gaXRlbSBpcyByZW1vdmVkIGZyb20gdGhlIERPTS4gVGhlIGluZGV4IGFuZCBET00gZWxlbWVudCBpcyBwcm92aWRlZCBhcyBhcmd1bWVudHMuXG4gICAqXG4gICAqICAgICBUaGUgZnVuY3Rpb24gaXMgb3B0aW9uYWwgYnV0IG1heSBiZSBpbXBvcnRhbnQgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGxlYWtzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVxuICAgKiAgICAg44GT44Gu6Zai5pWw44Gv44CB44GC44KL44Ki44Kk44OG44Og44GMRE9N44OE44Oq44O844GL44KJ6Zmk44GL44KM44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44G+44GZ44CCXG4gICAqICAgICDjgqLjgqTjg4bjg6Djga7jgqTjg7Pjg4fjg4Pjgq/jgrnlgKTjgahET03opoHntKDjgYzlvJXmlbDjgajjgZfjgabmuKHjgZXjgozjgb7jgZnjgIJcbiAgICogICAgIOOBk+OBrumWouaVsOOBr+OCquODl+OCt+ODp+ODiuODq+OBp+OBmeOBjOOAgeWQhOOCouOCpOODhuODoOOBruW+jOWHpueQhuOBjOW/heimgeOBquWgtOWQiOOBq+OBr+ODoeODouODquODvOODquODvOOCr+OCkumBv+OBkeOCi+OBn+OCgeOBq+mHjeimgeOBp+OBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIHNldCBkZWxlZ2F0ZSh1c2VyRGVsZWdhdGUpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLmRlc3Ryb3koKTtcblxuICAgIGlmICghdGhpcy5fdGVtcGxhdGVFbGVtZW50ICYmIHRoaXMuY2hpbGRyZW5bMF0pIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRWxlbWVudCA9IHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5jaGlsZHJlblswXSk7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsZWdhdGUgPSBuZXcgTGF6eVJlcGVhdERlbGVnYXRlKHVzZXJEZWxlZ2F0ZSwgdGhpcy5fdGVtcGxhdGVFbGVtZW50IHx8IG51bGwpO1xuICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlciA9IG5ldyBMYXp5UmVwZWF0UHJvdmlkZXIodGhpcy5wYXJlbnRFbGVtZW50LCBkZWxlZ2F0ZSk7XG4gIH1cblxuICBnZXQgZGVsZWdhdGUoKSB7XG4gICAgdXRpbC50aHJvdygnTm8gZGVsZWdhdGUgZ2V0dGVyJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZWZyZXNoXG4gICAqIEBzaWduYXR1cmUgcmVmcmVzaCgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1SZWZyZXNoIHRoZSBsaXN0LiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgZGF0YSBoYXMgY2hhbmdlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjgrnjg4jjgpLmm7TmlrDjgZfjgb7jgZnjgILjgoLjgZfjg4fjg7zjgr/jgYzlpInjgo/jgaPjgZ/loLTlkIjjgavjga/jgZPjga7jg6Hjgr3jg4Pjg4njgpLkvb/jgaPjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgcmVmcmVzaCgpIHtcbiAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgJiYgdGhpcy5fbGF6eVJlcGVhdFByb3ZpZGVyLnJlZnJlc2goKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7fVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICh0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIpIHtcbiAgICAgIHRoaXMuX2xhenlSZXBlYXRQcm92aWRlci5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9sYXp5UmVwZWF0UHJvdmlkZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuXG59XG5cbmludGVybmFsLkxhenlSZXBlYXREZWxlZ2F0ZSA9IExhenlSZXBlYXREZWxlZ2F0ZTtcbmludGVybmFsLkxhenlSZXBlYXRQcm92aWRlciA9IExhenlSZXBlYXRQcm92aWRlcjtcblxub25zRWxlbWVudHMuTGF6eVJlcGVhdCA9IExhenlSZXBlYXRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGF6eS1yZXBlYXQnLCBMYXp5UmVwZWF0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdsaXN0LWhlYWRlcic7XG5jb25zdCBzY2hlbWUgPSB7Jyc6ICdsaXN0LWhlYWRlci0tKid9O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1saXN0LWhlYWRlclxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dSGVhZGVyIGVsZW1lbnQgZm9yIGxpc3QgaXRlbXMuIE11c3QgYmUgcHV0IGluc2lkZSB0aGUgYDxvbnMtbGlzdD5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFd44Oq44K544OI6KaB57Sg44Gr5L2/55So44GZ44KL44OY44OD44OA44O855So44Kz44Oz44Od44O844ON44Oz44OI44CCb25zLWxpc3TjgajlhbHjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3RcbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0PmAgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1saXN044Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1saXN0LWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1saXN0LWl0ZW0+YCBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAY29kZXBlbiB5eGNDdFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL2xpc3RcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IGhlYWRlci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWxpc3Q+XG4gKiAgIDxvbnMtbGlzdC1oZWFkZXI+SGVhZGVyIFRleHQ8L29ucy1saXN0LWhlYWRlcj5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqICAgPG9ucy1saXN0LWl0ZW0+SXRlbTwvb25zLWxpc3QtaXRlbT5cbiAqIDwvb25zLWxpc3Q+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RIZWFkZXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdCBoZWFkZXIuWy9lbl1cbiAgICogICBbamFd44OY44OD44OA44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuTGlzdEhlYWRlciA9IExpc3RIZWFkZXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdC1oZWFkZXInLCBMaXN0SGVhZGVyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdsaXN0LXRpdGxlJztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2xpc3QtdGl0bGUtLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdC10aXRsZVxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dUmVwcmVzZW50cyBhIGxpc3QgdGl0bGUuWy9lbl1cbiAqICAgW2phXeODquOCueODiOOBruOCv+OCpOODiOODq+OCkuihqOePvuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1saXN0LXRpdGxlPkxpc3QgVGl0bGU8L29ucy1saXN0LXRpdGxlPlxuICogPG9ucy1saXN0PlxuICogICA8b25zLWxpc3QtaXRlbT5JdGVtPC9vbnMtbGlzdC1pdGVtPlxuICogPC9vbnMtbGlzdD5cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IHRpdGxlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RUaXRsZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuTGlzdFRpdGxlID0gTGlzdFRpdGxlRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxpc3QtdGl0bGUnLCBMaXN0VGl0bGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE4IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcidcblxuZXhwb3J0IGNsYXNzIExpc3RJdGVtQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2xpbmVhcicsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjJ9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgc2hvd0V4cGFuc2lvbihsaXN0SXRlbSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgaGlkZUV4cGFuc2lvbihsaXN0SXRlbSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTbGlkZUxpc3RJdGVtQW5pbWF0b3IgZXh0ZW5kcyBMaXN0SXRlbUFuaW1hdG9yIHtcblxuICBzaG93RXhwYW5zaW9uKGxpc3RJdGVtLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVFeHBhbnNpb24obGlzdEl0ZW0sIHRydWUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGhpZGVFeHBhbnNpb24obGlzdEl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUV4cGFuc2lvbihsaXN0SXRlbSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIF9hbmltYXRlRXhwYW5zaW9uKGxpc3RJdGVtLCBzaG91bGRPcGVuLCBjYWxsYmFjaykge1xuICAgIC8vIFRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgdGhlIGV4cGFuc2lvbiBwYW5lbCBjb3JyZWN0bHksIHdlIG5lZWQgdG8ga25vdyBpdHNcbiAgICAvLyBoZWlnaHQuIFRvIGNhbGN1bGF0ZSB0aGlzLCB3ZSBzZXQgaXRzIGhlaWdodCB0byBhdXRvLCBhbmQgdGhlbiBnZXQgdGhlIGNvbXB1dGVkXG4gICAgLy8gaGVpZ2h0IGFuZCBwYWRkaW5nLiBPbmNlIHRoaXMgaXMgZG9uZSwgd2Ugc2V0IHRoZSBoZWlnaHQgYmFjayB0byBpdHMgb3JpZ2luYWwgdmFsdWUuXG4gICAgY29uc3Qgb2xkSGVpZ2h0ID0gbGlzdEl0ZW0uZXhwYW5kYWJsZUNvbnRlbnQuc3R5bGUuaGVpZ2h0O1xuICAgIGNvbnN0IG9sZERpc3BsYXkgPSBsaXN0SXRlbS5leHBhbmRhYmxlQ29udGVudC5zdHlsZS5kaXNwbGF5O1xuICAgIGxpc3RJdGVtLmV4cGFuZGFibGVDb250ZW50LnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICBsaXN0SXRlbS5leHBhbmRhYmxlQ29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobGlzdEl0ZW0uZXhwYW5kYWJsZUNvbnRlbnQpO1xuXG4gICAgY29uc3QgZXhwYW5zaW9uT3BlblRyYW5zaXRpb24gPSBbXG4gICAgICB7IGhlaWdodDogMCwgcGFkZGluZ1RvcDogMCwgcGFkZGluZ0JvdHRvbTogMCB9LFxuICAgICAge1xuICAgICAgICBoZWlnaHQ6IGNvbXB1dGVkU3R5bGUuaGVpZ2h0LFxuICAgICAgICBwYWRkaW5nVG9wOiBjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3AsXG4gICAgICAgIHBhZGRpbmdCb3R0b206IGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSxcbiAgICAgIH1cbiAgICBdO1xuICAgIGNvbnN0IGljb25PcGVuVHJhbnNpdGlvbiA9IFt7dHJhbnNmb3JtOiAncm90YXRlKDQ1ZGVnKSd9LCB7dHJhbnNmb3JtOiAncm90YXRlKDIyNWRlZyknfV07XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSBoYXZlIHRoZSB2YWx1ZXMgd2UgbmVlZCwgcmVzZXQgdGhlIGhlaWdodCBiYWNrIHRvIGl0cyBvcmlnaW5hbCBzdGF0ZVxuICAgIGxpc3RJdGVtLmV4cGFuZGFibGVDb250ZW50LnN0eWxlLmhlaWdodCA9IG9sZEhlaWdodDtcblxuICAgIGFuaW1pdChsaXN0SXRlbS5leHBhbmRhYmxlQ29udGVudCwgeyBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiwgcHJvcGVydHk6ICdoZWlnaHQgcGFkZGluZy10b3AgcGFkZGluZy1ib3R0b20nIH0pXG4gICAgICAuZGVmYXVsdCguLi4oc2hvdWxkT3BlbiA/IGV4cGFuc2lvbk9wZW5UcmFuc2l0aW9uIDogZXhwYW5zaW9uT3BlblRyYW5zaXRpb24ucmV2ZXJzZSgpKSlcbiAgICAgIC5wbGF5KCgpID0+IHtcbiAgICAgICAgbGlzdEl0ZW0uZXhwYW5kYWJsZUNvbnRlbnQuc3R5bGUuZGlzcGxheSA9IG9sZERpc3BsYXk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcblxuICAgIGlmKGxpc3RJdGVtLmV4cGFuZENoZXZyb24pIHtcbiAgICAgIGFuaW1pdChsaXN0SXRlbS5leHBhbmRDaGV2cm9uLCB7IGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLCBwcm9wZXJ0eTogJ3RyYW5zZm9ybScgfSlcbiAgICAgICAgLmRlZmF1bHQoLi4uKHNob3VsZE9wZW4gPyBpY29uT3BlblRyYW5zaXRpb24gOiBpY29uT3BlblRyYW5zaXRpb24ucmV2ZXJzZSgpKSlcbiAgICAgICAgLnBsYXkoKTtcbiAgICB9XG4gIH1cblxufSIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBzdHlsZXIgZnJvbSAnLi4vLi4vb25zL3N0eWxlcic7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7IExpc3RJdGVtQW5pbWF0b3IsIFNsaWRlTGlzdEl0ZW1BbmltYXRvciB9IGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ2xpc3QtaXRlbSc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcubGlzdC1pdGVtJzogJ2xpc3QtaXRlbS0tKicsXG4gICcubGlzdC1pdGVtX19sZWZ0JzogJ2xpc3QtaXRlbS0tKl9fbGVmdCcsXG4gICcubGlzdC1pdGVtX19jZW50ZXInOiAnbGlzdC1pdGVtLS0qX19jZW50ZXInLFxuICAnLmxpc3QtaXRlbV9fcmlnaHQnOiAnbGlzdC1pdGVtLS0qX19yaWdodCcsXG4gICcubGlzdC1pdGVtX19sYWJlbCc6ICdsaXN0LWl0ZW0tLSpfX2xhYmVsJyxcbiAgJy5saXN0LWl0ZW1fX3RpdGxlJzogJ2xpc3QtaXRlbS0tKl9fdGl0bGUnLFxuICAnLmxpc3QtaXRlbV9fc3VidGl0bGUnOiAnbGlzdC1pdGVtLS0qX19zdWJ0aXRsZScsXG4gICcubGlzdC1pdGVtX190aHVtYm5haWwnOiAnbGlzdC1pdGVtLS0qX190aHVtYm5haWwnLFxuICAnLmxpc3QtaXRlbV9faWNvbic6ICdsaXN0LWl0ZW0tLSpfX2ljb24nXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6IFNsaWRlTGlzdEl0ZW1BbmltYXRvcixcbiAgJ25vbmUnOiBMaXN0SXRlbUFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1saXN0LWl0ZW1cbiAqIEBjYXRlZ29yeSBsaXN0XG4gKiBAbW9kaWZpZXIgdGFwcGFibGVcbiAqICAgW2VuXU1ha2UgdGhlIGxpc3QgaXRlbSBjaGFuZ2UgYXBwZWFyYW5jZSB3aGVuIGl0J3MgdGFwcGVkLiBPbiBpT1MgaXQgaXMgYmV0dGVyIHRvIHVzZSB0aGUgXCJ0YXBwYWJsZVwiIGFuZCBcInRhcC1iYWNrZ3JvdW5kLWNvbG9yXCIgYXR0cmlidXRlIGZvciBiZXR0ZXIgYmVoYXZpb3Igd2hlbiBzY3JvbGxpbmcuWy9lbl1cbiAqICAgW2phXeOCv+ODg+ODl+OChOOCr+ODquODg+OCr+OBl+OBn+aZguOBq+WKueaenOOBjOihqOekuuOBleOCjOOCi+OCiOOBhuOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgY2hldnJvblxuICogICBbZW5dRGlzcGxheSBhIGNoZXZyb24gYXQgdGhlIHJpZ2h0IGVuZCBvZiB0aGUgbGlzdCBpdGVtIGFuZCBtYWtlIGl0IGNoYW5nZSBhcHBlYXJhbmNlIHdoZW4gdGFwcGVkLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIGxvbmdkaXZpZGVyXG4gKiAgIFtlbl1EaXNwbGF5cyBhIGxvbmcgaG9yaXpvbnRhbCBkaXZpZGVyIGJldHdlZW4gaXRlbXMuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbm9kaXZpZGVyXG4gKiAgIFtlbl1SZW1vdmVzIHRoZSBkaXZpZGVyIGJldHdlZW4gbGlzdCBpdGVtcy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dRGlzcGxheSBhIE1hdGVyaWFsIERlc2lnbiBsaXN0IGl0ZW0uWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIENvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgZWFjaCBpdGVtIGluIGEgbGlzdC4gVGhlIGxpc3QgaXRlbSBpcyBjb21wb3NlZCBvZiBmb3VyIHBhcnRzIHRoYXQgYXJlIHJlcHJlc2VudGVkIHdpdGggdGhlIGBsZWZ0YCwgYGNlbnRlcmAsIGByaWdodGAgYW5kIGBleHBhbmRhYmxlLWNvbnRlbnRgIGNsYXNzZXMuIFRoZXNlIGNsYXNzZXMgY2FuIGJlIHVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGNvbnRlbnQgb2YgdGhlIGxpc3QgaXRlbXMgaXMgcHJvcGVybHkgYWxpZ25lZC5cbiAqXG4gKiAgICAgYGBgXG4gKiAgICAgPG9ucy1saXN0LWl0ZW0+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwibGVmdFwiPkxlZnQ8L2Rpdj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5DZW50ZXI8L2Rpdj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlJpZ2h0PC9kaXY+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiZXhwYW5kYWJsZS1jb250ZW50XCI+RXhwYW5kYWJsZSBjb250ZW50PC9kaXY+XG4gKiAgICAgPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIGBgYFxuICpcbiAqICAgICBUaGVyZSBhcmUgYWxzbyBhIG51bWJlciBvZiBjbGFzc2VzIChwcmVmaXhlZCB3aXRoIGBsaXN0LWl0ZW1fXypgKSB0aGF0IGhlbHAgd2hlbiBwdXR0aW5nIHRoaW5ncyBsaWtlIGljb25zIGFuZCB0aHVtYm5haWxzIGludG8gdGhlIGxpc3QgaXRlbXMuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLWxpc3RcbiAqICAgW2VuXW9ucy1saXN0IGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGlzdOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1oZWFkZXJcbiAqICAgW2VuXW9ucy1saXN0LWhlYWRlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaGVhZGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBjb2RlcGVuIHl4Y0N0XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbGlzdFxuICogQGV4YW1wbGVcbiAqIDxvbnMtbGlzdC1pdGVtPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtaWNvbiBpY29uPVwibWQtZmFjZVwiIGNsYXNzPVwibGlzdC1pdGVtX19pY29uXCI+PC9vbnMtaWNvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICA8ZGl2IGNsYXNzPVwibGlzdC1pdGVtX190aXRsZVwiPlRpdGxlPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxpc3QtaXRlbV9fc3VidGl0bGVcIj5TdWJ0aXRsZTwvZGl2PlxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgPG9ucy1zd2l0Y2g+PC9vbnMtc3dpdGNoPlxuICogICA8L2Rpdj5cbiAqIDwvb25zLWxpc3QtaXRlbT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdEl0ZW1FbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGlmaWVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgbGlzdCBpdGVtLlsvZW5dXG4gICAqICAgW2phXeWQhOimgee0oOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGxvY2stb24tZHJhZ1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUHJldmVudCB2ZXJ0aWNhbCBzY3JvbGxpbmcgd2hlbiB0aGUgdXNlciBkcmFncyBob3Jpem9udGFsbHkuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL44Go44CB44Om44O844K244O844GM44GT44Gu6KaB57Sg44KS5qiq5pa55ZCR44Gr44OJ44Op44OD44Kw44GX44Gm44GE44KL5pmC44Gr44CB57im5pa55ZCR44Gu44K544Kv44Ot44O844Or44GM6LW344GN44Gq44GE44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGFwcGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1NYWtlcyB0aGUgZWxlbWVudCByZWFjdCB0byB0YXBzLiBgcHJldmVudC10YXBgIGF0dHJpYnV0ZSBjYW4gYmUgYWRkZWQgdG8gY2hpbGQgZWxlbWVudHMgbGlrZSBidXR0b25zIG9yIGlucHV0cyB0byBwcmV2ZW50IHRoaXMgZWZmZWN0LiBgb25zLSpgIGVsZW1lbnRzIGFyZSBpZ25vcmVkIGJ5IGRlZmF1bHQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGFwLWJhY2tncm91bmQtY29sb3JcbiAgICogQHR5cGUge0NvbG9yfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dIENoYW5nZXMgdGhlIGJhY2tncm91bmQgY29sb3Igd2hlbiB0YXBwZWQuIEZvciB0aGlzIHRvIHdvcmssIHRoZSBhdHRyaWJ1dGUgXCJ0YXBwYWJsZVwiIG5lZWRzIHRvIGJlIHNldC4gVGhlIGRlZmF1bHQgY29sb3IgaXMgXCIjZDlkOWQ5XCIuIEl0IHdpbGwgZGlzcGxheSBhcyBhIHJpcHBsZSBlZmZlY3Qgb24gQW5kcm9pZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBleHBhbmRhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTWFrZXMgdGhlIGVsZW1lbnQgYWJsZSB0byBiZSBleHBhbmRlZCB0byByZXZlYWwgZXh0cmEgY29udGVudC4gRm9yIHRoaXMgdG8gd29yaywgdGhlIGV4cGFuZGFibGUgY29udGVudCBtdXN0IGJlIGRlZmluZWQgaW4gYGRpdi5leHBhbmRhYmxlLWNvbnRlbnRgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgZXhwYW5kYWJsZSBjb250ZW50LiBDYW4gYmUgZWl0aGVyIGBcImRlZmF1bHRcImAgb3IgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgICB0aGlzLnRvZ2dsZUV4cGFuc2lvbiA9IHRoaXMudG9nZ2xlRXhwYW5zaW9uLmJpbmQodGhpcyk7XG5cbiAgICAvLyBFbGVtZW50cyBpZ25vcmVkIHdoZW4gdGFwcGluZ1xuICAgIGNvbnN0IHJlID0gL15vbnMtKD8hY29sJHxyb3ckfGlmJCkvaTtcbiAgICB0aGlzLl9zaG91bGRJZ25vcmVUYXAgPSBlID0+IGUuaGFzQXR0cmlidXRlKCdwcmV2ZW50LXRhcCcpIHx8IHJlLnRlc3QoZS50YWdOYW1lKTtcblxuICAgIC8vIHNob3cgYW5kIGhpZGUgZnVuY3Rpb25zIGZvciBWdWUgaGlkYWJsZSBtaXhpblxuICAgIHRoaXMuc2hvdyA9IHRoaXMuc2hvd0V4cGFuc2lvbjtcbiAgICB0aGlzLmhpZGUgPSB0aGlzLmhpZGVFeHBhbnNpb247XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29tcGlsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICBpZih0aGlzLmhhc0F0dHJpYnV0ZSgnZXhwYW5kYWJsZScpKSB7XG4gICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2xpc3QtaXRlbS0tZXhwYW5kYWJsZScpO1xuICAgIH1cblxuICAgIGxldCBsZWZ0LCBjZW50ZXIsIHJpZ2h0LCBleHBhbmRhYmxlQ29udGVudDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWwgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdsZWZ0JykpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbGlzdC1pdGVtX19sZWZ0Jyk7XG4gICAgICAgIGxlZnQgPSBlbDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnY2VudGVyJykpIHtcbiAgICAgICAgY2VudGVyID0gZWw7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ3JpZ2h0JykpIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnbGlzdC1pdGVtX19yaWdodCcpO1xuICAgICAgICByaWdodCA9IGVsO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdleHBhbmRhYmxlLWNvbnRlbnQnKSkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdsaXN0LWl0ZW1fX2V4cGFuZGFibGUtY29udGVudCcpO1xuICAgICAgICBleHBhbmRhYmxlQ29udGVudCA9IGVsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcmlnaHQgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2V4cGFuZGFibGUnKSkge1xuICAgICAgcmlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHJpZ2h0LmNsYXNzTGlzdC5hZGQoJ2xpc3QtaXRlbV9fcmlnaHQnLCAncmlnaHQnKTtcblxuICAgICAgLy8gV2UgY2Fubm90IHVzZSBhIHBzZXVkby1lbGVtZW50IGZvciB0aGlzIGNoZXZyb24sIGFzIHdlIGNhbm5vdCBhbmltYXRlIGl0IHVzaW5nXG4gICAgICAvLyBKUy4gU28sIHdlIG1ha2UgYSBjaGV2cm9uIHNwYW4gaW5zdGVhZC5cbiAgICAgIGNvbnN0IGNoZXZyb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICBjaGV2cm9uLmNsYXNzTGlzdC5hZGQoJ2xpc3QtaXRlbV9fZXhwYW5kLWNoZXZyb24nKTtcbiAgICAgIHJpZ2h0LmFwcGVuZENoaWxkKGNoZXZyb24pO1xuICAgIH1cblxuICAgIGlmICghY2VudGVyKSB7XG4gICAgICBjZW50ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgaWYgKCFsZWZ0ICYmICFyaWdodCAmJiAhZXhwYW5kYWJsZUNvbnRlbnQpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICAgIGNlbnRlci5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgZWwgPSB0aGlzLmNoaWxkTm9kZXNbaV07XG4gICAgICAgICAgaWYgKGVsICE9PSBsZWZ0ICYmIGVsICE9PSByaWdodCAmJiBlbCAhPT0gZXhwYW5kYWJsZUNvbnRlbnQgJiYgZWwudGFnTmFtZSAhPT0gJ09OUy1SSVBQTEUnKSB7XG4gICAgICAgICAgICBjZW50ZXIuaW5zZXJ0QmVmb3JlKGVsLCBjZW50ZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCFleHBhbmRhYmxlQ29udGVudCkge1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShjZW50ZXIsIHJpZ2h0IHx8IG51bGwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCdjZW50ZXInLCAnbGlzdC1pdGVtX19jZW50ZXInKTtcblxuICAgIGlmKGV4cGFuZGFibGVDb250ZW50KSB7XG4gICAgICAvLyBjcmVhdGUgJ3RvcCcgZGl2XG4gICAgICAvLyB0aGlzIGhvbGRzIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBleHBhbmRhYmxlIGNvbnRlbnRcbiAgICAgIHRoaXMuX3RvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5fdG9wLmNsYXNzTGlzdC5hZGQoJ3RvcCcsICdsaXN0LWl0ZW1fX3RvcCcpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl90b3ApO1xuXG4gICAgICB0aGlzLl90b3AuYXBwZW5kQ2hpbGQoY2VudGVyKTtcbiAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgIHRoaXMuX3RvcC5hcHBlbmRDaGlsZChsZWZ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChyaWdodCkge1xuICAgICAgICB0aGlzLl90b3AuYXBwZW5kQ2hpbGQocmlnaHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd0V4cGFuc2lvblxuICAgKiBAc2lnbmF0dXJlIHNob3dFeHBhbnNpb24oKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgZXhwYW5kYWJsZSBjb250ZW50IGlmIHRoZSBlbGVtZW50IGlzIGV4cGFuZGFibGUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNob3dFeHBhbnNpb24oKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdleHBhbmRhYmxlJykgJiYgIXRoaXMuX2V4cGFuZGluZykge1xuICAgICAgdGhpcy5leHBhbmRlZCA9IHRydWU7XG4gICAgICB0aGlzLl9leHBhbmRpbmcgPSB0cnVlO1xuXG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcigpO1xuICAgICAgYW5pbWF0b3Iuc2hvd0V4cGFuc2lvbih0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZXhwYW5kZWQnKTtcbiAgICAgICAgdGhpcy5fZXhwYW5kaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlRXhwYW5zaW9uXG4gICAqIEBzaWduYXR1cmUgaGlkZUV4cGFuc2lvbigpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBleHBhbmRhYmxlIGNvbnRlbnQgaWYgdGhlIGVsZW1lbnQgZXhwYW5kYWJsZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgaGlkZUV4cGFuc2lvbigpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2V4cGFuZGFibGUnKSAmJiAhdGhpcy5fZXhwYW5kaW5nKSB7XG4gICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9leHBhbmRpbmcgPSB0cnVlO1xuXG4gICAgICBjb25zdCBhbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcigpO1xuICAgICAgYW5pbWF0b3IuaGlkZUV4cGFuc2lvbih0aGlzLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgnZXhwYW5kZWQnKTtcbiAgICAgICAgdGhpcy5fZXhwYW5kaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB0b2dnbGVFeHBhbnNpb24oKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ2V4cGFuZGVkJykgPyB0aGlzLmhpZGVFeHBhbnNpb24oKSA6IHRoaXMuc2hvd0V4cGFuc2lvbigpO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IExpc3RJdGVtQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTGlzdEl0ZW1BbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJykgfHwgJ2RlZmF1bHQnXG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcycsICdyaXBwbGUnLCAnYW5pbWF0aW9uJ107XG4gIH1cblxuICBnZXQgZXhwYW5kYWJsZUNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmxpc3QtaXRlbV9fZXhwYW5kYWJsZS1jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgZXhwYW5kQ2hldnJvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcubGlzdC1pdGVtX19leHBhbmQtY2hldnJvbicpO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yRmFjdG9yeSA9IHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnModHJ1ZSk7XG4gICAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuICAgICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKGZhbHNlKTtcbiAgfVxuXG4gIF9zZXR1cExpc3RlbmVycyhhZGQpIHtcbiAgICBjb25zdCBhY3Rpb24gPSAoYWRkID8gJ2FkZCcgOiAncmVtb3ZlJykgKyAnRXZlbnRMaXN0ZW5lcic7XG4gICAgdXRpbFthY3Rpb25dKHRoaXMsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIHV0aWxbYWN0aW9uXSh0aGlzLCAndG91Y2htb3ZlJywgdGhpcy5fb25SZWxlYXNlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgdGhpc1thY3Rpb25dKCd0b3VjaGNhbmNlbCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpc1thY3Rpb25dKCd0b3VjaGVuZCcsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgdGhpc1thY3Rpb25dKCd0b3VjaGxlYXZlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzW2FjdGlvbl0oJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIHRoaXNbYWN0aW9uXSgnbW91c2Vkb3duJywgdGhpcy5fb25Ub3VjaCk7XG4gICAgdGhpc1thY3Rpb25dKCdtb3VzZXVwJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgICB0aGlzW2FjdGlvbl0oJ21vdXNlb3V0JywgdGhpcy5fb25SZWxlYXNlKTtcblxuICAgIGlmKHRoaXMuX3RvcCkge1xuICAgICAgdGhpcy5fdG9wW2FjdGlvbl0oJ2NsaWNrJywgdGhpcy50b2dnbGVFeHBhbnNpb24pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRyYWcoZXZlbnQpIHtcbiAgICBjb25zdCBnZXN0dXJlID0gZXZlbnQuZ2VzdHVyZTtcbiAgICAvLyBQcmV2ZW50IHZlcnRpY2FsIHNjcm9sbGluZyBpZiB0aGUgdXNlcnMgcGFucyBsZWZ0IG9yIHJpZ2h0LlxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnbG9jay1vbi1kcmFnJykgJiYgWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihnZXN0dXJlLmRpcmVjdGlvbikgPiAtMSkge1xuICAgICAgZ2VzdHVyZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIF9vblRvdWNoKGUpIHtcbiAgICBpZiAodGhpcy50YXBwZWQgfHxcbiAgICAgICh0aGlzICE9PSBlLnRhcmdldCAmJiAodGhpcy5fc2hvdWxkSWdub3JlVGFwKGUudGFyZ2V0KSB8fCB1dGlsLmZpbmRQYXJlbnQoZS50YXJnZXQsIHRoaXMuX3Nob3VsZElnbm9yZVRhcCwgcCA9PiBwID09PSB0aGlzKSkpXG4gICAgKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSB0YXBcbiAgICB9XG5cbiAgICB0aGlzLnRhcHBlZCA9IHRydWU7XG4gICAgY29uc3QgdG91Y2hTdHlsZSA9IHsgdHJhbnNpdGlvbjogJ2JhY2tncm91bmQtY29sb3IgMC4wcyBsaW5lYXIgMC4wMnMsIGJveC1zaGFkb3cgMC4wcyBsaW5lYXIgMC4wMnMnIH07XG5cbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3RhcHBhYmxlJykpIHtcbiAgICAgIGlmICh0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB0aGlzLl9vcmlnaW5hbEJhY2tncm91bmRDb2xvciA9IHRoaXMuc3R5bGUuYmFja2dyb3VuZENvbG9yO1xuICAgICAgfVxuXG4gICAgICB0b3VjaFN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0YXAtYmFja2dyb3VuZC1jb2xvcicpIHx8ICcjZDlkOWQ5JztcbiAgICAgIHRvdWNoU3R5bGUuYm94U2hhZG93ID0gYDBweCAtMXB4IDBweCAwcHggJHt0b3VjaFN0eWxlLmJhY2tncm91bmRDb2xvcn1gO1xuICAgIH1cblxuICAgIHN0eWxlcih0aGlzLCB0b3VjaFN0eWxlKTtcbiAgfVxuXG4gIF9vblJlbGVhc2UoKSB7XG4gICAgdGhpcy50YXBwZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX29yaWdpbmFsQmFja2dyb3VuZENvbG9yIHx8ICcnO1xuICAgIHN0eWxlci5jbGVhcih0aGlzLCAndHJhbnNpdGlvbiBib3hTaGFkb3cnKTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5MaXN0SXRlbSA9IExpc3RJdGVtRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWxpc3QtaXRlbScsIExpc3RJdGVtRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdsaXN0JztcbmNvbnN0IHNjaGVtZSA9IHsnJzogJ2xpc3QtLSonfTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtbGlzdFxuICogQGNhdGVnb3J5IGxpc3RcbiAqIEBtb2RpZmllciBpbnNldFxuICogICBbZW5dSW5zZXQgbGlzdCB0aGF0IGRvZXNuJ3QgY292ZXIgdGhlIHdob2xlIHdpZHRoIG9mIHRoZSBwYXJlbnQuWy9lbl1cbiAqICAgW2phXeimquimgee0oOOBrueUu+mdouOBhOOBo+OBseOBhOOBq+W6g+OBjOOCieOBquOBhOODquOCueODiOOCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbm9ib3JkZXJcbiAqICAgW2VuXUEgbGlzdCB3aXRoIG5vIGJvcmRlcnMgYXQgdGhlIHRvcCBhbmQgYm90dG9tLlsvZW5dXG4gKiAgIFtqYV3jg6rjgrnjg4jjga7kuIrkuIvjga7jg5zjg7zjg4Djg7zjgYznhKHjgYTjg6rjgrnjg4jjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1Db21wb25lbnQgdG8gZGVmaW5lIGEgbGlzdCwgYW5kIHRoZSBjb250YWluZXIgZm9yIG9ucy1saXN0LWl0ZW0ocykuWy9lbl1cbiAqICAgW2phXeODquOCueODiOOCkuihqOePvuOBmeOCi+OBn+OCgeOBruOCs+ODs+ODneODvOODjeODs+ODiOOAgm9ucy1saXN0LWl0ZW3jga7jgrPjg7Pjg4bjg4rjgajjgZfjgabkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICogQHNlZWFsc28gb25zLWxpc3QtaXRlbVxuICogICBbZW5db25zLWxpc3QtaXRlbSBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaXRlbeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtbGlzdC1oZWFkZXJcbiAqICAgW2VuXW9ucy1saXN0LWhlYWRlciBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWxpc3QtaGVhZGVy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1sYXp5LXJlcGVhdFxuICogICBbZW5db25zLWxhenktcmVwZWF0IGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtbGF6eS1yZXBlYXTjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGNvZGVwZW4geXhjQ3RcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9saXN0XG4gKiBAZXhhbXBsZVxuICogPG9ucy1saXN0PlxuICogICA8b25zLWxpc3QtaGVhZGVyPkhlYWRlciBUZXh0PC9vbnMtbGlzdC1oZWFkZXI+XG4gKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gKiAgIDxvbnMtbGlzdC1pdGVtPkl0ZW08L29ucy1saXN0LWl0ZW0+XG4gKiA8L29ucy1saXN0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxpc3QuWy9lbl1cbiAgICogICBbamFd44Oq44K544OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxub25zRWxlbWVudHMuTGlzdCA9IExpc3RFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbGlzdCcsIExpc3RFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IElOUFVUX0FUVFJJQlVURVMgPSBbXG4gICdhdXRvY2FwaXRhbGl6ZScsXG4gICdhdXRvY29tcGxldGUnLFxuICAnYXV0b2NvcnJlY3QnLFxuICAnYXV0b2ZvY3VzJyxcbiAgJ2Rpc2FibGVkJyxcbiAgJ2lucHV0bW9kZScsXG4gICdtYXgnLFxuICAnbWF4bGVuZ3RoJyxcbiAgJ21pbicsXG4gICdtaW5sZW5ndGgnLFxuICAnbmFtZScsXG4gICdwYXR0ZXJuJyxcbiAgJ3BsYWNlaG9sZGVyJyxcbiAgJ3JlYWRvbmx5JyxcbiAgJ3JlcXVpcmVkJyxcbiAgJ3NpemUnLFxuICAnc3RlcCcsXG4gICd2YWxpZGF0b3InLFxuICAndmFsdWUnXG5dO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlSW5wdXRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIF91cGRhdGUoKSB7fSAvLyBPcHRpb25hbGx5IGltcGxlbWVudGVkXG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICB1dGlsLnRocm93TWVtYmVyKCk7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICB1dGlsLnRocm93TWVtYmVyKCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VJbnB1dEVsZW1lbnQpIHtcbiAgICAgIHV0aWwudGhyb3dBYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICAgIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCA9IHRoaXMuX2RlbGVnYXRlRXZlbnQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuX2RlZmF1bHRDbGFzc05hbWUgJiYgdGhpcy5jbGFzc0xpc3QuYWRkKHRoaXMuX2RlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hcHBlbmRDaGlsZCh1dGlsLmNyZWF0ZUZyYWdtZW50KHRoaXMuX3RlbXBsYXRlKSk7XG5cbiAgICB0aGlzLl9zZXRJbnB1dElkKCk7XG5cbiAgICB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKTtcblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIF91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSB7XG4gICAgSU5QVVRfQVRUUklCVVRFUy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHRoaXMuX2lucHV0LnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmdldEF0dHJpYnV0ZShhdHRyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgfVxuXG4gIF9kZWxlZ2F0ZUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZSA9IG5ldyBDdXN0b21FdmVudChldmVudC50eXBlLCB7XG4gICAgICBidWJibGVzOiBmYWxzZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gIH1cblxuICBfc2V0SW5wdXRJZCgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2lucHV0LWlkJykpIHtcbiAgICAgIHRoaXMuX2lucHV0LmlkID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2lucHV0LWlkJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGdldCBfaW5wdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgfVxuXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQgPT09IG51bGxcbiAgICAgID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJylcbiAgICAgIDogdGhpcy5faW5wdXQudmFsdWU7XG4gIH1cblxuICBzZXQgdmFsdWUodmFsKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHZhbCA9IHZhbC50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHZhbDtcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZERlbGVnYXRlRXZlbnQpO1xuICAgICAgdGhpcy5faW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JvdW5kRGVsZWdhdGVFdmVudCk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdpbnB1dC1pZCcsICdjbGFzcycsIC4uLklOUFVUX0FUVFJJQlVURVNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCB0aGlzLl9zY2hlbWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dC1pZCc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9zZXRJbnB1dElkKCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgdGhpcy5fZGVmYXVsdENsYXNzTmFtZSwgdGhpcy5fc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKElOUFVUX0FUVFJJQlVURVMuaW5kZXhPZihuYW1lKSA+PSAwKSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VJbnB1dEVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtaW5wdXQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy50ZXh0LWlucHV0JzogJ3RleHQtaW5wdXQtLSonLFxuICAnLnRleHQtaW5wdXRfX2xhYmVsJzogJ3RleHQtaW5wdXQtLSpfX2xhYmVsJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtaW5wdXRcbiAqIEBjYXRlZ29yeSBmb3JtXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICBbZW5dRGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB1bmRlcmJhclxuICogIFtlbl1EaXNwbGF5cyBhIGhvcml6b250YWwgbGluZSB1bmRlcm5lYXRoIGEgdGV4dCBpbnB1dC5bL2VuXVxuICogIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIHRyYW5zcGFyZW50XG4gKiAgW2VuXURpc3BsYXlzIGEgdHJhbnNwYXJlbnQgaW5wdXQuIFdvcmtzIGZvciBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEFuIGlucHV0IGVsZW1lbnQuIFRoZSBgdHlwZWAgYXR0cmlidXRlIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSB0aGUgaW5wdXQgdHlwZS4gQWxsIHRleHQgaW5wdXQgdHlwZXMgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiAgICBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSByZW5kZXIgYXMgYSBNYXRlcmlhbCBEZXNpZ24gaW5wdXQgb24gQW5kcm9pZCBkZXZpY2VzLlxuICpcbiAqICAgIE1vc3QgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBhIG5vcm1hbCBgPGlucHV0PmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1pbnB1dD5gIGVsZW1lbnQuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9pbnB1dFxuICogQHNlZWFsc28gb25zLWNoZWNrYm94XG4gKiAgIFtlbl1UaGUgYDxvbnMtY2hlY2tib3g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGNoZWNrYm94LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXJhZGlvXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFkaW8+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhZGlvIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYW5nZVxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zZWxlY3RcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWxlY3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlbGVjdCBib3guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWlucHV0IHBsYWNlaG9sZGVyPVwiVXNlcm5hbWVcIiBmbG9hdD48L29ucy1pbnB1dD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5wdXRFbGVtZW50IGV4dGVuZHMgQmFzZUlucHV0RWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JvdW5kT25JbnB1dCA9IHRoaXMuX3VwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2JvdW5kT25Gb2N1c2luID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcyk7XG4gIH1cblxuICAvKiBJbmhlcml0ZWQgcHJvcHMgKi9cblxuICBfdXBkYXRlKCkge1xuICAgIHRoaXMuX3VwZGF0ZUxhYmVsKCk7XG4gICAgdGhpcy5fdXBkYXRlTGFiZWxDbGFzcygpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIGBcbiAgICAgIDxpbnB1dCB0eXBlPVwiJHt0aGlzLnR5cGV9XCIgY2xhc3M9XCJ0ZXh0LWlucHV0XCI+XG4gICAgICA8c3BhbiBjbGFzcz1cInRleHQtaW5wdXRfX2xhYmVsXCI+PC9zcGFuPlxuICAgIGA7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICByZXR1cm4gKFsnY2hlY2tib3gnLCAncmFkaW8nXS5pbmRleE9mKHR5cGUpIDwgMCkgJiYgdHlwZSB8fCAndGV4dCc7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBfdXBkYXRlTGFiZWwoKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInKSB8fCAnJztcblxuICAgIGlmICh0eXBlb2YgdGhpcy5faGVscGVyLnRleHRDb250ZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5faGVscGVyLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2hlbHBlci5pbm5lclRleHQgPSBsYWJlbDtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTGFiZWxDbGFzcygpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHRoaXMuX2hlbHBlci5jbGFzc0xpc3QucmVtb3ZlKCd0ZXh0LWlucHV0LS1tYXRlcmlhbF9fbGFiZWwtLWFjdGl2ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oZWxwZXIuY2xhc3NMaXN0LmFkZCgndGV4dC1pbnB1dC0tbWF0ZXJpYWxfX2xhYmVsLS1hY3RpdmUnKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX2hlbHBlcigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fYm91bmRPbklucHV0KTtcbiAgICAgIHRoaXMuX2lucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLl9ib3VuZE9uRm9jdXNpbik7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcbiAgICBpZiAoWydjaGVja2JveCcsICdyYWRpbyddLmluZGV4T2YodHlwZSkgPj0gMCkge1xuICAgICAgdXRpbC53YXJuKGBXYXJuOiA8b25zLWlucHV0IHR5cGU9XCIke3R5cGV9XCI+IGlzIGRlcHJlY2F0ZWQgc2luY2UgdjIuNC4wLiBVc2UgPG9ucy0ke3R5cGV9PiBpbnN0ZWFkLmApXG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX2JvdW5kT25JbnB1dCk7XG4gICAgICB0aGlzLl9pbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5fYm91bmRPbkZvY3VzaW4pO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsICd0eXBlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9pbnB1dC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCB0aGlzLnR5cGUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGxhY2Vob2xkZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBsYWNlaG9sZGVyIHRleHQuIEluIE1hdGVyaWFsIERlc2lnbiwgdGhpcyBwbGFjZWhvbGRlciB3aWxsIGJlIGEgZmxvYXRpbmcgbGFiZWwuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZmxvYXRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgcHJlc2VudCwgdGhlIHBsYWNlaG9sZGVyIHdpbGwgYmUgYW5pbWF0ZWQgaW4gTWF0ZXJpYWwgRGVzaWduLlsvZW5dXG4gICAqICBbamFd44GT44Gu5bGe5oCn44GM6Kit5a6a44GV44KM44Gf5pmC44CB44Op44OZ44Or44Gv44Ki44OL44Oh44O844K344On44Oz44GZ44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdHlwZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1cbiAgICogICAgU3BlY2lmeSB0aGUgaW5wdXQgdHlwZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgXCJ0eXBlXCIgYXR0cmlidXRlIGZvciBub3JtYWwgaW5wdXRzLiBJdCBleHBlY3RzIHN0cmljdCB0ZXh0IHR5cGVzIHN1Y2ggYXMgYHRleHRgLCBgcGFzc3dvcmRgLCBldGMuIEZvciBjaGVja2JveCwgcmFkaW8gYnV0dG9uLCBzZWxlY3Qgb3IgcmFuZ2UsIHBsZWFzZSBoYXZlIGEgbG9vayBhdCB0aGUgY29ycmVzcG9uZGluZyBlbGVtZW50cy5cbiAgICpcbiAgICogICAgUGxlYXNlIHRha2UgYSBsb29rIGF0IFtNRE5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dCNhdHRyLXR5cGUpIGZvciBhbiBleGhhdXN0aXZlIGxpc3Qgb2YgcG9zc2libGUgdmFsdWVzLiBEZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtIGFuZCBicm93c2VyIHZlcnNpb24gc29tZSBvZiB0aGVzZSBtaWdodCBub3Qgd29yay5cbiAgICogIFsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5wdXQtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgXCJpZFwiIGF0dHJpYnV0ZSBvZiB0aGUgaW5uZXIgYDxpbnB1dD5gIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYDxsYWJlbCBmb3I9XCIuLi5cIj5gIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBpbnB1dCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG59XG5cbm9uc0VsZW1lbnRzLklucHV0ID0gSW5wdXRFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtaW5wdXQnLCBJbnB1dEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBCYXNlSW5wdXRFbGVtZW50IGZyb20gJy4vYmFzZS1pbnB1dCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZUNoZWNrYm94RWxlbWVudCBleHRlbmRzIEJhc2VJbnB1dEVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUNoZWNrYm94RWxlbWVudCkge1xuICAgICAgdXRpbC50aHJvd0Fic3RyYWN0KCk7XG4gICAgfVxuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdjaGVja2VkJywgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiBJbmhlcml0ZWQgcHJvcHMgKi9cblxuICBnZXQgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8aW5wdXQgdHlwZT1cIiR7dGhpcy50eXBlfVwiIGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9faW5wdXRcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9fY2hlY2ttYXJrXCI+PC9zcGFuPlxuICAgIGA7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBnZXQgX2hlbHBlcigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gIH1cblxuICBnZXQgY2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQuY2hlY2tlZDtcbiAgfVxuXG4gIHNldCBjaGVja2VkKHZhbCkge1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9pbnB1dC5jaGVja2VkID0gdmFsO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsuLi5zdXBlci5vYnNlcnZlZEF0dHJpYnV0ZXMsICdjaGVja2VkJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VDaGVja2JveEVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtY2hlY2tib3gnO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcuY2hlY2tib3gnOiAnY2hlY2tib3gtLSonLFxuICAnLmNoZWNrYm94X19pbnB1dCc6ICdjaGVja2JveC0tKl9faW5wdXQnLFxuICAnLmNoZWNrYm94X19jaGVja21hcmsnOiAnY2hlY2tib3gtLSpfX2NoZWNrbWFyaydcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLWNoZWNrYm94XG4gKiBAY2F0ZWdvcnkgZm9ybVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgW2VuXURpc3BsYXlzIGEgTWF0ZXJpYWwgRGVzaWduIGNoZWNrYm94LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAbW9kaWZpZXIgbm9ib3JkZXJcbiAqICBbZW5daU9TIGJvcmRlcmxlc3MgY2hlY2tib3guWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEEgY2hlY2tib3ggZWxlbWVudC4gVGhlIGNvbXBvbmVudCB3aWxsIGF1dG9tYXRpY2FsbHkgcmVuZGVyIGFzIGEgTWF0ZXJpYWwgRGVzaWduIGNoZWNrYm94IG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqXG4gKiAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIj5gIGVsZW1lbnQgY2FuIGFsc28gYmUgdXNlZCBvbiB0aGUgYDxvbnMtY2hlY2tib3g+YCBlbGVtZW50LlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvY2hlY2tib3hcbiAqIEBzZWVhbHNvIG9ucy1zd2l0Y2hcbiAqICAgW2VuXVRoZSBgPG9ucy1zd2l0Y2g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGRyYWdnYWJsZSB0b2dnbGUgc3dpdGNoLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXJhZGlvXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFkaW8+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhZGlvIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1pbnB1dFxuICogICBbZW5dVGhlIGA8b25zLWlucHV0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSB0ZXh0IGlucHV0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXNlYXJjaC1pbnB1dFxuICogICBbZW5dVGhlIGA8b25zLXNlYXJjaC1pbnB1dD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgc2VhcmNoIGlucHV0LlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLXJhbmdlXG4gKiAgIFtlbl1UaGUgYDxvbnMtcmFuZ2U+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHJhbmdlIHNsaWRlci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zZWxlY3RcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWxlY3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlbGVjdCBib3guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWNoZWNrYm94IGNoZWNrZWQ+PC9vbnMtY2hlY2tib3g+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoZWNrYm94RWxlbWVudCBleHRlbmRzIEJhc2VDaGVja2JveEVsZW1lbnQge1xuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICdjaGVja2JveCc7XG4gIH1cblxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gJ2NoZWNrYm94JztcbiAgfVxuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIFwiaWRcIiBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGA8bGFiZWwgZm9yPVwiLi4uXCI+YCBlbGVtZW50cy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjaGVja2JveC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBjaGVja2JveCBpcyBjaGVja2VkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgY2hlY2tib3ggaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xufVxuXG5vbnNFbGVtZW50cy5DaGVja2JveCA9IENoZWNrYm94RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLWNoZWNrYm94JywgQ2hlY2tib3hFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlQ2hlY2tib3hFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWNoZWNrYm94JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnJhZGlvLWJ1dHRvbic6ICdyYWRpby1idXR0b24tLSonLFxuICAnLnJhZGlvLWJ1dHRvbl9faW5wdXQnOiAncmFkaW8tYnV0dG9uLS0qX19pbnB1dCcsXG4gICcucmFkaW8tYnV0dG9uX19jaGVja21hcmsnOiAncmFkaW8tYnV0dG9uLS0qX19jaGVja21hcmsnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yYWRpb1xuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiByYWRpbyBidXR0b24uWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEEgcmFkaW8gYnV0dG9uIGVsZW1lbnQuIFRoZSBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlbmRlciBhcyBhIE1hdGVyaWFsIERlc2lnbiByYWRpbyBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlxuICpcbiAqICAgIE1vc3QgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBhIG5vcm1hbCBgPGlucHV0IHR5cGU9XCJyYWRpb1wiPmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1yYWRpbz5gIGVsZW1lbnQuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9yYWRpb1xuICogQHNlZWFsc28gb25zLXNlbGVjdFxuICogICBbZW5dVGhlIGA8b25zLXNlbGVjdD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgc2VsZWN0IGJveC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1jaGVja2JveFxuICogICBbZW5dVGhlIGA8b25zLWNoZWNrYm94PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBjaGVja2JveC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zd2l0Y2hcbiAqICAgW2VuXVRoZSBgPG9ucy1zd2l0Y2g+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGRyYWdnYWJsZSB0b2dnbGUgc3dpdGNoLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHRleHQgaW5wdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc2VhcmNoLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtc2VhcmNoLWlucHV0PmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBzZWFyY2ggaW5wdXQuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcmFuZ2VcbiAqICAgW2VuXVRoZSBgPG9ucy1yYW5nZT5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFuZ2Ugc2xpZGVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1yYWRpbyBjaGVja2VkPjwvb25zLXJhZGlvPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRpb0VsZW1lbnQgZXh0ZW5kcyBCYXNlQ2hlY2tib3hFbGVtZW50IHtcblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAncmFkaW8tYnV0dG9uJztcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAncmFkaW8nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaW5wdXQtaWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgXCJpZFwiIGF0dHJpYnV0ZSBvZiB0aGUgaW5uZXIgYDxpbnB1dD5gIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgYDxsYWJlbCBmb3I9XCIuLi5cIj5gIGVsZW1lbnRzLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHJhZGlvIGJ1dHRvbi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSByYWRpbyBidXR0b24gaXMgY2hlY2tlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHJhZGlvIGJ1dHRvbiBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG59XG5cbm9uc0VsZW1lbnRzLlJhZGlvID0gUmFkaW9FbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcmFkaW8nLCBSYWRpb0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VJbnB1dEVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtaW5wdXQnO1xuXG5jb25zdCBzY2hlbWUgPSB7XG4gICcuc2VhcmNoLWlucHV0JzogJ3NlYXJjaC1pbnB1dC0tKidcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNlYXJjaC1pbnB1dFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBzZWFyY2ggaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIEEgc2VhcmNoIGlucHV0IGVsZW1lbnQuIFRoZSBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHJlbmRlciBhcyBhIE1hdGVyaWFsIERlc2lnbiBzZWFyY2ggaW5wdXQgb24gQW5kcm9pZCBkZXZpY2VzLlxuICpcbiAqICAgIE1vc3QgYXR0cmlidXRlcyB0aGF0IGNhbiBiZSB1c2VkIGZvciBhIG5vcm1hbCBgPGlucHV0PmAgZWxlbWVudCBjYW4gYWxzbyBiZSB1c2VkIG9uIHRoZSBgPG9ucy1zZWFyY2gtaW5wdXQ+YCBlbGVtZW50LlxuICogIFsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2Uvc2VhcmNoLWlucHV0XG4gKiBAc2VlYWxzbyBvbnMtaW5wdXRcbiAqICAgW2VuXVRoZSBgPG9ucy1pbnB1dD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgdGV4dCBpbnB1dC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1yYW5nZVxuICogICBbZW5dVGhlIGA8b25zLXJhbmdlPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSByYW5nZSBzbGlkZXIuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3dpdGNoXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3dpdGNoPmAgZWxlbWVudCBpcyB1c2VkIHRvIGRpc3BsYXkgYSBkcmFnZ2FibGUgdG9nZ2xlIHN3aXRjaC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zZWxlY3RcbiAqICAgW2VuXVRoZSBgPG9ucy1zZWxlY3Q+YCBlbGVtZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIHNlbGVjdCBib3guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtY2hlY2tib3hcbiAqICAgW2VuXVRoZSBgPG9ucy1jaGVja2JveD5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgY2hlY2tib3guWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcmFkaW9cbiAqICAgW2VuXVRoZSBgPG9ucy1yYWRpbz5gIGVsZW1lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgcmFkaW8gYnV0dG9uLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zZWFyY2gtaW5wdXQgcGxhY2Vob2xkZXI9XCJTZWFyY2hcIj48L29ucy1zZWFyY2gtaW5wdXQ+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaElucHV0RWxlbWVudCBleHRlbmRzIEJhc2VJbnB1dEVsZW1lbnQge1xuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBnZXQgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiBgXG4gICAgICA8aW5wdXQgdHlwZT1cIiR7dGhpcy50eXBlfVwiIGNsYXNzPVwic2VhcmNoLWlucHV0XCI+XG4gICAgYDtcbiAgfVxuXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiAnc2VhcmNoJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlucHV0LWlkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIFwiaWRcIiBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGA8bGFiZWwgZm9yPVwiLi4uXCI+YCBlbGVtZW50cy5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgaW5wdXQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xufVxuXG5vbnNFbGVtZW50cy5TZWFyY2hJbnB1dCA9IFNlYXJjaElucHV0RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNlYXJjaC1pbnB1dCcsIFNlYXJjaElucHV0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgQmFzZUFuaW1hdG9yIGZyb20gJy4uLy4uL29ucy9iYXNlLWFuaW1hdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWxBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cbiIsIlxuLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBNb2RhbEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWRlTW9kYWxBbmltYXRvciBleHRlbmRzIE1vZGFsQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuM30gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3cobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdChtb2RhbCwgdGhpcy5kZWYpXG4gICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0pXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwsIHRoaXMuZGVmKVxuICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAxIH0sIHsgb3BhY2l0eTogMCB9KVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBNb2RhbEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgbW9kYWwuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlmdE1vZGFsQW5pbWF0b3IgZXh0ZW5kcyBNb2RhbEFuaW1hdG9yXG57XG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKCAuMSwgLjcsIC4xLCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjR9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBzaG93KG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQobW9kYWwsIHRoaXMuZGVmKVxuICAgICAgLmRlZmF1bHQoXG4gICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMTAwJSwgMCknIH0sXG4gICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH1cbiAgICAgIClcbiAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSlcbiAgICAgIC5wbGF5KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbW9kYWxcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUobW9kYWwsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdChtb2RhbCwgdGhpcy5kZWYpXG4gICAgICAuZGVmYXVsdChcbiAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfSxcbiAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAxMDAlLCAwKScgfVxuICAgICAgKVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uLy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE1vZGFsQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgRmFkZU1vZGFsQW5pbWF0b3IgZnJvbSAnLi9mYWRlLWFuaW1hdG9yJztcbmltcG9ydCBMaWZ0TW9kYWxBbmltYXRvciBmcm9tICcuL2xpZnQtYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZURpYWxvZ0VsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWRpYWxvZyc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ21vZGFsLS0qJyxcbiAgJ21vZGFsX19jb250ZW50JzogJ21vZGFsLS0qX19jb250ZW50J1xufTtcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdtb2RhbCc7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogTW9kYWxBbmltYXRvcixcbiAgJ2ZhZGUnOiBGYWRlTW9kYWxBbmltYXRvcixcbiAgJ2xpZnQnOiBMaWZ0TW9kYWxBbmltYXRvcixcbiAgJ25vbmUnOiBNb2RhbEFuaW1hdG9yXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1tb2RhbFxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBNb2RhbCBjb21wb25lbnQgdGhhdCBtYXNrcyBjdXJyZW50IHNjcmVlbi4gVW5kZXJseWluZyBjb21wb25lbnRzIGFyZSBub3Qgc3ViamVjdCB0byBhbnkgZXZlbnRzIHdoaWxlIHRoZSBtb2RhbCBjb21wb25lbnQgaXMgc2hvd24uXG4gKlxuICogICAgIFRoaXMgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIGJsb2NrIHVzZXIgaW5wdXQgd2hpbGUgc29tZSBvcGVyYXRpb24gaXMgcnVubmluZyBvciB0byBzaG93IHNvbWUgaW5mb3JtYXRpb24gdG8gdGhlIHVzZXIuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1cbiAqICAgICDnlLvpnaLlhajkvZPjgpLjg57jgrnjgq/jgZnjgovjg6Ljg7zjg4Djg6vnlKjjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgILkuIvlgbTjgavjgYLjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjga/jgIFcbiAqICAgICDjg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozjgabjgYTjgovplpPjga/jgqTjg5njg7Pjg4jpgJrnn6XjgYzooYzjgo/jgozjgb7jgZvjgpPjgIJcbiAqICAgWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1kaWFsb2dcbiAqICAgW2VuXVRoZSBgPG9ucy1kaWFsb2c+YCBjb21wb25lbnQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgbW9kYWwgZGlhbG9nLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gZGV2SWdcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL3JlZmVyZW5jZS9tb2RhbFxuICogQGV4YW1wbGVcbiAqIDxvbnMtbW9kYWwgaWQ9XCJtb2RhbFwiPlxuICogICBNb2RhbCBjb250ZW50XG4gKiA8L29ucy1tb2RhbD5cbiAqIDxzY3JpcHQ+XG4gKiAgIHZhciBtb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2RhbCcpO1xuICogICBtb2RhbC5zaG93KCk7XG4gKiA8L3NjcmlwdD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kYWxFbGVtZW50IGV4dGVuZHMgQmFzZURpYWxvZ0VsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlc2hvd1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBtb2RhbCBpcyBkaXNwbGF5ZWQuWy9lbl1cbiAgICogW2phXeODouODvOODgOODq+OBjOihqOekuuOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5tb2RhbFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1FeGVjdXRlIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgbW9kYWwgZnJvbSBiZWluZyBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlrp/ooYzjgZnjgovjgajjgIHjg4DjgqTjgqLjg63jgrDjga7ooajnpLrjgYzjgq3jg6Pjg7Pjgrvjg6vjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RzaG93XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgbW9kYWwgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqIFtqYV3jg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozjgZ/nm7TlvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubW9kYWxcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHByZWhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgbW9kYWwgaXMgaGlkZGVuLlsvZW5dXG4gICAqIFtqYV3jg6Ljg7zjg4Djg6vjgYzpmqDjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubW9kYWxcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dRXhlY3V0ZSB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIG1vZGFsIGZyb20gYmVpbmcgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWun+ihjOOBmeOCi+OBqOOAgeODgOOCpOOCouODreOCsOOBrumdnuihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGhpZGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFtlbl1GaXJlZCBqdXN0IGFmdGVyIHRoZSBtb2RhbCBpcyBoaWRkZW4uWy9lbl1cbiAgICogW2phXeODouODvOODgOODq+OBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5tb2RhbFxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgbW9kYWwuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCwgYFwiZmFkZVwiYCBvciBgXCJsaWZ0XCJgLlsvZW5dXG4gICAqICBbamFd44Oi44O844OA44Or44KS6KGo56S644GZ44KL6Zqb44Gu44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCLjgoLjgZfjgY/jga9cImZhZGVcIixcImxpZnRcIuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4gPGNvZGU+e2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ308L2NvZGU+Wy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2RlZmF1bHREQkIgPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IE1vZGFsQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnTW9kYWxBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIF9jb21waWxlKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLnpJbmRleCA9IDEwMDAxO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQodGhpcywgJy5tb2RhbF9fY29udGVudCcpKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ21vZGFsX19jb250ZW50Jyk7XG5cbiAgICAgIHdoaWxlICh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgY29udGVudC5pbnNlcnRCZWZvcmUobm9kZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCB0aGlzLl9zY2hlbWUpO1xuICB9XG5cbiAgX3RvZ2dsZVN0eWxlKHNob3VsZFNob3cpIHtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBzaG91bGRTaG93ID8gJ3RhYmxlJyA6ICdub25lJztcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2aXNpYmxlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd6KaB57Sg44GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJub25lXCJgIGFuZCBgXCJmYWRlXCJgLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAglwibm9uZVwiLCBcImZhZGVcIuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYWZ0ZXIgdGhlIG1vZGFsIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TaG93IG1vZGFsLlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBkaXNwbGF5ZWQgZWxlbWVudFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcIm5vbmVcImAgYW5kIGBcImZhZGVcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJub25lXCIsIFwiZmFkZVwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciB0aGUgbW9kYWwgaGFzIGJlZW4gcmV2ZWFsZWQuWy9lbl1cbiAgICogICBbamFd44Oi44O844OA44Or44GM6KGo56S644GV44KM57WC44KP44Gj44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRvZ2dsZSBtb2RhbCB2aXNpYmlsaXR5LlsvZW5dXG4gICAqICAgW2phXeODouODvOODgOODq+OBruihqOekuuOCkuWIh+OCiuabv+OBiOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGhpZGVcbiAgICogQHNpZ25hdHVyZSBoaWRlKFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwibm9uZVwiYCBhbmQgYFwiZmFkZVwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcIm5vbmVcIiwgXCJmYWRlXCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBtb2RhbCBoYXMgYmVlbiByZXZlYWxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgYzooajnpLrjgZXjgozntYLjgo/jgaPjgZ/lvozjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSBtb2RhbC5bL2VuXVxuICAgKiAgIFtqYV3jg6Ljg7zjg4Djg6vjgpLpnZ7ooajnpLrjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWy4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIE1vZGFsQW5pbWF0b3IpKSB7XG4gICAgICB1dGlsLnRocm93QW5pbWF0b3IoJ01vZGFsJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBNb2RhbEFuaW1hdG9yKCkge1xuICAgIHJldHVybiBNb2RhbEFuaW1hdG9yO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLk1vZGFsID0gTW9kYWxFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtbW9kYWwnLCBNb2RhbEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi8uLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5cbmNvbnN0IHdpZHRoVG9QeCA9ICh3aWR0aCkgPT4ge1xuICBjb25zdCBbdmFsdWUsIHB4XSA9IFtwYXJzZUludCh3aWR0aCwgMTApLCAvcHgvLnRlc3Qod2lkdGgpXTtcbiAgcmV0dXJuIHB4ID8gdmFsdWUgOiBNYXRoLnJvdW5kKGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGggKiB2YWx1ZSAvIDEwMCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTd2lwZVJldmVhbCB7XG5cbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgJ2VsZW1lbnQgaWdub3JlU3dpcGUgaXNJbml0aWFsU3RhdGUgb25EcmFnQ2FsbGJhY2sgc3dpcGVNYXggc3dpcGVNaW4gc3dpcGVNaWQnXG4gICAgICAuc3BsaXQoL1xccysvKS5mb3JFYWNoKGtleSA9PiB0aGlzW2tleV0gPSBwYXJhbXNba2V5XSk7XG5cbiAgICB0aGlzLmVsZW1lbnRIYW5kbGVyID0gcGFyYW1zLmVsZW1lbnRIYW5kbGVyIHx8IHBhcmFtcy5lbGVtZW50O1xuICAgIHRoaXMuZ2V0VGhyZXNob2xkID0gcGFyYW1zLmdldFRocmVzaG9sZCB8fCAoKCkgPT4gLjUpO1xuICAgIHRoaXMuZ2V0U2lkZSA9IHBhcmFtcy5nZXRTaWRlIHx8ICgoKSA9PiAnbGVmdCcpO1xuXG4gICAgdGhpcy5oYW5kbGVHZXN0dXJlID0gdGhpcy5oYW5kbGVHZXN0dXJlLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9zaG91bGRGaXhTY3JvbGwgPSB1dGlsLmdsb2JhbHMuYWN0dWFsTW9iaWxlT1MgPT09ICdpb3MnO1xuICB9XG5cbiAgdXBkYXRlKHN3aXBlYWJsZSA9IHRoaXMuZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpKSB7XG4gICAgaWYgKCF0aGlzLmdlc3R1cmVEZXRlY3Rvcikge1xuICAgICAgdGhpcy5nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMuZWxlbWVudEhhbmRsZXIsIHsgZHJhZ01pbkRpc3RhbmNlOiAxLCBwYXNzaXZlOiAhdGhpcy5fc2hvdWxkRml4U2Nyb2xsIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGlvbiA9IHN3aXBlYWJsZSA/ICdvbicgOiAnb2ZmJztcbiAgICB0aGlzLmdlc3R1cmVEZXRlY3RvclthY3Rpb25dKCdkcmFnIGRyYWdzdGFydCBkcmFnZW5kJywgdGhpcy5oYW5kbGVHZXN0dXJlKTtcbiAgfVxuXG4gIGhhbmRsZUdlc3R1cmUoZSkge1xuICAgIGlmIChlLmdlc3R1cmUpIHtcbiAgICAgIGlmIChlLnR5cGUgPT09ICdkcmFnc3RhcnQnKSB7XG4gICAgICAgIHRoaXMub25EcmFnU3RhcnQoZSk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pZ25vcmVEcmFnKSB7XG4gICAgICAgIGUudHlwZSA9PT0gJ2RyYWdlbmQnID8gdGhpcy5vbkRyYWdFbmQoZSkgOiB0aGlzLm9uRHJhZyhlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkRyYWdTdGFydChldmVudCkge1xuICAgIGNvbnN0IGdldERpc3RhbmNlID0gKCkgPT4gdGhpcy5nZXRTaWRlKCkgPT09ICdsZWZ0JyA/IGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFggOiB3aW5kb3cuaW5uZXJXaWR0aCAtIGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFg7XG4gICAgdGhpcy5faWdub3JlRHJhZyA9IGV2ZW50LmNvbnN1bWVkIHx8ICF1dGlsLmlzVmFsaWRHZXN0dXJlKGV2ZW50KSB8fCB0aGlzLmlnbm9yZVN3aXBlKGV2ZW50LCBnZXREaXN0YW5jZSgpKTtcblxuICAgIGlmICghdGhpcy5faWdub3JlRHJhZykge1xuICAgICAgZXZlbnQuY29uc3VtZSAmJiBldmVudC5jb25zdW1lKCk7XG4gICAgICBldmVudC5jb25zdW1lZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGhUb1B4KHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCB8fCAnMTAwJScpO1xuICAgICAgdGhpcy5fc3RhcnREaXN0YW5jZSA9IHRoaXMuX2Rpc3RhbmNlID0gKCEodGhpcy5pc0luaXRpYWxTdGF0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB8fCB0aGlzLmlzSW5pdGlhbFN0YXRlKCkpID8gMCA6IHRoaXMuX3dpZHRoO1xuXG4gICAgICB1dGlsLmlvc1ByZXZlbnRTY3JvbGwodGhpcy5nZXN0dXJlRGV0ZWN0b3IpO1xuICAgIH1cbiAgfVxuXG4gIG9uRHJhZyhldmVudCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgY29uc3QgZGVsdGEgPSB0aGlzLmdldFNpZGUoKSA9PT0gJ2xlZnQnID8gZXZlbnQuZ2VzdHVyZS5kZWx0YVggOiAtZXZlbnQuZ2VzdHVyZS5kZWx0YVg7XG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLl93aWR0aCwgdGhpcy5fc3RhcnREaXN0YW5jZSArIGRlbHRhKSk7XG4gICAgaWYgKGRpc3RhbmNlICE9PSB0aGlzLl9kaXN0YW5jZSkge1xuICAgICAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgIHRoaXMuc3dpcGVNaWQodGhpcy5fZGlzdGFuY2UsIHRoaXMuX3dpZHRoKTtcbiAgICB9XG4gIH1cblxuICBvbkRyYWdFbmQoZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGV2ZW50Lmdlc3R1cmUuaW50ZXJpbURpcmVjdGlvbjtcbiAgICBjb25zdCBpc1N3aXBlTWF4ID0gdGhpcy5nZXRTaWRlKCkgIT09IGRpcmVjdGlvbiAmJiB0aGlzLl9kaXN0YW5jZSA+IHRoaXMuX3dpZHRoICogdGhpcy5nZXRUaHJlc2hvbGQoKTtcbiAgICBpc1N3aXBlTWF4ID8gdGhpcy5zd2lwZU1heCgpIDogdGhpcy5zd2lwZU1pbigpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLmdlc3R1cmVEZXRlY3RvciAmJiB0aGlzLmdlc3R1cmVEZXRlY3Rvci5kaXNwb3NlKCk7XG4gICAgdGhpcy5nZXN0dXJlRGV0ZWN0b3IgPSB0aGlzLmVsZW1lbnQgPSB0aGlzLmVsZW1lbnRIYW5kbGVyID0gbnVsbDtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy50aW1pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZHVyYXRpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuZGVsYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe1xuICAgICAgdGltaW5nOiAnbGluZWFyJyxcbiAgICAgIGR1cmF0aW9uOiAnMC40JyxcbiAgICAgIGRlbGF5OiAnMCdcbiAgICB9LCBvcHRpb25zIHx8IHt9KTtcblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG5cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBibG9jayhwYWdlKSB7XG4gICAgY29uc3QgYmxvY2tlciA9IHV0aWwuY3JlYXRlRWxlbWVudChgXG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgei1pbmRleDogMTAwMDAwXCI+PC9kaXY+XG4gICAgYCk7XG4gICAgcGFnZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGJsb2NrZXIpO1xuICAgIHJldHVybiAoKSA9PiBibG9ja2VyLnJlbW92ZSgpO1xuICB9XG59XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogQWJzdHJhY3Qgc3dpcGUgYW5pbWF0b3IgZm9yIGlPUyBuYXZpZ2F0b3IgdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TU3dpcGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBzdGF0aWMgZ2V0IHN3aXBlYWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHsgZHVyYXRpb25SZXN0b3JlID0gMC4xLCBkdXJhdGlvblN3aXBlID0gMC4xNSwgdGltaW5nU3dpcGUgPSAnbGluZWFyJywgLi4ucmVzdCB9ID0ge30pIHtcbiAgICBzdXBlcih7Li4ucmVzdH0pO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IElPU1N3aXBlTmF2aWdhdG9yQW5pbWF0b3IpIHtcbiAgICAgIHV0aWwudGhyb3dBYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIHRoaXMuZHVyYXRpb25SZXN0b3JlID0gZHVyYXRpb25SZXN0b3JlO1xuICAgIHRoaXMuZHVyYXRpb25Td2lwZSA9IGR1cmF0aW9uU3dpcGU7XG4gICAgdGhpcy50aW1pbmdTd2lwZSA9IHRpbWluZ1N3aXBlO1xuXG4gICAgdGhpcy5vcHRTd2lwZSA9IHsgdGltaW5nOiB0aW1pbmdTd2lwZSwgZHVyYXRpb246IGR1cmF0aW9uU3dpcGUgfTtcbiAgICB0aGlzLm9wdFJlc3RvcmUgPSB7IHRpbWluZzogdGltaW5nU3dpcGUsIGR1cmF0aW9uOiBkdXJhdGlvblJlc3RvcmUgfTtcblxuICAgIHRoaXMuc3dpcGVTaGFkb3cgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBgPGRpdiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiAxMDAlOyB3aWR0aDogMTJweDsgcmlnaHQ6IDEwMCU7IHRvcDogMDsgYm90dG9tOiAwOyB6LWluZGV4OiAtMTtgICtcbiAgICAgICAgYGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgdHJhbnNwYXJlbnQgMCwgcmdiYSgwLDAsMCwuMDQpIDQwJSwgcmdiYSgwLDAsMCwuMTIpIDgwJSwgcmdiYSgwLDAsMCwuMTYpIDEwMCUpO1wiPjwvZGl2PmBcbiAgICApO1xuXG4gICAgdGhpcy5pc0RyYWdTdGFydCA9IHRydWU7XG4gIH1cblxuICBfZGVjb21wb3NlKCkge1xuICAgIHV0aWwudGhyb3dNZW1iZXIoKTtcbiAgfVxuXG4gIF9zaG91bGRBbmltYXRlVG9vbGJhcigpIHtcbiAgICB1dGlsLnRocm93TWVtYmVyKCk7XG4gIH1cblxuICBfY2FsY3VsYXRlRGVsdGEoKSB7XG4gICAgdXRpbC50aHJvd01lbWJlcigpO1xuICB9XG5cbiAgX2RyYWdTdGFydFNldHVwKGVudGVyUGFnZSwgbGVhdmVQYWdlKSB7XG4gICAgdGhpcy5pc0RyYWdTdGFydCA9IGZhbHNlO1xuXG4gICAgLy8gQXZvaWQgY29udGVudCBjbGlja3NcbiAgICB0aGlzLnVuYmxvY2sgPSBzdXBlci5ibG9jayhsZWF2ZVBhZ2UpO1xuXG4gICAgLy8gTWFza1xuICAgIGVudGVyUGFnZS5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgLy8gRGVjb21wb3NpdGlvblxuICAgIHRoaXMudGFyZ2V0ID0ge1xuICAgICAgZW50ZXI6IHV0aWwuZmluZFRvb2xiYXJQYWdlKGVudGVyUGFnZSkgfHwgZW50ZXJQYWdlLFxuICAgICAgbGVhdmU6IHV0aWwuZmluZFRvb2xiYXJQYWdlKGxlYXZlUGFnZSkgfHwgbGVhdmVQYWdlLFxuICAgIH07XG4gICAgdGhpcy5kZWNvbXAgPSB7XG4gICAgICBlbnRlcjogdGhpcy5fZGVjb21wb3NlKHRoaXMudGFyZ2V0LmVudGVyKSxcbiAgICAgIGxlYXZlOiB0aGlzLl9kZWNvbXBvc2UodGhpcy50YXJnZXQubGVhdmUpXG4gICAgfTtcblxuICAgIC8vIEFuaW1hdGlvbiB2YWx1ZXNcbiAgICB0aGlzLmRlbHRhID0gdGhpcy5fY2FsY3VsYXRlRGVsdGEobGVhdmVQYWdlLCB0aGlzLmRlY29tcC5sZWF2ZSk7XG4gICAgdGhpcy5zaG91bGRBbmltYXRlVG9vbGJhciA9IHRoaXMuX3Nob3VsZEFuaW1hdGVUb29sYmFyKHRoaXMudGFyZ2V0LmVudGVyLCB0aGlzLnRhcmdldC5sZWF2ZSk7XG5cbiAgICAvLyBTaGFkb3cgJiYgc3R5bGVzXG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcbiAgICAgIHRoaXMuc3dpcGVTaGFkb3cuc3R5bGUudG9wID0gdGhpcy5kZWNvbXAubGVhdmUudG9vbGJhci5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgdGhpcy50YXJnZXQubGVhdmUuYXBwZW5kQ2hpbGQodGhpcy5zd2lwZVNoYWRvdyk7XG4gICAgICB0aGlzLl9zYXZlU3R5bGUodGhpcy50YXJnZXQuZW50ZXIsIHRoaXMudGFyZ2V0LmxlYXZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVhdmVQYWdlLmFwcGVuZENoaWxkKHRoaXMuc3dpcGVTaGFkb3cpO1xuICAgICAgdGhpcy5fc2F2ZVN0eWxlKGVudGVyUGFnZSwgbGVhdmVQYWdlKTtcbiAgICB9XG4gICAgbGVhdmVQYWdlLmNsYXNzTGlzdC5hZGQoJ292ZXJmbG93LXZpc2libGUnKTtcbiAgICB0aGlzLm92ZXJmbG93RWxlbWVudCA9IGxlYXZlUGFnZTtcbiAgICB0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LmNsYXNzTGlzdC5hZGQoJ2NvbnRlbnQtc3dpcGluZycpO1xuXG4gIH1cblxuICB0cmFuc2xhdGUoZGlzdGFuY2UsIG1heFdpZHRoLCBlbnRlclBhZ2UsIGxlYXZlUGFnZSkge1xuICAgIHRoaXMuaXNTd2lwaW5nID0gdHJ1ZTtcblxuICAgIGlmIChlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICBlbnRlclBhZ2Uuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRHJhZ1N0YXJ0KSB7XG4gICAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgICB0aGlzLl9kcmFnU3RhcnRTZXR1cChlbnRlclBhZ2UsIGxlYXZlUGFnZSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3dpcGVSYXRpbyA9IChkaXN0YW5jZSAtIG1heFdpZHRoKSAvIG1heFdpZHRoO1xuXG4gICAgaWYgKHRoaXMuc2hvdWxkQW5pbWF0ZVRvb2xiYXIpIHtcblxuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAvKiBFbnRlciBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5lbnRlci5jb250ZW50LCB0aGlzLmRlY29tcC5lbnRlci5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5lbnRlci5iYWNrZ3JvdW5kXSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtzd2lwZVJhdGlvICogMjV9JSwgMCwgMClgLFxuICAgICAgICAgICAgb3BhY2l0eTogMSArIHN3aXBlUmF0aW8gKiAxMCAvIDEwMCAvLyAwLjkgLT4gMVxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMuZGVsdGEudGl0bGUgKiBzd2lwZVJhdGlvfXB4LCAwLCAwKWAsXG4gICAgICAgICAgICBvcGFjaXR5OiAxICsgc3dpcGVSYXRpbyAvLyAwIC0+IDFcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAxICsgc3dpcGVSYXRpbyAqIDEwIC8gMTAwLCAvLyAwLjkgLT4gMVxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLmxhYmVsICogc3dpcGVSYXRpb31weCwgMCwgMClgXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLm90aGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAxICsgc3dpcGVSYXRpbyAvLyAwIC0+IDFcbiAgICAgICAgICB9KSxcblxuICAgICAgICAvKiBMZWF2ZSBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LCB0aGlzLmRlY29tcC5sZWF2ZS5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5sZWF2ZS5iYWNrZ3JvdW5kLCB0aGlzLnN3aXBlU2hhZG93XSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtkaXN0YW5jZX1weCwgMCwgMClgXG4gICAgICAgICAgfSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IC0xICogc3dpcGVSYXRpbyAvLyAxIC0+IDBcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHsoMSArIHN3aXBlUmF0aW8pICogMTI1fSUsIDAsIDApYFxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS5iYWNrQnV0dG9uTGFiZWwpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IC0xICogc3dpcGVSYXRpbywgLy8gMSAtPiAwXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMuZGVsdGEudGl0bGUgKiAoMSArIHN3aXBlUmF0aW8pfXB4LCAwLCAwKWBcbiAgICAgICAgICB9KSxcblxuXG4gICAgICAgIC8qIE90aGVyICovXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuc3dpcGVTaGFkb3cpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IC0xICogc3dpcGVSYXRpbyAvLyAxIC0+IDBcbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7ZGlzdGFuY2V9cHgsIDAsIDApYFxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChlbnRlclBhZ2UpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7c3dpcGVSYXRpbyAqIDI1fSUsIDAsIDApYCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEgKyBzd2lwZVJhdGlvICogMTAgLyAxMDAgLy8gMC45IC0+IDFcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5zd2lwZVNoYWRvdylcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogLTEgKiBzd2lwZVJhdGlvIC8vIDEgLT4gMFxuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlc3RvcmUoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaXNEcmFnU3RhcnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zaG91bGRBbmltYXRlVG9vbGJhcikge1xuXG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIC8qIEVudGVyIHBhZ2UgKi9cblxuICAgICAgICBhbmltaXQoW3RoaXMuZGVjb21wLmVudGVyLmNvbnRlbnQsIHRoaXMuZGVjb21wLmVudGVyLmJvdHRvbVRvb2xiYXIsIHRoaXMuZGVjb21wLmVudGVyLmJhY2tncm91bmRdKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtMjUlLCAwLCAwKScsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjlcbiAgICAgICAgICB9LCB0aGlzLm9wdFJlc3RvcmUpLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgtJHt0aGlzLmRlbHRhLnRpdGxlfXB4LCAwLCAwKWAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb25SZXN0b3JlfXMgbGluZWFyLCB0cmFuc2Zvcm0gJHt0aGlzLmR1cmF0aW9uUmVzdG9yZX1zICR7dGhpcy50aW1pbmdTd2lwZX1gLFxuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci5iYWNrQnV0dG9uTGFiZWwpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKC0ke3RoaXMuZGVsdGEubGFiZWx9cHgsIDAsIDApYFxuICAgICAgICAgIH0sIHRoaXMub3B0UmVzdG9yZSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmVudGVyLm90aGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgfSwgdGhpcy5vcHRSZXN0b3JlKSxcblxuICAgICAgICAvKiBMZWF2ZSBwYWdlICovXG5cbiAgICAgICAgYW5pbWl0KFt0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LCB0aGlzLmRlY29tcC5sZWF2ZS5ib3R0b21Ub29sYmFyLCB0aGlzLmRlY29tcC5sZWF2ZS5iYWNrZ3JvdW5kLCB0aGlzLnN3aXBlU2hhZG93XSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgMCwgMClgXG4gICAgICAgICAgfSwgdGhpcy5vcHRSZXN0b3JlKSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUudG9vbGJhcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sIHRoaXMub3B0UmVzdG9yZSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLnRvb2xiYXJDZW50ZXIpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDAsIDApYFxuICAgICAgICAgIH0sIHRoaXMub3B0UmVzdG9yZSksXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuZGVjb21wLmxlYXZlLmJhY2tCdXR0b25MYWJlbClcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDAsIDApYCxcbiAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvblJlc3RvcmV9cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb25SZXN0b3JlfXMgJHt0aGlzLnRpbWluZ1N3aXBlfWBcbiAgICAgICAgICB9KSxcblxuXG4gICAgICAgIC8qIE90aGVyICovXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuc3dpcGVTaGFkb3cpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDBcbiAgICAgICAgICB9LCB0aGlzLm9wdFJlc3RvcmUpXG4gICAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXQodGhpcy50YXJnZXQuZW50ZXIsIHRoaXMudGFyZ2V0LmxlYXZlKTtcbiAgICAgICAgICAgIGVudGVyUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgtMjUlLCAwLCAwKScsXG4gICAgICAgICAgb3BhY2l0eTogMC45XG4gICAgICAgIH0sIHRoaXMub3B0UmVzdG9yZSksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKSdcbiAgICAgICAgfSwgdGhpcy5vcHRSZXN0b3JlKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5fcmVzZXQoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UpO1xuICAgICAgICAgIGVudGVyUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwb3BTd2lwZShlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5pc0RyYWdTdGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG5cbiAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgLyogRW50ZXIgcGFnZSAqL1xuXG4gICAgICAgIGFuaW1pdChbdGhpcy5kZWNvbXAuZW50ZXIuY29udGVudCwgdGhpcy5kZWNvbXAuZW50ZXIuYm90dG9tVG9vbGJhciwgdGhpcy5kZWNvbXAuZW50ZXIuYmFja2dyb3VuZF0pXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgICB9LCB0aGlzLm9wdFN3aXBlKSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAuZW50ZXIudG9vbGJhckNlbnRlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgMCwgMClgLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHt0aGlzLmR1cmF0aW9uU3dpcGV9cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb25Td2lwZX1zICR7dGhpcy50aW1pbmdTd2lwZX1gLFxuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci5iYWNrQnV0dG9uTGFiZWwpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIDAsIDApYFxuICAgICAgICAgIH0sIHRoaXMub3B0U3dpcGUpLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5lbnRlci5vdGhlcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgIH0sIHRoaXMub3B0U3dpcGUpLFxuXG4gICAgICAgIC8qIExlYXZlIHBhZ2UgKi9cblxuICAgICAgICBhbmltaXQoW3RoaXMuZGVjb21wLmxlYXZlLmNvbnRlbnQsIHRoaXMuZGVjb21wLmxlYXZlLmJvdHRvbVRvb2xiYXIsIHRoaXMuZGVjb21wLmxlYXZlLmJhY2tncm91bmRdKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKWBcbiAgICAgICAgICB9LCB0aGlzLm9wdFN3aXBlKSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUudG9vbGJhcilcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICAgIH0sIHRoaXMub3B0U3dpcGUpLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLmRlY29tcC5sZWF2ZS50b29sYmFyQ2VudGVyKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgxMjUlLCAwLCAwKWBcbiAgICAgICAgICB9LCB0aGlzLm9wdFN3aXBlKSxcblxuICAgICAgICBhbmltaXQodGhpcy5kZWNvbXAubGVhdmUuYmFja0J1dHRvbkxhYmVsKVxuICAgICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLmRlbHRhLnRpdGxlfXB4LCAwLCAwKWAsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb25Td2lwZX1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvblN3aXBlfXMgJHt0aGlzLnRpbWluZ1N3aXBlfWBcbiAgICAgICAgICB9KSxcblxuXG4gICAgICAgIC8qIE90aGVyICovXG5cbiAgICAgICAgYW5pbWl0KHRoaXMuc3dpcGVTaGFkb3cpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWF4V2lkdGh9cHgsIDAsIDApYFxuICAgICAgICAgIH0sIHRoaXMub3B0U3dpcGUpXG4gICAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXQodGhpcy50YXJnZXQuZW50ZXIsIHRoaXMudGFyZ2V0LmxlYXZlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlKVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyxcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSwgdGhpcy5vcHRTd2lwZSksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgxMDAlLCAwLCAwKSdcbiAgICAgICAgfSwgdGhpcy5vcHRTd2lwZSlcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHRoaXMuX3Jlc2V0KGVudGVyUGFnZSwgbGVhdmVQYWdlKTtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgX3NhdmVTdHlsZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fc2F2ZWRTdHlsZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3Qgc2F2ZSA9IGVsID0+IHRoaXMuX3NhdmVkU3R5bGUuc2V0KGVsLCBlbC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuICAgIGFyZ3MuZm9yRWFjaChzYXZlKTtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuZGVjb21wKS5mb3JFYWNoKHAgPT4ge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5kZWNvbXBbcF0pLmZvckVhY2goayA9PiB7XG4gICAgICAgICh0aGlzLmRlY29tcFtwXVtrXSBpbnN0YW5jZW9mIEFycmF5ID8gdGhpcy5kZWNvbXBbcF1ba10gOiBbdGhpcy5kZWNvbXBbcF1ba11dKS5mb3JFYWNoKHNhdmUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfcmVzdG9yZVN0eWxlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZXN0b3JlID0gZWwgPT4ge1xuICAgICAgdGhpcy5fc2F2ZWRTdHlsZS5nZXQoZWwpID09PSBudWxsID8gZWwucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpIDogZWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIHRoaXMuX3NhdmVkU3R5bGUuZ2V0KGVsKSlcbiAgICAgIHRoaXMuX3NhdmVkU3R5bGUuZGVsZXRlKGVsKVxuICAgIH07XG4gICAgYXJncy5mb3JFYWNoKHJlc3RvcmUpO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5kZWNvbXApLmZvckVhY2gocCA9PiB7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmRlY29tcFtwXSkuZm9yRWFjaChrID0+IHtcbiAgICAgICAgKHRoaXMuZGVjb21wW3BdW2tdIGluc3RhbmNlb2YgQXJyYXkgPyB0aGlzLmRlY29tcFtwXVtrXSA6IFt0aGlzLmRlY29tcFtwXVtrXV0pLmZvckVhY2gocmVzdG9yZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9yZXNldCguLi5hcmdzKSB7XG4gICAgdGhpcy5pc1N3aXBpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9zYXZlZFN0eWxlICYmIHRoaXMuX3Jlc3RvcmVTdHlsZSguLi5hcmdzKTtcbiAgICB0aGlzLnVuYmxvY2sgJiYgdGhpcy51bmJsb2NrKCk7XG4gICAgdGhpcy5zd2lwZVNoYWRvdy5yZW1vdmUoKTtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIHRoaXMub3ZlcmZsb3dFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ292ZXJmbG93LXZpc2libGUnKTtcbiAgICB0aGlzLmRlY29tcC5sZWF2ZS5jb250ZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2NvbnRlbnQtc3dpcGluZycpO1xuICAgIHRoaXMuZGVjb21wID0gdGhpcy50YXJnZXQgPSB0aGlzLm92ZXJmbG93RWxlbWVudCA9IHRoaXMuX3NhdmVkU3R5bGUgPSBudWxsO1xuICAgIHRoaXMuaXNEcmFnU3RhcnQgPSB0cnVlO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgSU9TU3dpcGVOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2lvcy1zd2lwZS1hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHRyYW5zbGF0ZTNkID0gKHggPSAwLCB5ID0gMCwgeiA9IDApID0+IGB0cmFuc2xhdGUzZCgke3h9LCAke3l9LCAke3p9KWA7XG5cbi8qKlxuICogU2xpZGUgYW5pbWF0b3IgZm9yIG5hdmlnYXRvciB0cmFuc2l0aW9uIGxpa2UgaU9TJ3Mgc2NyZWVuIHNsaWRlIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBJT1NTd2lwZU5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7IHRpbWluZyA9ICdjdWJpYy1iZXppZXIoMC4zLCAuNCwgMCwgLjkpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuNCwgLi4ucmVzdCB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uLCAuLi5yZXN0IH0pO1xuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzayA9IHV0aWwuY3JlYXRlRWxlbWVudChcbiAgICAgIGA8ZGl2IHN0eWxlPVwicG9zaXRpb246IGFic29sdXRlOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO2AgK1xuICAgICAgICBgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7IHotaW5kZXg6IDJcIj48L2Rpdj5gXG4gICAgKTtcbiAgfVxuXG4gIF9kZWNvbXBvc2UocGFnZSkge1xuICAgIGNvbnN0IHRvb2xiYXIgPSBwYWdlLl9nZXRUb29sYmFyRWxlbWVudCgpO1xuICAgIGNvbnN0IGxlZnQgPSB0b29sYmFyLl9nZXRUb29sYmFyTGVmdEl0ZW1zRWxlbWVudCgpO1xuICAgIGNvbnN0IHJpZ2h0ID0gdG9vbGJhci5fZ2V0VG9vbGJhclJpZ2h0SXRlbXNFbGVtZW50KCk7XG5cbiAgICBjb25zdCBleGNsdWRlQmFja0J1dHRvbiA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZWxlbWVudHNbaV0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ29ucy1iYWNrLWJ1dHRvbicpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbGVtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgY29uc3Qgb3RoZXIgPSBbXVxuICAgICAgLmNvbmNhdChsZWZ0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IGxlZnQgOiBleGNsdWRlQmFja0J1dHRvbihsZWZ0LmNoaWxkcmVuKSlcbiAgICAgIC5jb25jYXQocmlnaHQuY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gcmlnaHQgOiBleGNsdWRlQmFja0J1dHRvbihyaWdodC5jaGlsZHJlbikpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2xiYXJDZW50ZXI6IHRvb2xiYXIuX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQoKSxcbiAgICAgIGJhY2tCdXR0b25JY29uOiB0b29sYmFyLl9nZXRUb29sYmFyQmFja0J1dHRvbkljb25FbGVtZW50KCksXG4gICAgICBiYWNrQnV0dG9uTGFiZWw6IHRvb2xiYXIuX2dldFRvb2xiYXJCYWNrQnV0dG9uTGFiZWxFbGVtZW50KCksXG4gICAgICBvdGhlcjogb3RoZXIsXG4gICAgICBjb250ZW50OiBwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpLFxuICAgICAgYmFja2dyb3VuZDogcGFnZS5fZ2V0QmFja2dyb3VuZEVsZW1lbnQoKSxcbiAgICAgIHRvb2xiYXI6IHRvb2xiYXIsXG4gICAgICBib3R0b21Ub29sYmFyOiBwYWdlLl9nZXRCb3R0b21Ub29sYmFyRWxlbWVudCgpXG4gICAgfTtcbiAgfVxuXG4gIF9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2UsIGxlYXZlUGFnZSkge1xuICAgIGNvbnN0IHRvb2xiYXJzID0gZW50ZXJQYWdlLl9jYW5BbmltYXRlVG9vbGJhcigpICYmIGxlYXZlUGFnZS5fY2FuQW5pbWF0ZVRvb2xiYXIoKTtcblxuICAgIGNvbnN0IGVudGVyVG9vbGJhciA9IGVudGVyUGFnZS5fZ2V0VG9vbGJhckVsZW1lbnQoKTtcbiAgICBjb25zdCBsZWF2ZVRvb2xiYXIgPSBsZWF2ZVBhZ2UuX2dldFRvb2xiYXJFbGVtZW50KCk7XG5cbiAgICBjb25zdCBpc1N0YXRpYyA9IGVudGVyVG9vbGJhci5oYXNBdHRyaWJ1dGUoJ3N0YXRpYycpIHx8IGxlYXZlVG9vbGJhci5oYXNBdHRyaWJ1dGUoJ3N0YXRpYycpO1xuICAgIGNvbnN0IGlzTWF0ZXJpYWwgPSB1dGlsLmhhc01vZGlmaWVyKGVudGVyVG9vbGJhciwgJ21hdGVyaWFsJykgfHwgdXRpbC5oYXNNb2RpZmllcihsZWF2ZVRvb2xiYXIsICdtYXRlcmlhbCcpO1xuICAgIGNvbnN0IGlzVHJhbnNwYXJlbnQgPSB1dGlsLmhhc01vZGlmaWVyKGVudGVyVG9vbGJhciwgJ3RyYW5zcGFyZW50JykgfHwgdXRpbC5oYXNNb2RpZmllcihsZWF2ZVRvb2xiYXIsICd0cmFuc3BhcmVudCcpO1xuXG4gICAgcmV0dXJuIHRvb2xiYXJzICYmICFpc1N0YXRpYyAmJiAhaXNNYXRlcmlhbCAmJiAhaXNUcmFuc3BhcmVudDtcbiAgfVxuXG4gIF9jYWxjdWxhdGVEZWx0YShlbGVtZW50LCBkZWNvbXBvc2l0aW9uKSB7XG4gICAgbGV0IHRpdGxlLCBsYWJlbDtcblxuICAgIGNvbnN0IHBhZ2VSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoZGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdiYWNrLWJ1dHRvbl9fbGFiZWwnKSkge1xuICAgICAgY29uc3QgbGFiZWxSZWN0ID0gZGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uTGFiZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aXRsZSA9IE1hdGgucm91bmQocGFnZVJlY3Qud2lkdGggLyAyIC0gbGFiZWxSZWN0LndpZHRoIC8gMiAtIGxhYmVsUmVjdC5sZWZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGUgPSBNYXRoLnJvdW5kKChwYWdlUmVjdC53aWR0aCAvIDIpICogMC42KTtcbiAgICB9XG5cbiAgICBpZiAoZGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uSWNvbi5jbGFzc0xpc3QuY29udGFpbnMoJ2JhY2stYnV0dG9uX19pY29uJykpIHtcbiAgICAgIGxhYmVsID0gZGVjb21wb3NpdGlvbi5iYWNrQnV0dG9uSWNvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCAtIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt0aXRsZSwgbGFiZWx9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgbGVhdmVQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGxlYXZlUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGNvbnRlbnRSZWFkeShlbnRlclBhZ2UsICgpID0+IHtcbiAgICAgIGNvbnN0IGVudGVyUGFnZVRhcmdldCA9IHV0aWwuZmluZFRvb2xiYXJQYWdlKGVudGVyUGFnZSkgfHwgZW50ZXJQYWdlO1xuICAgICAgY29uc3QgbGVhdmVQYWdlVGFyZ2V0ID0gdXRpbC5maW5kVG9vbGJhclBhZ2UobGVhdmVQYWdlKSB8fCBsZWF2ZVBhZ2U7XG4gICAgICBjb25zdCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGVudGVyUGFnZVRhcmdldCk7XG4gICAgICBjb25zdCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlKGxlYXZlUGFnZVRhcmdldCk7XG5cbiAgICAgIGNvbnN0IGRlbHRhID0gdGhpcy5fY2FsY3VsYXRlRGVsdGEobGVhdmVQYWdlLCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uKTtcblxuICAgICAgY29uc3Qgc2hvdWxkQW5pbWF0ZVRvb2xiYXIgPSB0aGlzLl9zaG91bGRBbmltYXRlVG9vbGJhcihlbnRlclBhZ2VUYXJnZXQsIGxlYXZlUGFnZVRhcmdldCk7XG5cbiAgICAgIGlmIChzaG91bGRBbmltYXRlVG9vbGJhcikge1xuXG4gICAgICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgICAgICBhbmltaXQoW2VudGVyUGFnZURlY29tcG9zaXRpb24uY29udGVudCwgZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5ib3R0b21Ub29sYmFyLCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tncm91bmRdLCB0aGlzLmRlZilcbiAgICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoJzEwMCUnKSB9LFxuICAgICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSB9XG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhciwgdGhpcy5kZWYpXG4gICAgICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0pLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlciwgdGhpcy5kZWYpXG4gICAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCcxMjUlJyksIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCksIG9wYWNpdHk6IDEgfVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbCwgdGhpcy5kZWYpXG4gICAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKGAke2RlbHRhLnRpdGxlfXB4YCksIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSxcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLFxuXG4gICAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24ub3RoZXIsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICAgIHsgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAgICB7IGNzczogeyBvcGFjaXR5OiAxIH0sIHRpbWluZzogJ2xpbmVhcicgfVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgIGFuaW1pdChbbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0sIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnLTI1JScpLCBvcGFjaXR5OiAwLjkgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlciwgdGhpcy5kZWYpXG4gICAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCksIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoYC0ke2RlbHRhLnRpdGxlfXB4YCksXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBgb3BhY2l0eSAke3RoaXMuZHVyYXRpb259cyBsaW5lYXIsIHRyYW5zZm9ybSAke3RoaXMuZHVyYXRpb259cyAke3RoaXMudGltaW5nfWBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmJhY2tCdXR0b25MYWJlbCwgdGhpcy5kZWYpXG4gICAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCksIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKGAtJHtkZWx0YS5sYWJlbH1weGApLCBvcGFjaXR5OiAwIH1cbiAgICAgICAgICAgICksXG5cbiAgICAgICAgICBhbmltaXQobGVhdmVQYWdlRGVjb21wb3NpdGlvbi5vdGhlciwgdGhpcy5kZWYpXG4gICAgICAgICAgICAuZGVmYXVsdCggeyBvcGFjaXR5OiAxIH0sIHsgY3NzOiB7IG9wYWNpdHk6IDAgfSwgdGltaW5nOiAnbGluZWFyJyB9KVxuXG4gICAgICAgICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICAgIGFuaW1pdChlbnRlclBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnMTAwJScpLCB9LCB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSB9KSxcblxuICAgICAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAgICAgLmRlZmF1bHQoIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLCBvcGFjaXR5OiAxIH0sIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnLTI1JScpLCBvcGFjaXR5OiAuOSB9KVxuICAgICAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5pc1N3aXBpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLnBvcFN3aXBlKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgZW50ZXJQYWdlVGFyZ2V0ID0gdXRpbC5maW5kVG9vbGJhclBhZ2UoZW50ZXJQYWdlKSB8fCBlbnRlclBhZ2U7XG4gICAgY29uc3QgbGVhdmVQYWdlVGFyZ2V0ID0gdXRpbC5maW5kVG9vbGJhclBhZ2UobGVhdmVQYWdlKSB8fCBsZWF2ZVBhZ2U7XG4gICAgY29uc3QgZW50ZXJQYWdlRGVjb21wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZShlbnRlclBhZ2VUYXJnZXQpO1xuICAgIGNvbnN0IGxlYXZlUGFnZURlY29tcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2UobGVhdmVQYWdlVGFyZ2V0KTtcblxuICAgIGNvbnN0IGRlbHRhID0gdGhpcy5fY2FsY3VsYXRlRGVsdGEobGVhdmVQYWdlLCBsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uKTtcblxuICAgIGNvbnN0IHNob3VsZEFuaW1hdGVUb29sYmFyID0gdGhpcy5fc2hvdWxkQW5pbWF0ZVRvb2xiYXIoZW50ZXJQYWdlVGFyZ2V0LCBsZWF2ZVBhZ2VUYXJnZXQpO1xuXG4gICAgaWYgKHNob3VsZEFuaW1hdGVUb29sYmFyKSB7XG4gICAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICAgIGFuaW1pdChbZW50ZXJQYWdlRGVjb21wb3NpdGlvbi5jb250ZW50LCBlbnRlclBhZ2VEZWNvbXBvc2l0aW9uLmJvdHRvbVRvb2xiYXIsIGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja2dyb3VuZF0sIHRoaXMuZGVmKVxuICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCctMjUlJyksIG9wYWNpdHk6IC45IH0sXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSwgb3BhY2l0eTogMSB9XG4gICAgICAgICAgKSxcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlRGVjb21wb3NpdGlvbi50b29sYmFyQ2VudGVyLCB0aGlzLmRlZilcbiAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZChgLSR7ZGVsdGEudGl0bGV9cHhgKSwgb3BhY2l0eTogMCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCksXG4gICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7dGhpcy5kdXJhdGlvbn1zIGxpbmVhciwgdHJhbnNmb3JtICR7dGhpcy5kdXJhdGlvbn1zICR7dGhpcy50aW1pbmd9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgICksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsLCB0aGlzLmRlZilcbiAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZChgLSR7ZGVsdGEubGFiZWx9cHhgKSB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCkgfVxuICAgICAgICAgICksXG5cbiAgICAgICAgYW5pbWl0KGVudGVyUGFnZURlY29tcG9zaXRpb24ub3RoZXIsIHRoaXMuZGVmKVxuICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgeyBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgICB7IGNzczogeyBvcGFjaXR5OiAxIH0sIHRpbWluZzogJ2xpbmVhcicgfVxuICAgICAgICAgICksXG5cbiAgICAgICAgYW5pbWl0KFtsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLmNvbnRlbnQsIGxlYXZlUGFnZURlY29tcG9zaXRpb24uYm90dG9tVG9vbGJhciwgbGVhdmVQYWdlRGVjb21wb3NpdGlvbi5iYWNrZ3JvdW5kXSwgdGhpcy5kZWYpXG4gICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCcxMDAlJykgfVxuICAgICAgICAgIClcbiAgICAgICAgICAud2FpdCgwKVxuICAgICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH0pLFxuXG4gICAgICAgIGFuaW1pdChsZWF2ZVBhZ2VEZWNvbXBvc2l0aW9uLnRvb2xiYXIsIHRoaXMuZGVmKVxuICAgICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgICAgeyBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICB7IG9wYWNpdHk6IDAgfVxuICAgICAgICAgICksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24udG9vbGJhckNlbnRlciwgdGhpcy5kZWYpXG4gICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCcxMjUlJykgfVxuICAgICAgICAgICksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZURlY29tcG9zaXRpb24uYmFja0J1dHRvbkxhYmVsLCB0aGlzLmRlZilcbiAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgpLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoYCR7ZGVsdGEudGl0bGV9cHhgKSxcbiAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvbjogYG9wYWNpdHkgJHt0aGlzLmR1cmF0aW9ufXMgbGluZWFyLCB0cmFuc2Zvcm0gJHt0aGlzLmR1cmF0aW9ufXMgJHt0aGlzLnRpbWluZ31gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgnLTI1JScpLCBvcGFjaXR5OiAuOSB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCksIG9wYWNpdHk6IDEgfVxuICAgICAgICAgICksXG5cbiAgICAgICAgYW5pbWl0KGxlYXZlUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoKSB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKCcxMDAlJykgfVxuICAgICAgICAgIClcbiAgICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbi8qKlxuICogTGlmdCBzY3JlZW4gdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TTGlmdE5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuNH0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KFxuICAgICAgJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7JyArXG4gICAgICAgICdiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoYmxhY2ssIHdoaXRlKTtcIj48L2Rpdj4nXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMTAwJSwgMCknIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScgfVxuICAgICAgICApLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIC0xMCUsIDApJywgb3BhY2l0eTogLjkgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuYmFja2dyb3VuZE1hc2sucmVtb3ZlKCk7XG4gICAgZW50ZXJQYWdlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuYmFja2dyb3VuZE1hc2ssIGVudGVyUGFnZSk7XG5cbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIC00M3B4LCAwKScsIG9wYWNpdHk6IC45IH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzRCgwLCAwLCAwKScsIG9wYWNpdHk6IDEgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDAsIDApJyB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMTAwJSwgMCknIH1cbiAgICAgICAgKVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBOYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5cbmNvbnN0IHRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSc7XG5cbi8qKlxuICogRmFkZS1pbiBzY3JlZW4gdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSU9TRmFkZU5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuNH0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGVudGVyUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm0sIG9wYWNpdHk6IDEgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm0sIG9wYWNpdHk6IDAgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcblxuLyoqXG4gKiBTbGlkZSBhbmltYXRvciBmb3IgbmF2aWdhdG9yIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EU2xpZGVOYXZpZ2F0b3JBbmltYXRvciBleHRlbmRzIE5hdmlnYXRvckFuaW1hdG9yIHtcblxuICBjb25zdHJ1Y3Rvcih7dGltaW5nID0gJ2N1YmljLWJlemllciguMSwgLjcsIC40LCAxKScsIGRlbGF5ID0gMCwgZHVyYXRpb24gPSAwLjN9ID0ge30pIHtcbiAgICBzdXBlcih7dGltaW5nLCBkZWxheSwgZHVyYXRpb259KTtcblxuICAgIHRoaXMuYmxhY2tNYXNrT3BhY2l0eSA9IDAuNDtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KFxuICAgICAgJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHotaW5kZXg6IDI7JyArXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yOiBibGFjazsgb3BhY2l0eTogMDtcIj48L2Rpdj4nXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlLm5leHRTaWJsaW5nKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJywgb3BhY2l0eTogMCB9LFxuICAgICAgICAgIHsgb3BhY2l0eTogdGhpcy5ibGFja01hc2tPcGFjaXR5IH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgxMDAlLCAwLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9XG4gICAgICAgICksXG5cbiAgICAgIGFuaW1pdChsZWF2ZVBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoLTQ1JSwgMCwgMCknIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudGVyUGFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbGVhdmVQYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBlbnRlclBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgZW50ZXJQYWdlLm5leHRTaWJsaW5nKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2ssIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJywgb3BhY2l0eTogdGhpcy5ibGFja01hc2tPcGFjaXR5IH0sXG4gICAgICAgICAgeyBvcGFjaXR5OiAwIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQoZW50ZXJQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgtNDUlLCAwLCAwKScsIG9wYWNpdHk6IC45IH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IDEgfVxuICAgICAgICApLFxuXG4gICAgICBhbmltaXQobGVhdmVQYWdlLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDEwMCUsIDAsIDApJyB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG59XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuXG4vKipcbiAqIExpZnQgc2NyZWVuIHRyYW5zaXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1ETGlmdE5hdmlnYXRvckFuaW1hdG9yIGV4dGVuZHMgTmF2aWdhdG9yQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJywgZGVsYXkgPSAwLjA1LCBkdXJhdGlvbiA9IDAuNH0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG5cbiAgICB0aGlzLmJhY2tncm91bmRNYXNrID0gdXRpbC5jcmVhdGVFbGVtZW50KFxuICAgICAgJzxkaXYgc3R5bGU9XCJwb3NpdGlvbjogYWJzb2x1dGU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7JyArXG4gICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcIj48L2Rpdj4nXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHB1c2goZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICBsZWF2ZVBhZ2UucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5iYWNrZ3JvdW5kTWFzaywgbGVhdmVQYWdlKTtcblxuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgbWFza0NsZWFyID0gYW5pbWl0KHRoaXMuYmFja2dyb3VuZE1hc2spXG4gICAgICAud2FpdCh0aGlzLmRlbGF5ICsgdGhpcy5kdXJhdGlvbilcbiAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFzay5yZW1vdmUoKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBtYXNrQ2xlYXIsXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDEwMCUsIDApJyB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH1cbiAgICAgICAgKSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IC40IH0pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHBvcChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgIGVudGVyUGFnZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmJhY2tncm91bmRNYXNrLCBlbnRlclBhZ2UpO1xuXG4gICAgY29uc3QgdW5ibG9jayA9IHN1cGVyLmJsb2NrKGVudGVyUGFnZSk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuXG4gICAgICBhbmltaXQodGhpcy5iYWNrZ3JvdW5kTWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb24pXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXNrLnJlbW92ZSgpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IC40IH0sIHsgb3BhY2l0eTogMSB9KVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAxMDAlLCAwKScgfVxuICAgICAgICApXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcblxuLyoqXG4gKiBGYWRlLWluICsgTGlmdCBzY3JlZW4gdHJhbnNpdGlvbi5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURGYWRlTmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JBbmltYXRvciB7XG5cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpJywgdGltaW5nUG9wID0gJ2N1YmljLWJlemllcigwLjQsIDAsIDEsIDEpJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuMn0gPSB7fSkge1xuICAgIHN1cGVyKHt0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbn0pO1xuICAgIHRoaXMudGltaW5nUG9wID0gdGltaW5nUG9wO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRlclBhZ2VcbiAgICogQHBhcmFtIHtPYmplY3R9IGxlYXZlUGFnZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcHVzaChlbnRlclBhZ2UsIGxlYXZlUGFnZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB1bmJsb2NrID0gc3VwZXIuYmxvY2soZW50ZXJQYWdlKTtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG5cbiAgICAgIGFuaW1pdChlbnRlclBhZ2UsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNEKDAsIDQycHgsIDApJywgb3BhY2l0eTogMCB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW50ZXJQYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsZWF2ZVBhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgcG9wKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHVuYmxvY2sgPSBzdXBlci5ibG9jayhlbnRlclBhZ2UpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcblxuICAgICAgYW5pbWl0KGxlYXZlUGFnZSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMCwgMCknLCBvcGFjaXR5OiAxIH0sXG4gICAgICAgICAgeyBjc3M6IHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM0QoMCwgMzhweCwgMCknLCBvcGFjaXR5OiAwIH0sIHRpbWluZzogdGhpcy50aW1pbmdQb3AgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICB1bmJsb2NrKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25lTmF2aWdhdG9yQW5pbWF0b3IgZXh0ZW5kcyBOYXZpZ2F0b3JBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuICBwdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBwb3AoZW50ZXJQYWdlLCBsZWF2ZVBhZ2UsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uLy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgaW50ZXJuYWwgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsJztcbmltcG9ydCBTd2lwZVJldmVhbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvc3dpcGUtcmV2ZWFsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3Mtc2xpZGUtYW5pbWF0b3InO1xuaW1wb3J0IElPU0xpZnROYXZpZ2F0b3JBbmltYXRvciBmcm9tICcuL2lvcy1saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBJT1NGYWRlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9pb3MtZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgTURTbGlkZU5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vbWQtc2xpZGUtYW5pbWF0b3InO1xuaW1wb3J0IE1ETGlmdE5hdmlnYXRvckFuaW1hdG9yIGZyb20gJy4vbWQtbGlmdC1hbmltYXRvcic7XG5pbXBvcnQgTURGYWRlTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9tZC1mYWRlLWFuaW1hdG9yJztcbmltcG9ydCBOb25lTmF2aWdhdG9yQW5pbWF0b3IgZnJvbSAnLi9ub25lLWFuaW1hdG9yJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi8uLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQge1BhZ2VMb2FkZXIsIGRlZmF1bHRQYWdlTG9hZGVyLCBpbnN0YW50UGFnZUxvYWRlcn0gZnJvbSAnLi4vLi4vb25zL3BhZ2UtbG9hZGVyJztcblxuY29uc3QgX2FuaW1hdG9yRGljdCA9IHtcbiAgJ2RlZmF1bHQnOiAoKSA9PiBwbGF0Zm9ybS5pc0FuZHJvaWQoKSA/IE1ERmFkZU5hdmlnYXRvckFuaW1hdG9yIDogSU9TU2xpZGVOYXZpZ2F0b3JBbmltYXRvcixcbiAgJ3NsaWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNRFNsaWRlTmF2aWdhdG9yQW5pbWF0b3IgOiBJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yLFxuICAnbGlmdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURMaWZ0TmF2aWdhdG9yQW5pbWF0b3IgOiBJT1NMaWZ0TmF2aWdhdG9yQW5pbWF0b3IsXG4gICdmYWRlJzogKCkgPT4gcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBNREZhZGVOYXZpZ2F0b3JBbmltYXRvciA6IElPU0ZhZGVOYXZpZ2F0b3JBbmltYXRvcixcbiAgJ3NsaWRlLWlvcyc6IElPU1NsaWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdzbGlkZS1tZCc6IE1EU2xpZGVOYXZpZ2F0b3JBbmltYXRvcixcbiAgJ2xpZnQtaW9zJzogSU9TTGlmdE5hdmlnYXRvckFuaW1hdG9yLFxuICAnbGlmdC1tZCc6IE1ETGlmdE5hdmlnYXRvckFuaW1hdG9yLFxuICAnZmFkZS1pb3MnOiBJT1NGYWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogTURGYWRlTmF2aWdhdG9yQW5pbWF0b3IsXG4gICdub25lJzogTm9uZU5hdmlnYXRvckFuaW1hdG9yXG59O1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbmF2aWdhdG9yU2lkZUVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KG5hdmlnYXRvckVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufTtcblxuY29uc3QgdmVyaWZ5UGFnZUVsZW1lbnQgPSBlbCA9PiAoZWwubm9kZU5hbWUgIT09ICdPTlMtUEFHRScpICYmIHV0aWwudGhyb3coICdPbmx5IHBhZ2UgZWxlbWVudHMgY2FuIGJlIGNoaWxkcmVuIG9mIG5hdmlnYXRvcicpO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1uYXZpZ2F0b3JcbiAqIEBjYXRlZ29yeSBuYXZpZ2F0aW9uXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEEgY29tcG9uZW50IHRoYXQgcHJvdmlkZXMgcGFnZSBzdGFjayBtYW5hZ2VtZW50IGFuZCBuYXZpZ2F0aW9uLiBTdGFjayBuYXZpZ2F0aW9uIGlzIHRoZSBtb3N0IGNvbW1vbiBuYXZpZ2F0aW9uIHBhdHRlcm4gZm9yIG1vYmlsZSBhcHBzLlxuICpcbiAqICAgICBXaGVuIGEgcGFnZSBpcyBwdXNoZWQgb24gdG9wIG9mIHRoZSBzdGFjayBpdCBpcyBkaXNwbGF5ZWQgd2l0aCBhIHRyYW5zaXRpb24gYW5pbWF0aW9uLiBXaGVuIHRoZSB1c2VyIHJldHVybnMgdG8gdGhlIHByZXZpb3VzIHBhZ2UgdGhlIHRvcCBwYWdlIHdpbGwgYmUgcG9wcGVkIGZyb20gdGhlIHRvcCBvZiB0aGUgc3RhY2sgYW5kIGhpZGRlbiB3aXRoIGFuIG9wcG9zaXRlIHRyYW5zaXRpb24gYW5pbWF0aW9uLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHlyaHR2XG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvbmF2aWdhdG9yXG4gKiBAZ3VpZGUgbGlmZWN5Y2xlLmh0bWwjZXZlbnRzXG4gKiAgIFtlbl1PdmVydmlldyBvZiBwYWdlIGV2ZW50c1svZW5dXG4gKiAgIFtqYV1PdmVydmlldyBvZiBwYWdlIGV2ZW50c1svamFdXG4gKiBAc2VlYWxzbyBvbnMtdG9vbGJhclxuICogICBbZW5dVGhlIGA8b25zLXRvb2xiYXI+YCBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IGEgdG9vbGJhciBvbiB0aGUgdG9wIG9mIGEgcGFnZS5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgY29tcG9uZW50IGxldHMgdGhlIHVzZXIgcmV0dXJuIHRvIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtbmF2aWdhdG9yIGlkPVwibmF2aWdhdG9yXCI+XG4gKiAgIDxvbnMtcGFnZT5cbiAqICAgICA8b25zLXRvb2xiYXI+XG4gKiAgICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+XG4gKiAgICAgICAgIFRpdGxlXG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICA8L29ucy10b29sYmFyPlxuICogICAgIDxwPlxuICogICAgICAgPG9ucy1idXR0b25cbiAqICAgICAgICAgb25jbGljaz1cImRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCduYXZpZ2F0b3InKS5wdXNoUGFnZSgncGFnZS5odG1sJylcIj5cbiAqICAgICAgICAgUHVzaCBwYWdlXG4gKiAgICAgICA8L29ucy1idXR0b24+XG4gKiAgICAgPC9wPlxuICogICA8L29ucy1wYWdlPlxuICogPC9vbnMtbmF2aWdhdG9yPlxuICpcbiAqIDx0ZW1wbGF0ZSBpZD1cInBhZ2UuaHRtbFwiPlxuICogICA8b25zLXBhZ2U+XG4gKiAgICAgPG9ucy10b29sYmFyPlxuICogICAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICAgICAgPG9ucy1iYWNrLWJ1dHRvbj5CYWNrPC9vbnMtYmFjay1idXR0b24+XG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICAgICAgQW5vdGhlciBwYWdlXG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICA8L29ucy10b29sYmFyPlxuICogICA8L29ucy1wYWdlPlxuICogPC90ZW1wbGF0ZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdG9yRWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwYWdlXG4gICAqIEBpbml0b25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyc3QgcGFnZSB0byBzaG93IHdoZW4gbmF2aWdhdG9yIGlzIGluaXRpYWxpemVkLlsvZW5dXG4gICAqICAgW2phXeODiuODk+OCsuODvOOCv+ODvOOBjOWIneacn+WMluOBleOCjOOBn+aZguOBq+ihqOekuuOBmeOCi+ODmuODvOOCuOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlYWJsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUVuYWJsZSBpT1MgXCJzd2lwZSB0byBwb3BcIiBmZWF0dXJlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlLXRhcmdldC13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCAyMHB4XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgd2lkdGggb2Ygc3dpcGVhYmxlIGFyZWEgY2FsY3VsYXRlZCBmcm9tIHRoZSBlZGdlIChpbiBwaXhlbHMpLiBVc2UgdGhpcyB0byBlbmFibGUgc3dpcGUgb25seSB3aGVuIHRoZSBmaW5nZXIgdG91Y2ggb24gdGhlIHNjcmVlbiBlZGdlLlsvZW5dXG4gICAqICAgW2phXeOCueODr+OCpOODl+OBruWIpOWumumgmOWfn+OCkuODlOOCr+OCu+ODq+WNmOS9jeOBp+aMh+WumuOBl+OBvuOBmeOAgueUu+mdouOBruerr+OBi+OCieaMh+WumuOBl+OBn+i3nembouOBq+mBlOOBmeOCi+OBqOODmuODvOOCuOOBjOihqOekuuOBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlLXRocmVzaG9sZFxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVmYXVsdCAwLjJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSBob3cgbXVjaCB0aGUgcGFnZSBuZWVkcyB0byBiZSBzd2lwZWQgYmVmb3JlIHBvcHBpbmcuIEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGAxYC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwic2xpZGVcImAsIGBcImxpZnRcImAsIGBcImZhZGVcImAgYW5kIGBcIm5vbmVcImAuXG4gICAqXG4gICAqICAgICBUaGVzZSBhcmUgcGxhdGZvcm0gYmFzZWQgYW5pbWF0aW9ucy4gRm9yIGZpeGVkIGFuaW1hdGlvbnMsIGFkZCBgXCItaW9zXCJgIG9yIGBcIi1tZFwiYCBzdWZmaXggdG8gdGhlIGFuaW1hdGlvbiBuYW1lLiBFLmcuIGBcImxpZnQtaW9zXCJgLCBgXCJsaWZ0LW1kXCJgLiBEZWZhdWx0cyB2YWx1ZXMgYXJlIGBcInNsaWRlLWlvc1wiYCBhbmQgYFwiZmFkZS1tZFwiYCBkZXBlbmRpbmcgb24gdGhlIHBsYXRmb3JtLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwdXNoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44KL55u05YmN44Gr55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jdXJyZW50UGFnZVxuICAgKiAgIFtlbl1DdXJyZW50IHBhZ2Ugb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrnBhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgcHVzaC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwdXNo5Yem55CG44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVwb3BcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOCi+ebtOWJjeOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuY3VycmVudFBhZ2VcbiAgICogICBbZW5dQ3VycmVudCBwYWdlIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuY2FuY2VsXG4gICAqICAgW2VuXUNhbGwgdGhpcyBmdW5jdGlvbiB0byBjYW5jZWwgdGhlIHBvcC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7plqLmlbDjgpLlkbzjgbPlh7rjgZnjgajjgIFwYWdl44GucG9w44GM44Kt44Oj44Oz44K744Or44GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cHVzaFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciBhIHBhZ2UgaXMgcHVzaGVkLlsvZW5dXG4gICAqICAgW2phXXBhZ2XjgYxwdXNo44GV44KM44Gm44Ki44OL44Oh44O844K344On44Oz44GM57WC5LqG44GX44Gm44GL44KJ55m654Gr44GV44KM44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm5hdmlnYXRvclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5lbnRlclBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBuZXh0IHBhZ2UuWy9lbl1cbiAgICogICBbamFdcHVzaOOBleOCjOOBn3BhZ2Xjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubGVhdmVQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgcHJldmlvdXMgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3ku6XliY3jga5wYWdl44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0cG9wXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGFmdGVyIGEgcGFnZSBpcyBwb3BwZWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBjHBvcOOBleOCjOOBpuOCouODi+ODoeODvOOCt+ODp+ODs+OBjOe1guOCj+OBo+OBn+W+jOOBq+eZuueBq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5uYXZpZ2F0b3JcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZW50ZXJQYWdlXG4gICAqICAgW2VuXU9iamVjdCBvZiB0aGUgbmV4dCBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpuihqOekuuOBleOCjOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5sZWF2ZVBhZ2VcbiAgICogICBbZW5dT2JqZWN0IG9mIHRoZSBwcmV2aW91cyBwYWdlLlsvZW5dXG4gICAqICAgW2phXXBvcOOBleOCjOOBpua2iOOBiOOCi+ODmuODvOOCuOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIGdldCBhbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FuaW1hdG9yRmFjdG9yeTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcbiAgICB0aGlzLl9wYWdlTWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICAgIHRoaXMuX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlTG9hZGVyXG4gICAqIEB0eXBlIHtQYWdlTG9hZGVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUGFnZUxvYWRlciBpbnN0YW5jZS4gSXQgY2FuIGJlIG92ZXJyaWRlbiB0byBjaGFuZ2UgdGhlIHdheSBwYWdlcyBhcmUgbG9hZGVkIGJ5IHRoaXMgZWxlbWVudC4gVXNlZnVsIGZvciBsaWIgZGV2ZWxvcGVycy5bL2VuXVxuICAgKiAgIFtqYV1QYWdlTG9hZGVy44Kk44Oz44K544K/44Oz44K544KS5qC857SN44GX44Gm44GE44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIocGFnZUxvYWRlcikge1xuICAgIGlmICghKHBhZ2VMb2FkZXIgaW5zdGFuY2VvZiBQYWdlTG9hZGVyKSkge1xuICAgICAgdXRpbC50aHJvd1BhZ2VMb2FkZXIoKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IHBhZ2VMb2FkZXI7XG4gIH1cblxuICBfZ2V0UGFnZVRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgcGFnZSB0byBiZSBsb2FkZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLiBUaGlzIHZhbHVlIHRha2VzIHByZWNlZGVuY2Ugb3ZlciB0aGUgYHBhZ2VgIGF0dHJpYnV0ZS4gVXNlZnVsIGZvciBsaWIgZGV2ZWxvcGVycy5bL2VuXVxuICAgKiAgIFtqYV3liJ3mnJ/ljJbmmYLjgavoqq3jgb/ovrzjgoDjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJgcGFnZWDlsZ7mgKfjgafmjIflrprjgZfjgZ/lgKTjgojjgorjgoJgcGFnZWDjg5fjg63jg5Hjg4bjgqPjgavmjIflrprjgZfjgZ/lgKTjgpLlhKrlhYjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XG4gIH1cblxuICBzZXQgcGFnZShwYWdlKSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKCFwbGF0Zm9ybS5pc0FuZHJvaWQoKSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgnc3dpcGVhYmxlJykgPT09ICdmb3JjZScpIHtcbiAgICAgIGxldCBzd2lwZUFuaW1hdG9yO1xuXG4gICAgICB0aGlzLl9zd2lwZSA9IG5ldyBTd2lwZVJldmVhbCh7XG4gICAgICAgIGVsZW1lbnQ6IHRoaXMsXG4gICAgICAgIGdldFRocmVzaG9sZDogKCkgPT4gTWF0aC5tYXgoMC4yLCBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZS10aHJlc2hvbGQnKSkgfHwgMCksXG5cbiAgICAgICAgc3dpcGVNYXg6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9vblN3aXBlICYmIHRoaXMuX29uU3dpcGUoMSwgeyBkdXJhdGlvbjogc3dpcGVBbmltYXRvci5kdXJhdGlvblN3aXBlLCB0aW1pbmc6IHN3aXBlQW5pbWF0b3IudGltaW5nU3dpcGUgfSk7XG4gICAgICAgICAgdGhpc1t0aGlzLnN3aXBlTWF4ID8gJ3N3aXBlTWF4JyA6ICdwb3BQYWdlJ10oeyBhbmltYXRvcjogc3dpcGVBbmltYXRvciB9KTtcbiAgICAgICAgICBzd2lwZUFuaW1hdG9yID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc3dpcGVNaWQ6IChkaXN0YW5jZSwgd2lkdGgpID0+IHtcbiAgICAgICAgICB0aGlzLl9vblN3aXBlICYmIHRoaXMuX29uU3dpcGUoZGlzdGFuY2Uvd2lkdGgpO1xuICAgICAgICAgIHN3aXBlQW5pbWF0b3IudHJhbnNsYXRlKGRpc3RhbmNlLCB3aWR0aCwgdGhpcy50b3BQYWdlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcsIHRoaXMudG9wUGFnZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN3aXBlTWluOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKDAsIHsgZHVyYXRpb246IHN3aXBlQW5pbWF0b3IuZHVyYXRpb25SZXN0b3JlLCB0aW1pbmc6IHN3aXBlQW5pbWF0b3IudGltaW5nU3dpcGUgfSk7XG4gICAgICAgICAgc3dpcGVBbmltYXRvci5yZXN0b3JlKHRoaXMudG9wUGFnZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLCB0aGlzLnRvcFBhZ2UpO1xuICAgICAgICAgIHN3aXBlQW5pbWF0b3IgPSBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlnbm9yZVN3aXBlOiAoZXZlbnQsIGRpc3RhbmNlKSA9PiB7XG4gICAgICAgICAgLy8gQmFzaWMgY29uZGl0aW9uc1xuICAgICAgICAgIGlmICghdGhpcy5faXNSdW5uaW5nICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuXG4gICAgICAgICAgICAvLyBBcmVhIG9yIGRpcmVjdGlvbmFsIGlzc3Vlc1xuICAgICAgICAgICAgY29uc3QgYXJlYSA9IHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdzd2lwZS10YXJnZXQtd2lkdGgnKSB8fCAyNSwgMTApO1xuICAgICAgICAgICAgaWYgKGV2ZW50Lmdlc3R1cmUuZGlyZWN0aW9uID09PSAgJ3JpZ2h0JyAmJiBhcmVhID4gZGlzdGFuY2UpIHtcblxuICAgICAgICAgICAgICAvLyBTd2lwZXMgb24gb25zLWJhY2stYnV0dG9uIGFuZCBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgICAgY29uc3QgaXNCQiA9IGVsID0+IC9vbnMtYmFjay1idXR0b24vaS50ZXN0KGVsLnRhZ05hbWUpO1xuICAgICAgICAgICAgICBpZiAoIWlzQkIoZXZlbnQudGFyZ2V0KSAmJiAhdXRpbC5maW5kUGFyZW50KGV2ZW50LnRhcmdldCwgaXNCQiwgcCA9PiAvb25zLXBhZ2UvaS50ZXN0KHAudGFnTmFtZSkpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBBbmltYXRvciBpcyBzd2lwZWFibGVcbiAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb24gPSAodGhpcy50b3BQYWdlLnB1c2hlZE9wdGlvbnMgfHwge30pLmFuaW1hdGlvbiB8fCB0aGlzLmFuaW1hdG9yRmFjdG9yeS5fYW5pbWF0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IEFuaW1hdG9yID0gX2FuaW1hdG9yRGljdFthbmltYXRpb25dIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgID8gX2FuaW1hdG9yRGljdFthbmltYXRpb25dLmNhbGwoKVxuICAgICAgICAgICAgICAgICAgOiBfYW5pbWF0b3JEaWN0W2FuaW1hdGlvbl07XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIEFuaW1hdG9yICE9PSAndW5kZWZpbmVkJyAmJiBBbmltYXRvci5zd2lwZWFibGUpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXBlQW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTsgLy8gUHJlcGFyZSBmb3IgdGhlIHN3aXBlXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7IC8vIElnbm9yZSBzd2lwZVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ3N3aXBlYWJsZScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIGNvbnN0IGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuICAgIHRoaXMubG9hZGVkID0gZGVmZXJyZWQucHJvbWlzZTtcblxuICAgIHJld3JpdGFibGVzLnJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGNvbnN0IHNob3cgPSAhdXRpbC5oYXNBbnlDb21wb25lbnRBc1BhcmVudCh0aGlzKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IGFuaW1hdGlvbjogJ25vbmUnLCBzaG93IH07XG5cbiAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl9nZXRQYWdlVGFyZ2V0KCkpIHtcbiAgICAgICAgdGhpcy5wdXNoUGFnZSh0aGlzLl9nZXRQYWdlVGFyZ2V0KCksIG9wdGlvbnMpLnRoZW4oKCkgPT4gZGVmZXJyZWQucmVzb2x2ZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZlcmlmeVBhZ2VFbGVtZW50KHRoaXMucGFnZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudG9wUGFnZSkge1xuICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLnRvcFBhZ2UsICgpID0+XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICBzaG93ICYmIHRoaXMudG9wUGFnZS5fc2hvdygpO1xuICAgICAgICAgICAgICB0aGlzLl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24oKTtcbiAgICAgICAgICAgIH0sIDApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5fZ2V0UGFnZVRhcmdldCgpKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hQYWdlKHRoaXMuX2dldFBhZ2VUYXJnZXQoKSwgb3B0aW9ucykudGhlbigoKSA9PiBkZWZlcnJlZC5yZXNvbHZlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgdGhpcy5fYW5pbWF0b3JGYWN0b3J5ID0gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IE5hdmlnYXRvckFuaW1hdG9yLFxuICAgICAgYmFzZUNsYXNzTmFtZTogJ05hdmlnYXRvckFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcblxuICAgIHRoaXMuX3N3aXBlICYmIHRoaXMuX3N3aXBlLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9zd2lwZSA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydhbmltYXRpb24nLCAnc3dpcGVhYmxlJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaChuYW1lKSB7XG4gICAgICBjYXNlICdhbmltYXRpb24nOlxuICAgICAgICB0aGlzLl91cGRhdGVBbmltYXRvckZhY3RvcnkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzd2lwZWFibGUnOlxuICAgICAgICB0aGlzLl9zd2lwZSAmJiB0aGlzLl9zd2lwZS51cGRhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgcG9wUGFnZVxuICAgKiBAc2lnbmF0dXJlIHBvcFBhZ2UoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jg6Hjgr3jg4Pjg4njgavjgojjgovnlLvpnaLpgbfnp7vjgYzntYLkuobjgZfjgZ/pmpvjgavlkbzjgbPlh7rjgZXjgozjgovplqLmlbDjgqrjg5bjgrjjgqfjgq/jg4jjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZGF0YV1cbiAgICogICBbZW5dQ3VzdG9tIGRhdGEgdGhhdCB3aWxsIGJlIHN0b3JlZCBpbiB0aGUgbmV3IHBhZ2UgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGltZXNdXG4gICAqICAgW2VuXU51bWJlciBvZiBwYWdlcyB0byBiZSBwb3BwZWQuIE9ubHkgb25lIGFuaW1hdGlvbiB3aWxsIGJlIHNob3duLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHJldmVhbGVkIHBhZ2UuWy9lbl1cbiAgICogICBbamFd5piO44KJ44GL44Gr44GX44Gf44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Qb3BzIHRoZSBjdXJyZW50IHBhZ2UgZnJvbSB0aGUgcGFnZSBzdGFjay4gVGhlIHByZXZpb3VzIHBhZ2Ugd2lsbCBiZSBkaXNwbGF5ZWQuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S65Lit44Gu44Oa44O844K444KS44Oa44O844K444K544K/44OD44Kv44GL44KJ5Y+W44KK6Zmk44GN44G+44GZ44CC5LiA44Gk5YmN44Gu44Oa44O844K444Gr5oi744KK44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHBvcFBhZ2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgKHtvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhudWxsLCBvcHRpb25zKSk7XG5cbiAgICBpZiAodXRpbC5pc0ludGVnZXIob3B0aW9ucy50aW1lcykgJiYgb3B0aW9ucy50aW1lcyA+IDEpIHtcbiAgICAgIHRoaXMuX3JlbW92ZVBhZ2VzKG9wdGlvbnMudGltZXMpO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcFVwZGF0ZSA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV0pO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX3BvcFBhZ2Uob3B0aW9ucywgcG9wVXBkYXRlKTtcbiAgfVxuXG4gIF9wb3BQYWdlKG9wdGlvbnMsIHVwZGF0ZSA9ICgpID0+IFByb21pc2UucmVzb2x2ZSgpKSB7XG4gICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdwb3BQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYWdlcy5sZW5ndGggPD0gMSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdvbnMtbmF2aWdhdG9yXFwncyBwYWdlIHN0YWNrIGlzIGVtcHR5LicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbWl0UHJlUG9wRXZlbnQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5jZWxlZCBpbiBwcmVwb3AgZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5wYWdlcy5sZW5ndGg7XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5wYWdlc1tsZW5ndGggLSAyXS51cGRhdGVCYWNrQnV0dG9uKChsZW5ndGggLSAyKSA+IDApO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgbGVhdmVQYWdlID0gdGhpcy5wYWdlc1tsZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGVudGVyUGFnZSA9IHRoaXMucGFnZXNbbGVuZ3RoIC0gMl07XG5cbiAgICAgIG9wdGlvbnMgPSB1dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zIHx8IHt9LCBsZWF2ZVBhZ2UucHVzaGVkT3B0aW9ucyB8fCB7fSwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgZW50ZXJQYWdlLmRhdGEgPSB1dGlsLmV4dGVuZCh7fSwgZW50ZXJQYWdlLmRhdGEgfHwge30sIG9wdGlvbnMuZGF0YSB8fCB7fSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgZW50ZXJQYWdlLl9zaG93KCk7XG4gICAgICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0cG9wJywge2xlYXZlUGFnZSwgZW50ZXJQYWdlLCBuYXZpZ2F0b3I6IHRoaXN9KTtcblxuICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgJiYgb3B0aW9ucy5jYWxsYmFjayhlbnRlclBhZ2UpO1xuXG4gICAgICAgICAgcmVzb2x2ZShlbnRlclBhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGxlYXZlUGFnZS5faGlkZSgpO1xuICAgICAgZW50ZXJQYWdlLnN0eWxlLmRpc3BsYXkgPSAnJztcblxuICAgICAgY29uc3QgYW5pbWF0b3IgPSBvcHRpb25zLmFuaW1hdG9yIHx8IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcihvcHRpb25zKTtcbiAgICAgIGFuaW1hdG9yLnBvcCh0aGlzLnBhZ2VzW2xlbmd0aCAtIDJdLCB0aGlzLnBhZ2VzW2xlbmd0aCAtIDFdLCBkb25lKTtcbiAgICB9KS5jYXRjaCgoKSA9PiB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHB1c2hQYWdlXG4gICAqIEBzaWduYXR1cmUgcHVzaFBhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGFnZVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gQ2FuIGJlIGVpdGhlciBhIEhUTUwgZG9jdW1lbnQgb3IgYSB0ZW1wbGF0ZSBkZWZpbmVkIHdpdGggdGhlIGA8dGVtcGxhdGU+YCB0YWcuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgeOCguOBl+OBj+OBr2A8dGVtcGxhdGU+YOOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wYWdlXVxuICAgKiAgIFtlbl1QYWdlIFVSTC4gT25seSBuZWNlc3NhcnkgaWYgYHBhZ2VgIHBhcmFtZXRlciBpcyBudWxsIG9yIHVuZGVmaW5lZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGFnZUhUTUxdXG4gICAqICAgW2VuXUhUTUwgY29kZSB0aGF0IHdpbGwgYmUgY29tcHV0ZWQgYXMgYSBuZXcgcGFnZS4gT3ZlcndyaXRlcyBgcGFnZWAgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXVxuICAgKiAgICAgQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJzbGlkZVwiYCwgYFwibGlmdFwiYCwgYFwiZmFkZVwiYCBhbmQgYFwibm9uZVwiYC5cbiAgICpcbiAgICogICAgIFRoZXNlIGFyZSBwbGF0Zm9ybSBiYXNlZCBhbmltYXRpb25zLiBGb3IgZml4ZWQgYW5pbWF0aW9ucywgYWRkIGBcIi1pb3NcImAgb3IgYFwiLW1kXCJgIHN1ZmZpeCB0byB0aGUgYW5pbWF0aW9uIG5hbWUuIEUuZy4gYFwibGlmdC1pb3NcImAsIGBcImxpZnQtbWRcImAuIERlZmF1bHRzIHZhbHVlcyBhcmUgYFwic2xpZGUtaW9zXCJgIGFuZCBgXCJmYWRlLW1kXCJgLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWBbL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1GdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2l0aW9uIGhhcyBlbmRlZC5bL2VuXVxuICAgKiAgIFtqYV1wdXNoUGFnZSgp44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf5pmC44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmRhdGFdXG4gICAqICAgW2VuXUN1c3RvbSBkYXRhIHRoYXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcHVzaGVkIHBhZ2UuWy9lbl1cbiAgICogICBbamFd6L+95Yqg44GX44Gf44Oa44O844K444KS6Kej5rG644GZ44KLUHJvbWlzZeOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1QdXNoZXMgdGhlIHNwZWNpZmllZCBwYWdlIGludG8gdGhlIHN0YWNrLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn3BhZ2XjgpLmlrDjgZfjgYTjg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgavov73liqDjgZfjgb7jgZnjgILmlrDjgZfjgYTjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcHVzaFBhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgKHtwYWdlLCBvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG5cbiAgICBjb25zdCBwcmVwYXJlID0gcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgdmVyaWZ5UGFnZUVsZW1lbnQocGFnZUVsZW1lbnQpO1xuICAgICAgdGhpcy5fcGFnZU1hcC5zZXQocGFnZUVsZW1lbnQsIHBhZ2UpO1xuICAgICAgcGFnZUVsZW1lbnQgPSB1dGlsLmV4dGVuZChwYWdlRWxlbWVudCwge1xuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGFcbiAgICAgIH0pO1xuICAgICAgcGFnZUVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5wYWdlSFRNTCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMsICgpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBpbnN0YW50UGFnZUxvYWRlci5sb2FkKHtwYWdlOiBvcHRpb25zLnBhZ2VIVE1MLCBwYXJlbnQ6IHRoaXMsIHBhcmFtczogb3B0aW9ucy5kYXRhfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICAgIHByZXBhcmUocGFnZUVsZW1lbnQpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3B1c2hQYWdlKG9wdGlvbnMsICgpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHtwYWdlLCBwYXJlbnQ6IHRoaXMsIHBhcmFtczogb3B0aW9ucy5kYXRhfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICBwcmVwYXJlKHBhZ2VFbGVtZW50KTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG5cbiAgX3B1c2hQYWdlKG9wdGlvbnMgPSB7fSwgdXBkYXRlID0gKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ3B1c2hQYWdlIGlzIGFscmVhZHkgcnVubmluZy4nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZW1pdFByZVB1c2hFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXB1c2ggZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKTtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucyB8fCB7fSwge2FuaW1hdGlvbk9wdGlvbnN9LCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGFuaW1hdG9yID0gdGhpcy5fYW5pbWF0b3JGYWN0b3J5Lm5ld0FuaW1hdG9yKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHVwZGF0ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgcGFnZUxlbmd0aCA9IHRoaXMucGFnZXMubGVuZ3RoO1xuXG4gICAgICBjb25zdCBlbnRlclBhZ2UgID0gdGhpcy5wYWdlc1twYWdlTGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCBsZWF2ZVBhZ2UgPSBvcHRpb25zLmxlYXZlUGFnZSB8fCB0aGlzLnBhZ2VzW3BhZ2VMZW5ndGggLSAyXTtcblxuICAgICAgdmVyaWZ5UGFnZUVsZW1lbnQoZW50ZXJQYWdlKTtcblxuICAgICAgZW50ZXJQYWdlLnVwZGF0ZUJhY2tCdXR0b24ocGFnZUxlbmd0aCA+IChvcHRpb25zLl9yZXBsYWNlUGFnZSA/IDIgOiAxKSk7XG5cbiAgICAgIGVudGVyUGFnZS5wdXNoZWRPcHRpb25zID0gdXRpbC5leHRlbmQoe30sIGVudGVyUGFnZS5wdXNoZWRPcHRpb25zIHx8IHt9LCBvcHRpb25zIHx8IHt9KTtcbiAgICAgIGVudGVyUGFnZS5kYXRhID0gdXRpbC5leHRlbmQoe30sIGVudGVyUGFnZS5kYXRhIHx8IHt9LCBvcHRpb25zLmRhdGEgfHwge30pO1xuICAgICAgZW50ZXJQYWdlLnVubG9hZCA9IGVudGVyUGFnZS51bmxvYWQgfHwgb3B0aW9ucy51bmxvYWQ7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgICAgICAgIG9wdGlvbnMuc2hvdyAhPT0gZmFsc2UgJiYgc2V0SW1tZWRpYXRlKCgpID0+IGVudGVyUGFnZS5fc2hvdygpKTtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3Bvc3RwdXNoJywge2xlYXZlUGFnZSwgZW50ZXJQYWdlLCBuYXZpZ2F0b3I6IHRoaXN9KTtcblxuICAgICAgICAgIGlmIChsZWF2ZVBhZ2UpIHtcbiAgICAgICAgICAgIGxlYXZlUGFnZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgJiYgb3B0aW9ucy5jYWxsYmFjayhlbnRlclBhZ2UpO1xuXG4gICAgICAgICAgcmVzb2x2ZShlbnRlclBhZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVudGVyUGFnZS5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIGlmIChsZWF2ZVBhZ2UpIHtcbiAgICAgICAgICBsZWF2ZVBhZ2UuX2hpZGUoKTtcbiAgICAgICAgICBhbmltYXRvci5wdXNoKGVudGVyUGFnZSwgbGVhdmVQYWdlLCBkb25lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlcGxhY2VQYWdlXG4gICAqIEBzaWduYXR1cmUgcmVwbGFjZVBhZ2UocGFnZSwgW29wdGlvbnNdKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1Qcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mlrDjgZfjgYTjg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJlcGxhY2VzIHRoZSBjdXJyZW50IHRvcCBwYWdlIHdpdGggdGhlIHNwZWNpZmllZCBvbmUuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd54++5Zyo6KGo56S65Lit44Gu44Oa44O844K444KS44KS5oyH5a6a44GX44Gf44Oa44O844K444Gr572u44GN5o+b44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHJlcGxhY2VQYWdlKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpXG4gICAgICAudGhlbihyZXNvbHZlZFZhbHVlID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNvbHZlZFZhbHVlKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgaW5zZXJ0UGFnZVxuICAgKiBAc2lnbmF0dXJlIGluc2VydFBhZ2UoaW5kZXgsIHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRoZSBpbmRleCB3aGVyZSBpdCBzaG91bGQgYmUgaW5zZXJ0ZWQuWy9lbl1cbiAgICogICBbamFd44K544K/44OD44Kv44Gr5oy/5YWl44GZ44KL5L2N572u44Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgaW5zZXJ0ZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUluc2VydCB0aGUgc3BlY2lmaWVkIHBhZ2UgaW50byB0aGUgc3RhY2sgd2l0aCBhdCBhIHBvc2l0aW9uIGRlZmluZWQgYnkgdGhlIGBpbmRleGAgYXJndW1lbnQuIEV4dGVuZHMgYHB1c2hQYWdlKClgIHBhcmFtZXRlcnMuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44GfcGFnZeOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBrmluZGV444Gn5oyH5a6a44GX44Gf5L2N572u44Gr6L+95Yqg44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGluc2VydFBhZ2UoaW5kZXgsIHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICh7cGFnZSwgb3B0aW9uc30gPSB0aGlzLl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMocGFnZSwgb3B0aW9ucykpO1xuICAgIGluZGV4ID0gdGhpcy5fbm9ybWFsaXplSW5kZXgoaW5kZXgpO1xuXG4gICAgaWYgKGluZGV4ID49IHRoaXMucGFnZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdXNoUGFnZShwYWdlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBwYWdlID0gdHlwZW9mIG9wdGlvbnMucGFnZUhUTUwgPT09ICdzdHJpbmcnID8gb3B0aW9ucy5wYWdlSFRNTCA6IHBhZ2U7XG4gICAgY29uc3QgbG9hZGVyID0gdHlwZW9mIG9wdGlvbnMucGFnZUhUTUwgPT09ICdzdHJpbmcnID8gaW5zdGFudFBhZ2VMb2FkZXIgOiB0aGlzLl9wYWdlTG9hZGVyO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbG9hZGVyLmxvYWQoe3BhZ2UsIHBhcmVudDogdGhpc30sIHBhZ2VFbGVtZW50ID0+IHtcbiAgICAgICAgdmVyaWZ5UGFnZUVsZW1lbnQocGFnZUVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9wYWdlTWFwLnNldChwYWdlRWxlbWVudCwgcGFnZSk7XG4gICAgICAgIHBhZ2VFbGVtZW50ID0gdXRpbC5leHRlbmQocGFnZUVsZW1lbnQsIHtcbiAgICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGEsXG4gICAgICAgICAgcHVzaGVkT3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9KTtcblxuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgPSB1dGlsLmV4dGVuZChcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBBbmltYXRvckZhY3RvcnkucGFyc2VBbmltYXRpb25PcHRpb25zU3RyaW5nKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSxcbiAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnMgfHwge31cbiAgICAgICAgKTtcblxuICAgICAgICBwYWdlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShwYWdlRWxlbWVudCwgdGhpcy5wYWdlc1tpbmRleF0pO1xuICAgICAgICB0aGlzLnRvcFBhZ2UudXBkYXRlQmFja0J1dHRvbih0cnVlKTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBwYWdlRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgcmVzb2x2ZSh0aGlzLnBhZ2VzW2luZGV4XSk7XG4gICAgICAgIH0sIDEwMDAgLyA2MCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHJlbW92ZVBhZ2VcbiAgICogQHNpZ25hdHVyZSByZW1vdmVQYWdlKGluZGV4LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxuICAgKiAgIFtlbl1UaGUgaW5kZXggd2hlcmUgaXQgc2hvdWxkIGJlIHJlbW92ZWQuWy9lbl1cbiAgICogICBbamFd44K544K/44OD44Kv44GL44KJ5YmK6Zmk44GZ44KL44Oa44O844K444Gu44Kk44Oz44OH44OD44Kv44K544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgcmV2ZWFsZWQgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3liYrpmaTjgavjgojjgaPjgabooajnpLrjgZXjgozjgZ/jg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJlbW92ZSB0aGUgc3BlY2lmaWVkIHBhZ2UgYXQgYSBwb3NpdGlvbiBpbiB0aGUgc3RhY2sgZGVmaW5lZCBieSB0aGUgYGluZGV4YCBhcmd1bWVudC4gRXh0ZW5kcyBgcG9wUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+OCpOODs+ODh+ODg+OCr+OCueOBq+OBguOCi+ODmuODvOOCuOOCkuWJiumZpOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICByZW1vdmVQYWdlKGluZGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpbmRleCA9IHRoaXMuX25vcm1hbGl6ZUluZGV4KGluZGV4KTtcblxuICAgIGlmIChpbmRleCA8IHRoaXMucGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCBsZWF2ZVBhZ2UgPSB0aGlzLnBhZ2VzW2luZGV4XTtcbiAgICAgICAgY29uc3QgZW50ZXJQYWdlID0gdGhpcy50b3BQYWdlO1xuXG4gICAgICAgIHRoaXMuX3BhZ2VNYXAuZGVsZXRlKGxlYXZlUGFnZSk7XG4gICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKGxlYXZlUGFnZSk7XG4gICAgICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA9PT0gMSkgeyAvLyBlZGdlIGNhc2VcbiAgICAgICAgICB0aGlzLnRvcFBhZ2UudXBkYXRlQmFja0J1dHRvbihmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKGVudGVyUGFnZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucG9wUGFnZShvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCByZXNldFRvUGFnZVxuICAgKiBAc2lnbmF0dXJlIHJlc2V0VG9QYWdlKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgbmV3IHRvcCBwYWdlLlsvZW5dXG4gICAqICAgW2phXeaWsOOBl+OBhOODiOODg+ODl+ODmuODvOOCuOOCkuino+axuuOBmeOCi1Byb21pc2XjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnBvcF1cbiAgICogICBbZW5dUGVyZm9ybXMgJ3BvcCcgZWZmZWN0IGlmIGB0cnVlYCBpbnN0ZWFkIG9mICdwdXNoJyBvciBub25lLiBUaGlzIGFsc28gc2V0cyBgb3B0aW9ucy5hbmltYXRpb25gIHZhbHVlIHRvIGBkZWZhdWx0YCBpbnN0ZWFkIG9mIGBub25lYC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2xlYXJzIHBhZ2Ugc3RhY2sgYW5kIGFkZHMgdGhlIHNwZWNpZmllZCBwYWdlIHRvIHRoZSBzdGFjay4gRXh0ZW5kcyBgcHVzaFBhZ2UoKWAgcGFyYW1ldGVycy5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgrnjgr/jg4Pjgq/jgpLjg6rjgrvjg4Pjg4jjgZfjgIHmjIflrprjgZfjgZ/jg5rjg7zjgrjjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgcmVzZXRUb1BhZ2UocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgKHtwYWdlLCBvcHRpb25zfSA9IHRoaXMuX3ByZXBhcmVQYWdlQW5kT3B0aW9ucyhwYWdlLCBvcHRpb25zKSk7XG5cbiAgICBpZiAoIW9wdGlvbnMuYW5pbWF0b3IgJiYgIW9wdGlvbnMuYW5pbWF0aW9uICYmICFvcHRpb25zLnBvcCkge1xuICAgICAgb3B0aW9ucy5hbmltYXRpb24gPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnBhZ2UgJiYgIW9wdGlvbnMucGFnZUhUTUwgJiYgdGhpcy5fZ2V0UGFnZVRhcmdldCgpKSB7XG4gICAgICBwYWdlID0gb3B0aW9ucy5wYWdlID0gdGhpcy5fZ2V0UGFnZVRhcmdldCgpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnBvcCkge1xuICAgICAgdGhpcy5fcmVtb3ZlUGFnZXMoKVxuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0UGFnZSgwLCBwYWdlLCB7IGRhdGE6IG9wdGlvbnMuZGF0YSB9KVxuICAgICAgICAudGhlbigoKSA9PiB0aGlzLnBvcFBhZ2Uob3B0aW9ucykpO1xuICAgIH1cblxuICAgIC8vIFRpcDogY2FsbGJhY2sgcnVucyBiZWZvcmUgcmVzb2x2ZWQgcHJvbWlzZVxuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgICBvcHRpb25zLmNhbGxiYWNrID0gbmV3UGFnZSA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVQYWdlcygpXG4gICAgICBuZXdQYWdlLnVwZGF0ZUJhY2tCdXR0b24oZmFsc2UpO1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2sobmV3UGFnZSk7XG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzLnB1c2hQYWdlKHBhZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYnJpbmdQYWdlVG9wXG4gICAqIEBzaWduYXR1cmUgYnJpbmdQYWdlVG9wKGl0ZW0sIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpdGVtXG4gICAqICAgW2VuXVBhZ2UgVVJMIG9yIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UgaW4gbmF2aWdhdG9yJ3Mgc3RhY2suWy9lbl1cbiAgICogICBbamFd44Oa44O844K444GuVVJM44GL44KC44GX44GP44Gvb25zLW5hdmlnYXRvcuOBruODmuODvOOCuOOCueOCv+ODg+OCr+OBruOCpOODs+ODh+ODg+OCr+OCueWApOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIG5ldyB0b3AgcGFnZS5bL2VuXVxuICAgKiAgIFtqYV3mlrDjgZfjgYTjg4jjg4Pjg5fjg5rjg7zjgrjjgpLop6PmsbrjgZnjgotQcm9taXNl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJyaW5ncyB0aGUgZ2l2ZW4gcGFnZSB0byB0aGUgdG9wIG9mIHRoZSBwYWdlIHN0YWNrIGlmIGl0IGFscmVhZHkgZXhpc3RzIG9yIHB1c2hlcyBpdCBpbnRvIHRoZSBzdGFjayBpZiBkb2Vzbid0LiBFeHRlbmRzIGBwdXNoUGFnZSgpYCBwYXJhbWV0ZXJzLlsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn+ODmuODvOOCuOOCkuODmuODvOOCuOOCueOCv+ODg+OCr+OBruS4gOeVquS4iuOBq+enu+WLleOBl+OBvuOBmeOAguOCguOBl+aMh+WumuOBl+OBn+ODmuODvOOCuOOBjOeEoeOBi+OBo+OBn+WgtOWQiOaWsOOBl+OBj3B1c2jjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgYnJpbmdQYWdlVG9wKGl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChbJ251bWJlcicsICdzdHJpbmcnXS5pbmRleE9mKHR5cGVvZiBpdGVtKSA9PT0gLTEpIHtcbiAgICAgIHV0aWwudGhyb3coJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwYWdlIG5hbWUgb3IgdGhlIGluZGV4IG9mIGFuIGV4aXN0aW5nIHBhZ2UuIFlvdSBzdXBwbGllZCAnICsgaXRlbSk7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gdHlwZW9mIGl0ZW0gPT09ICdudW1iZXInID8gdGhpcy5fbm9ybWFsaXplSW5kZXgoaXRlbSkgOiB0aGlzLl9sYXN0SW5kZXhPZlBhZ2UoaXRlbSk7XG4gICAgY29uc3QgcGFnZSA9IHRoaXMucGFnZXNbaW5kZXhdO1xuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVzaFBhZ2UoaXRlbSwgb3B0aW9ucyk7XG4gICAgfVxuICAgICh7b3B0aW9uc30gPSB0aGlzLl9wcmVwYXJlUGFnZUFuZE9wdGlvbnMocGFnZSwgb3B0aW9ucykpO1xuXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnBhZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGFnZSk7XG4gICAgfVxuICAgIGlmICghcGFnZSkge1xuICAgICAgdXRpbC50aHJvdygnRmFpbGVkIHRvIGZpbmQgaXRlbSAnICsgaXRlbSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgncHVzaFBhZ2UgaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZW1pdFByZVB1c2hFdmVudCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0NhbmNlbGVkIGluIHByZXB1c2ggZXZlbnQuJyk7XG4gICAgfVxuXG4gICAgcGFnZS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgcGFnZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgcGFnZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHBhZ2UpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoUGFnZShvcHRpb25zKTtcbiAgfVxuXG4gIF9wcmVwYXJlUGFnZUFuZE9wdGlvbnMocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9ICdvYmplY3QnKSB7XG4gICAgICB1dGlsLnRocm93KCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0LiBZb3Ugc3VwcGxpZWQgJyArIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmICgocGFnZSA9PT0gbnVsbCB8fCBwYWdlID09PSB1bmRlZmluZWQpICYmIG9wdGlvbnMucGFnZSkge1xuICAgICAgcGFnZSA9IG9wdGlvbnMucGFnZTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucyB8fCB7fSwgb3B0aW9ucywge3BhZ2V9KTtcblxuICAgIHJldHVybiB7cGFnZSwgb3B0aW9uc307XG4gIH1cblxuICBfcmVtb3ZlUGFnZXModGltZXMpIHtcbiAgICBjb25zdCBwYWdlcyA9IHRoaXMucGFnZXM7XG4gICAgbGV0IHVudGlsID0gdGltZXMgPT09IHVuZGVmaW5lZCA/IDAgOiBwYWdlcy5sZW5ndGggLSB0aW1lcztcbiAgICB1bnRpbCA9IHVudGlsIDwgMCA/IDEgOiB1bnRpbDtcblxuICAgIGZvciAobGV0IGkgPSBwYWdlcy5sZW5ndGggLSAyOyBpID49IHVudGlsOyBpLS0pIHtcbiAgICAgIHRoaXMuX3BhZ2VNYXAuZGVsZXRlKHBhZ2VzW2ldKTtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHBhZ2VzW2ldKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlTGFzdFBhZ2VCYWNrQnV0dG9uKCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLnBhZ2VzW2luZGV4XS51cGRhdGVCYWNrQnV0dG9uKGluZGV4ID4gMCk7XG4gICAgfVxuICB9XG5cbiAgX25vcm1hbGl6ZUluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgPyBpbmRleCA6IE1hdGguYWJzKHRoaXMucGFnZXMubGVuZ3RoICsgaW5kZXgpICUgdGhpcy5wYWdlcy5sZW5ndGg7XG4gIH1cblxuICBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucGFnZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5wb3BQYWdlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gICAgfVxuICB9XG5cbiAgX2xhc3RJbmRleE9mUGFnZShwYWdlTmFtZSkge1xuICAgIGxldCBpbmRleDtcbiAgICBmb3IgKGluZGV4ID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhZ2VNYXAuaGFzKHRoaXMucGFnZXNbaW5kZXhdKSkge1xuICAgICAgICB1dGlsLnRocm93KCdJbmNvcnJlY3Qgc3RhdGUgb2YgcGFnZU1hcCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFnZU5hbWUgPT09IHRoaXMuX3BhZ2VNYXAuZ2V0KHRoaXMucGFnZXNbaW5kZXhdKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgX2VtaXRQcmVFdmVudChuYW1lLCBkYXRhID0ge30pIHtcbiAgICBsZXQgaXNDYW5jZWxlZCA9IGZhbHNlO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmUnICsgbmFtZSwgdXRpbC5leHRlbmQoe1xuICAgICAgbmF2aWdhdG9yOiB0aGlzLFxuICAgICAgY3VycmVudFBhZ2U6IHRoaXMucGFnZXNbdGhpcy5wYWdlcy5sZW5ndGggLSAxXSxcbiAgICAgIGNhbmNlbDogKCkgPT4gaXNDYW5jZWxlZCA9IHRydWVcbiAgICB9LCBkYXRhKSk7XG5cbiAgICByZXR1cm4gaXNDYW5jZWxlZDtcbiAgfVxuXG4gIF9lbWl0UHJlUHVzaEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9lbWl0UHJlRXZlbnQoJ3B1c2gnKTtcbiAgfVxuXG4gIF9lbWl0UHJlUG9wRXZlbnQoKSB7XG4gICAgY29uc3QgbCA9IHRoaXMucGFnZXMubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9lbWl0UHJlRXZlbnQoJ3BvcCcsIHtcbiAgICAgIGxlYXZlUGFnZTogdGhpcy5wYWdlc1tsIC0gMV0sXG4gICAgICBlbnRlclBhZ2U6IHRoaXMucGFnZXNbbCAtIDJdXG4gICAgfSk7XG4gIH1cblxuICAvLyBUT0RPOiDmm7jjgY3nm7TjgZlcbiAgX2NyZWF0ZVBhZ2VFbGVtZW50KHRlbXBsYXRlSFRNTCkge1xuICAgIGNvbnN0IHBhZ2VFbGVtZW50ID0gdXRpbC5jcmVhdGVFbGVtZW50KGludGVybmFsLm5vcm1hbGl6ZVBhZ2VIVE1MKHRlbXBsYXRlSFRNTCkpO1xuICAgIHZlcmlmeVBhZ2VFbGVtZW50KHBhZ2VFbGVtZW50KTtcbiAgICByZXR1cm4gcGFnZUVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uRGV2aWNlQmFja0J1dHRvblxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQmFjay1idXR0b24gaGFuZGxlci5bL2VuXVxuICAgKiAgIFtqYV3jg5Djg4Pjgq/jg5zjgr/jg7Pjg4/jg7Pjg4njg6njgIJbL2phXVxuICAgKi9cbiAgZ2V0IG9uRGV2aWNlQmFja0J1dHRvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja0J1dHRvbkhhbmRsZXI7XG4gIH1cblxuICBzZXQgb25EZXZpY2VCYWNrQnV0dG9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyKSB7XG4gICAgICB0aGlzLl9iYWNrQnV0dG9uSGFuZGxlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIgPSBkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlci5jcmVhdGVIYW5kbGVyKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdG9wUGFnZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCB0b3AgcGFnZSBlbGVtZW50LiBVc2UgdGhpcyBtZXRob2QgdG8gYWNjZXNzIG9wdGlvbnMgcGFzc2VkIGJ5IGBwdXNoUGFnZSgpYC1saWtlIG1ldGhvZHMuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Oa44O844K444KS5Y+W5b6X44GX44G+44GZ44CCcHVzaFBhZ2UoKeOChHJlc2V0VG9QYWdlKCnjg6Hjgr3jg4Pjg4njga7lvJXmlbDjgpLlj5blvpfjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHRvcFBhZ2UoKSB7XG4gICAgbGV0IGxhc3QgPSB0aGlzLmxhc3RFbGVtZW50Q2hpbGQ7XG4gICAgd2hpbGUgKGxhc3QgJiYgbGFzdC50YWdOYW1lICE9PSAnT05TLVBBR0UnKSB7IGxhc3QgPSBsYXN0LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7IH1cbiAgICByZXR1cm4gbGFzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZXNcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNvcHkgb2YgdGhlIG5hdmlnYXRvcidzIHBhZ2Ugc3RhY2suWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5jaGlsZHJlbilcbiAgICAgIC5maWx0ZXIoZWxlbWVudCA9PiBlbGVtZW50LnRhZ05hbWUgPT09ICdPTlMtUEFHRScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvblN3aXBlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhvb2sgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIHNsaWRlcyB0aGUgbmF2aWdhdG9yIChzd2lwZS10by1wb3ApLiBJdCBnZXRzIGEgZGVjaW1hbCByYXRpbyAoMC0xKSBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25Td2lwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25Td2lwZTtcbiAgfVxuXG4gIHNldCBvblN3aXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHV0aWwudGhyb3coJ1wib25Td2lwZVwiIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICB0aGlzLl9vblN3aXBlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9wdGlvbnNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURlZmF1bHQgb3B0aW9ucyBvYmplY3QuIEF0dHJpYnV0ZXMgaGF2ZSBwcmlvcml0eSBvdmVyIHRoaXMgcHJvcGVydHkuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dXG4gICAqICAgICBBbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcInNsaWRlXCJgLCBgXCJsaWZ0XCJgLCBgXCJmYWRlXCJgIGFuZCBgXCJub25lXCJgLlxuICAgKiAgICAgVGhlc2UgYXJlIHBsYXRmb3JtIGJhc2VkIGFuaW1hdGlvbnMuIEZvciBmaXhlZCBhbmltYXRpb25zLCBhZGQgYFwiLWlvc1wiYCBvciBgXCItbWRcImAgc3VmZml4IHRvIHRoZSBhbmltYXRpb24gbmFtZS4gRS5nLiBgXCJsaWZ0LWlvc1wiYCwgYFwibGlmdC1tZFwiYC4gRGVmYXVsdHMgdmFsdWVzIGFyZSBgXCJzbGlkZS1pb3NcImAgYW5kIGBcImZhZGUtbWRcImAuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9ucy5jYWxsYmFja1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgdHJhbnNpdGlvbiBoYXMgZW5kZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Oh44K944OD44OJ44Gr44KI44KL55S76Z2i6YG356e744GM57WC5LqG44GX44Gf6Zqb44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob2JqZWN0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9iamVjdDtcbiAgfVxuXG4gIHNldCBfaXNSdW5uaW5nKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ19pcy1ydW5uaW5nJywgdmFsdWUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgfVxuICBnZXQgX2lzUnVubmluZygpIHtcbiAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKCdfaXMtcnVubmluZycpKTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIHRoaXMubG9hZGVkLnRoZW4oKCkgPT4gdGhpcy50b3BQYWdlICYmIHRoaXMudG9wUGFnZS5fc2hvdygpKVxuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdGhpcy50b3BQYWdlICYmIHRoaXMudG9wUGFnZS5faGlkZSgpXG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5wYWdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQodGhpcy5wYWdlc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBBbmltYXRvclxuICAgKi9cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBOYXZpZ2F0b3JBbmltYXRvcikpIHtcbiAgICAgIHV0aWwudGhyb3dBbmltYXRvcignTmF2aWdhdG9yJyk7XG4gICAgfVxuXG4gICAgX2FuaW1hdG9yRGljdFtuYW1lXSA9IEFuaW1hdG9yO1xuICB9XG5cbiAgc3RhdGljIGdldCBhbmltYXRvcnMoKSB7XG4gICAgcmV0dXJuIF9hbmltYXRvckRpY3Q7XG4gIH1cblxuICBzdGF0aWMgZ2V0IE5hdmlnYXRvckFuaW1hdG9yKCkge1xuICAgIHJldHVybiBOYXZpZ2F0b3JBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ3ByZXB1c2gnLCAncG9zdHB1c2gnLCAncHJlcG9wJywgJ3Bvc3Rwb3AnXTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLk5hdmlnYXRvciA9IE5hdmlnYXRvckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1uYXZpZ2F0b3InLCBOYXZpZ2F0b3JFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICd0b29sYmFyJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3Rvb2xiYXItLSonLFxuICAnLnRvb2xiYXJfX2xlZnQnOiAndG9vbGJhci0tKl9fbGVmdCcsXG4gICcudG9vbGJhcl9fY2VudGVyJzogJ3Rvb2xiYXItLSpfX2NlbnRlcicsXG4gICcudG9vbGJhcl9fcmlnaHQnOiAndG9vbGJhci0tKl9fcmlnaHQnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy10b29sYmFyXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gdG9vbGJhci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB0cmFuc3BhcmVudFxuICogICBbZW5dVHJhbnNwYXJlbnQgdG9vbGJhci5bL2VuXVxuICogICBbamFd6YCP5piO44Gq6IOM5pmv44KS5oyB44Gk44OE44O844Or44OQ44O844KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAqIEBtb2RpZmllciBjb3Zlci1jb250ZW50XG4gKiAgIFtlbl1EaXNwbGF5cyB0aGUgdG9vbGJhciBvbiB0b3Agb2YgdGhlIHBhZ2UncyBjb250ZW50LiBTaG91bGQgYmUgY29tYmluZWQgd2l0aCBgdHJhbnNwYXJlbnRgIG1vZGlmaWVyLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQG1vZGlmaWVyIG5vc2hhZG93XG4gKiAgIFtlbl1Ub29sYmFyIHdpdGhvdXQgc2hhZG93LlsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjgavlvbHjgpLku5jjgZHjgZrjgavooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUb29sYmFyIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHdpdGggbmF2aWdhdGlvbi5cbiAqXG4gKiAgICAgTGVmdCwgY2VudGVyIGFuZCByaWdodCBjb250YWluZXIgY2FuIGJlIHNwZWNpZmllZCBieSBjbGFzcyBuYW1lcy5cbiAqXG4gKiAgICAgVGhpcyBjb21wb25lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IGRpc3BsYXlzIGFzIGEgTWF0ZXJpYWwgRGVzaWduIHRvb2xiYXIgd2hlbiBydW5uaW5nIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODiuODk+OCsuODvOOCt+ODp+ODs+OBp+S9v+eUqOOBmeOCi+ODhOODvOODq+ODkOODvOeUqOOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguOCr+ODqeOCueWQjeOBq+OCiOOCiuOAgeW3puOAgeS4reWkruOAgeWPs+OBruOCs+ODs+ODhuODiuOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBhSG1HTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3Rvb2xiYXJcbiAqIEBndWlkZSBjb21waWxhdGlvbi5odG1sI3Rvb2xiYXItY29tcGlsYXRpb24gW2VuXUFkZGluZyBhIHRvb2xiYXJbL2VuXVtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQHNlZWFsc28gb25zLWJvdHRvbS10b29sYmFyXG4gKiAgIFtlbl1UaGUgYDxvbnMtYm90dG9tLXRvb2xiYXI+YCBkaXNwbGF5cyBhIHRvb2xiYXIgb24gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5bL2VuXVxuICogICBbamFdb25zLWJvdHRvbS10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgYmFjayBidXR0b24gaW5zaWRlIHRoZSB0b29sYmFyLlsvZW5dXG4gKiAgIFtqYV1vbnMtYmFjay1idXR0b27jgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXItYnV0dG9uXG4gKiAgIFtlbl1UaGUgYDxvbnMtdG9vbGJhci1idXR0b24+YCBjb21wb25lbnQgZGlzcGxheXMgYSB0b29sYmFyIGJ1dHRvbiBpbnNpZGUgdGhlIHRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFyLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXRvb2xiYXI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICAgIDxvbnMtYmFjay1idXR0b24+XG4gKiAgICAgICAgIEJhY2tcbiAqICAgICAgIDwvb25zLWJhY2stYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICAgIFRpdGxlXG4gKiAgICAgPC9kaXY+XG4gKiAgICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgICA8b25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgICAgICA8b25zLWljb24gaWNvbj1cIm1kLW1lbnVcIj48L29ucy1pY29uPlxuICogICAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvb25zLXRvb2xiYXI+XG4gKiA8L29ucy1wYWdlPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvb2xiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGlubGluZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3BsYXkgdGhlIHRvb2xiYXIgYXMgYW4gaW5saW5lIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844KS44Kk44Oz44Op44Kk44Oz44Gr572u44GN44G+44GZ44CC44K544Kv44Ot44O844Or6aCY5Z+f5YaF44Gr44Gd44Gu44G+44G+6KGo56S644GV44KM44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3RhdGljXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TdGF0aWMgdG9vbGJhcnMgYXJlIG5vdCBhbmltYXRlZCBieSBgb25zLW5hdmlnYXRvcmAgd2hlbiBwdXNoaW5nIG9yIHBvcHBpbmcgcGFnZXMuIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIGluIHNvbWUgc2l0dWF0aW9ucy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHRvb2xiYXIuWy9lbl1cbiAgICogICBbamFd44OE44O844Or44OQ44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhckxlZnRJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLmxlZnQnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyQ2VudGVySXRlbXNFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJy5jZW50ZXInKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyUmlnaHRJdGVtc0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvcignLnJpZ2h0JykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gICAqL1xuICBfZ2V0VG9vbGJhckJhY2tCdXR0b25MYWJlbEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignb25zLWJhY2stYnV0dG9uIC5iYWNrLWJ1dHRvbl9fbGFiZWwnKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIF9nZXRUb29sYmFyQmFja0J1dHRvbkljb25FbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbiAuYmFjay1idXR0b25fX2ljb24nKSB8fCBpbnRlcm5hbC5udWxsRWxlbWVudDtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICB0aGlzLl9lbnN1cmVUb29sYmFySXRlbUVsZW1lbnRzKCk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2Vuc3VyZVRvb2xiYXJJdGVtRWxlbWVudHMoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDAgOyBpLS0pIHtcbiAgICAgIC8vIGNhc2Ugb2Ygbm90IGVsZW1lbnRcbiAgICAgIGlmICh0aGlzLmNoaWxkTm9kZXNbaV0ubm9kZVR5cGUgIT0gMSkge1xuICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKHRoaXMuY2hpbGROb2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2VudGVyID0gdGhpcy5fZW5zdXJlVG9vbGJhckVsZW1lbnQoJ2NlbnRlcicpO1xuICAgIGNlbnRlci5jbGFzc0xpc3QuYWRkKCd0b29sYmFyX190aXRsZScpO1xuXG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8ICF0aGlzLmNoaWxkcmVuWzBdLmNsYXNzTGlzdC5jb250YWlucygnY2VudGVyJykpIHtcbiAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgnbGVmdCcpO1xuICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLl9lbnN1cmVUb29sYmFyRWxlbWVudCgncmlnaHQnKTtcblxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bMF0gIT09IGxlZnQgfHwgdGhpcy5jaGlsZHJlblsxXSAhPT0gY2VudGVyIHx8IHRoaXMuY2hpbGRyZW5bMl0gIT09IHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobGVmdCk7XG4gICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2VudGVyKTtcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChyaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2Vuc3VyZVRvb2xiYXJFbGVtZW50KG5hbWUpIHtcbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJy50b29sYmFyX18nICsgbmFtZSkpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRvb2xiYXJfXycgKyBuYW1lKTtcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLicgKyBuYW1lKSB8fCB1dGlsLmNyZWF0ZSgnLicgKyBuYW1lKTtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Rvb2xiYXJfXycgKyBuYW1lKTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlRvb2xiYXIgPSBUb29sYmFyRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXRvb2xiYXInLCBUb29sYmFyRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IGRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIGZyb20gJy4uL29ucy9pbnRlcm5hbC9kZXZpY2UtYmFjay1idXR0b24tZGlzcGF0Y2hlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuaW1wb3J0ICcuL29ucy10b29sYmFyJzsgLy8gZW5zdXJlcyB0aGF0ICdvbnMtdG9vbGJhcicgZWxlbWVudCBpcyByZWdpc3RlcmVkXG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAncGFnZSc7XG5jb25zdCBzY2hlbWUgPSB7XG4gICcnOiAncGFnZS0tKicsXG4gICcucGFnZV9fY29udGVudCc6ICdwYWdlLS0qX19jb250ZW50JyxcbiAgJy5wYWdlX19iYWNrZ3JvdW5kJzogJ3BhZ2UtLSpfX2JhY2tncm91bmQnXG59O1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wYWdlXG4gKiBAY2F0ZWdvcnkgcGFnZVxuICogQG1vZGlmaWVyIG1hdGVyaWFsXG4gKiAgIFtlbl1NYXRlcmlhbCBEZXNpZ24gc3R5bGVbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZGVmaW5lcyB0aGUgcm9vdCBvZiBlYWNoIHBhZ2UuIElmIHRoZSBjb250ZW50IGlzIGxhcmdlIGl0IHdpbGwgYmVjb21lIHNjcm9sbGFibGUuXG4gKlxuICogICAgIEEgbmF2aWdhdGlvbiBiYXIgY2FuIGJlIGFkZGVkIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UgdXNpbmcgdGhlIGA8b25zLXRvb2xiYXI+YCBlbGVtZW50LlxuICogICBbL2VuXVxuICogICBbamFd44Oa44O844K45a6a576p44Gu44Gf44KB44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CC44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu5YaF5a6544Gv44K544Kv44Ot44O844Or44GM6Kix5Y+v44GV44KM44G+44GZ44CCWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wYWdlXG4gKiBAZ3VpZGUgbGlmZWN5Y2xlLmh0bWwjZXZlbnRzXG4gKiAgIFtlbl1PdmVydmlldyBvZiBwYWdlIGV2ZW50c1svZW5dXG4gKiAgIFtqYV1PdmVydmlldyBvZiBwYWdlIGV2ZW50c1svamFdXG4gKiBAZ3VpZGUgZnVuZGFtZW50YWxzLmh0bWwjbWFuYWdpbmctcGFnZXNcbiAqICAgW2VuXU1hbmFnaW5nIG11bHRpcGxlIHBhZ2VzWy9lbl1cbiAqICAgW2phXeikh+aVsOOBruODmuODvOOCuOOCkueuoeeQhuOBmeOCi1svamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10b29sYmFyXG4gKiAgIFtlbl1Vc2UgdGhlIGA8b25zLXRvb2xiYXI+YCBlbGVtZW50IHRvIGFkZCBhIG5hdmlnYXRpb24gYmFyIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXRvb2xiYXI+XG4gKiAgICAgPGRpdiBjbGFzcz1cImxlZnRcIj5cbiAqICAgICAgIDxvbnMtYmFjay1idXR0b24+QmFjazwvb25zLWJhY2stYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5UaXRsZTwvZGl2PlxuICogICAgIDxkaXYgY2xhc3M9XCJyaWdodFwiPlxuICogICAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgICAgPG9ucy1pY29uIGljb249XCJtZC1tZW51XCI+PC9vbnMtaWNvbj5cbiAqICAgICAgIDwvb25zLXRvb2xiYXItYnV0dG9uPlxuICogICAgIDwvZGl2PlxuICogICA8L29ucy10b29sYmFyPlxuICpcbiAqICAgPHA+UGFnZSBjb250ZW50PC9wPlxuICogPC9vbnMtcGFnZT5cbiAqXG4gKiBAZXhhbXBsZVxuICogPHNjcmlwdD5cbiAqICAgbXlBcHAuaGFuZGxlciA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAqICAgICBsb2FkTW9yZSgpLnRoZW4oZG9uZSk7XG4gKiAgIH1cbiAqIDwvc2NyaXB0PlxuICpcbiAqIDxvbnMtcGFnZSBvbi1pbmZpbml0ZS1zY3JvbGw9XCJteUFwcC5oYW5kbGVyXCI+XG4gKiAgIDxvbnMtdG9vbGJhcj5cbiAqICAgICA8ZGl2IGNsYXNzPVwiY2VudGVyXCI+TGlzdDwvZGl2PlxuICogICA8L29ucy10b29sYmFyPlxuICpcbiAqICAgPG9ucy1saXN0PlxuICogICAgIDxvbnMtbGlzdC1pdGVtPiMxPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIDxvbnMtbGlzdC1pdGVtPiMyPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIDxvbnMtbGlzdC1pdGVtPiMzPC9vbnMtbGlzdC1pdGVtPlxuICogICAgIC4uLlxuICogICA8L29ucy1saXN0PlxuICogPC9vbnMtcGFnZT5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFnZUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBpbml0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCByaWdodCBhZnRlciB0aGUgcGFnZSBpcyBhdHRhY2hlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYzjgqLjgr/jg4Pjg4HjgZXjgozjgZ/lvozjgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHJpZ2h0IGFmdGVyIHRoZSBwYWdlIGlzIHNob3duLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOihqOekuuOBleOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgaGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYWZ0ZXIgdGhlIHBhZ2UgaXMgaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODmuODvOOCuOOBjOmaoOOCjOOBn+W+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgZGVzdHJveVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgcmlnaHQgYmVmb3JlIHRoZSBwYWdlIGlzIGRlc3Ryb3llZC5bL2VuXVxuICAgKiAgIFtqYV3jg5rjg7zjgrjjgYznoLTmo4TjgZXjgozjgovliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBtb2RpZmllciBuYW1lIHRvIHNwZWNpZnkgY3VzdG9tIHN0eWxlcy5bL2VuXVxuICAgKiAgIFtqYV3jgrnjgr/jgqTjg6vlrprnvqnjgpLjgqvjgrnjgr/jg57jgqTjgrrjgZnjgovjgZ/jgoHjga7lkI3liY3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBvbi1pbmZpbml0ZS1zY3JvbGxcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhdGggb2YgdGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uIGluZmluaXRlIHNjcm9sbGluZy4gRXhhbXBsZTogYGFwcC5sb2FkRGF0YWAuIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhIGRvbmUgY2FsbGJhY2sgdGhhdCBtdXN0IGJlIGNhbGxlZCB3aGVuIGl0J3MgZmluaXNoZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2Rlcml2ZUhvb2tzKCk7XG5cbiAgICB0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lID0gZGVmYXVsdENsYXNzTmFtZTtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG5cbiAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcblxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQgPSB0aGlzLl9nZXRDb250ZW50RWxlbWVudCgpO1xuICAgICAgdGhpcy5fYmFja2dyb3VuZEVsZW1lbnQgPSB0aGlzLl9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG5cbiAgICBjb25zdCB0b29sYmFyID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJyk7XG5cbiAgICBjb25zdCBiYWNrZ3JvdW5kID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19iYWNrZ3JvdW5kJykgfHwgdXRpbC5maW5kQ2hpbGQodGhpcywgJy5iYWNrZ3JvdW5kJykgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFja2dyb3VuZC5jbGFzc0xpc3QuYWRkKCdwYWdlX19iYWNrZ3JvdW5kJyk7XG4gICAgdGhpcy5pbnNlcnRCZWZvcmUoYmFja2dyb3VuZCwgIXRvb2xiYXIgJiYgdGhpcy5maXJzdENoaWxkIHx8IHRvb2xiYXIgJiYgdG9vbGJhci5uZXh0U2libGluZyk7XG5cbiAgICBjb25zdCBjb250ZW50ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19jb250ZW50JykgfHwgdXRpbC5maW5kQ2hpbGQodGhpcywgJy5jb250ZW50JykgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdwYWdlX19jb250ZW50Jyk7XG4gICAgaWYgKCFjb250ZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGROb2RlcykuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IDEgfHwgdGhpcy5fZWxlbWVudFNob3VsZEJlTW92ZWQobm9kZSkpIHtcbiAgICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUpOyAvLyBDYW4gdHJpZ2dlciBkZXRhY2hlZCBjb25uZWN0ZWRDYWxsYmFja3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJ5VG9GaWxsU3RhdHVzQmFyKGNvbnRlbnQpOyAvLyBNdXN0IHJ1biBiZWZvcmUgY2hpbGQgcGFnZXMgdHJ5IHRvIGZpbGwgc3RhdHVzIGJhci5cbiAgICB0aGlzLmluc2VydEJlZm9yZShjb250ZW50LCBiYWNrZ3JvdW5kLm5leHRTaWJsaW5nKTsgLy8gQ2FuIHRyaWdnZXIgYXR0YWNoZWQgY29ubmVjdGVkQ2FsbGJhY2tzXG5cbiAgICBpZiAoKCF0b29sYmFyIHx8ICF1dGlsLmhhc01vZGlmaWVyKHRvb2xiYXIsICd0cmFuc3BhcmVudCcpKVxuICAgICAgJiYgY29udGVudC5jaGlsZHJlbi5sZW5ndGggPT09IDFcbiAgICAgICYmIHV0aWwuaXNQYWdlQ29udHJvbChjb250ZW50LmNoaWxkcmVuWzBdKVxuICAgICkge1xuICAgICAgdGhpcy5fZGVmYXVsdENsYXNzTmFtZSArPSAnIHBhZ2UtLXdyYXBwZXInO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ2NsYXNzJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2VsZW1lbnRTaG91bGRCZU1vdmVkKGVsKSB7XG4gICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygncGFnZV9fYmFja2dyb3VuZCcpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRhZ05hbWUgPT09ICdvbnMtZmFiJykge1xuICAgICAgcmV0dXJuICFlbC5oYXNBdHRyaWJ1dGUoJ3Bvc2l0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IGZpeGVkRWxlbWVudHMgPSBbJ3NjcmlwdCcsICdvbnMtdG9vbGJhcicsICdvbnMtYm90dG9tLXRvb2xiYXInLCAnb25zLW1vZGFsJywgJ29ucy1zcGVlZC1kaWFsJywgJ29ucy1kaWFsb2cnLCAnb25zLWFsZXJ0LWRpYWxvZycsICdvbnMtcG9wb3ZlcicsICdvbnMtYWN0aW9uLXNoZWV0J107XG4gICAgcmV0dXJuIGVsLmhhc0F0dHJpYnV0ZSgnaW5saW5lJykgfHwgZml4ZWRFbGVtZW50cy5pbmRleE9mKHRhZ05hbWUpID09PSAtMTtcbiAgfVxuXG4gIF90cnlUb0ZpbGxTdGF0dXNCYXIoY29udGVudCA9IHRoaXMuX2NvbnRlbnRFbGVtZW50KSB7XG4gICAgaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwoKCkgPT4ge1xuICAgICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ3N0YXR1cy1iYXItZmlsbCcsXG4gICAgICAgICF1dGlsLmZpbmRQYXJlbnQodGhpcywgZSA9PiBlLmhhc0F0dHJpYnV0ZSgnc3RhdHVzLWJhci1maWxsJykpIC8vIE5vdCBhbHJlYWR5IGZpbGxlZFxuICAgICAgICAmJiAodGhpcy5fY2FuQW5pbWF0ZVRvb2xiYXIoY29udGVudCkgfHwgIXV0aWwuZmluZENoaWxkKGNvbnRlbnQsIHV0aWwuaXNQYWdlQ29udHJvbCkpIC8vIEhhcyB0b29sYmFyIG9yIGNhbm5vdCBkZWxlZ2F0ZVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jYW5BbmltYXRlVG9vbGJhcihjb250ZW50ID0gdGhpcy5fY29udGVudEVsZW1lbnQpIHtcbiAgICBpZiAodXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy10b29sYmFyJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiAhIXV0aWwuZmluZENoaWxkKGNvbnRlbnQsIGVsID0+IHtcbiAgICAgIHJldHVybiB1dGlsLm1hdGNoKGVsLCAnb25zLXRvb2xiYXInKSAmJiAhZWwuaGFzQXR0cmlidXRlKCdpbmxpbmUnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5pc0F0dGFjaGVkKHRoaXMpKSB7IC8vIEF2b2lkIGRldGFjaGVkIGNhbGxzXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3RyeVRvRmlsbFN0YXR1c0JhcigpOyAvLyBFbnN1cmUgc3RhdHVzIGJhciB3aGVuIHRoZSBlbGVtZW50IHdhcyBjb21waWxlZCBiZWZvcmUgY29ubmVjdGVkXG5cbiAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnb24taW5maW5pdGUtc2Nyb2xsJykpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soJ29uLWluZmluaXRlLXNjcm9sbCcsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdvbi1pbmZpbml0ZS1zY3JvbGwnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vbkluaXQgJiYgdGhpcy5vbkluaXQoKTtcbiAgICAgICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ2luaXQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCF1dGlsLmhhc0FueUNvbXBvbmVudEFzUGFyZW50KHRoaXMpKSB7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3Nob3coKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHVwZGF0ZUJhY2tCdXR0b24oc2hvdykge1xuICAgIGlmICh0aGlzLmJhY2tCdXR0b24pIHtcbiAgICAgIHNob3cgPyB0aGlzLmJhY2tCdXR0b24uc2hvdygpIDogdGhpcy5iYWNrQnV0dG9uLmhpZGUoKTtcbiAgICB9XG4gIH1cblxuICBzZXQgbmFtZShzdHIpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbmFtZScsIHN0cik7XG4gIH1cblxuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgfVxuXG4gIGdldCBiYWNrQnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ29ucy1iYWNrLWJ1dHRvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkluZmluaXRlU2Nyb2xsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gc2Nyb2xsaW5nIHRvIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuIFRoZSBmdW5jdGlvbiByZWNlaXZlcyBhIGRvbmUgY2FsbGJhY2sgYXMgYW4gYXJndW1lbnQgdGhhdCBtdXN0IGJlIGNhbGxlZCB3aGVuIGl0J3MgZmluaXNoZWQuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cbiAgc2V0IG9uSW5maW5pdGVTY3JvbGwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdXRpbC50aHJvdygnXCJvbkluZmluaXRlU2Nyb2xsXCIgbXVzdCBiZSBmdW5jdGlvbiBvciBudWxsJyk7XG4gICAgfVxuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9vbkluZmluaXRlU2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuX2luZmluaXRlU2Nyb2xsTGltaXQgPSAwLjk7XG4gICAgICAgIHRoaXMuX2JvdW5kT25TY3JvbGwgPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fY29udGVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fYm91bmRPblNjcm9sbCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fb25JbmZpbml0ZVNjcm9sbCA9IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IG9uSW5maW5pdGVTY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uSW5maW5pdGVTY3JvbGw7XG4gIH1cblxuICBfb25TY3JvbGwoKSB7XG4gICAgY29uc3QgYyA9IHRoaXMuX2NvbnRlbnRFbGVtZW50LFxuICAgICAgb3ZlckxpbWl0ID0gKGMuc2Nyb2xsVG9wICsgYy5jbGllbnRIZWlnaHQpIC8gYy5zY3JvbGxIZWlnaHQgPj0gdGhpcy5faW5maW5pdGVTY3JvbGxMaW1pdDtcblxuICAgIGlmICh0aGlzLl9vbkluZmluaXRlU2Nyb2xsICYmICF0aGlzLl9sb2FkaW5nQ29udGVudCAmJiBvdmVyTGltaXQpIHtcbiAgICAgIHRoaXMuX2xvYWRpbmdDb250ZW50ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX29uSW5maW5pdGVTY3JvbGwoKCkgPT4gdGhpcy5fbG9hZGluZ0NvbnRlbnQgPSBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBnZXQgc2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICBzZXQgc2Nyb2xsVG9wKG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5fY29udGVudEVsZW1lbnQuc2Nyb2xsVG9wID0gbmV3VmFsdWU7XG4gIH1cblxuICBfZ2V0Q29udGVudEVsZW1lbnQoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wYWdlX19jb250ZW50Jyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdXRpbC50aHJvdygnRmFpbCB0byBnZXQgXCIucGFnZV9fY29udGVudFwiIGVsZW1lbnQnKTtcbiAgfVxuXG4gIF9nZXRCYWNrZ3JvdW5kRWxlbWVudCgpIHtcbiAgICBjb25zdCByZXN1bHQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnBhZ2VfX2JhY2tncm91bmQnKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB1dGlsLnRocm93KCdGYWlsIHRvIGdldCBcIi5wYWdlX19iYWNrZ3JvdW5kXCIgZWxlbWVudCcpO1xuICB9XG5cbiAgX2dldEJvdHRvbVRvb2xiYXJFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLWJvdHRvbS10b29sYmFyJykgfHwgaW50ZXJuYWwubnVsbEVsZW1lbnQ7XG4gIH1cblxuICBfZ2V0VG9vbGJhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtdG9vbGJhcicpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy10b29sYmFyJyk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdvbi1pbmZpbml0ZS1zY3JvbGwnLCAnY2xhc3MnXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIHV0aWwucmVzdG9yZUNsYXNzKHRoaXMsIHRoaXMuX2RlZmF1bHRDbGFzc05hbWUsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9kaWZpZXInOlxuICAgICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvbi1pbmZpbml0ZS1zY3JvbGwnOlxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbkluZmluaXRlU2Nyb2xsID0gKGRvbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB1dGlsLmZpbmRGcm9tUGF0aChjdXJyZW50KTtcbiAgICAgICAgICAgIHRoaXMub25JbmZpbml0ZVNjcm9sbCA9IGY7XG4gICAgICAgICAgICBmKGRvbmUpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duICYmIHV0aWwuaXNBdHRhY2hlZCh0aGlzKSkge1xuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2hvd24nLCAnJyk7XG4gICAgICB0aGlzLm9uU2hvdyAmJiB0aGlzLm9uU2hvdygpO1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdzaG93Jyk7XG4gICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX3Nob3cnKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3Nob3duJyk7XG4gICAgICB0aGlzLm9uSGlkZSAmJiB0aGlzLm9uSGlkZSgpO1xuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdoaWRlJyk7XG4gICAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2hpZGUnKTtcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLl9oaWRlKCk7XG5cbiAgICB0aGlzLm9uRGVzdHJveSAmJiB0aGlzLm9uRGVzdHJveSgpO1xuICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnZGVzdHJveScpO1xuXG4gICAgaWYgKHRoaXMub25EZXZpY2VCYWNrQnV0dG9uKSB7XG4gICAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbi5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19kZXN0cm95Jyk7XG5cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgX2Rlcml2ZUhvb2tzKCkge1xuICAgIHRoaXMuY29uc3RydWN0b3IuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gJ29uJyArIGV2ZW50LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzW2BfJHtrZXl9YF0sXG4gICAgICAgIHNldDogdmFsdWUgPT4ge1xuICAgICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICB1dGlsLnRocm93KGBcIiR7a2V5fVwiIGhvb2sgbXVzdCBiZSBhIGZ1bmN0aW9uYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXNbYF8ke2tleX1gXSA9IHZhbHVlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsnaW5pdCcsICdzaG93JywgJ2hpZGUnLCAnZGVzdHJveSddO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkYXRhXG4gICAqIEB0eXBlIHsqfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVXNlcidzIGN1c3RvbSBkYXRhIHBhc3NlZCB0byBgcHVzaFBhZ2UoKWAtbGlrZSBtZXRob2RzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xufVxuXG5vbnNFbGVtZW50cy5QYWdlID0gUGFnZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wYWdlJywgUGFnZUVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgQmFzZUFuaW1hdG9yIGZyb20gJy4uLy4uL29ucy9iYXNlLWFuaW1hdG9yJztcblxuZXhwb3J0IGNsYXNzIFBvcG92ZXJBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdjdWJpYy1iZXppZXIoLjEsIC43LCAuNCwgMSknLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIHNob3cocG9wb3ZlciwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgaGlkZShwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cblxuICBfYW5pbWF0ZShlbGVtZW50LCB7ZnJvbSwgdG8sIG9wdGlvbnMsIGNhbGxiYWNrLCByZXN0b3JlID0gZmFsc2UsIGFuaW1hdGlvbn0pIHtcbiAgICBvcHRpb25zID0gdXRpbC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICBmcm9tID0gYW5pbWF0aW9uLmZyb207XG4gICAgICB0byA9IGFuaW1hdGlvbi50bztcbiAgICB9XG5cbiAgICBhbmltYXRpb24gPSBhbmltaXQoZWxlbWVudCk7XG4gICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5zYXZlU3R5bGUoKTtcbiAgICB9XG4gICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnF1ZXVlKGZyb20pLndhaXQodGhpcy5kZWxheSkucXVldWUoe1xuICAgICAgY3NzOiB0byxcbiAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgdGltaW5nOiB0aGlzLnRpbWluZ1xuICAgIH0pO1xuICAgIGlmIChyZXN0b3JlKSB7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24ucmVzdG9yZVN0eWxlKCk7XG4gICAgfVxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLnF1ZXVlKChkb25lKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9XG5cbiAgX2FuaW1hdGVBbGwoZWxlbWVudCwgYW5pbWF0aW9ucykge1xuICAgIE9iamVjdC5rZXlzKGFuaW1hdGlvbnMpLmZvckVhY2goa2V5ID0+IHRoaXMuX2FuaW1hdGUoZWxlbWVudFtrZXldLCBhbmltYXRpb25zW2tleV0pLnBsYXkoKSk7XG4gIH1cblxufVxuXG5jb25zdCBmYWRlID0ge1xuICBvdXQ6IHtcbiAgICBmcm9tOiB7b3BhY2l0eTogMS4wfSxcbiAgICB0bzoge29wYWNpdHk6IDB9XG4gIH0sXG4gIGluOiB7XG4gICAgZnJvbToge29wYWNpdHk6IDB9LFxuICAgIHRvOiB7b3BhY2l0eTogMS4wfVxuICB9XG59O1xuXG5leHBvcnQgY2xhc3MgTURGYWRlUG9wb3ZlckFuaW1hdG9yIGV4dGVuZHMgUG9wb3ZlckFuaW1hdG9yIHtcbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgX21hc2s6IGZhZGUuaW4sXG4gICAgICBfcG9wb3Zlcjoge2FuaW1hdGlvbjogZmFkZS5pbiwgcmVzdG9yZTogdHJ1ZSwgY2FsbGJhY2t9XG4gICAgfSk7XG4gIH1cblxuICBoaWRlKHBvcG92ZXIsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYW5pbWF0ZUFsbChwb3BvdmVyLCB7XG4gICAgICBfbWFzazogZmFkZS5vdXQsXG4gICAgICBfcG9wb3Zlcjoge2FuaW1hdGlvbjogZmFkZS5vdXQsIHJlc3RvcmU6IHRydWUsIGNhbGxiYWNrfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJT1NGYWRlUG9wb3ZlckFuaW1hdG9yIGV4dGVuZHMgTURGYWRlUG9wb3ZlckFuaW1hdG9yIHtcbiAgc2hvdyhwb3BvdmVyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FuaW1hdGVBbGwocG9wb3Zlciwge1xuICAgICAgX21hc2s6IGZhZGUuaW4sXG4gICAgICBfcG9wb3Zlcjoge1xuICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLjMsIDEuMywgMS4wKScsXG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9LFxuICAgICAgICB0bzoge1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlM2QoMS4wLCAxLjAsICAxLjApJyxcbiAgICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdG9yZTogdHJ1ZSxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uLy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCB7IFBvcG92ZXJBbmltYXRvciwgSU9TRmFkZVBvcG92ZXJBbmltYXRvciwgTURGYWRlUG9wb3ZlckFuaW1hdG9yIH0gZnJvbSAnLi9hbmltYXRvcic7XG5pbXBvcnQgcGxhdGZvcm0gZnJvbSAnLi4vLi4vb25zL3BsYXRmb3JtJztcbmltcG9ydCBpUGhvbmVYUGF0Y2ggZnJvbSAnLi4vLi4vb25zL2lwaG9uZXgtcGF0Y2gnO1xuaW1wb3J0IEJhc2VEaWFsb2dFbGVtZW50IGZyb20gJy4uL2Jhc2UvYmFzZS1kaWFsb2cnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi8uLi9vbnMvY29udGVudC1yZWFkeSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJy5wb3BvdmVyJzogJ3BvcG92ZXItLSonLFxuICAnLnBvcG92ZXItbWFzayc6ICdwb3BvdmVyLW1hc2stLSonLFxuICAnLnBvcG92ZXJfX2NvbnRlbnQnOiAncG9wb3Zlci0tKl9fY29udGVudCcsXG4gICcucG9wb3Zlcl9fYXJyb3cnOiAncG9wb3Zlci0tKl9fYXJyb3cnXG59O1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICAnZGVmYXVsdCc6ICgpID0+IHBsYXRmb3JtLmlzQW5kcm9pZCgpID8gTURGYWRlUG9wb3ZlckFuaW1hdG9yIDogSU9TRmFkZVBvcG92ZXJBbmltYXRvcixcbiAgJ25vbmUnOiBQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLWlvcyc6IElPU0ZhZGVQb3BvdmVyQW5pbWF0b3IsXG4gICdmYWRlLW1kJzogTURGYWRlUG9wb3ZlckFuaW1hdG9yXG59O1xuXG5jb25zdCBwb3NpdGlvbnMgPSB7XG4gIHVwOiAnYm90dG9tJyxcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgZG93bjogJ3RvcCcsXG4gIHJpZ2h0OiAnbGVmdCdcbn07XG5cbmNvbnN0IGRpcmVjdGlvbnMgPSBPYmplY3Qua2V5cyhwb3NpdGlvbnMpO1xuLyoqXG4gKiBAZWxlbWVudCBvbnMtcG9wb3ZlclxuICogQGNhdGVnb3J5IGRpYWxvZ1xuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBjb21wb25lbnQgdGhhdCBkaXNwbGF5cyBhIHBvcG92ZXIgbmV4dCB0byBhbiBlbGVtZW50LiBUaGUgcG9wb3ZlciBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IGV4dHJhIGluZm9ybWF0aW9uIGFib3V0IGEgY29tcG9uZW50IG9yIGEgdG9vbHRpcC5cbiAqXG4gKiAgICBUbyB1c2UgdGhlIGVsZW1lbnQgaXQgY2FuIGVpdGhlciBiZSBhdHRhY2hlZCBkaXJlY3RseSB0byB0aGUgYDxib2R5PmAgZWxlbWVudCBvciBkeW5hbWljYWxseSBjcmVhdGVkIGZyb20gYSB0ZW1wbGF0ZSB1c2luZyB0aGUgYG9ucy5jcmVhdGVQb3BvdmVyKHRlbXBsYXRlKWAgdXRpbGl0eSBmdW5jdGlvbiBhbmQgdGhlIGA8dGVtcGxhdGU+YCB0YWcuXG4gKlxuICogICAgQW5vdGhlciBjb21tb24gd2F5IHRvIHVzZSB0aGUgcG9wb3ZlciBpcyB0byBkaXNwbGF5IGEgbWVudSB3aGVuIGEgYnV0dG9uIG9uIHRoZSBzY3JlZW4gaXMgdGFwcGVkLiBGb3IgTWF0ZXJpYWwgRGVzaWduLCBwb3BvdmVyIGxvb2tzIGV4YWN0bHkgYXMgYSBkcm9wZG93biBtZW51LlxuICogIFsvZW5dXG4gKiAgW2phXeOBguOCi+imgee0oOOCkuWvvuixoeOBqOOBmeOCi+ODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBmeOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAY29kZXBlbiBaWVlSS29cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9wb3BvdmVyXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI21vZGlmaWVycyBbZW5dTW9yZSBkZXRhaWxzIGFib3V0IHRoZSBgbW9kaWZpZXJgIGF0dHJpYnV0ZVsvZW5dW2phXW1vZGlmaWVy5bGe5oCn44Gu5L2/44GE5pa5Wy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLWJ1dHRvbiBvbmNsaWNrPVwic2hvd1BvcG92ZXIodGhpcylcIj5cbiAqICAgQ2xpY2sgbWUhXG4gKiA8L29ucy1idXR0b24+XG4gKlxuICogPG9ucy1wb3BvdmVyIGRpcmVjdGlvbj1cImRvd25cIiBpZD1cInBvcG92ZXJcIj5cbiAqICAgPHA+VGhpcyBpcyBhIHBvcG92ZXIhPC9wPlxuICogPC9vbnMtcG9wb3Zlcj5cbiAqXG4gKiA8c2NyaXB0PlxuICogICB2YXIgc2hvd1BvcG92ZXIgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gKiAgICAgdmFyIHBvcG92ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncG9wb3ZlcicpO1xuICogICAgIHBvcG92ZXIuc2hvdyhlbGVtZW50KTtcbiAqICAgfTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3BvdmVyRWxlbWVudCBleHRlbmRzIEJhc2VEaWFsb2dFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHByZXNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBwb3BvdmVyIGlzIGRpc3BsYXllZC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgYzooajnpLrjgZXjgozjgovnm7TliY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQucG9wb3ZlclxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRoaXMgZnVuY3Rpb24gdG8gc3RvcCB0aGUgcG9wb3ZlciBmcm9tIGJlaW5nIHNob3duLlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBruihqOekuuOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdHNob3dcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHBvcG92ZXIgaXMgZGlzcGxheWVkLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOOBn+ebtOW+jOOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5wb3BvdmVyXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVoaWRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgcG9wb3ZlciBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44KL55u05YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHN0b3AgdGhlIHBvcG92ZXIgZnJvbSBiZWluZyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44GT44Gu6Zai5pWw44KS5ZG844Gz5Ye644GZ44Go44CB44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44KL5Yem55CG44KS44Kt44Oj44Oz44K744Or44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0aGlkZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgcG9wb3ZlciBpcyBoaWRkZW4uWy9lbl1cbiAgICogICBbamFd44Od44OD44OX44Kq44O844OQ44O844GM6Zqg44KM44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnBvcG92ZXJcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgcG9wb3Zlci5bL2VuXVxuICAgKiAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpcmVjdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1cbiAgICogICAgQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBkaXJlY3Rpb25zLiBJZiBtb3JlIHRoYW4gb25lIGRpcmVjdGlvbiBpcyBzcGVjaWZpZWQsXG4gICAqICAgIGl0IHdpbGwgYmUgY2hvc2VuIGF1dG9tYXRpY2FsbHkuIFZhbGlkIGRpcmVjdGlvbnMgYXJlIGBcInVwXCJgLCBgXCJkb3duXCJgLCBgXCJsZWZ0XCJgIGFuZCBgXCJyaWdodFwiYC5cbiAgICogIFsvZW5dXG4gICAqICBbamFdXG4gICAqICAgIOODneODg+ODl+OCquODvOODkOODvOOCkuihqOekuuOBmeOCi+aWueWQkeOCkuepuueZveWMuuWIh+OCiuOBp+ikh+aVsOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgICDmjIflrprjgafjgY3jgovmlrnlkJHjga/jgIFcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiwgXCJyaWdodFwi44GuNOOBpOOBp+OBmeOAguepuueZveWMuuWIh+OCiuOBp+ikh+aVsOaMh+WumuOBmeOCi+OBk+OBqOOCguOBp+OBjeOBvuOBmeOAglxuICAgKiAgICDopIfmlbDmjIflrprjgZXjgozjgZ/loLTlkIjjgIHlr77osaHjgajjgZnjgovopoHntKDjgavlkIjjgo/jgZvjgabmjIflrprjgZfjgZ/lgKTjgYvjgonoh6rli5XnmoTjgavpgbjmip7jgZXjgozjgb7jgZnjgIJcbiAgICogIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNhbmNlbGFibGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgcG9wb3ZlciBjYW4gYmUgY2xvc2VkIGJ5IHRhcHBpbmcgdGhlIGJhY2tncm91bmQgb3IgYnkgcHJlc3NpbmcgdGhlIGJhY2sgYnV0dG9uLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+OBqOOAgeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOOBn+aZguOBq+OAgeiDjOaZr+OChOODkOODg+OCr+ODnOOCv+ODs+OCkuOCv+ODg+ODl+OBl+OBn+aZguOBq+OCkuODneODg+ODl+OCquODvOODkOODvOmWieOBmOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNvdmVyLXRhcmdldFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgc2V0IHRoZSBwb3BvdmVyIHdpbGwgY292ZXIgdGhlIHRhcmdldCBvbiB0aGUgc2NyZWVuLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFuaW1hdGlvbiB1c2VkIHdoZW4gc2hvd2luZyBhbiBoaWRpbmcgdGhlIHBvcG92ZXIuIENhbiBiZSBlaXRoZXIgYFwibm9uZVwiYCwgYFwiZGVmYXVsdFwiYCwgYFwiZmFkZS1pb3NcImAgb3IgYFwiZmFkZS1tZFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZnjgovpmpvjga7jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb24tb3B0aW9uc1xuICAgKiBAdHlwZSB7RXhwcmVzc2lvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIHRpbWluZyBhbmQgZGVsYXkgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIHRpbWluZywgZGVsYXnjgpLjgqrjg5bjgrjjgqfjgq/jg4jjg6rjg4bjg6njg6vjgafmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbWFzay1jb2xvclxuICAgKiBAdHlwZSB7Q29sb3J9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgYmFja2dyb3VuZCBtYXNrLiBEZWZhdWx0IGlzIGBcInJnYmEoMCwgMCwgMCwgMC4yKVwiYC5bL2VuXVxuICAgKiAgIFtqYV3og4zmma/jga7jg57jgrnjgq/jga7oibLjgpLmjIflrprjgZfjgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cInJnYmEoMCwgMCwgMCwgMC4yKVwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JvdW5kT25DaGFuZ2UgPSB0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBnZXQgX21hc2soKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcucG9wb3Zlci1tYXNrJyk7XG4gIH1cblxuICBnZXQgX3BvcG92ZXIoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcucG9wb3ZlcicpO1xuICB9XG5cbiAgZ2V0IF9jb250ZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLl9wb3BvdmVyLCAnLnBvcG92ZXJfX2NvbnRlbnQnKTtcbiAgfVxuXG4gIGdldCBfYXJyb3coKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMuX3BvcG92ZXIsICcucG9wb3Zlcl9fYXJyb3cnKTtcbiAgfVxuXG4gIF91cGRhdGVBbmltYXRvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRvckZhY3Rvcnkoe1xuICAgICAgYW5pbWF0b3JzOiBfYW5pbWF0b3JEaWN0LFxuICAgICAgYmFzZUNsYXNzOiBQb3BvdmVyQW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnUG9wb3ZlckFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSB8fCAnZGVmYXVsdCdcbiAgICB9KTtcbiAgfVxuXG4gIF90b2dnbGVTdHlsZShzaG91bGRTaG93LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoc2hvdWxkU2hvdykge1xuICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uUG9wb3ZlcihvcHRpb25zLnRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuX2NsZWFyU3R5bGVzKCk7XG4gICAgfVxuICB9XG5cbiAgX3Bvc2l0aW9uUG9wb3Zlcih0YXJnZXQpIHtcbiAgICBjb25zdCB7X3JhZGl1czogcmFkaXVzLCBfY29udGVudDogY29udGVudEVsZW1lbnQsIF9tYXJnaW46IG1hcmdpbn0gPSB0aGlzO1xuICAgIGNvbnN0IHNhZmVBcmVhTGVuZ3RocyA9IGlQaG9uZVhQYXRjaC5nZXRTYWZlQXJlYUxlbmd0aHMoKTtcbiAgICBjb25zdCBzYWZlQXJlYVJlY3QgPSBpUGhvbmVYUGF0Y2guZ2V0U2FmZUFyZWFET01SZWN0KCk7XG4gICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBpc01EID0gdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKTtcbiAgICBjb25zdCBjb3ZlciA9IGlzTUQgJiYgdGhpcy5oYXNBdHRyaWJ1dGUoJ2NvdmVyLXRhcmdldCcpO1xuICAgIGNvbnN0IHBhcmVudCA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKSB8fCBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IHBhcmVudERpbWVuc2lvbnMgPSBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgbWF4UG9zaXRpb25zID0ge1xuICAgICAgdG9wOiBNYXRoLm1heChwYXJlbnREaW1lbnNpb25zLnRvcCwgc2FmZUFyZWFSZWN0LnRvcCksXG4gICAgICBsZWZ0OiBNYXRoLm1heChwYXJlbnREaW1lbnNpb25zLmxlZnQsIHNhZmVBcmVhUmVjdC5sZWZ0KSxcbiAgICAgIGJvdHRvbTogTWF0aC5taW4ocGFyZW50RGltZW5zaW9ucy5ib3R0b20sIHNhZmVBcmVhUmVjdC5ib3R0b20pLFxuICAgICAgcmlnaHQ6IE1hdGgubWluKHBhcmVudERpbWVuc2lvbnMucmlnaHQsIHNhZmVBcmVhUmVjdC5yaWdodCksXG4gICAgfTtcblxuICAgIC8vIERpc3RhbmNlIGZyb20gZWFjaCBzaWRlIG9mIHRoZSBzYWZlIGFyZWEgKHdpdGggbWFyZ2luKSB0byB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICBjb25zdCB0YXJnZXREaXN0YW5jZSA9IHtcbiAgICAgIHRvcDogdGFyZ2V0UmVjdC50b3AgLSAobWF4UG9zaXRpb25zLnRvcCArIG1hcmdpbiksXG4gICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQgLSAobWF4UG9zaXRpb25zLmxlZnQgKyBtYXJnaW4pLFxuICAgICAgYm90dG9tOiAobWF4UG9zaXRpb25zLmJvdHRvbSAtIG1hcmdpbikgLSB0YXJnZXRSZWN0LmJvdHRvbSxcbiAgICAgIHJpZ2h0OiAobWF4UG9zaXRpb25zLnJpZ2h0IC0gbWFyZ2luKSAtIHRhcmdldFJlY3QucmlnaHRcbiAgICB9O1xuXG4gICAgLy8gRGlzdGFuY2UgZnJvbSBlYWNoIHNpZGUgb2YgdGhlIHNhZmUgYXJlYSAod2l0aCBtYXJnaW4pIHRvIHRoZSBnZW9tZXRyaWMgY2VudGVyIG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuICAgIGNvbnN0IHRhcmdldENlbnRlckRpc3RhbmNlRnJvbSA9IHtcbiAgICAgIHRvcDogdGFyZ2V0UmVjdC50b3AgKyBNYXRoLnJvdW5kKHRhcmdldFJlY3QuaGVpZ2h0IC8gMikgLSAobWF4UG9zaXRpb25zLnRvcCArIG1hcmdpbiksXG4gICAgICBsZWZ0OiB0YXJnZXRSZWN0LmxlZnQgKyBNYXRoLnJvdW5kKHRhcmdldFJlY3Qud2lkdGggLyAyKSAtIChtYXhQb3NpdGlvbnMubGVmdCArIG1hcmdpbiksXG4gICAgICBib3R0b206IChtYXhQb3NpdGlvbnMuYm90dG9tIC0gbWFyZ2luKSAtIHRhcmdldFJlY3QuYm90dG9tICsgTWF0aC5yb3VuZCh0YXJnZXRSZWN0LmhlaWdodCAvIDIpLFxuICAgICAgcmlnaHQ6IChtYXhQb3NpdGlvbnMucmlnaHQgLSBtYXJnaW4pIC0gdGFyZ2V0UmVjdC5yaWdodCArIE1hdGgucm91bmQodGFyZ2V0UmVjdC53aWR0aCAvIDIpXG4gICAgfTtcblxuICAgIGNvbnN0IHt2ZXJ0aWNhbCwgcHJpbWFyeTogcHJpbWFyeURpcmVjdGlvbiwgc2Vjb25kYXJ5OiBzZWNvbmRhcnlEaXJlY3Rpb259ID0gdGhpcy5fY2FsY3VsYXRlRGlyZWN0aW9ucyh0YXJnZXREaXN0YW5jZSk7XG4gICAgdGhpcy5fY3VycmVudERpcmVjdGlvbiA9IHByaW1hcnlEaXJlY3Rpb247XG4gICAgdXRpbC5hZGRNb2RpZmllcih0aGlzLCBwcmltYXJ5RGlyZWN0aW9uKTtcblxuICAgIGNvbnN0IHNpemVOYW1lID0gdmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgLy8gR2V0IC5wb3BvdmVyX19jb250ZW50IHNpemVcbiAgICBjb25zdCBjb250ZW50U2l6ZSA9IChzdHlsZSA9PiAoe1xuICAgICAgd2lkdGg6IHBhcnNlSW50KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJyksIDEwKSxcbiAgICAgIGhlaWdodDogcGFyc2VJbnQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnaGVpZ2h0JyksIDEwKVxuICAgIH0pKSh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjb250ZW50RWxlbWVudCkpO1xuXG4gICAgLy8gU2V0dGluZyAucG9wb3ZlciBwb3NpdGlvbi5cbiAgICBjb25zdCB0YXJnZXRBbmRBcnJvd0xlbmd0aCA9IGNvdmVyID8gMCA6ICh2ZXJ0aWNhbCA/IHRhcmdldFJlY3QuaGVpZ2h0IDogdGFyZ2V0UmVjdC53aWR0aCkgKyAoaXNNRCA/IDAgOiAxNCk7XG4gICAgY29uc3QgcHJpbWFyeU9mZnNldCA9IE1hdGgubWF4KFxuICAgICAgc2FmZUFyZWFMZW5ndGhzW3ByaW1hcnlEaXJlY3Rpb25dICsgbWFyZ2luLFxuICAgICAgc2FmZUFyZWFMZW5ndGhzW3ByaW1hcnlEaXJlY3Rpb25dICsgbWFyZ2luICsgdGFyZ2V0RGlzdGFuY2VbcHJpbWFyeURpcmVjdGlvbl0gKyB0YXJnZXRBbmRBcnJvd0xlbmd0aFxuICAgICk7XG4gICAgY29uc3Qgc2Vjb25kYXJ5T2Zmc2V0ID0gTWF0aC5tYXgoXG4gICAgICBzYWZlQXJlYUxlbmd0aHNbc2Vjb25kYXJ5RGlyZWN0aW9uXSArIG1hcmdpbixcbiAgICAgIHNhZmVBcmVhTGVuZ3Roc1tzZWNvbmRhcnlEaXJlY3Rpb25dICsgbWFyZ2luICsgdGFyZ2V0Q2VudGVyRGlzdGFuY2VGcm9tW3NlY29uZGFyeURpcmVjdGlvbl0gLSAoY29udGVudFNpemVbc2l6ZU5hbWVdIC8gMilcbiAgICApO1xuICAgIHRoaXMuX3BvcG92ZXIuc3R5bGVbcHJpbWFyeURpcmVjdGlvbl0gPSBwcmltYXJ5T2Zmc2V0ICsgJ3B4JztcbiAgICB0aGlzLl9wb3BvdmVyLnN0eWxlW3NlY29uZGFyeURpcmVjdGlvbl0gPSBzZWNvbmRhcnlPZmZzZXQgKyAncHgnO1xuXG4gICAgLy8gU2V0dGluZyAucG9wb3Zlcl9fYXJyb3cgcG9zaXRpb24uXG4gICAgdGhpcy5fYXJyb3cuc3R5bGVbc2Vjb25kYXJ5RGlyZWN0aW9uXSA9IE1hdGgubWF4KFxuICAgICAgcmFkaXVzLFxuICAgICAgKHNhZmVBcmVhTGVuZ3Roc1tzZWNvbmRhcnlEaXJlY3Rpb25dICsgbWFyZ2luKSArIHRhcmdldENlbnRlckRpc3RhbmNlRnJvbVtzZWNvbmRhcnlEaXJlY3Rpb25dIC0gc2Vjb25kYXJ5T2Zmc2V0XG4gICAgKSArICdweCc7XG4gIH1cblxuICBfY2FsY3VsYXRlRGlyZWN0aW9ucyhkaXN0YW5jZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSAodGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpIHx8ICd1cCBkb3duIGxlZnQgcmlnaHQnKS5zcGxpdCgvXFxzKy8pLm1hcChlID0+IHBvc2l0aW9uc1tlXSk7XG4gICAgY29uc3QgcHJpbWFyeSA9IG9wdGlvbnMuc29ydCgoYSwgYikgPT4gZGlzdGFuY2VbYV0gLSBkaXN0YW5jZVtiXSlbMF07XG4gICAgY29uc3QgdmVydGljYWwgPSAndG9wJyA9PSBwcmltYXJ5IHx8ICdib3R0b20nID09IHByaW1hcnk7XG4gICAgbGV0IHNlY29uZGFyeTtcblxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UubGVmdCA8IGRpc3RhbmNlLnJpZ2h0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vjb25kYXJ5ID0gZGlzdGFuY2UudG9wIDwgZGlzdGFuY2UuYm90dG9tID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICB9XG5cbiAgICByZXR1cm4ge3ZlcnRpY2FsLCBwcmltYXJ5LCBzZWNvbmRhcnl9O1xuICB9XG5cbiAgX2NsZWFyU3R5bGVzKCkge1xuICAgIHRoaXMuX2N1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgIFsndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J10uZm9yRWFjaChlID0+IHtcbiAgICAgIHRoaXMuX2Fycm93LnN0eWxlW2VdID0gdGhpcy5fY29udGVudC5zdHlsZVtlXSA9IHRoaXMuX3BvcG92ZXIuc3R5bGVbZV0gPSAnJztcbiAgICAgIHV0aWwucmVtb3ZlTW9kaWZpZXIodGhpcywgZSk7XG4gICAgfSk7XG4gIH1cblxuICBfb25DaGFuZ2UoKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uUG9wb3Zlcih0aGlzLl9jdXJyZW50VGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX3BvcG92ZXIgJiYgdGhpcy5fbWFzaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhhc0RlZmF1bHRDb250YWluZXIgPSB0aGlzLl9wb3BvdmVyICYmIHRoaXMuX2NvbnRlbnQ7XG5cbiAgICBpZiAoaGFzRGVmYXVsdENvbnRhaW5lcikge1xuXG4gICAgICBpZiAoIXRoaXMuX21hc2spIHtcbiAgICAgICAgY29uc3QgbWFzayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtYXNrLmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXItbWFzaycpO1xuICAgICAgICB0aGlzLmluc2VydEJlZm9yZShtYXNrLCB0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2Fycm93KSB7XG4gICAgICAgIGNvbnN0IGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGFycm93LmNsYXNzTGlzdC5hZGQoJ3BvcG92ZXJfX2Fycm93Jyk7XG4gICAgICAgIHRoaXMuX3BvcG92ZXIuYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB1dGlsLmNyZWF0ZUZyYWdtZW50KGBcbiAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXItbWFza1wiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwicG9wb3ZlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwb3BvdmVyX19jb250ZW50XCI+PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInBvcG92ZXJfX2Fycm93XCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgYCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGVtcGxhdGUucXVlcnlTZWxlY3RvcignLnBvcG92ZXJfX2NvbnRlbnQnKTtcblxuICAgICAgd2hpbGUgKHRoaXMuY2hpbGROb2Rlc1swXSkge1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8vIEZJWE1FIVxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgdGhpcy5fcG9wb3Zlci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCB0aGlzLl9zY2hlbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3codGFyZ2V0LCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfEV2ZW50fEhUTUxFbGVtZW50fSB0YXJnZXRcbiAgICogICBbZW5dVGFyZ2V0IGVsZW1lbnQuIENhbiBiZSBlaXRoZXIgYSBDU1Mgc2VsZWN0b3IsIGFuIGV2ZW50IG9iamVjdCBvciBhIERPTSBlbGVtZW50LiBJdCBjYW4gYmUgYWxzbyBwcm92aWRlZCBhcyAnb3B0aW9ucy50YXJnZXQnIGluc3RlYWQuIFsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBruOCv+ODvOOCsuODg+ODiOOBqOOBquOCi+imgee0oOOCkuaMh+WumuOBl+OBvuOBmeOAgkNTU+OCu+ODrOOCr+OCv+OBi2V2ZW5044Kq44OW44K444Kn44Kv44OI44GLRE9N6KaB57Sg44Gu44GE44Ga44KM44GL44KS5rih44Gb44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiAgVXNlIG9uZSBvZiBgXCJmYWRlLWlvc1wiYCwgYFwiZmFkZS1tZFwiYCwgYFwibm9uZVwiYCBhbmQgYFwiZGVmYXVsdFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PlkI3jgpLmjIflrprjgZfjgb7jgZnjgIJcImZhZGUtaW9zXCIsIFwiZmFkZS1tZFwiLCBcIm5vbmVcIiwgXCJkZWZhdWx0XCLjga7jgYTjgZrjgozjgYvjgpLmjIflrprjgafjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIHRoZSBwb3BvdmVyIGhhcyBiZWVuIHJldmVhbGVkLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOihqOekuuOBleOCjOe1guOCj+OBo+OBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVuIHRoZSBwb3BvdmVyIGFuZCBwb2ludCBpdCBhdCBhIHRhcmdldC4gVGhlIHRhcmdldCBjYW4gYmUgZWl0aGVyIGFuIGV2ZW50LCBhIENTUyBzZWxlY3RvciBvciBhIERPTSBlbGVtZW50Li5bL2VuXVxuICAgKiAgIFtqYV3lr77osaHjgajjgZnjgovopoHntKDjgavjg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJ0YXJnZXTlvJXmlbDjgavjga/jgIEkZXZlbnTjgqrjg5bjgrjjgqfjgq/jg4jjgoRET03jgqjjg6zjg6Hjg7Pjg4jjgoRDU1Pjgrvjg6zjgq/jgr/jgpLmuKHjgZnjgZPjgajjgYzlh7rmnaXjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgc2hvdyh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIENvcHkgb3B0aW9ucyBhbmQgaW5jbHVkZSBvcHRpb25zLnRhcmdldFxuICAgIGlmICh0YXJnZXQgJiYgdHlwZW9mIHRhcmdldCA9PT0gJ29iamVjdCcgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBFdmVudCkgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgIG9wdGlvbnMgPSB7IC4uLnRhcmdldCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0YXJnZXQgfTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucy50YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvbnMudGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMudGFyZ2V0IGluc3RhbmNlb2YgRXZlbnQpIHtcbiAgICAgIG9wdGlvbnMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQudGFyZ2V0O1xuICAgIH1cblxuICAgIGlmICghKG9wdGlvbnMudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgIHV0aWwudGhyb3coJ0ludmFsaWQgdGFyZ2V0IHR5cGUgb3IgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLnNob3cob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gIFVzZSBvbmUgb2YgYFwiZmFkZS1pb3NcImAsIGBcImZhZGUtbWRcImAsIGBcIm5vbmVcImAgYW5kIGBcImRlZmF1bHRcImAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCXCJmYWRlLWlvc1wiLCBcImZhZGUtbWRcIiwgXCJub25lXCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiAgIFtlbl1UaGlzIGZ1bmN0aW9ucyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHBvcG92ZXIgaGFzIGJlZW4gaGlkZGVuLlsvZW5dXG4gICAqICAgW2phXeODneODg+ODl+OCquODvOODkOODvOOBjOmaoOOCjOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSB0aGUgcG9wb3Zlci5bL2VuXVxuICAgKiAgIFtqYV3jg53jg4Pjg5fjgqrjg7zjg5Djg7zjgpLplonjgZjjgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgaGlkZGVuIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZpc2libGVcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3opoHntKDjgYzopovjgYjjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNhbmNlbGFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIEEgYm9vbGVhbiB2YWx1ZSB0aGF0IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBwb3BvdmVyIGlzIGNhbmNlbGFibGUgb3Igbm90LlxuICAgKlxuICAgKiAgICAgV2hlbiB0aGUgcG9wb3ZlciBpcyBjYW5jZWxhYmxlIGl0IGNhbiBiZSBjbG9zZWQgYnkgdGFwcGluZyB0aGUgYmFja2dyb3VuZCBvciBieSBwcmVzc2luZyB0aGUgYmFjayBidXR0b24gb24gQW5kcm9pZCBkZXZpY2VzLlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmRPbkNoYW5nZSwgZmFsc2UpO1xuICAgIHRoaXMuX21hcmdpbiA9IHRoaXMuX21hcmdpbiB8fCBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5nZXRQcm9wZXJ0eVZhbHVlKCd0b3AnKSk7XG4gICAgdGhpcy5fbWFyZ2luID0gdGhpcy5fbWFyZ2luIHx8IDY7IC8vIEZpeCBmb3IgaWZyYW1lc1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3JhZGl1cyA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX2NvbnRlbnQpLmdldFByb3BlcnR5VmFsdWUoJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnKSk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE9uQ2hhbmdlLCBmYWxzZSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWy4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcywgJ2RpcmVjdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2RpcmVjdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ib3VuZE9uQ2hhbmdlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICB0aGlzLl9jdXJyZW50RGlyZWN0aW9uICYmIHV0aWwuYWRkTW9kaWZpZXIodGhpcywgdGhpcy5fY3VycmVudERpcmVjdGlvbik7XG4gICAgfVxuICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge1BvcG92ZXJBbmltYXRvcn0gQW5pbWF0b3JcbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckFuaW1hdG9yKG5hbWUsIEFuaW1hdG9yKSB7XG4gICAgaWYgKCEoQW5pbWF0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUG9wb3ZlckFuaW1hdG9yKSkge1xuICAgICAgdXRpbC50aHJvd0FuaW1hdG9yKCdQb3BvdmVyJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBQb3BvdmVyQW5pbWF0b3IoKSB7XG4gICAgcmV0dXJuIFBvcG92ZXJBbmltYXRvcjtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5Qb3BvdmVyID0gUG9wb3ZlckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wb3BvdmVyJywgUG9wb3ZlckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnByb2dyZXNzLWJhcic6ICdwcm9ncmVzcy1iYXItLSonLFxuICAnLnByb2dyZXNzLWJhcl9fcHJpbWFyeSc6ICdwcm9ncmVzcy1iYXItLSpfX3ByaW1hcnknLFxuICAnLnByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5JzogJ3Byb2dyZXNzLWJhci0tKl9fc2Vjb25kYXJ5J1xufTtcblxuY29uc3QgdGVtcGxhdGUgPSB1dGlsLmNyZWF0ZUVsZW1lbnQoYFxuICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyXCI+XG4gICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhcl9fc2Vjb25kYXJ5XCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWJhcl9fcHJpbWFyeVwiPjwvZGl2PlxuICA8L2Rpdj5cbmApO1xuXG5jb25zdCBJTkRFVCA9ICdpbmRldGVybWluYXRlJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcHJvZ3Jlc3MtYmFyXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXURpc3BsYXkgYSBNYXRlcmlhbCBEZXNpZ24gcHJvZ3Jlc3MgYmFyLlsvZW5dXG4gKiAgIFtqYV3jg57jg4bjg6rjgqLjg6vjg4fjgrbjgqTjg7Pjga7jgrnjgr/jgqTjg6vjgafjg5fjg63jgrDjg6zjgrnjg5Djg7zjgpLooajnpLrjgZfjgb7jgZnjgIJbL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGUgY29tcG9uZW50IGlzIHVzZWQgdG8gZGlzcGxheSBhIGxpbmVhciBwcm9ncmVzcyBiYXIuIEl0IGNhbiBlaXRoZXIgZGlzcGxheSBhIHByb2dyZXNzIGJhciB0aGF0IHNob3dzIHRoZSB1c2VyIGhvdyBtdWNoIG9mIGEgdGFzayBoYXMgYmVlbiBjb21wbGV0ZWQuIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBwZXJjZW50YWdlIGlzIG5vdCBrbm93biBpdCBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IGFuIGFuaW1hdGVkIHByb2dyZXNzIGJhciBzbyB0aGUgdXNlciBjYW4gc2VlIHRoYXQgYW4gb3BlcmF0aW9uIGlzIGluIHByb2dyZXNzLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHp2UWJHalxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3Byb2dyZXNzXG4gKiBAc2VlYWxzbyBvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqICAgW2VuXVRoZSBgPG9ucy1wcm9ncmVzcy1jaXJjdWxhcj5gIGNvbXBvbmVudCBkaXNwbGF5cyBhIGNpcmN1bGFyIHByb2dyZXNzIGluZGljYXRvci5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXByb2dyZXNzLWJhclxuICogIHZhbHVlPVwiNTVcIlxuICogIHNlY29uZGFyeS12YWx1ZT1cIjg3XCI+XG4gKiA8L29ucy1wcm9ncmVzcy1iYXI+XG4gKlxuICogPG9ucy1wcm9ncmVzcy1iYXJcbiAqICBpbmRldGVybWluYXRlPlxuICogPC9vbnMtcHJvZ3Jlc3MtYmFyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmVzc0JhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gICAqICAgW2phXeODl+ODreOCsOODrOOCueOCpOODs+OCuOOCseODvOOCv+OBruimi+OBn+ebruOCkuWkieabtOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2Vjb25kYXJ5LXZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGluZGV0ZXJtaW5hdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQ29tcGlsZWQoKSkge1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RlbXBsYXRlID0gdXRpbC5maW5kQ2hpbGQodGhpcywgJy5wcm9ncmVzcy1iYXInKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcmltYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtYmFyX19wcmltYXJ5Jyk7XG4gICAgdGhpcy5fc2Vjb25kYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnknKTtcblxuICAgIHRoaXMuX3VwZGF0ZURldGVybWluYXRlKCk7XG4gICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcblxuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX2lzQ29tcGlsZWQoKSB7XG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnByb2dyZXNzLWJhcicpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgYmFyRWxlbWVudCA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtYmFyJyk7XG5cbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKGJhckVsZW1lbnQsICcucHJvZ3Jlc3MtYmFyX19zZWNvbmRhcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoYmFyRWxlbWVudCwgJy5wcm9ncmVzcy1iYXJfX3ByaW1hcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAndmFsdWUnLCAnc2Vjb25kYXJ5LXZhbHVlJywgSU5ERVRdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ21vZGlmaWVyJykge1xuICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICB0aGlzLmhhc0F0dHJpYnV0ZShJTkRFVCkgJiYgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICd2YWx1ZScgfHwgbmFtZSA9PT0gJ3NlY29uZGFyeS12YWx1ZScpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBJTkRFVCkge1xuICAgICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cblxuICBfdXBkYXRlRGV0ZXJtaW5hdGUoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHV0aWwudG9nZ2xlTW9kaWZpZXIodGhpcywgSU5ERVQsIHsgZm9yY2U6IHRoaXMuaGFzQXR0cmlidXRlKElOREVUKSB9KSk7XG4gIH1cblxuICBfdXBkYXRlVmFsdWUoKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3ByaW1hcnkuc3R5bGUud2lkdGggPSAodGhpcy5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgKyAnJScgOiAnMCUnO1xuICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlLndpZHRoID0gdGhpcy5oYXNBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpID8gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpICsgJyUnIDogJzAlJztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzZWNvbmRhcnlWYWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHNlY29uZGFyeVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKElOREVULCAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoSU5ERVQpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpbmRldGVybWluYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZShJTkRFVCk7XG4gIH1cbn1cblxub25zRWxlbWVudHMuUHJvZ3Jlc3NCYXIgPSBQcm9ncmVzc0JhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wcm9ncmVzcy1iYXInLCBQcm9ncmVzc0JhckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnByb2dyZXNzLWNpcmN1bGFyJzogJ3Byb2dyZXNzLWNpcmN1bGFyLS0qJyxcbiAgJy5wcm9ncmVzcy1jaXJjdWxhcl9fYmFja2dyb3VuZCc6ICdwcm9ncmVzcy1jaXJjdWxhci0tKl9fYmFja2dyb3VuZCcsXG4gICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnknOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSpfX3ByaW1hcnknLFxuICAnLnByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnknOiAncHJvZ3Jlc3MtY2lyY3VsYXItLSpfX3NlY29uZGFyeSdcbn07XG5cbmNvbnN0IHRlbXBsYXRlID0gdXRpbC5jcmVhdGVFbGVtZW50KGBcbiAgPHN2ZyBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyXCI+XG4gICAgPGNpcmNsZSBjbGFzcz1cInByb2dyZXNzLWNpcmN1bGFyX19iYWNrZ3JvdW5kXCIgLz5cbiAgICA8Y2lyY2xlIGNsYXNzPVwicHJvZ3Jlc3MtY2lyY3VsYXJfX3NlY29uZGFyeVwiIGN4PVwiNTAlXCIgY3k9XCI1MCVcIiByPVwiNDAlXCIgLz5cbiAgICA8Y2lyY2xlIGNsYXNzPVwicHJvZ3Jlc3MtY2lyY3VsYXJfX3ByaW1hcnlcIiBjeD1cIjUwJVwiIGN5PVwiNTAlXCIgcj1cIjQwJVwiIC8+XG4gIDwvc3ZnPlxuYCk7XG5cbmNvbnN0IElOREVUID0gJ2luZGV0ZXJtaW5hdGUnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogQGNhdGVnb3J5IHZpc3VhbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkaXNwbGF5cyBhIGNpcmN1bGFyIHByb2dyZXNzIGluZGljYXRvci4gSXQgY2FuIGVpdGhlciBiZSB1c2VkIHRvIHNob3cgaG93IG11Y2ggb2YgYSB0YXNrIGhhcyBiZWVuIGNvbXBsZXRlZCBvciB0byBzaG93IGEgbG9vcGluZyBhbmltYXRpb24gdG8gaW5kaWNhdGUgdGhhdCBhbiBvcGVyYXRpb24gaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gRVZ6TWpSXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqIEBzZWVhbHNvIG9ucy1wcm9ncmVzcy1iYXJcbiAqICAgW2VuXVRoZSBgPG9ucy1wcm9ncmVzcy1iYXI+YCBjb21wb25lbnQgZGlzcGxheXMgYSBiYXIgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcHJvZ3Jlc3MtY2lyY3VsYXJcbiAqICB2YWx1ZT1cIjU1XCJcbiAqICBzZWNvbmRhcnktdmFsdWU9XCI4N1wiPlxuICogPC9vbnMtcHJvZ3Jlc3MtY2lyY3VsYXI+XG4gKlxuICogPG9ucy1wcm9ncmVzcy1jaXJjdWxhclxuICogIGluZGV0ZXJtaW5hdGU+XG4gKiA8L29ucy1wcm9ncmVzcy1jaXJjdWxhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJvZ3Jlc3MgaW5kaWNhdG9yLlsvZW5dXG4gICAqICAgW2phXeODl+ODreOCsOODrOOCueOCpOODs+OCuOOCseODvOOCv+OBruimi+OBn+ebruOCkuWkieabtOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHByb2dyZXNzLiBTaG91bGQgYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEwMC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7pgLLooYznirbms4Hjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIIw44GL44KJMTAw44Gu6ZaT44Gu5YCk44KS5oyH5a6a44GX44Gm5LiL44GV44GE44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2Vjb25kYXJ5LXZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHNlY29uZGFyeSBwcm9ncmVzcy4gU2hvdWxkIGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxMDAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu77yS55Wq55uu44Gu6YCy6KGM54q25rOB44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCMOOBi+OCiTEwMOOBrumWk+OBruWApOOCkuaMh+WumuOBl+OBpuS4i+OBleOBhOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGluZGV0ZXJtaW5hdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICd2YWx1ZScsICdzZWNvbmRhcnktdmFsdWUnLCBJTkRFVF07XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKElOREVUKSAmJiB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3ZhbHVlJyB8fCBuYW1lID09PSAnc2Vjb25kYXJ5LXZhbHVlJykge1xuICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IElOREVUKSB7XG4gICAgICB0aGlzLl91cGRhdGVEZXRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVEZXRlcm1pbmF0ZSgpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdXRpbC50b2dnbGVNb2RpZmllcih0aGlzLCBJTkRFVCwgeyBmb3JjZTogdGhpcy5oYXNBdHRyaWJ1dGUoSU5ERVQpIH0pKTtcbiAgfVxuXG4gIF91cGRhdGVWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBlciA9IE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAqIDI1MS4zMiAqIDAuMDEpO1xuICAgICAgICB0aGlzLl9wcmltYXJ5LnN0eWxlWydzdHJva2UtZGFzaGFycmF5J10gPSBwZXIgKyAnJSwgMjUxLjMyJSc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdzZWNvbmRhcnktdmFsdWUnKSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGVyID0gIE1hdGguY2VpbCh0aGlzLmdldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5LXZhbHVlJykgKiAyNTEuMzIgKiAwLjAxKTtcbiAgICAgICAgdGhpcy5fc2Vjb25kYXJ5LnN0eWxlLmRpc3BsYXkgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGVbJ3N0cm9rZS1kYXNoYXJyYXknXSA9IHBlciArICclLCAyNTEuMzIlJztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICB0aGlzLl9zZWNvbmRhcnkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmFsdWVcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgTWF0aC5mbG9vcih2YWx1ZSkpO1xuICB9XG5cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWUnKSB8fCAnMCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBzZWNvbmRhcnlWYWx1ZVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzZWNvbmRhcnkgcHJvZ3Jlc3MuIFNob3VsZCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMTAwLlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBru+8kueVquebruOBrumAsuihjOeKtuazgeOBruWApOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokxMDDjga7plpPjga7lgKTjgpLmjIflrprjgZfjgabkuIvjgZXjgYTjgIJbL2phXVxuICAgKi9cbiAgc2V0IHNlY29uZGFyeVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicgfHwgdmFsdWUgPCAwIHx8IHZhbHVlID4gMTAwKSB7XG4gICAgICB1dGlsLnRocm93KCdJbnZhbGlkIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScsIE1hdGguZmxvb3IodmFsdWUpKTtcbiAgfVxuXG4gIGdldCBzZWNvbmRhcnlWYWx1ZSgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3NlY29uZGFyeS12YWx1ZScpIHx8ICcwJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGluZGV0ZXJtaW5hdGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIHByb3BlcnR5IGlzIGB0cnVlYCwgYW4gaW5maW5pdGUgbG9vcGluZyBhbmltYXRpb24gd2lsbCBiZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7lsZ7mgKfjgYzoqK3lrprjgZXjgozjgZ/loLTlkIjjgIHjg6vjg7zjg5fjgZnjgovjgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgc2V0IGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKElOREVULCAnJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoSU5ERVQpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpbmRldGVybWluYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZShJTkRFVCk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBpZiAodGhpcy5faXNDb21waWxlZCgpKSB7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSB0ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpbWFyeSA9IHV0aWwuZmluZENoaWxkKHRoaXMuX3RlbXBsYXRlLCAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5Jyk7XG4gICAgdGhpcy5fc2Vjb25kYXJ5ID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGVtcGxhdGUsICcucHJvZ3Jlc3MtY2lyY3VsYXJfX3NlY29uZGFyeScpO1xuXG4gICAgdGhpcy5fdXBkYXRlRGV0ZXJtaW5hdGUoKTtcbiAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuXG4gICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl90ZW1wbGF0ZSk7XG5cbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfaXNDb21waWxlZCgpIHtcbiAgICBpZiAoIXV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHN2ZyA9IHV0aWwuZmluZENoaWxkKHRoaXMsICcucHJvZ3Jlc3MtY2lyY3VsYXInKTtcblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoc3ZnLCAnLnByb2dyZXNzLWNpcmN1bGFyX19zZWNvbmRhcnknKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdXRpbC5maW5kQ2hpbGQoc3ZnLCAnLnByb2dyZXNzLWNpcmN1bGFyX19wcmltYXJ5JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5Qcm9ncmVzc0NpcmN1bGFyID0gUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1wcm9ncmVzcy1jaXJjdWxhcicsIFByb2dyZXNzQ2lyY3VsYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9vbnMvc3R5bGVyJztcbmltcG9ydCBwbGF0Zm9ybSBmcm9tICcuLi9vbnMvcGxhdGZvcm0nO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEdlc3R1cmVEZXRlY3RvciBmcm9tICcuLi9vbnMvZ2VzdHVyZS1kZXRlY3Rvcic7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uL29ucy9hbmltaXQnO1xuXG5jb25zdCBTVEFURV9JTklUSUFMID0gJ2luaXRpYWwnO1xuY29uc3QgU1RBVEVfUFJFQUNUSU9OID0gJ3ByZWFjdGlvbic7XG5jb25zdCBTVEFURV9BQ1RJT04gPSAnYWN0aW9uJztcblxuY29uc3QgdGhyb3dUeXBlID0gKGVsLCB0eXBlKSA9PiB1dGlsLnRocm93KGBcIiR7ZWx9XCIgbXVzdCBiZSAke3R5cGV9YCk7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXB1bGwtaG9va1xuICogQGNhdGVnb3J5IGNvbnRyb2xcbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgQ29tcG9uZW50IHRoYXQgYWRkcyAqKlB1bGwgdG8gcmVmcmVzaCoqIGZ1bmN0aW9uYWxpdHkgdG8gYW4gYDxvbnMtcGFnZT5gIGVsZW1lbnQuXG4gKlxuICogICAgIEl0IGNhbiBiZSB1c2VkIHRvIHBlcmZvcm0gYSB0YXNrIHdoZW4gdGhlIHVzZXIgcHVsbHMgZG93biBhdCB0aGUgdG9wIG9mIHRoZSBwYWdlLiBBIGNvbW1vbiB1c2FnZSBpcyB0byByZWZyZXNoIHRoZSBkYXRhIGRpc3BsYXllZCBpbiBhIHBhZ2UuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4gV2JKb2dNXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcHVsbC1ob29rXG4gKiBAZXhhbXBsZVxuICogPG9ucy1wYWdlPlxuICogICA8b25zLXB1bGwtaG9vaz5cbiAqICAgICBSZWxlYXNlIHRvIHJlZnJlc2hcbiAqICAgPC9vbnMtcHVsbC1ob29rPlxuICogPC9vbnMtcGFnZT5cbiAqXG4gKiA8c2NyaXB0PlxuICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdvbnMtcHVsbC1ob29rJykub25BY3Rpb24gPSBmdW5jdGlvbihkb25lKSB7XG4gKiAgICAgc2V0VGltZW91dChkb25lLCAxMDAwKTtcbiAqICAgfTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdWxsSG9va0VsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBjaGFuZ2VzdGF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQgd2hlbiB0aGUgc3RhdGUgaXMgY2hhbmdlZC4gVGhlIHN0YXRlIGNhbiBiZSBlaXRoZXIgXCJpbml0aWFsXCIsIFwicHJlYWN0aW9uXCIgb3IgXCJhY3Rpb25cIi5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7nirbmhYvjgYzlpInjgo/jgaPjgZ/loLTlkIjjgavnmbrngavjgZfjgb7jgZnjgILnirbmhYvjga/jgIFcImluaXRpYWxcIiwgXCJwcmVhY3Rpb25cIiwgXCJhY3Rpb25cIuOBruOBhOOBmuOCjOOBi+OBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnB1bGxIb29rXG4gICAqICAgW2VuXUNvbXBvbmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50LnN0YXRlXG4gICAqICAgW2VuXUN1cnJlbnQgc3RhdGUuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu54q25oWL5ZCN44KS5Y+C54Wn44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgXCJwdWxsLXRvLXJlZnJlc2hcIiBmdW5jdGlvbmFsaXR5IGlzIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOOBguOCi+aZguOAgWRpc2FibGVk54q25oWL44Gr44Gq44KK44Ki44Kv44K344On44Oz44GM5a6f6KGM44GV44KM44Gq44GP44Gq44KK44G+44GZWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaGVpZ2h0XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudC4gV2hlbiBwdWxsZWQgZG93biBmdXJ0aGVyIHRoYW4gdGhpcyB2YWx1ZSBpdCB3aWxsIHN3aXRjaCB0byB0aGUgXCJwcmVhY3Rpb25cIiBzdGF0ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCI2NHB4XCIuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI44Gu6auY44GV44KS5oyH5a6a44GX44G+44GZ44CC44GT44Gu6auY44GV5Lul5LiK44GrcHVsbCBkb3du44GZ44KL44GoXCJwcmVhY3Rpb25cIueKtuaFi+OBq+enu+ihjOOBl+OBvuOBmeOAguODh+ODleOCqeODq+ODiOOBruWApOOBr1wiNjRweFwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgdGhyZXNob2xkLWhlaWdodFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgdGhyZXNob2xkIGhlaWdodC4gVGhlIGNvbXBvbmVudCBhdXRvbWF0aWNhbGx5IHN3aXRjaGVzIHRvIHRoZSBcImFjdGlvblwiIHN0YXRlIHdoZW4gcHVsbGVkIGZ1cnRoZXIgdGhhbiB0aGlzIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBcIjk2cHhcIi4gQSBuZWdhdGl2ZSB2YWx1ZSB3aWxsIGRpc2FibGUgdGhpcyBwcm9wZXJ0eS4gSWYgdGhpcyB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBoZWlnaHQsIGl0IHdpbGwgc2tpcCBcInByZWFjdGlvblwiIHN0YXRlLlsvZW5dXG4gICAqICAgW2phXemWvuWApOOBqOOBquOCi+mrmOOBleOCkuaMh+WumuOBl+OBvuOBmeOAguOBk+OBruWApOOBp+aMh+WumuOBl+OBn+mrmOOBleOCiOOCiuOCgnB1bGwgZG93buOBmeOCi+OBqOOAgeOBk+OBruOCs+ODs+ODneODvOODjeODs+ODiOOBr+iHquWLleeahOOBq1wiYWN0aW9uXCLnirbmhYvjgavnp7vooYzjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBmaXhlZC1jb250ZW50XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIGNvbnRlbnQgb2YgdGhlIHBhZ2Ugd2lsbCBub3QgbW92ZSB3aGVuIHB1bGxpbmcuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44OX44Or44OV44OD44Kv44GM5byV44GN5Ye644GV44KM44Gm44GE44KL5pmC44Gr44KC44Kz44Oz44OG44Oz44OE44Gv5YuV44GN44G+44Gb44KT44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3Nob3VsZEZpeFNjcm9sbCA9IHV0aWwuZ2xvYmFscy5pc1VJV2ViVmlldztcblxuICAgIHRoaXMuX29uRHJhZyA9IHRoaXMuX29uRHJhZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uRHJhZ1N0YXJ0ID0gdGhpcy5fb25EcmFnU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkRyYWdFbmQgPSB0aGlzLl9vbkRyYWdFbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblNjcm9sbCA9IHRoaXMuX29uU2Nyb2xsLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMLCB0cnVlKTtcbiAgICB0aGlzLl9oaWRlKCk7IC8vIEZpeCBmb3IgdHJhbnNwYXJlbnQgdG9vbGJhciB0cmFuc2l0aW9uc1xuICB9XG5cbiAgX3NldFN0eWxlKCkge1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4JztcbiAgICBzdHlsZXIodGhpcywgeyBoZWlnaHQsIGxpbmVIZWlnaHQ6IGhlaWdodCB9KTtcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPT09ICcnICYmIHRoaXMuX3Nob3coKTtcbiAgfVxuXG4gIF9vblNjcm9sbChldmVudCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9wYWdlRWxlbWVudDtcblxuICAgIGlmIChlbGVtZW50LnNjcm9sbFRvcCA8IDApIHtcbiAgICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICB9XG4gIH1cblxuICBfY2FuQ29uc3VtZUdlc3R1cmUoZ2VzdHVyZSkge1xuICAgIHJldHVybiBnZXN0dXJlLmRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBnZXN0dXJlLmRpcmVjdGlvbiA9PT0gJ2Rvd24nO1xuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5nZXN0dXJlIHx8IHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXBZID0gZXZlbnQuZ2VzdHVyZS5jZW50ZXIuY2xpZW50WSArIHRoaXMuX3BhZ2VFbGVtZW50LnNjcm9sbFRvcDtcbiAgICBjb25zdCBtYXhZID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIC8vIE9ubHkgdXNlIGRyYWdzIHRoYXQgc3RhcnQgbmVhciB0aGUgcHVsbEhvb2sgdG8gcmVkdWNlIGZsaWNrZXJpbmdzXG4gICAgY29uc3QgZHJhZ2dhYmxlQXJlYVJhdGlvID0gdGhpcy5fc2hvdWxkRml4U2Nyb2xsID8gLjggOiAxO1xuXG4gICAgdGhpcy5faWdub3JlRHJhZyA9IGV2ZW50LmNvbnN1bWVkIHx8ICh0YXBZID4gbWF4WSAqIGRyYWdnYWJsZUFyZWFSYXRpbyk7XG5cbiAgICBpZiAoIXRoaXMuX2lnbm9yZURyYWcpIHtcbiAgICAgIGNvbnN0IGNvbnN1bWUgPSBldmVudC5jb25zdW1lO1xuICAgICAgZXZlbnQuY29uc3VtZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3VtZSAmJiBjb25zdW1lKCk7XG4gICAgICAgIHRoaXMuX2lnbm9yZURyYWcgPSB0cnVlO1xuICAgICAgICAvLyBUaGlzIGVsZW1lbnRzIHJlc2l6ZXMgLnBhZ2VfX2NvbnRlbnQgc28gaXQgaXMgc2FmZXJcbiAgICAgICAgLy8gdG8gaGlkZSBpdCB3aGVuIG90aGVyIGNvbXBvbmVudHMgYXJlIGRyYWdnZWQuXG4gICAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9jYW5Db25zdW1lR2VzdHVyZShldmVudC5nZXN0dXJlKSkge1xuICAgICAgICBjb25zdW1lICYmIGNvbnN1bWUoKTtcbiAgICAgICAgZXZlbnQuY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zaG93KCk7IC8vIE5vdCBlbm91Z2ggZHVlIHRvICdkcmFnTG9ja0F4aXMnXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhcnRTY3JvbGwgPSB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cblxuICBfb25EcmFnKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5nZXN0dXJlIHx8IHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5faWdub3JlRHJhZyB8fCAhdGhpcy5fY2FuQ29uc3VtZUdlc3R1cmUoZXZlbnQuZ2VzdHVyZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOZWNlc3NhcnkgZHVlIHRvICdkcmFnTG9ja0F4aXMnICgyNXB4KVxuICAgIGlmICh0aGlzLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgdGhpcy5fc2hvdygpO1xuICAgIH1cblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgY29uc3QgdGFwWSA9IGV2ZW50Lmdlc3R1cmUuY2VudGVyLmNsaWVudFkgKyB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgY29uc3QgbWF4WSA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgIC8vIEhhY2sgdG8gbWFrZSBpdCB3b3JrIG9uIEFuZHJvaWQgNC40IFdlYlZpZXcgYW5kIGlPUyBVSVdlYlZpZXcuIFNjcm9sbHMgbWFudWFsbHlcbiAgICAvLyBuZWFyIHRoZSB0b3Agb2YgdGhlIHBhZ2Ugc28gdGhlcmUgd2lsbCBiZSBubyBpbmVydGlhbCBzY3JvbGwgd2hlbiBzY3JvbGxpbmcgZG93bi5cbiAgICAvLyBBbGxvd2luZyBkZWZhdWx0IHNjcm9sbGluZyB3aWxsIGtpbGwgYWxsICd0b3VjaG1vdmUnIGV2ZW50cy5cbiAgICBpZiAodGhpcy5fc2hvdWxkRml4U2Nyb2xsKSB7XG4gICAgICB0aGlzLl9wYWdlRWxlbWVudC5zY3JvbGxUb3AgPSB0aGlzLl9zdGFydFNjcm9sbCAtIGV2ZW50Lmdlc3R1cmUuZGVsdGFZO1xuICAgICAgLy8gQWxsb3cgaW5lcnRpYSB3aGVuIHNjcm9sbGluZyBkb3duIGJlbG93IDUwJSBvZiB0aGUgdmlldyB0byByZWR1Y2UgZmxpY2tlcmluZ3NcbiAgICAgIGlmIChldmVudC5nZXN0dXJlLmludGVyaW1EaXJlY3Rpb24gIT09ICd1cCcgfHwgKHRhcFkgPD0gbWF4WSAqIC41KSkge1xuICAgICAgICBldmVudC5nZXN0dXJlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc2Nyb2xsID0gTWF0aC5tYXgoZXZlbnQuZ2VzdHVyZS5kZWx0YVkgLSB0aGlzLl9zdGFydFNjcm9sbCwgMCk7XG4gICAgaWYgKHNjcm9sbCAhPT0gdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uKSB7XG5cbiAgICAgIGNvbnN0IHRoID0gdGhpcy50aHJlc2hvbGRIZWlnaHQ7XG4gICAgICBpZiAodGggPiAwICYmIHNjcm9sbCA+PSB0aCkge1xuICAgICAgICBldmVudC5nZXN0dXJlLnN0b3BEZXRlY3QoKTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2ZpbmlzaCgpKTtcblxuICAgICAgfSBlbHNlIGlmIChzY3JvbGwgPj0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfUFJFQUNUSU9OKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfSU5JVElBTCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKHNjcm9sbCk7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ0VuZChldmVudCkge1xuICAgIGlmICghZXZlbnQuZ2VzdHVyZSB8fCB0aGlzLmRpc2FibGVkIHx8IHRoaXMuX2lnbm9yZURyYWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIGlmICh0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPiAwKSB7XG4gICAgICBjb25zdCBzY3JvbGwgPSB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb247XG5cbiAgICAgIGlmIChzY3JvbGwgPiB0aGlzLmhlaWdodCkge1xuICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKDAsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkFjdGlvblxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBgYWN0aW9uYCBzdGF0ZSBpZiBpdCBleGlzdHMuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGdpdmVuIGEgYGRvbmVgIGNhbGxiYWNrIGFzIGl0J3MgZmlyc3QgYXJndW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBvbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fb25BY3Rpb247XG4gIH1cblxuICBzZXQgb25BY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3dUeXBlKCdvbkFjdGlvbicsICdmdW5jdGlvbiBvciBudWxsJyk7XG4gICAgfVxuICAgIHRoaXMuX29uQWN0aW9uID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IG9uUHVsbFxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ib29rIGNhbGxlZCB3aGVuZXZlciB0aGUgdXNlciBwdWxscyB0aGUgZWxlbWVudC4gSXQgZ2V0cyB0aGUgcHVsbGVkIGRpc3RhbmNlIHJhdGlvIChzY3JvbGwgLyBoZWlnaHQpIGFuZCBhbiBhbmltYXRpb25PcHRpb25zIG9iamVjdCBhcyBhcmd1bWVudHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBvblB1bGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uUHVsbDtcbiAgfVxuXG4gIHNldCBvblB1bGwodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdGhyb3dUeXBlKCdvblB1bGwnLCAnZnVuY3Rpb24gb3IgbnVsbCcpO1xuICAgIH1cbiAgICB0aGlzLl9vblB1bGwgPSB2YWx1ZTtcbiAgfVxuXG4gIF9maW5pc2goKSB7XG4gICAgdGhpcy5fc2V0U3RhdGUoU1RBVEVfQUNUSU9OKTtcbiAgICB0aGlzLl90cmFuc2xhdGVUbyh0aGlzLmhlaWdodCwge2FuaW1hdGU6IHRydWV9KTtcbiAgICBjb25zdCBhY3Rpb24gPSB0aGlzLm9uQWN0aW9uIHx8IChkb25lID0+IGRvbmUoKSk7XG4gICAgYWN0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuX3RyYW5zbGF0ZVRvKDAsIHthbmltYXRlOiB0cnVlfSk7XG4gICAgICB0aGlzLl9zZXRTdGF0ZShTVEFURV9JTklUSUFMKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgaGVpZ2h0XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgaGVpZ2h0IG9mIHRoZSBwdWxsIGhvb2sgaW4gcGl4ZWxzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgNjRweGAuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCBoZWlnaHQodmFsdWUpIHtcbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgdGhyb3dUeXBlKCdoZWlnaHQnLCAnaW50ZWdlcicpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBgJHt2YWx1ZX1weGApO1xuICB9XG5cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8ICc2NCcsIDEwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdGhyZXNob2xkSGVpZ2h0XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgdGhyZXNob2xkSGVpZ2h0IG9mIHRoZSBwdWxsIGhvb2sgaW4gcGl4ZWxzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgOTZweGAuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldCB0aHJlc2hvbGRIZWlnaHQodmFsdWUpIHtcbiAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKHZhbHVlKSkge1xuICAgICAgdGhyb3dUeXBlKCd0aHJlc2hvbGRIZWlnaHQnLCAnaW50ZWdlcicpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JywgYCR7dmFsdWV9cHhgKTtcbiAgfVxuXG4gIGdldCB0aHJlc2hvbGRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCd0aHJlc2hvbGQtaGVpZ2h0JykgfHwgJzk2JywgMTApO1xuICB9XG5cbiAgX3NldFN0YXRlKHN0YXRlLCBub0V2ZW50KSB7XG4gICAgY29uc3QgbGFzdFN0YXRlID0gdGhpcy5zdGF0ZTtcblxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzdGF0ZScsIHN0YXRlKTtcblxuICAgIGlmICghbm9FdmVudCAmJiBsYXN0U3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2hhbmdlc3RhdGUnLCB7XG4gICAgICAgIHB1bGxIb29rOiB0aGlzLFxuICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgIGxhc3RTdGF0ZTogbGFzdFN0YXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHN0YXRlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnc3RhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcHVsbERpc3RhbmNlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGN1cnJlbnQgbnVtYmVyIG9mIHBpeGVscyB0aGUgcHVsbCBob29rIGhhcyBtb3ZlZC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7jg5fjg6vjg5Xjg4Pjgq/jgYzlvJXjgY3lh7rjgZXjgozjgZ/ot53pm6LjgpLjg5Tjgq/jgrvjg6vmlbDjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHB1bGxEaXN0YW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRyYW5zbGF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIC8vIFJ1biBhc3luY3Job25vdXNseSB0byBhdm9pZCBjb25mbGljdHMgd2l0aCBBbmltaXQncyBzdHlsZSBjbGVhblxuICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgIGlmICh0aGlzLl9wYWdlRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9wYWdlRWxlbWVudC5zdHlsZS5tYXJnaW5Ub3AgPSBgLSR7dGhpcy5oZWlnaHR9cHhgO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmICh0aGlzLl9wYWdlRWxlbWVudCkge1xuICAgICAgdGhpcy5fcGFnZUVsZW1lbnQuc3R5bGUubWFyZ2luVG9wID0gJyc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGxcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqL1xuICBfdHJhbnNsYXRlVG8oc2Nyb2xsLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodGhpcy5fY3VycmVudFRyYW5zbGF0aW9uID09IDAgJiYgc2Nyb2xsID09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50VHJhbnNsYXRpb24gPSBzY3JvbGw7XG4gICAgY29uc3Qgb3B0ID0gb3B0aW9ucy5hbmltYXRlID8geyBkdXJhdGlvbjogLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguMSwgLjcsIC4xLCAxKScgfSA6IHt9O1xuICAgIHRoaXMuX29uUHVsbCAmJiB0aGlzLl9vblB1bGwoKHNjcm9sbCAvIHRoaXMuaGVpZ2h0KS50b0ZpeGVkKDIpLCBvcHQpO1xuICAgIGNvbnN0IHNjcm9sbEVsZW1lbnQgPSAgdGhpcy5oYXNBdHRyaWJ1dGUoJ2ZpeGVkLWNvbnRlbnQnKSA/IHRoaXMgOiB0aGlzLl9wYWdlRWxlbWVudDtcblxuICAgIGFuaW1pdChzY3JvbGxFbGVtZW50KVxuICAgICAgLnF1ZXVlKHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMHB4LCAke3Njcm9sbH1weCwgMHB4KWAgfSwgb3B0KVxuICAgICAgLnBsYXkoKCkgPT4ge1xuICAgICAgICBzY3JvbGwgPT09IDAgJiYgc3R5bGVyLmNsZWFyKHNjcm9sbEVsZW1lbnQsICd0cmFuc2l0aW9uIHRyYW5zZm9ybScpO1xuICAgICAgICBvcHRpb25zLmNhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgb3B0aW9ucy5jYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG5cbiAgX2Rpc2FibGVEcmFnTG9jaygpIHsgLy8gZTJlIHRlc3RzIG5lZWQgaXRcbiAgICB0aGlzLl9kcmFnTG9ja0Rpc2FibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9zZXR1cExpc3RlbmVycyh0cnVlKTtcbiAgfVxuXG4gIF9zZXR1cExpc3RlbmVycyhhZGQpIHtcbiAgICBjb25zdCBzY3JvbGxUb2dnbGUgPSBhY3Rpb24gPT4gdGhpcy5fcGFnZUVsZW1lbnRbYCR7YWN0aW9ufUV2ZW50TGlzdGVuZXJgXSgnc2Nyb2xsJywgdGhpcy5fb25TY3JvbGwsIGZhbHNlKTtcbiAgICBjb25zdCBnZFRvZ2dsZSA9IGFjdGlvbiA9PiB7XG4gICAgICBjb25zdCBwYXNzaXZlID0geyBwYXNzaXZlOiB0cnVlIH07XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZycsIHRoaXMuX29uRHJhZywgcGFzc2l2ZSk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3JbYWN0aW9uXSgnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQsIHBhc3NpdmUpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yW2FjdGlvbl0oJ2RyYWdlbmQnLCB0aGlzLl9vbkRyYWdFbmQsIHBhc3NpdmUpO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5fZ2VzdHVyZURldGVjdG9yKSB7XG4gICAgICBnZFRvZ2dsZSgnb2ZmJyk7XG4gICAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yID0gbnVsbDtcbiAgICB9XG4gICAgc2Nyb2xsVG9nZ2xlKCdyZW1vdmUnKTtcblxuICAgIGlmIChhZGQpIHtcbiAgICAgIHRoaXMuX2dlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5fcGFnZUVsZW1lbnQsIHtcbiAgICAgICAgZHJhZ01pbkRpc3RhbmNlOiAxLFxuICAgICAgICBkcmFnRGlzdGFuY2VDb3JyZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgZHJhZ0xvY2tUb0F4aXM6ICF0aGlzLl9kcmFnTG9ja0Rpc2FibGVkLFxuICAgICAgICBwYXNzaXZlOiAhdGhpcy5fc2hvdWxkRml4U2Nyb2xsXG4gICAgICB9KTtcblxuICAgICAgZ2RUb2dnbGUoJ29uJyk7XG4gICAgICBzY3JvbGxUb2dnbGUoJ2FkZCcpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2xhdGlvbiA9IDA7XG4gICAgdGhpcy5fcGFnZUVsZW1lbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cbiAgICB0aGlzLl9zZXR1cExpc3RlbmVycyh0cnVlKTtcbiAgICB0aGlzLl9zZXRTdHlsZSgpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5faGlkZSgpO1xuICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKGZhbHNlKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2hlaWdodCddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2hlaWdodCcgJiYgdGhpcy5fcGFnZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsnY2hhbmdlc3RhdGUnXVxuICB9XG59XG5cbm9uc0VsZW1lbnRzLlB1bGxIb29rID0gUHVsbEhvb2tFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtcHVsbC1ob29rJywgUHVsbEhvb2tFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBCYXNlSW5wdXRFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWlucHV0JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3JhbmdlLS0qJyxcbiAgJy5yYW5nZV9faW5wdXQnOiAncmFuZ2UtLSpfX2lucHV0JyxcbiAgJy5yYW5nZV9fZm9jdXMtcmluZyc6ICdyYW5nZS0tKl9fZm9jdXMtcmluZydcbn07XG5cbmNvbnN0IGFjdGl2ZUNsYXNzVG9rZW4gPSAncmFuZ2VfX2lucHV0LS1hY3RpdmUnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yYW5nZVxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHNsaWRlclsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBSYW5nZSBpbnB1dCBjb21wb25lbnQuIFVzZWQgdG8gZGlzcGxheSBhIGRyYWdnYWJsZSBzbGlkZXIuXG4gKlxuICogICAgIFdvcmtzIHZlcnkgc2ltaWxhciB0byB0aGUgYDxpbnB1dCB0eXBlPVwicmFuZ2VcIj5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGNvZGVwZW4geFpRb21NXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcmFuZ2VcbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQHNlZWFsc28gb25zLWlucHV0XG4gKiAgIFtlbl1UaGUgYDxvbnMtaW5wdXQ+YCBjb21wb25lbnQgaXMgdXNlZCB0byBkaXNwbGF5IHRleHQgaW5wdXRzLCByYWRpbyBidXR0b25zIGFuZCBjaGVja2JveGVzLlsvZW5dXG4gKiAgIFtqYV1bL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtcmFuZ2UgdmFsdWU9XCIyMFwiPjwvb25zLXJhbmdlPlxuICogPG9ucy1yYW5nZSBtb2RpZmllcj1cIm1hdGVyaWFsXCIgdmFsdWU9XCIxMFwiPjwvcmFuZ2U+XG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFuZ2VFbGVtZW50IGV4dGVuZHMgQmFzZUlucHV0RWxlbWVudCB7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX29uTW91c2VEb3duID0gdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblRvdWNoU3RhcnQgPSB0aGlzLl9vblRvdWNoU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblRvdWNoRW5kID0gdGhpcy5fb25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uSW5wdXQgPSB0aGlzLl91cGRhdGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkRyYWdzdGFydCA9IHRoaXMuX29uRHJhZ3N0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25EcmFnZW5kID0gdGhpcy5fb25EcmFnZW5kLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBzdXBlci5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3VwZGF0ZURpc2FibGVkKHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKTtcbiAgfVxuXG4gIC8qIEluaGVyaXRlZCBwcm9wcyAqL1xuXG4gIF91cGRhdGUoKSB7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLl9pbnB1dDtcbiAgICBjb25zdCBmb2N1c1JpbmcgPSB0aGlzLl9mb2N1c1Jpbmc7XG5cbiAgICBpbnB1dC5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGAkezEwMCAqIHRoaXMuX3JhdGlvfSUgMnB4YDtcbiAgICBmb2N1c1JpbmcudmFsdWUgPSB0aGlzLnZhbHVlO1xuXG4gICAgLy8gTk9URTogXCJfemVyb1wiIGF0dHJpYnV0ZSBpcyB1c2VkIGZvciBDU1Mgc3R5bGluZy5cbiAgICBpZiAoKGlucHV0Lm1pbiA9PT0gJycgJiYgaW5wdXQudmFsdWUgPT09ICcwJykgfHwgaW5wdXQubWluID09PSBpbnB1dC52YWx1ZSkge1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdfemVybycsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdfemVybycpO1xuICAgIH1cblxuICAgIFsnbWluJywgJ21heCddLmZvckVhY2goYXR0ciA9PiBmb2N1c1JpbmdbYXR0cl0gPSBpbnB1dFthdHRyXSk7XG4gIH1cblxuICBnZXQgX3NjaGVtZSgpIHtcbiAgICByZXR1cm4gc2NoZW1lO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX2lucHV0XCI+XG4gICAgICA8aW5wdXQgdHlwZT1cInJhbmdlXCIgY2xhc3M9XCJyYW5nZV9fZm9jdXMtcmluZ1wiIHRhYkluZGV4PVwiLTFcIj5cbiAgICBgO1xuICB9XG5cbiAgZ2V0IF9kZWZhdWx0Q2xhc3NOYW1lKCkge1xuICAgIHJldHVybiAncmFuZ2UnO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdyYW5nZSc7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBfb25Nb3VzZURvd24oZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5hZGQoYWN0aXZlQ2xhc3NUb2tlbik7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2lucHV0LmZvY3VzKCkpO1xuICB9XG5cbiAgX29uVG91Y2hTdGFydChlKSB7XG4gICAgdGhpcy5fb25Nb3VzZURvd24oKTtcbiAgfVxuXG4gIF9vbk1vdXNlVXAoZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlQ2xhc3NUb2tlbik7XG4gIH1cblxuICBfb25Ub3VjaEVuZChlKSB7XG4gICAgdGhpcy5fb25Nb3VzZVVwKGUpO1xuICB9XG5cbiAgX29uRHJhZ3N0YXJ0KGUpIHtcbiAgICBlLmNvbnN1bWVkID0gdHJ1ZTtcbiAgICBlLmdlc3R1cmUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5faW5wdXQuY2xhc3NMaXN0LmFkZChhY3RpdmVDbGFzc1Rva2VuKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICB9XG5cbiAgX29uRHJhZyhlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIF9vbkRyYWdlbmQoZSkge1xuICAgIHRoaXMuX2lucHV0LmNsYXNzTGlzdC5yZW1vdmUoYWN0aXZlQ2xhc3NUb2tlbik7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnJywgdGhpcy5fb25EcmFnKTtcbiAgfVxuXG4gIGdldCBfZm9jdXNSaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzFdO1xuICB9XG5cbiAgZ2V0IF9yYXRpbygpIHtcbiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHJhdGlvLlxuICAgIGNvbnN0IG1pbiA9IHRoaXMuX2lucHV0Lm1pbiA9PT0gJycgPyAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWluKTtcbiAgICBjb25zdCBtYXggPSB0aGlzLl9pbnB1dC5tYXggPT09ICcnID8gMTAwIDogcGFyc2VJbnQodGhpcy5faW5wdXQubWF4KTtcblxuICAgIHJldHVybiAodGhpcy52YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2Rpc2FibGVkJywgLi4uQmFzZUlucHV0RWxlbWVudC5vYnNlcnZlZEF0dHJpYnV0ZXNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBpZiAobmFtZSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoY3VycmVudCk7XG4gICAgfVxuICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gICAqL1xuICBfdXBkYXRlRGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgncmFuZ2UtLWRpc2FibGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZSgncmFuZ2UtLWRpc2FibGVkJyk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcnModHJ1ZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9zZXR1cExpc3RlbmVycyhmYWxzZSk7XG4gIH1cblxuICBfc2V0dXBMaXN0ZW5lcnMoYWRkKSB7XG4gICAgY29uc3QgYWN0aW9uID0gKGFkZCA/ICdhZGQnIDogJ3JlbW92ZScpICsgJ0V2ZW50TGlzdGVuZXInO1xuICAgIHV0aWxbYWN0aW9uXSh0aGlzLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVG91Y2hTdGFydCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIHRoaXNbYWN0aW9uXSgnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgIHRoaXNbYWN0aW9uXSgnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcCk7XG4gICAgdGhpc1thY3Rpb25dKCd0b3VjaGVuZCcsIHRoaXMuX29uVG91Y2hFbmQpO1xuICAgIHRoaXNbYWN0aW9uXSgnZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnc3RhcnQpO1xuICAgIHRoaXNbYWN0aW9uXSgnZHJhZ2VuZCcsIHRoaXMuX29uRHJhZ2VuZCk7XG4gICAgdGhpc1thY3Rpb25dKCdpbnB1dCcsIHRoaXMuX29uSW5wdXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGRpc2FibGVkIG9yIG5vdC5bL2VuXVxuICAgKiAgIFtqYV3nhKHlirnljJbjgZXjgozjgabjgYTjgovloLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DdXJyZW50IHZhbHVlLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xufVxuXG5vbnNFbGVtZW50cy5SYW5nZSA9IFJhbmdlRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJhbmdlJywgUmFuZ2VFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE2IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwnO1xuXG4vKipcbiAqIEBjbGFzcyBBbmltYXRvckNTUyAtIGltcGxlbWVudGF0aW9uIG9mIEFuaW1hdG9yIGNsYXNzIHVzaW5nIGNzcyB0cmFuc2l0aW9uc1xuICovXG5jbGFzcyBBbmltYXRvckNTUyB7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgYW5pbWF0ZVxuICAgKiBAZGVzYyBtYWluIGFuaW1hdGlvbiBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGZpbmFsQ1NTXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXSAtIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LnRoZW4oY2FsbGJhY2spIC0gc2V0cyBhIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZSBhbmltYXRpb24gaGFzIHN0b3BwZWRcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5zdG9wKG9wdGlvbnMpIC0gc3RvcHMgdGhlIGFuaW1hdGlvbjsgaWYgb3B0aW9ucy5zdG9wTmV4dCBpcyB0cnVlIHRoZW4gaXQgZG9lc24ndCBjYWxsIHRoZSBjYWxsYmFja1xuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gcmVzdWx0LmZpbmlzaChtcykgLSBmaW5pc2hlcyB0aGUgYW5pbWF0aW9uIGluIHRoZSBzcGVjaWZpZWQgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAgICogQHJldHVybiB7RnVuY3Rpb259IHJlc3VsdC5zcGVlZChtcykgLSBzZXRzIHRoZSBhbmltYXRpb24gc3BlZWQgc28gdGhhdCBpdCBmaW5pc2hlcyBhcyBpZiB0aGUgb3JpZ2luYWwgZHVyYXRpb24gd2FzIHRoZSBvbmUgc3BlY2lmaWVkIGhlcmVcbiAgICogQGV4YW1wbGVcbiAgICogYGBgYFxuICAgKiAgdmFyIHJlc3VsdCA9IGFuaW1hdG9yLmFuaW1hdGUoZWwsIHtvcGFjaXR5OiAwLjV9LCAxMDAwKTtcbiAgICpcbiAgICogIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAqICAgIHJlc3VsdC5zcGVlZCgyMDApLnRoZW4oZnVuY3Rpb24oKXtcbiAgICogICAgICBjb25zb2xlLmxvZygnZG9uZScpO1xuICAgKiAgICB9KTtcbiAgICogIH0sIDMwMCk7XG4gICAqIGBgYGBcbiAgICovXG4gIGFuaW1hdGUoZWwsIGZpbmFsLCBkdXJhdGlvbiA9IDIwMCkge1xuICAgIHZhciBzdGFydCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCksXG4gICAgICAgIGluaXRpYWwgPSB7fSxcbiAgICAgICAgc3RvcHBlZCA9IGZhbHNlLFxuICAgICAgICBuZXh0ID0gZmFsc2UsXG4gICAgICAgIHRpbWVvdXQgPSBmYWxzZSxcbiAgICAgICAgcHJvcGVydGllcyA9IE9iamVjdC5rZXlzKGZpbmFsKTtcblxuICAgIHZhciB1cGRhdGVTdHlsZXMgPSAoKSA9PiB7XG4gICAgICBsZXQgcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChzLmdldFByb3BlcnR5VmFsdWUuYmluZChzKSk7XG4gICAgICBzID0gZWwub2Zmc2V0SGVpZ2h0O1xuICAgIH07XG5cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgc3RvcDogKG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICB0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdmFyIGsgPSBNYXRoLm1pbigxLCAoKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHN0YXJ0KSAvIGR1cmF0aW9uKTtcbiAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGkgPT4ge1xuICAgICAgICAgIGVsLnN0eWxlW2ldID0gKDEgLSBrKSAqIGluaXRpYWxbaV0gKyBrICogZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcblxuICAgICAgICBpZiAob3B0aW9ucy5zdG9wTmV4dCkge1xuICAgICAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RvcHBlZCkge1xuICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgIG5leHQgJiYgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgdGhlbjogKGNiKSA9PiB7XG4gICAgICAgIG5leHQgPSBjYjtcbiAgICAgICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHNwZWVkOiAobmV3RHVyYXRpb24pID0+IHtcbiAgICAgICAgaWYgKGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICAgICAgICBuZXdEdXJhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cbiAgICAgICAgICBjb25zdCBwYXNzZWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQ7XG4gICAgICAgICAgY29uc3QgIGsgPSBwYXNzZWQgLyBkdXJhdGlvbjtcbiAgICAgICAgICBjb25zdCByZW1haW5pbmcgPSBuZXdEdXJhdGlvbiAqICgxIC0gayk7XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICBlbC5zdHlsZVtpXSA9ICgxIC0gaykgKiBpbml0aWFsW2ldICsgayAqIGZpbmFsW2ldICsgKGkgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHVwZGF0ZVN0eWxlcygpO1xuXG4gICAgICAgICAgc3RhcnQgPSBlbC5zcGVlZFVwVGltZTtcbiAgICAgICAgICBkdXJhdGlvbiA9IHJlbWFpbmluZztcblxuICAgICAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uIC8gMTAwMCArICdzJztcblxuICAgICAgICAgIHByb3BlcnRpZXMuZm9yRWFjaChpID0+IHtcbiAgICAgICAgICAgIGVsLnN0eWxlW2ldID0gZmluYWxbaV0gKyAoaSA9PSAnb3BhY2l0eScgPyAnJyA6ICdweCcpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQocmVzdWx0LnN0b3AsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICBmaW5pc2g6IChtaWxsaXNlY29uZHMgPSA1MCkgPT4ge1xuICAgICAgICB2YXIgayA9ICgobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gc3RhcnQpIC8gZHVyYXRpb247XG5cbiAgICAgICAgcmVzdWx0LnNwZWVkKG1pbGxpc2Vjb25kcyAvICgxIC0gaykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IHN0b3BwZWQgfHwgaW50ZXJuYWwuY29uZmlnLmFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgcHJvcGVydGllcy5mb3JFYWNoKGUgPT4ge1xuICAgICAgY29uc3QgdiA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShlKSk7XG4gICAgICBpbml0aWFsW2VdID0gaXNOYU4odikgPyAwIDogdjtcbiAgICB9KTtcblxuXG4gICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICBlbC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSBwcm9wZXJ0aWVzLmpvaW4oJywnKTtcbiAgICAgIGVsLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uIC8gMTAwMCArICdzJztcblxuICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICBlbC5zdHlsZVtlXSA9IGZpbmFsW2VdICsgKGUgPT0gJ29wYWNpdHknID8gJycgOiAncHgnKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc3VsdC5zdG9wLCBkdXJhdGlvbik7XG4gICAgdGhpcy5fb25TdG9wQW5pbWF0aW9ucyhlbCwgcmVzdWx0LnN0b3ApO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5faW5kZXggPSAwO1xuICB9XG5cbiAgX29uU3RvcEFuaW1hdGlvbnMoZWwsIGxpc3RlbmVyKSB7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgdmFyIGkgPSB0aGlzLl9pbmRleCsrO1xuICAgIHF1ZXVlW2VsXSA9IHF1ZXVlW2VsXSB8fCBbXTtcbiAgICBxdWV1ZVtlbF1baV0gPSAob3B0aW9ucykgPT4ge1xuICAgICAgZGVsZXRlIHF1ZXVlW2VsXVtpXTtcbiAgICAgIGlmIChxdWV1ZVtlbF0gJiYgcXVldWVbZWxdLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBxdWV1ZVtlbF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdGVuZXIob3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZXRob2Qgc3RvcEFuaW1hdGlvbnNcbiAgKiBAZGVzYyBzdG9wcyBhY3RpdmUgYW5pbWF0aW9ucyBvbiBhIHNwZWNpZmllZCBlbGVtZW50XG4gICogQHBhcmFtIHtFbGVtZW50fEFycmF5fSBlbGVtZW50IC0gZWxlbWVudCBvciBhcnJheSBvZiBlbGVtZW50c1xuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV1cbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnN0b3BOZXh0XSAtIHRoZSBjYWxsYmFja3MgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgd29uJ3QgYmUgY2FsbGVkIGlmIHRoaXMgb3B0aW9uIGlzIHRydWVcbiAgKi9cbiAgc3RvcEFuaW1hdGlvbnMoZWwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVsKSkge1xuICAgICAgcmV0dXJuIGVsLmZvckVhY2goZWwgPT4ge1xuICAgICAgICB0aGlzLnN0b3BBbmltYXRpb25zKGVsLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgICh0aGlzLl9xdWV1ZVtlbF0gfHwgW10pLmZvckVhY2goZSA9PiB7IGUob3B0aW9ucyB8fCB7fSk7IH0pO1xuICB9XG5cbiAgLyoqXG4gICogQG1ldGhvZCBzdG9wQWxsXG4gICogQGRlc2Mgc3RvcHMgYWxsIGFjdGl2ZSBhbmltYXRpb25zXG4gICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XVxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc3RvcE5leHRdIC0gdGhlIGNhbGxiYWNrcyBhZnRlciB0aGUgYW5pbWF0aW9ucyB3b24ndCBiZSBjYWxsZWQgaWYgdGhpcyBvcHRpb24gaXMgdHJ1ZVxuICAqL1xuICBzdG9wQWxsKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc3RvcEFuaW1hdGlvbnMoT2JqZWN0LmtleXModGhpcy5fcXVldWUpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZXRob2QgZmFkZVxuICAqIEBkZXNjIGZhZGVzIHRoZSBlbGVtZW50IChzaG9ydCB2ZXJzaW9uIGZvciBhbmltYXRlKGVsLCB7b3BhY2l0eTogMH0pKVxuICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb249MjAwXVxuICAqL1xuICBmYWRlKGVsLCBkdXJhdGlvbiA9IDIwMCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoZWwsIHtvcGFjaXR5OiAwfSwgZHVyYXRpb24pO1xuICB9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0b3JDU1M7XG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi8uLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3ItY3NzJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAncmlwcGxlJztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdyaXBwbGUtLSonLFxuICAnLnJpcHBsZV9fd2F2ZSc6ICdyaXBwbGUtLSpfX3dhdmUnLFxuICAnLnJpcHBsZV9fYmFja2dyb3VuZCc6ICdyaXBwbGUtLSpfX2JhY2tncm91bmQnLFxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtcmlwcGxlXG4gKiBAY2F0ZWdvcnkgdmlzdWFsXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEFkZHMgYSBNYXRlcmlhbCBEZXNpZ24gXCJyaXBwbGVcIiBlZmZlY3QgdG8gYW4gZWxlbWVudC4gVGhlIHJpcHBsZSBlZmZlY3Qgd2lsbCBzcHJlYWQgZnJvbSB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIHVzZXIgdGFwcy5cbiAqXG4gKiAgICAgU29tZSBlbGVtZW50cyBzdWNoIGFzIGA8b25zLWJ1dHRvbj5gIGFuZCBgPG9ucy1mYWI+YCAgc3VwcG9ydCBhIGByaXBwbGVgIGF0dHJpYnV0ZS5cbiAqICAgWy9lbl1cbiAqICAgW2phXeODnuODhuODquOCouODq+ODh+OCtuOCpOODs+OBruODquODg+ODl+ODq+WKueaenOOCkkRPTeimgee0oOOBq+i/veWKoOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiB3S1FXZFpcbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS9yaXBwbGVcbiAqIEBtb2RpZmllciBsaWdodC1ncmF5XG4gKiAgIFtlbl1DaGFuZ2UgdGhlIGNvbG9yIG9mIGVmZmVjdHMgdG8gbGlnaHQgZ3JheS5bL2VuXVxuICogICBbamFd44Ko44OV44Kn44Kv44OI44Gu6Imy44GM5piO44KL44GE54Gw6Imy44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjY3Jvc3MtcGxhdGZvcm0tc3R5bGluZy1hdXRvc3R5bGluZ1xuICogIFtlbl1Dcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1cbiAqICBbamFdQ3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPGRpdiBjbGFzcz1cIm15LWRpdlwiPlxuICogIDxvbnMtcmlwcGxlPjwvb25zLXJpcHBsZT5cbiAqIDwvZGl2PlxuICpcbiAqIEBleGFtcGxlXG4gKiA8b25zLWJ1dHRvbiByaXBwbGU+Q2xpY2sgbWUhPC9vbnMtYnV0dG9uPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSaXBwbGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGNvbG9yXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Db2xvciBvZiB0aGUgcmlwcGxlIGVmZmVjdC5bL2VuXVxuICAgKiAgIFtqYV3jg6rjg4Pjg5fjg6vjgqjjg5Xjgqfjgq/jg4jjga7oibLjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHJpcHBsZSBlZmZlY3QuWy9lbl1cbiAgICogICBbamFd44Ko44OV44Kn44Kv44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYmFja2dyb3VuZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ29sb3Igb2YgdGhlIGJhY2tncm91bmQuWy9lbl1cbiAgICogICBbamFd6IOM5pmv44Gu6Imy44KS6Kit5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2l6ZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2l6aW5nIG9mIHRoZSB3YXZlIG9uIHJpcHBsZSBlZmZlY3QuIFNldCBcImNvdmVyXCIgb3IgXCJjb250YWluXCIuIERlZmF1bHQgaXMgXCJjb3ZlclwiLlsvZW5dXG4gICAqICAgW2phXeOCqOODleOCp+OCr+ODiOOBruOCteOCpOOCuuOCkuaMh+WumuOBl+OBvuOBmeOAglwiY292ZXJcIuOCguOBl+OBj+OBr1wiY29udGFpblwi44KS5oyH5a6a44GX44G+44GZ44CC44OH44OV44Kp44Or44OI44GvXCJjb3Zlclwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2VudGVyXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgcHJlc2VudHMsIGNoYW5nZSB0aGUgcG9zaXRpb24gb2Ygd2F2ZSBlZmZlY3QgdG8gY2VudGVyIG9mIHRoZSB0YXJnZXQgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjgpLoqK3lrprjgZnjgovjgajjgIHjgqjjg5Xjgqfjgq/jg4jjga7kvY3nva7jgYzopoHntKDjga7nnJ/jgpPkuK3jgYvjgonlp4vjgb7jgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0LCB0aGUgcmlwcGxlIGVmZmVjdCB3aWxsIGJlIGRpc2FibGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruWxnuaAp+OBjOioreWumuOBleOCjOOBn+WgtOWQiOOAgeODquODg+ODl+ODq+OCqOODleOCp+OCr+ODiOOBr+eEoeWKueOBq+OBquOCiuOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9vblRhcCA9IHRoaXMuX29uVGFwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Ib2xkID0gdGhpcy5fb25Ib2xkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25EcmFnU3RhcnQgPSB0aGlzLl9vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uUmVsZWFzZSA9IHRoaXMuX29uUmVsZWFzZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG5cbiAgICB0aGlzLl9hbmltYXRvciA9IG5ldyBBbmltYXRvcigpO1xuXG4gICAgWydjb2xvcicsICdjZW50ZXInLCAnc3RhcnQtcmFkaXVzJywgJ2JhY2tncm91bmQnLCAnbW9kaWZpZXInXS5mb3JFYWNoKGUgPT4ge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZSwgbnVsbCwgdGhpcy5nZXRBdHRyaWJ1dGUoZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgdGhpcy5fd2F2ZSA9IHRoaXMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmlwcGxlX193YXZlJylbMF07XG4gICAgdGhpcy5fYmFja2dyb3VuZCA9IHRoaXMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmlwcGxlX19iYWNrZ3JvdW5kJylbMF07XG5cbiAgICBpZiAoISh0aGlzLl9iYWNrZ3JvdW5kICYmIHRoaXMuX3dhdmUpKSB7XG4gICAgICB0aGlzLl93YXZlID0gdXRpbC5jcmVhdGUoJy5yaXBwbGVfX3dhdmUnKTtcbiAgICAgIHRoaXMuX2JhY2tncm91bmQgPSB1dGlsLmNyZWF0ZSgnLnJpcHBsZV9fYmFja2dyb3VuZCcpO1xuXG4gICAgICB0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3dhdmUpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLl9iYWNrZ3JvdW5kKTtcbiAgICB9XG5cbiAgICBNb2RpZmllclV0aWwuaW5pdE1vZGlmaWVyKHRoaXMsIHNjaGVtZSk7XG4gIH1cblxuICBfZ2V0RWZmZWN0U2l6ZSgpIHtcbiAgICBjb25zdCBzaXplcyA9IFsnY292ZXInLCAnY29udGFpbiddO1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnc2l6ZScpKSB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NpemUnKTtcbiAgICAgIGlmIChzaXplcy5pbmRleE9mKHNpemUpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJ2NvdmVyJztcbiAgfVxuXG4gIF9jYWxjdWxhdGVDb29yZHMoZSkge1xuICAgIGxldCB4LCB5LCBoLCB3LCByO1xuICAgIGNvbnN0IGIgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLl9nZXRFZmZlY3RTaXplKCk7XG4gICAgY29uc3QgZXJyb3IgPSAoKSA9PiB1dGlsLnRocm93KCdSaXBwbGUgaW52YWxpZCBzdGF0ZScpO1xuXG4gICAgaWYgKHRoaXMuX2NlbnRlcikge1xuICAgICAgeCA9IGIud2lkdGggLyAyO1xuICAgICAgeSA9IGIuaGVpZ2h0IC8gMjtcblxuICAgICAgaWYgKHNpemUgPT09ICdjb3ZlcicpIHtcbiAgICAgICAgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICAgIHIgPSBNYXRoLm1pbih4LCB5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAodHlwZW9mIGUuY2xpZW50WCA9PT0gJ251bWJlcicgPyBlLmNsaWVudFggOiBlLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgpIC0gYi5sZWZ0O1xuICAgICAgeSA9ICh0eXBlb2YgZS5jbGllbnRZID09PSAnbnVtYmVyJyA/IGUuY2xpZW50WSA6IGUuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSkgLSBiLnRvcDtcbiAgICAgIGggPSBNYXRoLm1heCh5LCBiLmhlaWdodCAtIHkpO1xuICAgICAgdyA9IE1hdGgubWF4KHgsIGIud2lkdGggLSB4KTtcblxuICAgICAgaWYgKHNpemUgPT09ICdjb3ZlcicpIHtcbiAgICAgICAgciA9IE1hdGguc3FydChoICogaCArIHcgKiB3KTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gJ2NvbnRhaW4nKSB7XG4gICAgICAgIHIgPSBNYXRoLm1pbihNYXRoLnJvdW5kKGggLyAyKSwgTWF0aC5yb3VuZCh3IC8gMikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge3gsIHksIHJ9O1xuICB9XG5cbiAgX3JpcHBsZUFuaW1hdGlvbihlLCBkdXJhdGlvbiA9IDMwMCkge1xuICAgIGNvbnN0IHtfYW5pbWF0b3IsIF93YXZlLCBfYmFja2dyb3VuZCwgX21pblJ9ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeSwgcn0gPSB0aGlzLl9jYWxjdWxhdGVDb29yZHMoZSk7XG5cbiAgICBfYW5pbWF0b3Iuc3RvcEFsbCh7c3RvcE5leHQ6IDF9KTtcbiAgICBfYW5pbWF0b3IuYW5pbWF0ZShfYmFja2dyb3VuZCwge29wYWNpdHk6IDF9LCBkdXJhdGlvbik7XG5cbiAgICB1dGlsLmV4dGVuZChfd2F2ZS5zdHlsZSwge1xuICAgICAgb3BhY2l0eTogMSxcbiAgICAgIHRvcDogeSAtIF9taW5SICsgJ3B4JyxcbiAgICAgIGxlZnQ6IHggLSBfbWluUiArICdweCcsXG4gICAgICB3aWR0aDogMiAqIF9taW5SICsgJ3B4JyxcbiAgICAgIGhlaWdodDogMiAqIF9taW5SICsgJ3B4J1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9hbmltYXRvci5hbmltYXRlKF93YXZlLCB7XG4gICAgICB0b3A6IHkgLSByLFxuICAgICAgbGVmdDogeCAtIHIsXG4gICAgICBoZWlnaHQ6IDIgKiByLFxuICAgICAgd2lkdGg6IDIgKiByXG4gICAgfSwgZHVyYXRpb24pO1xuICB9XG5cbiAgX3VwZGF0ZVBhcmVudCgpIHtcbiAgICBpZiAoIXRoaXMuX3BhcmVudFVwZGF0ZWQgJiYgdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5wYXJlbnROb2RlKTtcbiAgICAgIGlmIChjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICB9XG4gICAgICB0aGlzLl9wYXJlbnRVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBfb25UYXAoZSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCAmJiAhZS5yaXBwbGUpIHtcbiAgICAgIGUucmlwcGxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZVBhcmVudCgpO1xuICAgICAgdGhpcy5fcmlwcGxlQW5pbWF0aW9uKGUuZ2VzdHVyZS5zcmNFdmVudCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fd2F2ZSk7XG4gICAgICAgIHRoaXMuX2FuaW1hdG9yLmZhZGUodGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfb25Ib2xkKGUpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgIWUucmlwcGxlKSB7XG4gICAgICBlLnJpcHBsZSA9IHRydWU7XG4gICAgICB0aGlzLl91cGRhdGVQYXJlbnQoKTtcbiAgICAgIHRoaXMuX2hvbGRpbmcgPSB0aGlzLl9yaXBwbGVBbmltYXRpb24oZS5nZXN0dXJlLnNyY0V2ZW50LCAyMDAwKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9vblJlbGVhc2UpO1xuICAgIH1cbiAgfVxuXG4gIF9vblJlbGVhc2UoZSkge1xuICAgIGlmICh0aGlzLl9ob2xkaW5nICYmICFlLnJpcHBsZSkge1xuICAgICAgZS5yaXBwbGUgPSB0cnVlO1xuICAgICAgdGhpcy5faG9sZGluZy5zcGVlZCgzMDApLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9hbmltYXRvci5zdG9wQWxsKHtzdG9wTmV4dDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLl9hbmltYXRvci5mYWRlKHRoaXMuX3dhdmUpO1xuICAgICAgICB0aGlzLl9hbmltYXRvci5mYWRlKHRoaXMuX2JhY2tncm91bmQpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2hvbGRpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZWxlYXNlJywgdGhpcy5fb25SZWxlYXNlKTtcbiAgfVxuXG4gIF9vbkRyYWdTdGFydChlKSB7XG4gICAgaWYgKHRoaXMuX2hvbGRpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vblJlbGVhc2UoZSk7XG4gICAgfVxuICAgIGlmIChbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGUuZ2VzdHVyZS5kaXJlY3Rpb24pICE9IC0xKSB7XG4gICAgICB0aGlzLl9vblRhcChlKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9wYXJlbnROb2RlID0gdGhpcy5wYXJlbnROb2RlO1xuXG4gICAgaWYgKGludGVybmFsLmNvbmZpZy5hbmltYXRpb25zRGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuX29uVGFwKTtcbiAgICAgIHRoaXMuX3BhcmVudE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XG4gICAgICB0aGlzLl9wYXJlbnROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuX29uRHJhZ1N0YXJ0KTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb25zdCBwbiA9IHRoaXMuX3BhcmVudE5vZGUgfHwgdGhpcy5wYXJlbnROb2RlO1xuICAgIHBuLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuX29uVGFwKTtcbiAgICBwbi5yZW1vdmVFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICBwbi5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydzdGFydC1yYWRpdXMnLCAnY29sb3InLCAnYmFja2dyb3VuZCcsICdjZW50ZXInLCAnY2xhc3MnLCAnbW9kaWZpZXInXTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG5cbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdGFydC1yYWRpdXMnOlxuICAgICAgICB0aGlzLl9taW5SID0gTWF0aC5tYXgoMCwgcGFyc2VGbG9hdChjdXJyZW50KSB8fCAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fd2F2ZS5zdHlsZS5iYWNrZ3JvdW5kID0gY3VycmVudDtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ2JhY2tncm91bmQnKSkge1xuICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSBjdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdiYWNrZ3JvdW5kJzpcbiAgICAgICAgaWYgKGN1cnJlbnQgfHwgbGFzdCkge1xuICAgICAgICAgIGlmIChjdXJyZW50ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmQgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9iYWNrZ3JvdW5kLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2JhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgIGlmIChuYW1lID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRoaXMuX2NlbnRlciA9IGN1cnJlbnQgIT0gbnVsbCAmJiBjdXJyZW50ICE9ICdmYWxzZSc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnZGlzYWJsZWQnLCB2YWx1ZSk7XG4gIH1cblxuICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlJpcHBsZSA9IFJpcHBsZUVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1yaXBwbGUnLCBSaXBwbGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEBlbGVtZW50IG9ucy1yb3dcbiAqIEBjYXRlZ29yeSBncmlkXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSByb3cgaW4gdGhlIGdyaWQgc3lzdGVtLiBVc2Ugd2l0aCBgPG9ucy1jb2w+YCB0byBsYXlvdXQgY29tcG9uZW50cy5bL2VuXVxuICogICBbamFd44Kw44Oq44OD44OJ44K344K544OG44Og44Gr44Gm6KGM44KS5a6a576p44GX44G+44GZ44CCb25zLWNvbOOBqOOBqOOCguOBq+S9v+eUqOOBl+OAgeOCs+ODs+ODneODvOODjeODs+ODiOOBrumFjee9ruOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBHZ3VqQyB7d2lkZX1cbiAqIEBndWlkZSB0aGVtaW5nLmh0bWxcbiAqICAgW2VuXUxheW91dGluZyBndWlkZVsvZW5dXG4gKiAgIFtqYV3jg6zjgqTjgqLjgqbjg4joqr/mlbRbL2phXVxuICogQHNlZWFsc28gb25zLWNvbFxuICogICBbZW5dVGhlIGA8b25zLWNvbD5gIGNvbXBvbmVudCBpcyB1c2VkIGFzIGNoaWxkcmVuIG9mIGA8b25zLXJvdz5gLlsvZW5dXG4gKiAgIFtqYV1vbnMtY29s44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBub3RlXG4gKiAgIFtlbl1Gb3IgQW5kcm9pZCA0LjMgYW5kIGVhcmxpZXIsIGFuZCBpT1M2IGFuZCBlYXJsaWVyLCB3aGVuIHVzaW5nIG1peGVkIGFsaWdubWVudCB3aXRoIG9ucy1yb3cgYW5kIG9ucy1jb2wsIHRoZXkgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5LiBZb3UgY2FuIHVzZSBvbmx5IG9uZSB2ZXJ0aWNhbC1hbGlnbi5bL2VuXVxuICogICBbamFdQW5kcm9pZCA0LjPku6XliY3jgIHjgoLjgZfjgY/jga9pT1MgNuS7peWJjeOBrk9T44Gu5aC05ZCI44CBb25zLXJvd+OBqG9ucy1jb2zjgpLntYTjgb/lkIjjgo/jgZvjgabjgZ3jgozjgZ7jgozjga5vbnMtY29s6KaB57Sg44GudmVydGljYWwtYWxpZ27lsZ7mgKfjga7lgKTjgavliKXjgIXjga7lgKTjgpLmjIflrprjgZnjgovjgajjgIHmj4/nlLvjgYzltKnjgozjgovloLTlkIjjgYzjgYLjgorjgb7jgZnjgIJ2ZXJ0aWNhbC1hbGlnbuWxnuaAp+OBruWApOOBq+OBr+S4gOOBpOOBruWApOOBoOOBkeOCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1yb3c+XG4gKiAgIDxvbnMtY29sIHdpZHRoPVwiNTBweFwiPjxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+PC9vbnMtY29sPlxuICogICA8b25zLWNvbD5UZXh0PC9vbnMtY29sPlxuICogPC9vbnMtcm93PlxuICovXG5cbi8qKlxuICogQGF0dHJpYnV0ZSB2ZXJ0aWNhbC1hbGlnblxuICogQHR5cGUge1N0cmluZ31cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dU2hvcnQgaGFuZCBhdHRyaWJ1dGUgZm9yIGFsaWduaW5nIHZlcnRpY2FsbHkuIFZhbGlkIHZhbHVlcyBhcmUgdG9wLCBib3R0b20sIGFuZCBjZW50ZXIuWy9lbl1cbiAqICAgW2phXee4puOBq+aVtOWIl+OBmeOCi+OBn+OCgeOBq+aMh+WumuOBl+OBvuOBmeOAgnRvcOOAgWJvdHRvbeOAgWNlbnRlcuOBruOBhOOBmuOCjOOBi+OCkuaMh+WumuOBp+OBjeOBvuOBmeOAglsvamFdXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm93RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcbn1cblxub25zRWxlbWVudHMuUm93ID0gUm93RWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXJvdycsIFJvd0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdzZWdtZW50JztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzZWdtZW50LS0qJyxcbiAgJy5zZWdtZW50X19pdGVtJzogJ3NlZ21lbnQtLSpfX2l0ZW0nLFxuICAnLnNlZ21lbnRfX2lucHV0JzogJ3NlZ21lbnQtLSpfX2lucHV0JyxcbiAgJy5zZWdtZW50X19idXR0b24nOiAnc2VnbWVudC0tKl9fYnV0dG9uJ1xufTtcblxuY29uc3QgZ2VuZXJhdGVJZCA9ICgoKSA9PiB7XG4gIGxldCBpID0gMDtcbiAgcmV0dXJuICgpID0+ICdvbnMtc2VnbWVudC1nZW4tJyArIChpKyspO1xufSkoKTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc2VnbWVudFxuICogQGNhdGVnb3J5IGNvbnRyb2xcbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogICBbZW5dTWF0ZXJpYWwgRGVzaWduIHNlZ21lbnRbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgU2VnbWVudCBjb21wb25lbnQuIFVzZSB0aGlzIGNvbXBvbmVudCB0byBoYXZlIGEgYnV0dG9uIGJhciB3aXRoIGF1dG9tYXRpYyBzdHlsZXMgdGhhdCBzd2l0Y2ggb24gY2xpY2sgb2YgYW5vdGhlciBidXR0b24uXG4gKlxuICogICAgIFdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIHNlZ21lbnQgb24gQW5kcm9pZC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NlZ21lbnRcbiAqIEBndWlkZSB0aGVtaW5nLmh0bWwjbW9kaWZpZXJzIFtlbl1Nb3JlIGRldGFpbHMgYWJvdXQgdGhlIGBtb2RpZmllcmAgYXR0cmlidXRlWy9lbl1bamFdbW9kaWZpZXLlsZ7mgKfjga7kvb/jgYTmlrlbL2phXVxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNjcm9zcy1wbGF0Zm9ybS1zdHlsaW5nLWF1dG9zdHlsaW5nIFtlbl1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9lbl1bamFdSW5mb3JtYXRpb24gYWJvdXQgY3Jvc3MgcGxhdGZvcm0gc3R5bGluZ1svamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zZWdtZW50PlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAxPC9vbnMtYnV0dG9uPlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAyPC9vbnMtYnV0dG9uPlxuICogICA8b25zLWJ1dHRvbj5MYWJlbCAzPC9vbnMtYnV0dG9uPlxuICogPC9vbnMtc2VnbWVudD5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWdtZW50RWxlbWVudCBleHRlbmRzIEJhc2VFbGVtZW50IHtcblxuICAvKipcbiAgICogQGV2ZW50IHBvc3RjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVzIGFmdGVyIHRoZSBhY3RpdmUgYnV0dG9uIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dVGFwcGVkIGJ1dHRvbiBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2VnbWVudEl0ZW1cbiAgICogICBbZW5dU2VnbWVudCBpdGVtIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtb2RpZmllclxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1UaGUgYXBwZWFyYW5jZSBvZiB0aGUgc2VnbWVudC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhYmJhci1pZFxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSUQgb2YgdGhlIHRhYmJhciBlbGVtZW50IHRvIFwiY29ubmVjdFwiIHRvIHRoZSBzZWdtZW50LiBNdXN0IGJlIGluc2lkZSB0aGUgc2FtZSBwYWdlLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlLWluZGV4XG4gICAqIEBpbml0b25seVxuICAgKiBAZGVmYXVsdCAwXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUluZGV4IG9mIHRoZSBmaXJzdCBhY3RpdmUgYnV0dG9uLCBvbmx5IHdvcmtzIGlmIHRoZXJlIGlzIG5vIGNvbm5lY3RlZCB0YWJiYXIgKGluIHdoaWNoIGNhc2UgdGhlIGFjdGl2ZSB0YWIgc2V0cyB0aGUgYWN0aXZlIGJ1dHRvbikuWy9lbl1cbiAgICogIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBkaXNhYmxlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSBpZiBzZWdtZW50IHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9zZWdtZW50SWQgPSBnZW5lcmF0ZUlkKCk7XG4gICAgdGhpcy5fdGFiYmFyID0gbnVsbDtcbiAgICB0aGlzLl9vbkNoYW5nZSA9IHRoaXMuX29uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25UYWJiYXJQcmVDaGFuZ2UgPSB0aGlzLl9vblRhYmJhclByZUNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKVxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IHRoaXMuX3RhYmJhciA/IHRoaXMuX3RhYmJhci5nZXRBY3RpdmVUYWJJbmRleCgpIDogdGhpcy5nZXRBY3RpdmVCdXR0b25JbmRleCgpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChkZWZhdWx0Q2xhc3NOYW1lKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleC0tKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpcy5jaGlsZHJlbltpbmRleF07XG4gICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3NlZ21lbnRfX2l0ZW0nKTtcblxuICAgICAgY29uc3QgaW5wdXQgPSB1dGlsLmZpbmRDaGlsZChpdGVtLCAnLnNlZ21lbnRfX2lucHV0JykgfHwgdXRpbC5jcmVhdGUoJ2lucHV0LnNlZ21lbnRfX2lucHV0Jyk7XG4gICAgICBpbnB1dC50eXBlID0gJ3JhZGlvJztcbiAgICAgIGlucHV0LnZhbHVlID0gaW5kZXg7XG4gICAgICBpbnB1dC5uYW1lID0gaW5wdXQubmFtZSB8fCB0aGlzLl9zZWdtZW50SWQ7XG4gICAgICBpbnB1dC5jaGVja2VkID0gIXRoaXMuaGFzQXR0cmlidXRlKCd0YWJiYXItaWQnKSAmJiBpbmRleCA9PT0gKHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUtaW5kZXgnKSkgfHwgMCk7XG5cbiAgICAgIGNvbnN0IGJ1dHRvbiA9IHV0aWwuZmluZENoaWxkKGl0ZW0sICcuc2VnbWVudF9fYnV0dG9uJykgfHwgdXRpbC5jcmVhdGUoJy5zZWdtZW50X19idXR0b24nKTtcbiAgICAgIGlmIChidXR0b24ucGFyZW50RWxlbWVudCAhPT0gaXRlbSkge1xuICAgICAgICB3aGlsZSAoaXRlbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGl0ZW0uZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaXRlbS5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICBpdGVtLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgfVxuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCd0YWJiYXItaWQnKSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcbiAgICAgICAgdGhpcy5fdGFiYmFyID0gcGFnZSAmJiBwYWdlLnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmJhci1pZCcpKTtcbiAgICAgICAgaWYgKCF0aGlzLl90YWJiYXIgfHwgdGhpcy5fdGFiYmFyLnRhZ05hbWUgIT09ICdPTlMtVEFCQkFSJykge1xuICAgICAgICAgIHV0aWwudGhyb3coYE5vIHRhYmJhciB3aXRoIGlkICR7dGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmJhci1pZCcpfSB3YXMgZm91bmQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90YWJiYXIuc2V0QXR0cmlidXRlKCdoaWRlLXRhYnMnLCAnJyk7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLl9zZXRDaGVja2VkKHRoaXMuX3RhYmJhci5nZXRBY3RpdmVUYWJJbmRleCgpKSk7XG5cbiAgICAgICAgdGhpcy5fdGFiYmFyLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZWNoYW5nZScsIHRoaXMuX29uVGFiYmFyUHJlQ2hhbmdlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl90YWJiYXIpIHtcbiAgICAgICAgdGhpcy5fdGFiYmFyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3ByZWNoYW5nZScsIHRoaXMuX29uVGFiYmFyUHJlQ2hhbmdlKTtcbiAgICAgICAgdGhpcy5fdGFiYmFyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgfVxuXG4gIF9zZXRDaGVja2VkKGluZGV4KSB7XG4gICAgdGhpcy5jaGlsZHJlbltpbmRleF0uZmlyc3RFbGVtZW50Q2hpbGQuY2hlY2tlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRBY3RpdmVCdXR0b25cbiAgICogQHNpZ25hdHVyZSBzZXRBY3RpdmVCdXR0b24oaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXUJ1dHRvbiBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QsIHdvcmtzIG9ubHkgaWYgdGhlcmUgaXMgYSBjb25uZWN0ZWQgdGFiYmFyLiBTdXBwb3J0cyB0aGUgc2FtZSBvcHRpb25zIGFzIGBvbnMtdGFiYmFyYCdzIGBzZXRBY3RpdmVUYWJgIG1ldGhvZC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTWFrZSBidXR0b24gd2l0aCB0aGUgc3BlY2lmaWVkIGluZGV4IGFjdGl2ZS4gSWYgdGhlcmUgaXMgYSBjb25uZWN0ZWQgdGFiYmFyIGl0IHNob3dzIHRoZSBjb3JyZXNwb25kaW5nIHRhYiBwYWdlLiBJbiB0aGlzIGNhc2UgYW5pbWF0aW9ucyBhbmQgdGhlaXIgb3B0aW9ucyBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSBzZWNvbmQgcGFyYW1ldGVyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzZWxlY3RlZCBpbmRleCBvciB0byB0aGUgbmV3IHBhZ2UgZWxlbWVudCBpZiB0aGVyZSBpcyBhIGNvbm5lY3RlZCB0YWJiYXIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldEFjdGl2ZUJ1dHRvbihpbmRleCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzLl90YWJiYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl90YWJiYXIuc2V0QWN0aXZlVGFiKGluZGV4LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRDaGVja2VkKGluZGV4KTtcbiAgICB0aGlzLl9wb3N0Q2hhbmdlKGluZGV4KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGluZGV4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZUJ1dHRvbkluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlQnV0dG9uSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBidXR0b24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgYnV0dG9uIGluZGV4IG9mIGN1cnJlbnQgYWN0aXZlIGJ1dHRvbi4gSWYgYWN0aXZlIGJ1dHRvbiBpcyBub3QgZm91bmQsIHJldHVybnMgLTEuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldEFjdGl2ZUJ1dHRvbkluZGV4KCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7IC8vIEFycmF5LmZpbmRJbmRleFxuICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0uZmlyc3RFbGVtZW50Q2hpbGQuY2hlY2tlZCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgX29uQ2hhbmdlKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5fdGFiYmFyXG4gICAgICA/IHRoaXMuX3RhYmJhci5zZXRBY3RpdmVUYWIodGhpcy5nZXRBY3RpdmVCdXR0b25JbmRleCgpLCB7IHJlamVjdDogZmFsc2UgfSlcbiAgICAgIDogdGhpcy5fcG9zdENoYW5nZSh0aGlzLmdldEFjdGl2ZUJ1dHRvbkluZGV4KCkpO1xuICB9XG5cbiAgX29uVGFiYmFyUHJlQ2hhbmdlKGV2ZW50KSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGlmICghZXZlbnQuZGV0YWlsLmNhbmNlbGVkKSB7XG4gICAgICAgIHRoaXMuX3NldENoZWNrZWQoZXZlbnQuaW5kZXgpO1xuICAgICAgICB0aGlzLl9wb3N0Q2hhbmdlKGV2ZW50LmluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9wb3N0Q2hhbmdlKGluZGV4KSB7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0Y2hhbmdlJywge1xuICAgICAgaW5kZXgsXG4gICAgICBhY3RpdmVJbmRleDogaW5kZXgsXG4gICAgICBsYXN0QWN0aXZlSW5kZXg6IHRoaXMuX2xhc3RBY3RpdmVJbmRleCxcbiAgICAgIHNlZ21lbnRJdGVtOiB0aGlzLmNoaWxkcmVuW2luZGV4XVxuICAgIH0pO1xuICAgIHRoaXMuX2xhc3RBY3RpdmVJbmRleCA9IGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIHNlZ21lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICB9XG5cbiAgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2NsYXNzJywgJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgZXZlbnRzKCkge1xuICAgIHJldHVybiBbJ3Bvc3RjaGFuZ2UnXTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5TZWdtZW50ID0gU2VnbWVudEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zZWdtZW50JywgU2VnbWVudEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3NlbGVjdC0qIHNlbGVjdC0tKicsXG4gICcuc2VsZWN0LWlucHV0JzogJ3NlbGVjdC1pbnB1dC0tKidcbn07XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnc2VsZWN0JztcblxuY29uc3QgSU5QVVRfQVRUUklCVVRFUyA9IFtcbiAgJ2F1dG9mb2N1cycsXG4gICdkaXNhYmxlZCcsXG4gICdmb3JtJyxcbiAgJ211bHRpcGxlJyxcbiAgJ25hbWUnLFxuICAncmVxdWlyZWQnLFxuICAnc2l6ZSdcbl07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNlbGVjdFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBtb2RpZmllciBtYXRlcmlhbFxuICogIFtlbl1EaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBzZWxlY3QgaW5wdXQuWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB1bmRlcmJhclxuICogIFtlbl1EaXNwbGF5cyBhIGhvcml6b250YWwgbGluZSB1bmRlcm5lYXRoIGEgc2VsZWN0IGlucHV0LlsvZW5dXG4gKiAgW2phXVsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFNlbGVjdCBjb21wb25lbnQuIElmIHlvdSB3YW50IHRvIHBsYWNlIGEgc2VsZWN0IHdpdGggYW4gSUQgb2YgYG15LWlkYCBvbiBhIHBhZ2UsIHVzZSBgPG9ucy1zZWxlY3Qgc2VsZWN0LWlkPVwibXktaWRcIj5gLlxuICpcbiAqICAgICBUaGUgY29tcG9uZW50IHdpbGwgYXV0b21hdGljYWxseSBkaXNwbGF5IGFzIGEgTWF0ZXJpYWwgRGVzaWduIHNlbGVjdCBvbiBBbmRyb2lkLlxuICpcbiAqICAgICBNb3N0IGF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYSBub3JtYWwgYDxzZWxlY3Q+YCBlbGVtZW50IGNhbiBhbHNvIGJlIHVzZWQgb24gdGhlIGA8b25zLXNlbGVjdD5gIGVsZW1lbnQuXG4gKiAgIFsvZW5dXG4gKiAgIFtqYV3jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgpLooajnpLrjgZnjgovjgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJgc2VsZWN0YCDopoHntKDjgavkvb/nlKjjgafjgY3jgovlsZ7mgKfjga7lpJrjgY/jgYwgYG9ucy1zZWxlY3RgIOimgee0oOOBp+OCguWIqeeUqOOBp+OBjeOBvuOBmeOAglsvamFdXG4gKiBAY29kZXBlbiBoTGF5eFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NlbGVjdFxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZ3VpZGUgdGhlbWluZy5odG1sI2Nyb3NzLXBsYXRmb3JtLXN0eWxpbmctYXV0b3N0eWxpbmcgW2VuXUluZm9ybWF0aW9uIGFib3V0IGNyb3NzIHBsYXRmb3JtIHN0eWxpbmdbL2VuXVtqYV1JbmZvcm1hdGlvbiBhYm91dCBjcm9zcyBwbGF0Zm9ybSBzdHlsaW5nWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXNlbGVjdD5cbiAqICAgPG9wdGlvbiB2YWx1ZT1cIjFcIj4xPC9vcHRpb24+XG4gKiAgIDxvcHRpb24gdmFsdWU9XCIyXCI+Mm5kPC9vcHRpb24+XG4gKiAgIDxvcHRpb24gdmFsdWU9XCIzXCI+M3JkIG9wdGlvbjwvb3B0aW9uPlxuICogPC9vbnMtc2VsZWN0PlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlbGVjdEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYXV0b2ZvY3VzXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1FbGVtZW50IGF1dG9tYXRpY2FsbHkgZ2FpbnMgZm9jdXMgb24gcGFnZSBsb2FkLlsvZW5dXG4gICAqICBbamFd44Oa44O844K444Ot44O844OJ5pmC44Gr44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544Gr44OV44Kp44O844Kr44K544GM56e744KL44KI44GG44Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIHNlbGVjdCBpbnB1dCBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544KS54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZm9ybVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQXNzb2NpYXRlIGEgc2VsZWN0IGVsZW1lbnQgdG8gYW4gZXhpc3RpbmcgZm9ybSBvbiB0aGUgcGFnZSwgZXZlbiBpZiBub3QgbmVzdGVkLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOCkuOAgeaMh+WumuOBl+OBnyBgZm9ybWAg6KaB57Sg44Gr57SQ5LuY44GR44G+44GZ44CC44K744Os44Kv44OI44Oc44OD44Kv44K544KSIGBmb3JtYCDopoHntKDjga7lpJblgbTjgavphY3nva7jgZnjgovpmpvjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBtdWx0aXBsZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgZGVmaW5lZCwgbXVsdGlwbGUgb3B0aW9ucyBjYW4gYmUgc2VsZWN0ZWQgYXQgb25jZS5bL2VuXVxuICAgKiAgW2phXemBuOaKnuiCouOBruikh+aVsOmBuOaKnuOCkuacieWKueOBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG5hbWVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU5hbWUgdGhlIHNlbGVjdCBlbGVtZW50LCB1c2VmdWwgZm9yIGluc3RhbmNlIGlmIGl0IGlzIHBhcnQgb2YgYSBmb3JtLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruOCu+ODrOOCr+ODiOODnOODg+OCr+OCueOBruWQjeWJjeOCkuaMh+WumuOBl+OBvuOBmeOAgumAmuW4uCBgZm9ybWAg6KaB57Sg44Go5YWx44Gr5L2/55So44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmVxdWlyZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1NYWtlIHRoZSBzZWxlY3QgaW5wdXQgcmVxdWlyZWQgZm9yIHN1Ym1pdHRpbmcgdGhlIGZvcm0gaXQgaXMgcGFydCBvZi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgpLlhaXlipvlv4XpoIjjgavjgZnjgovloLTlkIjjgavmjIflrprjgZfjgb7jgZnjgILpgJrluLggYGZvcm1gIOimgee0oOOBqOWFseOBq+S9v+eUqOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHNlbGVjdC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSUQgZ2l2ZW4gdG8gdGhlIGlubmVyIHNlbGVjdCwgdXNlZnVsIGZvciBkeW5hbWljIG1hbmlwdWxhdGlvbi5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7jgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjgYzlhoXpg6jjgavmjIHjgaQgc2VsZWN0IOimgee0oOOBq+S4juOBiOOCiyBJRCDjgpLmjIflrprjgZfjgb7jgZnjgILjgrvjg6zjgq/jg4jjg5zjg4Pjgq/jgrnjga7lhoXlrrnjgpLli5XnmoTjgavlpInmm7TjgZnjgovlv4XopoHjgYzjgYLjgovloLTlkIjjgavkvb/nlKjjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzaXplXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0IDFcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhvdyBtYW55IG9wdGlvbnMgYXJlIGRpc3BsYXllZDsgaWYgdGhlcmUgYXJlIG1vcmUgdGhhbiB0aGUgc2l6ZSB0aGVuIGEgc2Nyb2xsIGFwcGVhcnMgdG8gbmF2aWdhdGUgdGhlbS5bL2VuXVxuICAgKiAgIFtqYV3kuIDluqbjgavooajnpLrjgZnjgovpgbjmip7ogqLjga7lgIvmlbDjgpLmjIflrprjgZfjgb7jgZnjgILpgbjmip7ogqLjgYzjgZPjga7lsZ7mgKfjgafmjIflrprjgZfjgZ/lgIvmlbDjgojjgorjgoLlpJrjgYTloLTlkIjjgIHjgrnjgq/jg63jg7zjg6vjgYzmnInlirnjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG5cbiAgICB0aGlzLl9kZXJpdmVHZXR0ZXJzKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydtb2RpZmllcicsICdjbGFzcycsIC4uLklOUFVUX0FUVFJJQlVURVNdO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoSU5QVVRfQVRUUklCVVRFUy5pbmRleE9mKG5hbWUpID49IDApIHtcbiAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVCb3VuZEF0dHJpYnV0ZXMoKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IF9zZWxlY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3Rvcignc2VsZWN0Jyk7XG4gIH1cblxuICBfdXBkYXRlQm91bmRBdHRyaWJ1dGVzKCkge1xuICAgIElOUFVUX0FUVFJJQlVURVMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdC5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGxlbmd0aFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dTnVtYmVyIG9mIG9wdGlvbnMgaW4gdGhlIHNlbGVjdCBib3guWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544Gr5ZCr44G+44KM44KL6YG45oqe6IKi44Gu5YCL5pWw44KS6L+U44GX44G+44GZ44CCIGBzZWxlY3RgIOimgee0oFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb3B0aW9uc1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2V2ZXJhbCBvcHRpb25zIGZvciBoYW5kbGluZyB0aGUgc2VsZWN0IERPTSBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44GT44Gu44K744Os44Kv44OI44Oc44OD44Kv44K544Gr5ZCr44G+44KM44KLIGBvcHRpb25gIOimgee0oOOBrumFjeWIl+OCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2VsZWN0ZWRJbmRleFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSW5kZXggb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBvcHRpb24uWy9lbl1cbiAgICogICBbamFd54++5Zyo6YG45oqe44GV44KM44Gm44GE44KL6YG45oqe6IKi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVmFsdWUgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBvcHRpb24uWy9lbl1cbiAgICogICBbamFd54++5Zyo6YG45oqe44GV44KM44Gm44GE44KL6YG45oqe6IKi44Gu5YCk44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuICAgIGNvbnN0IHNlbCA9IHRoaXMuX3NlbGVjdCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICBpZiAoIXNlbC5pZCAmJiB0aGlzLmhhc0F0dHJpYnV0ZSgnc2VsZWN0LWlkJykpIHtcbiAgICAgIHNlbC5pZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzZWxlY3QtaWQnKTtcbiAgICB9XG4gICAgc2VsLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdC1pbnB1dCcpO1xuICAgIGlmICghdGhpcy5fc2VsZWN0KSB7XG4gICAgICB1dGlsLmFycmF5RnJvbSh0aGlzLmNoaWxkTm9kZXMpLmZvckVhY2goZWxlbWVudCA9PiBzZWwuYXBwZW5kQ2hpbGQoZWxlbWVudCkpO1xuICAgICAgdGhpcy5hcHBlbmRDaGlsZChzZWwpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgc2NoZW1lKTtcbiAgfVxuXG4gIF9kZXJpdmVHZXR0ZXJzKCkge1xuICAgIFsnZGlzYWJsZWQnLCAnbGVuZ3RoJywgJ211bHRpcGxlJywgJ25hbWUnLCAnb3B0aW9ucycsICdzZWxlY3RlZEluZGV4JywgJ3NpemUnLCAndmFsdWUnLCAnZm9ybScsICd0eXBlJ11cbiAgICAgIC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6ICgpID0+IHRoaXMuX3NlbGVjdFtrZXldLFxuICAgICAgICAgIHNldDogWydmb3JtJywgJ3R5cGUnXS5pbmRleE9mKGtleSkgPT09IC0xXG4gICAgICAgICAgICA/IHZhbHVlID0+IGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9zZWxlY3Rba2V5XSA9IHZhbHVlKVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGFkZChvcHRpb24sIGluZGV4ID0gbnVsbCkge1xuICAgIHRoaXMuX3NlbGVjdC5hZGQob3B0aW9uLCBpbmRleCk7XG4gIH1cblxuICByZW1vdmUoaW5kZXgpIHtcbiAgICB0aGlzLl9zZWxlY3QucmVtb3ZlKGluZGV4KTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5TZWxlY3QgPSBTZWxlY3RFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc2VsZWN0JywgU2VsZWN0RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQmFzZUVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5cbmNvbnN0IGRlZmF1bHRDbGFzc05hbWUgPSAnZmFiIGZhYi0tbWluaSBzcGVlZC1kaWFsX19pdGVtJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ2ZhYi0tKiBzcGVlZC1kaWFsX19pdGVtLS0qJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BlZWQtZGlhbC1pdGVtXG4gKiBAY2F0ZWdvcnkgY29udHJvbFxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1cbiAqICAgICBUaGlzIGNvbXBvbmVudCBkaXNwbGF5cyB0aGUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIE1hdGVyaWFsIERlc2lnbiBTcGVlZCBkaWFsIGNvbXBvbmVudC5cbiAqICAgWy9lbl1cbiAqICAgW2phXVxuICogICAgIE1hdGVyaWFsIERlc2lnbuOBrlNwZWVkIGRpYWzjga7lrZDopoHntKDjgpLooajnj77jgZnjgovopoHntKDjgafjgZnjgIJcbiAqICAgWy9qYV1cbiAqIEBjb2RlcGVuIGRZUVlMZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwZWVkLWRpYWxcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsXG4gKiAgIFtlbl1UaGUgYDxvbnMtc3BlZWQtZGlhbD5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdb25zLXNwZWVkLWRpYWzjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLWZhYlxuICogICBbZW5db25zLWZhYiBjb21wb25lbnRbL2VuXVxuICogICBbamFdb25zLWZhYuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGVlZC1kaWFsIHBvc2l0aW9uPVwibGVmdCBib3R0b21cIj5cbiAqICAgPG9ucy1mYWI+XG4gKiAgICAgPG9ucy1pY29uIGljb249XCJmYS10d2l0dGVyXCI+PC9vbnMtaWNvbj5cbiAqICAgPC9vbnMtZmFiPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5BPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5CPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogICA8b25zLXNwZWVkLWRpYWwtaXRlbT5DPC9vbnMtc3BlZWQtZGlhbC1pdGVtPlxuICogPC9vbnMtc3BlZWQtZGlhbD5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BlZWREaWFsSXRlbUVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjb21wb25lbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIHRhcHBlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fYm91bmRPbkNsaWNrID0gdGhpcy5fb25DbGljay5iaW5kKHRoaXMpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJywgJ2NsYXNzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICB1dGlsLnJlc3RvcmVDbGFzcyh0aGlzLCBkZWZhdWx0Q2xhc3NOYW1lLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21vZGlmaWVyJzpcbiAgICAgICAgTW9kaWZpZXJVdGlsLm9uTW9kaWZpZXJDaGFuZ2VkKGxhc3QsIGN1cnJlbnQsIHRoaXMsIHNjaGVtZSk7XG4gICAgICAgIHV0aWwuYWRkTW9kaWZpZXIodGhpcywgJ21pbmknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaXBwbGUnOlxuICAgICAgICB0aGlzLl91cGRhdGVSaXBwbGUoKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fYm91bmRPbkNsaWNrLCBmYWxzZSk7XG4gIH1cblxuICBfdXBkYXRlUmlwcGxlKCkge1xuICAgIHV0aWwudXBkYXRlUmlwcGxlKHRoaXMpO1xuICB9XG5cbiAgX29uQ2xpY2soZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGRlZmF1bHRDbGFzc05hbWUuc3BsaXQoL1xccysvKS5mb3JFYWNoKHRva2VuID0+IHRoaXMuY2xhc3NMaXN0LmFkZCh0b2tlbikpO1xuXG4gICAgdXRpbC5hZGRNb2RpZmllcih0aGlzLCAnbWluaScpO1xuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlNwZWVkRGlhbEl0ZW0gPSBTcGVlZERpYWxJdGVtRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwZWVkLWRpYWwtaXRlbScsIFNwZWVkRGlhbEl0ZW1FbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBhdXRvU3R5bGUgZnJvbSAnLi4vb25zL2F1dG9zdHlsZSc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi9vbnMvc3R5bGVyJztcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICdzcGVlZC1kaWFsJztcbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICdzcGVlZC1kaWFsLS0qJyxcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwZWVkLWRpYWxcbiAqIEBjYXRlZ29yeSBjb250cm9sXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIEVsZW1lbnQgdGhhdCBkaXNwbGF5cyBhIE1hdGVyaWFsIERlc2lnbiBTcGVlZCBEaWFsb2cgY29tcG9uZW50LiBJdCBpcyB1c2VmdWwgd2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSBwcmltYXJ5IGFjdGlvbiB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgaW4gYSBwYWdlLlxuICpcbiAqICAgICBUaGUgU3BlZWQgZGlhbCBsb29rcyBsaWtlIGEgYDxvbnMtZmFiPmAgZWxlbWVudCBidXQgd2lsbCBleHBhbmQgYSBtZW51IHdoZW4gdGFwcGVkLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIGRZUVlMZ1xuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwZWVkLWRpYWxcbiAqIEBzZWVhbHNvIG9ucy1zcGVlZC1kaWFsLWl0ZW1cbiAqICAgW2VuXVRoZSBgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+YCByZXByZXNlbnRzIGEgbWVudSBpdGVtLlsvZW5dXG4gKiAgIFtqYV1vbnMtc3BlZWQtZGlhbC1pdGVt44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1mYWJcbiAqICAgW2VuXW9ucy1mYWIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1mYWLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BlZWQtZGlhbCBwb3NpdGlvbj1cImxlZnQgYm90dG9tXCI+XG4gKiAgIDxvbnMtZmFiPlxuICogICAgIDxvbnMtaWNvbiBpY29uPVwiZmEtdHdpdHRlclwiPjwvb25zLWljb24+XG4gKiAgIDwvb25zLWZhYj5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+QTwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qjwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqICAgPG9ucy1zcGVlZC1kaWFsLWl0ZW0+Qzwvb25zLXNwZWVkLWRpYWwtaXRlbT5cbiAqIDwvb25zLXNwZWVkLWRpYWw+XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwZWVkRGlhbEVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBldmVudCBvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBtZW51IGl0ZW1zIGFyZSBzaG93bi5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IGNsb3NlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCB3aGVuIHRoZSBtZW51IGl0ZW1zIGFyZSBoaWRkZW4uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBjb21wb25lbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu44Kz44Oz44Od44O844ON44Oz44OI44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcmlwcGxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIGRlZmluZWQsIHRoZSBidXR0b24gd2lsbCBoYXZlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIHRhcHBlZC5bL2VuXVxuICAgKiAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBvc2l0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1cbiAgICogICAgIFNwZWNpZnkgdGhlIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBjb21wb25lbnQuXG4gICAqICAgICBJLmUuIHRvIGRpc3BsYXkgaXQgaW4gdGhlIHRvcCByaWdodCBjb3JuZXIgc3BlY2lmeSBcInJpZ2h0IHRvcFwiLlxuICAgKiAgICAgQ2hvb3NlIGZyb20gXCJyaWdodFwiLCBcImxlZnRcIiwgXCJ0b3BcIiBhbmQgXCJib3R0b21cIi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOBk+OBruimgee0oOOCkuihqOekuuOBmeOCi+W3puWPs+OBqOS4iuS4i+OBruS9jee9ruOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgKiAgICAg5L6L44GI44Gw44CB5Y+z5LiK44Gr6KGo56S644GZ44KL5aC05ZCI44Gr44GvXCJyaWdodCB0b3BcIuOCkuaMh+WumuOBl+OBvuOBmeOAglxuICAgKiAgICAg5bem5Y+z44Go5LiK5LiL44Gu5L2N572u44Gu5oyH5a6a44Gr44Gv44CBcmlnaHTjgahsZWZ044CBdG9w44GoYm90dG9t44GM44Gd44KM44Ge44KM5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlyZWN0aW9uXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBkaXJlY3Rpb24gdGhlIGl0ZW1zIGFyZSBkaXNwbGF5ZWQuIFBvc3NpYmxlIHZhbHVlcyBhcmUgXCJ1cFwiLCBcImRvd25cIiwgXCJsZWZ0XCIgYW5kIFwicmlnaHRcIi5bL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOimgee0oOOBjOihqOekuuOBmeOCi+aWueWQkeOCkuaMh+WumuOBl+OBvuOBmeOAgnVwLCBkb3duLCBsZWZ0LCByaWdodOOBjOaMh+WumuOBp+OBjeOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IGlmIGJ1dHRvbiBzaG91bGQgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jb21waWxlKCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9pdGVtU2hvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICB0aGlzLmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5fdXBkYXRlUmlwcGxlKCk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuXG4gICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKCdkaXJlY3Rpb24nKSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKHRoaXMuZ2V0QXR0cmlidXRlKCdkaXJlY3Rpb24nKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigndXAnKTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnY2xhc3MnLCAnbW9kaWZpZXInLCAncmlwcGxlJywgJ2RpcmVjdGlvbicsICdwb3NpdGlvbiddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIE1vZGlmaWVyVXRpbC5vbk1vZGlmaWVyQ2hhbmdlZChsYXN0LCBjdXJyZW50LCB0aGlzLCBzY2hlbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpcHBsZSc6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl91cGRhdGVSaXBwbGUoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGlyZWN0aW9uJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZURpcmVjdGlvbihjdXJyZW50KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fdXBkYXRlUG9zaXRpb24oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ib3VuZE9uQ2xpY2ssIGZhbHNlKTtcbiAgfVxuXG4gIGdldCBpdGVtcygpIHtcbiAgICByZXR1cm4gdXRpbC5hcnJheUZyb20odGhpcy5xdWVyeVNlbGVjdG9yQWxsKCdvbnMtc3BlZWQtZGlhbC1pdGVtJykpO1xuICB9XG5cbiAgZ2V0IF9mYWIoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtZmFiJyk7XG4gIH1cblxuICBfb25DbGljayhlKSB7XG4gICAgaWYgKHRoaXMub25DbGljaykge1xuICAgICAgdGhpcy5vbkNsaWNrLmFwcGx5KHRoaXMpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gdGhpcy50b2dnbGVJdGVtcygpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KCkge1xuICAgIGlmICghdGhpcy5pbmxpbmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3coKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlubGluZSkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5oaWRlKCkudGhlbihyZXNvbHZlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIF91cGRhdGVSaXBwbGUoKSB7XG4gICAgaWYgKHRoaXMuX2ZhYikge1xuICAgICAgdGhpcy5oYXNBdHRyaWJ1dGUoJ3JpcHBsZScpID8gdGhpcy5fZmFiLnNldEF0dHJpYnV0ZSgncmlwcGxlJywgJycpIDogdGhpcy5fZmFiLnJlbW92ZUF0dHJpYnV0ZSgncmlwcGxlJyk7XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuaXRlbXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgIHRyYW5zaXRpb25EZWxheTogMjUgKiBpICsgJ21zJyxcbiAgICAgICAgYm90dG9tOiAnYXV0bycsXG4gICAgICAgIHJpZ2h0OiAnYXV0bycsXG4gICAgICAgIHRvcDogJ2F1dG8nLFxuICAgICAgICBsZWZ0OiAnYXV0bydcbiAgICAgIH0pO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAndXAnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUuYm90dG9tID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgICBjaGlsZHJlbltpXS5zdHlsZS5sZWZ0ID0gJzhweCc7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnRvcCA9ICc4cHgnO1xuICAgICAgICAgIGNoaWxkcmVuW2ldLnN0eWxlLnJpZ2h0ID0gNzIgKyA1NiAqIGkgKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUudG9wID0gJzhweCc7XG4gICAgICAgICAgY2hpbGRyZW5baV0uc3R5bGUubGVmdCA9IDcyICsgNTYgKiBpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHV0aWwudGhyb3coJ0FyZ3VtZW50IG11c3QgYmUgb25lIG9mIHVwLCBkb3duLCBsZWZ0IG9yIHJpZ2h0LicpO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbigpIHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpO1xuICAgIHRoaXMuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdmYWItLXRvcF9fbGVmdCcsXG4gICAgICAnZmFiLS1ib3R0b21fX3JpZ2h0JyxcbiAgICAgICdmYWItLWJvdHRvbV9fbGVmdCcsXG4gICAgICAnZmFiLS10b3BfX3JpZ2h0JyxcbiAgICAgICdmYWItLXRvcF9fY2VudGVyJyxcbiAgICAgICdmYWItLWJvdHRvbV9fY2VudGVyJyk7XG4gICAgc3dpdGNoKHBvc2l0aW9uKSB7XG4gICAgICBjYXNlICd0b3AgcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgdG9wJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLXRvcF9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3AgbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IHRvcCc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS10b3BfX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gcmlnaHQnOlxuICAgICAgY2FzZSAncmlnaHQgYm90dG9tJzpcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdmYWItLWJvdHRvbV9fcmlnaHQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20gbGVmdCc6XG4gICAgICBjYXNlICdsZWZ0IGJvdHRvbSc6XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0LmFkZCgnZmFiLS1ib3R0b21fX2xlZnQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgdG9wJzpcbiAgICAgIGNhc2UgJ3RvcCBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tdG9wX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjZW50ZXIgYm90dG9tJzpcbiAgICAgIGNhc2UgJ2JvdHRvbSBjZW50ZXInOlxuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoJ2ZhYi0tYm90dG9tX19jZW50ZXInKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBfZ2V0VHJhbnNsYXRlKCkge1xuICAgIGNvbnN0IGlzQm90dG9tID0gKHRoaXMuZ2V0QXR0cmlidXRlKCdwb3NpdGlvbicpIHx8ICcnKS5pbmRleE9mKCdib3R0b20nKSA+PSAwO1xuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGlzQm90dG9tID8gYHRyYW5zbGF0ZTNkKDBweCwgLSR7dXRpbC5nbG9iYWxzLmZhYk9mZnNldCB8fCAwfXB4LCAwcHgpIGAgOiAnJztcbiAgICByZXR1cm4gdHJhbnNsYXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2Qgc2hvd1xuICAgKiBAc2lnbmF0dXJlIHNob3coKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgc3BlZWQgZGlhbC5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNob3coKSB7XG4gICAgdGhpcy5fZmFiLnNob3coKTtcbiAgICBzdHlsZXIodGhpcywgeyB0cmFuc2Zvcm06IHRoaXMuX2dldFRyYW5zbGF0ZSB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1IaWRlIHRoZSBzcGVlZCBkaWFsLlsvZW5dXG4gICAqICAgW2phXVNwZWVkIGRpYWzjgpLpnZ7ooajnpLrjgavjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgaGlkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oaWRlSXRlbXMoKS50aGVuKCgpPT4gdGhpcy5fZmFiLmhpZGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzaG93SXRlbXNcbiAgICogQHNpZ25hdHVyZSBzaG93SXRlbXMoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgc3BlZWQgZGlhbCBpdGVtcy5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6KGo56S644GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHNob3dJdGVtcygpIHtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24odGhpcy5nZXRBdHRyaWJ1dGUoJ2RpcmVjdGlvbicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCd1cCcpO1xuICAgIH1cblxuICAgIGxldCB0b3RhbERlbGF5ID0gMDtcbiAgICBpZiAoIXRoaXMuX2l0ZW1TaG93bikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkZWxheSA9IDI1ICogaTtcbiAgICAgICAgdG90YWxEZWxheSArPSBkZWxheTtcbiAgICAgICAgc3R5bGVyKGNoaWxkcmVuW2ldLCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknLFxuICAgICAgICAgIHRyYW5zaXRpb25EZWxheTogZGVsYXkgKyAnbXMnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdG90YWxEZWxheSArPSA1MDtcblxuICAgICAgdGhpcy5faXRlbVNob3duID0gdHJ1ZTtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnb3BlbicpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmVycmVkID0gdXRpbC5kZWZlcigpO1xuICAgIHNldFRpbWVvdXQoZGVmZXJyZWQucmVzb2x2ZSwgdG90YWxEZWxheSk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlSXRlbXNcbiAgICogQHNpZ25hdHVyZSBoaWRlSXRlbXMoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSGlkZSB0aGUgc3BlZWQgZGlhbCBpdGVtcy5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44KS6Z2e6KGo56S644Gr44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGhpZGVJdGVtcygpIHtcbiAgICBsZXQgdG90YWxEZWxheSA9IDA7XG4gICAgaWYgKHRoaXMuX2l0ZW1TaG93bikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLml0ZW1zO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkZWxheSA9IDI1ICogKGNoaWxkcmVuLmxlbmd0aCAtIGkpO1xuICAgICAgICB0b3RhbERlbGF5ICs9IGRlbGF5O1xuICAgICAgICBzdHlsZXIoY2hpbGRyZW5baV0sIHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZSgwKScsXG4gICAgICAgICAgdHJhbnNpdGlvbkRlbGF5OiBkZWxheSArICdtcydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0b3RhbERlbGF5ICs9IDUwO1xuXG4gICAgICB0aGlzLl9pdGVtU2hvd24gPSBmYWxzZTtcbiAgICAgIHV0aWwudHJpZ2dlckVsZW1lbnRFdmVudCh0aGlzLCAnY2xvc2UnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZlcnJlZCA9IHV0aWwuZGVmZXIoKTtcbiAgICBzZXRUaW1lb3V0KGRlZmVycmVkLnJlc29sdmUsIHRvdGFsRGVsYXkpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuaGlkZUl0ZW1zKCk7XG4gICAgfVxuICAgIHV0aWwuYXJyYXlGcm9tKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goZSA9PiB7XG4gICAgICB1dGlsLm1hdGNoKGUsICcuZmFiJykgJiYgdXRpbC50b2dnbGVBdHRyaWJ1dGUoZSwgJ2Rpc2FibGVkJywgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdkaXNhYmxlZCcsIHZhbHVlKTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGlubGluZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIGlubGluZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd44Kk44Oz44Op44Kk44Oz6KaB57Sg44Gu5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCBpbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmxpbmUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmFiLnZpc2libGUgJiYgdGhpcy5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBpc09wZW5cbiAgICogQHNpZ25hdHVyZSBpc09wZW4oKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmV0dXJucyB3aGV0aGVyIHRoZSBtZW51IGlzIG9wZW4gb3Igbm90LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1TaG93bjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZVxuICAgKiBAc2lnbmF0dXJlIHRvZ2dsZSgpXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu6KGo56S66Z2e6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52aXNpYmxlID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHRvZ2dsZUl0ZW1zXG4gICAqIEBzaWduYXR1cmUgdG9nZ2xlSXRlbXMoKVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVG9nZ2xlIGl0ZW0gdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV1TcGVlZCBkaWFs44Gu5a2Q6KaB57Sg44Gu6KGo56S66Z2e6KGo56S644KS5YiH44KK5pu/44GI44G+44GZ44CCWy9qYV1cbiAgICovXG4gIHRvZ2dsZUl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3BlbigpID8gdGhpcy5oaWRlSXRlbXMoKSA6IHRoaXMuc2hvd0l0ZW1zKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydvcGVuJywgJ2Nsb3NlJ107XG4gIH1cbn1cblxub25zRWxlbWVudHMuU3BlZWREaWFsID0gU3BlZWREaWFsRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwZWVkLWRpYWwnLCBTcGVlZERpYWxFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCB7UGFnZUxvYWRlciwgZGVmYXVsdFBhZ2VMb2FkZXJ9IGZyb20gJy4uL29ucy9wYWdlLWxvYWRlcic7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtc3BsaXR0ZXItY29udGVudFxuICogQGNhdGVnb3J5IG1lbnVcbiAqIEBkZXNjcmlwdGlvblxuICogIFtlbl1cbiAqICAgIFRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgZWxlbWVudCBpcyB1c2VkIGFzIGEgY2hpbGQgZWxlbWVudCBvZiBgPG9ucy1zcGxpdHRlcj5gLlxuICpcbiAqICAgIEl0IGNvbnRhaW5zIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIHBhZ2Ugd2hpbGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbnRhaW5zIHRoZSBsaXN0LlxuICogIFsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1jb250ZW506KaB57Sg44Gv44CBb25zLXNwbGl0dGVy6KaB57Sg44Gu5a2Q6KaB57Sg44Go44GX44Gm5Yip55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHJPUU9NTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwbGl0dGVyXG4gKiBAZ3VpZGUgZnVuZGFtZW50YWxzLmh0bWwjbWFuYWdpbmctcGFnZXNcbiAqICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBjb21wb25lbnQgaXMgdGhlIHBhcmVudCBlbGVtZW50LlsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlcuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtc3BsaXR0ZXItc2lkZVxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGNvbXBvbmVudCBjb250YWlucyB0aGUgbWVudS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItc2lkZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlcj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAqIDwvb25zLXNwbGl0dGVyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlckNvbnRlbnRFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIHVybCBvZiB0aGUgY29udGVudCBwYWdlLiBJZiB0aGlzIGF0dHJpYnV0ZSBpcyB1c2VkIHRoZSBjb250ZW50IHdpbGwgYmUgbG9hZGVkIGZyb20gYSBgPHRlbXBsYXRlPmAgdGFnIG9yIGEgcmVtb3RlIGZpbGUuXG4gICAqXG4gICAqICAgICBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHB1dCBgPG9ucy1wYWdlPmAgZWxlbWVudCBhcyBhIGNoaWxkIG9mIHRoZSBlbGVtZW50LlxuICAgKiAgIFsvZW5dXG4gICAqICAgW2phXW9ucy1zcGxpdHRlci1jb250ZW506KaB57Sg44Gr6KGo56S644GZ44KL44Oa44O844K444GuVVJM44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3BhZ2UgPSBudWxsO1xuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBkZWZhdWx0UGFnZUxvYWRlcjtcblxuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICByZXdyaXRhYmxlcy5yZWFkeSh0aGlzLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLl9nZXRQYWdlVGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKHBhZ2UpIHtcbiAgICAgICAgICB0aGlzLmxvYWQocGFnZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKCF1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XG4gICAgICB1dGlsLnRocm93KCdcIm9ucy1zcGxpdHRlci1jb250ZW50XCIgbXVzdCBoYXZlIFwib25zLXNwbGl0dGVyXCIgYXMgcGFyZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgX2dldFBhZ2VUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge31cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBwYWdlIHRvIGxvYWQgaW4gdGhlIHNwbGl0dGVyIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg5YaF44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gcGFnZVxuICAgKi9cbiAgc2V0IHBhZ2UocGFnZSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICB9XG5cbiAgZ2V0IF9jb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkcmVuWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBwYWdlTG9hZGVyXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhZ2UgZWxlbWVudCBsb2FkZWQgaW4gdGhlIHNwbGl0dGVyIGNvbnRlbnQuWy9lbl1cbiAgICogICBbamFd44GT44Gu6KaB57Sg5YaF44Gr6KGo56S644GZ44KL44Oa44O844K444KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgc2V0IHBhZ2VMb2FkZXIobG9hZGVyKSB7XG4gICAgaWYgKCEobG9hZGVyIGluc3RhbmNlb2YgUGFnZUxvYWRlcikpIHtcbiAgICAgIHV0aWwudGhyb3dQYWdlTG9hZGVyKCk7XG4gICAgfVxuICAgIHRoaXMuX3BhZ2VMb2FkZXIgPSBsb2FkZXI7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBsb2FkXG4gICAqIEBzaWduYXR1cmUgbG9hZChwYWdlLCBbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYWdlLCBbb3B0aW9uc11cbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBkb2N1bWVudCBvciBhbiBgPHRlbXBsYXRlPmAgaWQuWy9lbl1cbiAgICogICBbamFdcGFnZeOBrlVSTOOBi+OAgWA8dGVtcGxhdGU+YOOBp+Wuo+iogOOBl+OBn+ODhuODs+ODl+ODrOODvOODiOOBrmlk5bGe5oCn44Gu5YCk44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgdGhlIHBhZ2Ugc3BlY2lmaWVkIGluIGBwYWdlYCBpbiB0aGUgY29udGVudC5bL2VuXVxuICAgKiAgIFtqYV3mjIflrprjgZfjgZ9VUkzjgpLjg6HjgqTjg7Pjg5rjg7zjgrjjgpLoqq3jgb/ovrzjgb/jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgbmV3IGA8b25zLXBhZ2U+YCBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdYDxvbnMtcGFnZT5g6KaB57Sg44KS6Kej5rG644GZ44KLUHJvbWlzZeOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuICBsb2FkKHBhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX3BhZ2UgPSBwYWdlO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBmdW5jdGlvbigpIHt9O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IG9sZENvbnRlbnQgPSB0aGlzLl9jb250ZW50IHx8IG51bGw7XG5cbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIubG9hZCh7cGFnZSwgcGFyZW50OiB0aGlzfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAob2xkQ29udGVudCkge1xuICAgICAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKG9sZENvbnRlbnQpO1xuICAgICAgICAgIG9sZENvbnRlbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3Nob3coKSk7XG5cbiAgICAgICAgY2FsbGJhY2socGFnZUVsZW1lbnQpO1xuICAgICAgICByZXNvbHZlKHBhZ2VFbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX3Nob3coKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NvbnRlbnQuX3Nob3coKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fY29udGVudC5faGlkZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLnVubG9hZCh0aGlzLl9jb250ZW50KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcmV3cml0YWJsZXMoKSB7XG4gICAgcmV0dXJuIHJld3JpdGFibGVzO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlNwbGl0dGVyQ29udGVudCA9IFNwbGl0dGVyQ29udGVudEVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy1zcGxpdHRlci1jb250ZW50JywgU3BsaXR0ZXJDb250ZW50RWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCB1dGlsIGZyb20gJy4uL29ucy91dGlsJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlck1hc2tFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9ib3VuZE9uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUuX3NpZGVzLmV2ZXJ5KHNpZGUgPT4gc2lkZS5tb2RlID09PSAnc3BsaXQnKSkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZSAhaW1wb3J0YW50Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfb25DbGljayhldmVudCkge1xuICAgIGlmICh0aGlzLm9uQ2xpY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5vbkNsaWNrKCk7XG4gICAgfSBlbHNlIGlmICh1dGlsLm1hdGNoKHRoaXMucGFyZW50Tm9kZSwgJ29ucy1zcGxpdHRlcicpKSB7XG4gICAgICB0aGlzLnBhcmVudE5vZGUuX3NpZGVzLmZvckVhY2goc2lkZSA9PiBzaWRlLmNsb3NlKCdsZWZ0JykuY2F0Y2goKCkgPT4ge30pKTtcbiAgICB9XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljayk7XG4gICAgdXRpbC5pb3NNYXNrU2Nyb2xsRml4KHRoaXMsIHRydWUpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2JvdW5kT25DbGljayk7XG4gICAgdXRpbC5pb3NNYXNrU2Nyb2xsRml4KHRoaXMsIGZhbHNlKTtcbiAgfVxufVxuXG5vbnNFbGVtZW50cy5TcGxpdHRlck1hc2sgPSBTcGxpdHRlck1hc2tFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BsaXR0ZXItbWFzaycsIFNwbGl0dGVyTWFza0VsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IHV0aWwgZnJvbSAnLi4vLi4vb25zL3V0aWwnO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi8uLi9vbnMvc3R5bGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IEJhc2VBbmltYXRvciBmcm9tICcuLi8uLi9vbnMvYmFzZS1hbmltYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwbGl0dGVyQW5pbWF0b3IgZXh0ZW5kcyBCYXNlQW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnY3ViaWMtYmV6aWVyKC4xLCAuNywgLjEsIDEpJywgZHVyYXRpb24gPSAwLjMsIGRlbGF5ID0gMH0gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkdXJhdGlvbiwgZGVsYXkgfSk7XG4gIH1cblxuICB1cGRhdGVPcHRpb25zKG9wdGlvbnMgPSB7fSkge1xuICAgIHV0aWwuZXh0ZW5kKHRoaXMsIHtcbiAgICAgIHRpbWluZzogdGhpcy50aW1pbmcsIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLCBkZWxheTogdGhpcy5kZWxheVxuICAgIH0sIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc2lkZUVsZW1lbnRcbiAgICovXG4gIGFjdGl2YXRlKHNpZGVFbGVtZW50KSB7XG4gICAgY29uc3Qgc3BsaXR0ZXIgPSBzaWRlRWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgY29udGVudFJlYWR5KHNwbGl0dGVyLCAoKSA9PiB7XG4gICAgICB0aGlzLl9zaWRlID0gc2lkZUVsZW1lbnQ7XG4gICAgICB0aGlzLl9vcHBvc2l0ZVNpZGUgPSBzcGxpdHRlci5yaWdodCAhPT0gc2lkZUVsZW1lbnQgJiYgc3BsaXR0ZXIucmlnaHQgfHwgc3BsaXR0ZXIubGVmdCAhPT0gc2lkZUVsZW1lbnQgJiYgc3BsaXR0ZXIubGVmdDtcbiAgICAgIHRoaXMuX2NvbnRlbnQgPSBzcGxpdHRlci5jb250ZW50O1xuICAgICAgdGhpcy5fbWFzayA9IHNwbGl0dGVyLm1hc2s7XG4gICAgfSk7XG4gIH1cblxuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuY2xlYXJUcmFuc2l0aW9uKCk7XG4gICAgdGhpcy5fbWFzayAmJiB0aGlzLmNsZWFyTWFzaygpO1xuICAgIHRoaXMuX2NvbnRlbnQgPSB0aGlzLl9zaWRlID0gdGhpcy5fb3Bwb3NpdGVTaWRlID0gdGhpcy5fbWFzayA9IG51bGw7XG4gIH1cblxuICBnZXQgbWludXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpZGUuc2lkZSA9PT0gJ3JpZ2h0JyA/ICctJyA6ICcnO1xuICB9XG5cbiAgY2xlYXJUcmFuc2l0aW9uKCkge1xuICAgICdzaWRlIG1hc2sgY29udGVudCcuc3BsaXQoL1xccysvKVxuICAgICAgLmZvckVhY2goZSA9PiB0aGlzWydfJyArIGVdICYmIHN0eWxlci5jbGVhcih0aGlzWydfJyArIGVdLCAndHJhbnNmb3JtIHRyYW5zaXRpb24nKSlcbiAgfVxuXG4gIGNsZWFyTWFzaygpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgb3RoZXIgc2lkZSBuZWVkcyB0aGUgbWFzayBiZWZvcmUgY2xlYXJpbmdcbiAgICBpZiAoIXRoaXMuX29wcG9zaXRlU2lkZSB8fCB0aGlzLl9vcHBvc2l0ZVNpZGUubW9kZSA9PT0gJ3NwbGl0JyB8fCAhdGhpcy5fb3Bwb3NpdGVTaWRlLmlzT3Blbikge1xuICAgICAgdGhpcy5fbWFzay5zdHlsZS5vcGFjaXR5ID0gJyc7XG4gICAgICB0aGlzLl9tYXNrLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZVxuICAgKi9cbiAgdHJhbnNsYXRlKGRpc3RhbmNlKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBvcGVuKGRvbmUpIHtcbiAgICBkb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgY2xvc2UoZG9uZSkge1xuICAgIGRvbmUoKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3IuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdmVybGF5U3BsaXR0ZXJBbmltYXRvciBleHRlbmRzIFNwbGl0dGVyQW5pbWF0b3Ige1xuXG4gIHRyYW5zbGF0ZShkaXN0YW5jZSkge1xuICAgIHRoaXMuX21hc2suc3R5bGUuZGlzcGxheSA9ICdibG9jayc7IC8vIEF2b2lkIGNvbnRlbnQgY2xpY2tzXG5cbiAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgIC5xdWV1ZSh7XG4gICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7dGhpcy5taW51cyArIGRpc3RhbmNlfXB4LCAwLCAwKWBcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmVcbiAgICovXG4gIG9wZW4oZG9uZSkge1xuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXN9MTAwJSwgMCwgMClgXG4gICAgICAgIH0sIHRoaXMuZGVmKVxuICAgICAgICAucXVldWUoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgIH0pXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogJzEnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6ICdsaW5lYXInLFxuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgY2xvc2UoZG9uZSkge1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJ1xuICAgICAgICB9LCB0aGlzLmRlZilcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICBkb25lICYmIGRvbmUoKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgb3BhY2l0eTogJzAnXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICB0aW1pbmc6ICdsaW5lYXInLFxuICAgICAgICB9KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHVzaFNwbGl0dGVyQW5pbWF0b3IgZXh0ZW5kcyBTcGxpdHRlckFuaW1hdG9yIHtcblxuICBfZ2V0U2xpZGluZ0VsZW1lbnRzKCkge1xuICAgIGNvbnN0IHNsaWRpbmdFbGVtZW50cyA9IFt0aGlzLl9zaWRlLCB0aGlzLl9jb250ZW50XTtcbiAgICBpZiAodGhpcy5fb3Bwb3NpdGVTaWRlICYmIHRoaXMuX29wcG9zaXRlU2lkZS5tb2RlID09PSAnc3BsaXQnKSB7XG4gICAgICBzbGlkaW5nRWxlbWVudHMucHVzaCh0aGlzLl9vcHBvc2l0ZVNpZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzbGlkaW5nRWxlbWVudHM7XG4gIH1cblxuICB0cmFuc2xhdGUoZGlzdGFuY2UpIHtcbiAgICBpZiAoIXRoaXMuX3NsaWRpbmdFbGVtZW50cykge1xuICAgICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gdGhpcy5fZ2V0U2xpZGluZ0VsZW1lbnRzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzay5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsgLy8gQXZvaWQgY29udGVudCBjbGlja3NcblxuICAgIGFuaW1pdCh0aGlzLl9zbGlkaW5nRWxlbWVudHMpXG4gICAgICAucXVldWUoe1xuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyBkaXN0YW5jZX1weCwgMCwgMClgXG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBvcGVuKGRvbmUpIHtcbiAgICBjb25zdCBtYXggPSB0aGlzLl9zaWRlLm9mZnNldFdpZHRoO1xuICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNsaWRpbmdFbGVtZW50cygpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zbGlkaW5nRWxlbWVudHMpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzICsgbWF4fXB4LCAwLCAwKWBcbiAgICAgICAgfSwgdGhpcy5kZWYpXG4gICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gbnVsbDtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICB9KSxcblxuICAgICAgYW5pbWl0KHRoaXMuX21hc2spXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZVxuICAgKi9cbiAgY2xvc2UoZG9uZSkge1xuICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNsaWRpbmdFbGVtZW50cygpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0aGlzLl9zbGlkaW5nRWxlbWVudHMpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7XG4gICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCknXG4gICAgICAgIH0sIHRoaXMuZGVmKVxuICAgICAgICAucXVldWUoY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IG51bGw7XG4gICAgICAgICAgc3VwZXIuY2xlYXJUcmFuc2l0aW9uKCk7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUoe1xuICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHN0eWxlciBmcm9tICcuLi8uLi9vbnMvc3R5bGVyJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgU3BsaXR0ZXJBbmltYXRvciBmcm9tICcuL2FuaW1hdG9yLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmV2ZWFsU3BsaXR0ZXJBbmltYXRvciBleHRlbmRzIFNwbGl0dGVyQW5pbWF0b3Ige1xuXG4gIF9nZXRTbGlkaW5nRWxlbWVudHMoKSB7XG4gICAgY29uc3Qgc2xpZGluZ0VsZW1lbnRzID0gW3RoaXMuX2NvbnRlbnQsIHRoaXMuX21hc2tdO1xuICAgIGlmICh0aGlzLl9vcHBvc2l0ZVNpZGUgJiYgdGhpcy5fb3Bwb3NpdGVTaWRlLm1vZGUgPT09ICdzcGxpdCcpIHtcbiAgICAgIHNsaWRpbmdFbGVtZW50cy5wdXNoKHRoaXMuX29wcG9zaXRlU2lkZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNsaWRpbmdFbGVtZW50cztcbiAgfVxuXG4gIGFjdGl2YXRlKHNpZGVFbGVtZW50KSB7XG4gICAgc3VwZXIuYWN0aXZhdGUoc2lkZUVsZW1lbnQpO1xuICAgIGlmIChzaWRlRWxlbWVudC5tb2RlID09PSAnY29sbGFwc2UnKSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZXMoc2lkZUVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5fc2lkZSAmJiB0aGlzLl91bnNldFN0eWxlcyh0aGlzLl9zaWRlKTtcbiAgICBzdXBlci5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICBfc2V0U3R5bGVzKHNpZGVFbGVtZW50KSB7XG4gICAgc3R5bGVyKHNpZGVFbGVtZW50LCB7XG4gICAgICBsZWZ0OiBzaWRlRWxlbWVudC5zaWRlID09PSAncmlnaHQnID8gJ2F1dG8nIDogMCxcbiAgICAgIHJpZ2h0OiBzaWRlRWxlbWVudC5zaWRlID09PSAncmlnaHQnICA/IDAgOiAnYXV0bycsXG4gICAgICB6SW5kZXg6IDAsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdibGFjaycsXG4gICAgICB0cmFuc2Zvcm06IHRoaXMuX2dlbmVyYXRlQmVoaW5kUGFnZVN0eWxlKDApLmNvbnRhaW5lci50cmFuc2Zvcm0sXG4gICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICB9KTtcblxuICAgIGNvbnN0IHNwbGl0dGVyID0gc2lkZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBjb250ZW50UmVhZHkoc3BsaXR0ZXIsICgpID0+IHNwbGl0dGVyLmNvbnRlbnQgJiYgc3R5bGVyKHNwbGl0dGVyLmNvbnRlbnQsIHsgYm94U2hhZG93OiAnMCAwIDEycHggMCByZ2JhKDAsIDAsIDAsIDAuMiknIH0pKTtcbiAgfVxuXG4gIF91bnNldFN0eWxlcyhzaWRlRWxlbWVudCkge1xuICAgIHN0eWxlci5jbGVhcihzaWRlRWxlbWVudCwgJ2xlZnQgcmlnaHQgekluZGV4IGJhY2tncm91bmRDb2xvciBkaXNwbGF5Jyk7XG4gICAgaWYgKHNpZGVFbGVtZW50Ll9jb250ZW50KSB7XG4gICAgICBzaWRlRWxlbWVudC5fY29udGVudC5zdHlsZS5vcGFjaXR5ID0gJyc7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIG90aGVyIHNpZGUgbmVlZHMgdGhlIGNvbW1vbiBzdHlsZXNcbiAgICBpZiAoIXRoaXMuX29wcG9zaXRlU2lkZSB8fCB0aGlzLl9vcHBvc2l0ZVNpZGUubW9kZSA9PT0gJ3NwbGl0Jykge1xuICAgICAgc2lkZUVsZW1lbnQucGFyZW50RWxlbWVudC5jb250ZW50ICYmIHN0eWxlci5jbGVhcihzaWRlRWxlbWVudC5wYXJlbnRFbGVtZW50LmNvbnRlbnQsICdib3hTaGFkb3cnKTtcbiAgICB9XG4gIH1cblxuICBfZ2VuZXJhdGVCZWhpbmRQYWdlU3R5bGUoZGlzdGFuY2UpIHtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heFdpZHRoO1xuXG4gICAgbGV0IGJlaGluZERpc3RhbmNlID0gKGRpc3RhbmNlIC0gbWF4KSAvIG1heCAqIDEwO1xuICAgIGJlaGluZERpc3RhbmNlID0gaXNOYU4oYmVoaW5kRGlzdGFuY2UpID8gMCA6IE1hdGgubWF4KE1hdGgubWluKGJlaGluZERpc3RhbmNlLCAwKSwgLTEwKTtcblxuICAgIGNvbnN0IGJlaGluZFRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgkeyh0aGlzLm1pbnVzID8gLTEgOiAxKSAqIGJlaGluZERpc3RhbmNlfSUsIDAsIDApYDtcbiAgICBjb25zdCBvcGFjaXR5ID0gMSArIGJlaGluZERpc3RhbmNlIC8gMTAwO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgb3BhY2l0eVxuICAgICAgfSxcbiAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICB0cmFuc2Zvcm06IGJlaGluZFRyYW5zZm9ybVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB0cmFuc2xhdGUoZGlzdGFuY2UpIHtcbiAgICB0aGlzLl9zaWRlLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB0aGlzLl9zaWRlLnN0eWxlLnpJbmRleCA9IDE7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHRoaXMubWF4V2lkdGggfHwgdGhpcy5fZ2V0TWF4V2lkdGgoKTtcbiAgICBjb25zdCBtZW51U3R5bGUgPSB0aGlzLl9nZW5lcmF0ZUJlaGluZFBhZ2VTdHlsZShNYXRoLm1pbihkaXN0YW5jZSwgdGhpcy5tYXhXaWR0aCkpO1xuXG4gICAgaWYgKCF0aGlzLl9zbGlkaW5nRWxlbWVudHMpIHtcbiAgICAgIHRoaXMuX3NsaWRpbmdFbGVtZW50cyA9IHRoaXMuX2dldFNsaWRpbmdFbGVtZW50cygpO1xuICAgIH1cblxuICAgIHRoaXMuX21hc2suc3R5bGUuZGlzcGxheSA9ICdibG9jayc7IC8vIEF2b2lkIGNvbnRlbnQgY2xpY2tzXG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NsaWRpbmdFbGVtZW50cylcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke3RoaXMubWludXMgKyBkaXN0YW5jZX1weCwgMCwgMClgXG4gICAgICAgIH0pLFxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUuX2NvbnRlbnQpXG4gICAgICAgIC5xdWV1ZShtZW51U3R5bGUuY29udGVudCksXG4gICAgICBhbmltaXQodGhpcy5fc2lkZSlcbiAgICAgICAgLnF1ZXVlKG1lbnVTdHlsZS5jb250YWluZXIpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBvcGVuKGRvbmUpIHtcbiAgICB0aGlzLl9zaWRlLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICB0aGlzLl9zaWRlLnN0eWxlLnpJbmRleCA9IDE7XG4gICAgdGhpcy5tYXhXaWR0aCA9IHRoaXMubWF4V2lkdGggfHwgdGhpcy5fZ2V0TWF4V2lkdGgoKTtcbiAgICBjb25zdCBtZW51U3R5bGUgPSB0aGlzLl9nZW5lcmF0ZUJlaGluZFBhZ2VTdHlsZSh0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSB0aGlzLl9nZXRTbGlkaW5nRWxlbWVudHMoKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4geyAvLyBGaXg6IFRpbWUgdG8gdXBkYXRlIHByZXZpb3VzIHRyYW5zbGF0ZTNkIGFmdGVyIGNoYW5naW5nIHN0eWxlLmRpc3BsYXlcbiAgICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICAgIGFuaW1pdCh0aGlzLl9zbGlkaW5nRWxlbWVudHMpXG4gICAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgICAucXVldWUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHt0aGlzLm1pbnVzICsgdGhpcy5tYXhXaWR0aH1weCwgMCwgMClgXG4gICAgICAgICAgfSwgdGhpcy5kZWYpLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLl9tYXNrKVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgICB9KSxcblxuICAgICAgICBhbmltaXQodGhpcy5fc2lkZS5fY29udGVudClcbiAgICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAgIC5xdWV1ZShtZW51U3R5bGUuY29udGVudCwgdGhpcy5kZWYpLFxuXG4gICAgICAgIGFuaW1pdCh0aGlzLl9zaWRlKVxuICAgICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgICAgLnF1ZXVlKG1lbnVTdHlsZS5jb250YWluZXIsIHRoaXMuZGVmKVxuICAgICAgICAgIC5xdWV1ZShjYWxsYmFjayA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSBudWxsO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICAgICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9LCAxMDAwLzYwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lXG4gICAqL1xuICBjbG9zZShkb25lKSB7XG4gICAgY29uc3QgbWVudVN0eWxlID0gdGhpcy5fZ2VuZXJhdGVCZWhpbmRQYWdlU3R5bGUoMCk7XG4gICAgdGhpcy5fc2xpZGluZ0VsZW1lbnRzID0gdGhpcy5fZ2V0U2xpZGluZ0VsZW1lbnRzKCk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRoaXMuX3NsaWRpbmdFbGVtZW50cylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSdcbiAgICAgICAgfSwgdGhpcy5kZWYpLFxuXG4gICAgICBhbmltaXQodGhpcy5fbWFzaylcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9zaWRlLl9jb250ZW50KVxuICAgICAgICAud2FpdCh0aGlzLmRlbGF5KVxuICAgICAgICAucXVldWUobWVudVN0eWxlLmNvbnRlbnQsIHRoaXMuZGVmKSxcblxuICAgICAgYW5pbWl0KHRoaXMuX3NpZGUpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZShtZW51U3R5bGUuY29udGFpbmVyLCB0aGlzLmRlZilcbiAgICAgICAgLnF1ZXVlKGNhbGxiYWNrID0+IHtcbiAgICAgICAgICB0aGlzLl9zbGlkaW5nRWxlbWVudHMgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX3NpZGUuc3R5bGUuekluZGV4ID0gMDtcbiAgICAgICAgICB0aGlzLl9zaWRlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdGhpcy5fc2lkZS5fY29udGVudC5zdHlsZS5vcGFjaXR5ID0gJyc7XG4gICAgICAgICAgZG9uZSAmJiBkb25lKCk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSksXG4gICAgKTtcbiAgfVxuXG4gIF9nZXRNYXhXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2lkZS5vZmZzZXRXaWR0aDtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uLy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBBbmltYXRvckZhY3RvcnkgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2FuaW1hdG9yLWZhY3RvcnknO1xuaW1wb3J0IE92ZXJsYXlTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vb3ZlcmxheS1hbmltYXRvcic7XG5pbXBvcnQgUHVzaFNwbGl0dGVyQW5pbWF0b3IgZnJvbSAnLi9wdXNoLWFuaW1hdG9yJztcbmltcG9ydCBSZXZlYWxTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vcmV2ZWFsLWFuaW1hdG9yJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL2RldmljZS1iYWNrLWJ1dHRvbi1kaXNwYXRjaGVyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuXG5jb25zdCBfYW5pbWF0b3JEaWN0ID0ge1xuICBkZWZhdWx0OiBPdmVybGF5U3BsaXR0ZXJBbmltYXRvcixcbiAgb3ZlcmxheTogT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IsXG4gIHB1c2g6IFB1c2hTcGxpdHRlckFuaW1hdG9yLFxuICByZXZlYWw6IFJldmVhbFNwbGl0dGVyQW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwbGl0dGVyXG4gKiBAY2F0ZWdvcnkgbWVudVxuICogQGRlc2NyaXB0aW9uXG4gKiAgW2VuXVxuICogICAgQSBjb21wb25lbnQgdGhhdCBlbmFibGVzIHJlc3BvbnNpdmUgbGF5b3V0IGJ5IGltcGxlbWVudGluZyBib3RoIGEgdHdvLWNvbHVtbiBsYXlvdXQgYW5kIGEgc2xpZGluZyBtZW51IGxheW91dC5cbiAqXG4gKiAgICBJdCBjYW4gYmUgY29uZmlndXJlZCB0byBhdXRvbWF0aWNhbGx5IGV4cGFuZCBpbnRvIGEgY29sdW1uIGxheW91dCBvbiBsYXJnZSBzY3JlZW5zIGFuZCBjb2xsYXBzZSB0aGUgbWVudSBvbiBzbWFsbGVyIHNjcmVlbnMuIFdoZW4gdGhlIG1lbnUgaXMgY29sbGFwc2VkIHRoZSB1c2VyIGNhbiBvcGVuIGl0IGJ5IHN3aXBpbmcuXG4gKiAgWy9lbl1cbiAqICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIHJPUU9NTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwbGl0dGVyXG4gKiBAZ3VpZGUgZnVuZGFtZW50YWxzLmh0bWwjbWFuYWdpbmctcGFnZXNcbiAqICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlci1jb250ZW50XG4gKiAgW2VuXVRoZSBgPG9ucy1zcGxpdHRlci1jb250ZW50PmAgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBtYWluIGNvbnRlbnQgb2YgdGhlIHBhZ2UuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLWNvbnRlbnTjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLXNpZGVcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLXNpZGU+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1lbnUuWy9lbl1cbiAqICBbamFdb25zLXNwbGl0dGVyLXNpZGXjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQGV4YW1wbGVcbiAqIDxvbnMtc3BsaXR0ZXIgaWQ9XCJzcGxpdHRlclwiPlxuICogICA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKiAgICAgLi4uXG4gKiAgIDwvb25zLXNwbGl0dGVyLWNvbnRlbnQ+XG4gKlxuICogICA8b25zLXNwbGl0dGVyLXNpZGUgc2lkZT1cImxlZnRcIiB3aWR0aD1cIjgwJVwiIGNvbGxhcHNlIHN3aXBlYWJsZT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAqIDwvb25zLXNwbGl0dGVyPlxuICpcbiAqIDxzY3JpcHQ+XG4gKiAgIHZhciBzcGxpdHRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzcGxpdHRlcicpO1xuICogICBzcGxpdHRlci5sZWZ0Lm9wZW4oKTtcbiAqIDwvc2NyaXB0PlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlckVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgX2dldFNpZGUoc2lkZSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1dGlsLmZpbmRDaGlsZCh0aGlzLCBlID0+IHtcbiAgICAgIHJldHVybiB1dGlsLm1hdGNoKGUsICdvbnMtc3BsaXR0ZXItc2lkZScpICYmIGUuZ2V0QXR0cmlidXRlKCdzaWRlJykgPT09IHNpZGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IGxlZnRcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUxlZnQgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBsZWZ0KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTaWRlKCdsZWZ0Jyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSByaWdodFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dUmlnaHQgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCByaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U2lkZSgncmlnaHQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc2lkZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyc3QgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQgcmVnYXJkbGVzcyB0aGUgYWN0dWFsIHNpZGUuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBzaWRlKCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnb25zLXNwbGl0dGVyLXNpZGUnKTtcbiAgfVxuXG4gIGdldCBfc2lkZXMoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmxlZnQsIHRoaXMucmlnaHRdLmZpbHRlcihlID0+IGUpO1xuICB9XG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY29udGVudFxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0hUTUxFbGVtZW50fVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBlbGVtZW50LlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kQ2hpbGQodGhpcywgJ29ucy1zcGxpdHRlci1jb250ZW50Jyk7XG4gIH1cblxuICBnZXQgdG9wUGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50Ll9jb250ZW50O1xuICB9XG5cbiAgZ2V0IG1hc2soKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdvbnMtc3BsaXR0ZXItbWFzaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvbkRldmljZUJhY2tCdXR0b25cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUJhY2stYnV0dG9uIGhhbmRsZXIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44Kv44Oc44K/44Oz44OP44Oz44OJ44Op44CCWy9qYV1cbiAgICovXG4gIGdldCBvbkRldmljZUJhY2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyO1xuICB9XG5cbiAgc2V0IG9uRGV2aWNlQmFja0J1dHRvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uSGFuZGxlcikge1xuICAgICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gZGV2aWNlQmFja0J1dHRvbkRpc3BhdGNoZXIuY3JlYXRlSGFuZGxlcih0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICBfb25EZXZpY2VCYWNrQnV0dG9uKGV2ZW50KSB7XG4gICAgdGhpcy5fc2lkZXMuc29tZShzID0+IHMuaXNPcGVuID8gcy5jbG9zZSgpIDogZmFsc2UpIHx8IGV2ZW50LmNhbGxQYXJlbnRIYW5kbGVyKCk7XG4gIH1cblxuICBfb25Nb2RlQ2hhbmdlKGUpIHtcbiAgICBpZiAoZS50YXJnZXQucGFyZW50Tm9kZSkge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fbGF5b3V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfbGF5b3V0KCkge1xuICAgIHRoaXMuX3NpZGVzLmZvckVhY2goc2lkZSA9PiB7XG4gICAgICBpZiAodGhpcy5jb250ZW50KSB7XG4gICAgICAgIHRoaXMuY29udGVudC5zdHlsZVtzaWRlLnNpZGVdID0gc2lkZS5tb2RlID09PSAnc3BsaXQnID8gc2lkZS5zdHlsZS53aWR0aCA6IDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fb25Nb2RlQ2hhbmdlID0gdGhpcy5fb25Nb2RlQ2hhbmdlLmJpbmQodGhpcyk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgIXRoaXMubWFzayAmJiB0aGlzLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29ucy1zcGxpdHRlci1tYXNrJykpO1xuICAgICAgdGhpcy5fbGF5b3V0KCk7XG4gICAgfSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm9uRGV2aWNlQmFja0J1dHRvbiA9IHRoaXMuX29uRGV2aWNlQmFja0J1dHRvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW9kZWNoYW5nZScsIHRoaXMuX29uTW9kZUNoYW5nZSwgZmFsc2UpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fYmFja0J1dHRvbkhhbmRsZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuX2JhY2tCdXR0b25IYW5kbGVyID0gbnVsbDtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vZGVjaGFuZ2UnLCB0aGlzLl9vbk1vZGVDaGFuZ2UsIGZhbHNlKTtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBsYXN0LCBjdXJyZW50KSB7fVxuXG4gIF9zaG93KCkge1xuICAgIHV0aWwucHJvcGFnYXRlQWN0aW9uKHRoaXMsICdfc2hvdycpO1xuICB9XG5cbiAgX2hpZGUoKSB7XG4gICAgdXRpbC5wcm9wYWdhdGVBY3Rpb24odGhpcywgJ19oaWRlJyk7XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB1dGlsLnByb3BhZ2F0ZUFjdGlvbih0aGlzLCAnX2Rlc3Ryb3knKTtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgc3RhdGljIHJlZ2lzdGVyQW5pbWF0b3IobmFtZSwgQW5pbWF0b3IpIHtcbiAgICBpZiAoIShBbmltYXRvciBpbnN0YW5jZW9mIFNwbGl0dGVyQW5pbWF0b3IpKSB7XG4gICAgICB1dGlsLnRocm93QW5pbWF0b3IoJ1NwbGl0dGVyJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgU3BsaXR0ZXJBbmltYXRvcigpIHtcbiAgICByZXR1cm4gU3BsaXR0ZXJBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlNwbGl0dGVyID0gU3BsaXR0ZXJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3BsaXR0ZXInLCBTcGxpdHRlckVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi9vbnMvdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBvcmllbnRhdGlvbiBmcm9tICcuLi9vbnMvb3JpZW50YXRpb24nO1xuaW1wb3J0IGludGVybmFsIGZyb20gJy4uL29ucy9pbnRlcm5hbCc7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuL2Jhc2UvYmFzZS1lbGVtZW50JztcbmltcG9ydCBTcGxpdHRlckFuaW1hdG9yIGZyb20gJy4vb25zLXNwbGl0dGVyL2FuaW1hdG9yJztcbmltcG9ydCBTd2lwZVJldmVhbCBmcm9tICcuLi9vbnMvaW50ZXJuYWwvc3dpcGUtcmV2ZWFsJztcbmltcG9ydCBEb29yTG9jayBmcm9tICcuLi9vbnMvZG9vcmxvY2snO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgeyBQYWdlTG9hZGVyLCBkZWZhdWx0UGFnZUxvYWRlcn0gZnJvbSAnLi4vb25zL3BhZ2UtbG9hZGVyJztcbmltcG9ydCBTcGxpdHRlckVsZW1lbnQgZnJvbSAnLi9vbnMtc3BsaXR0ZXInO1xuXG5jb25zdCBTUExJVF9NT0RFID0gJ3NwbGl0JztcbmNvbnN0IENPTExBUFNFX01PREUgPSAnY29sbGFwc2UnO1xuY29uc3QgQ0xPU0VEX1NUQVRFID0gJ2Nsb3NlZCc7XG5jb25zdCBPUEVOX1NUQVRFID0gJ29wZW4nO1xuY29uc3QgQ0hBTkdJTkdfU1RBVEUgPSAnY2hhbmdpbmcnO1xuXG5jb25zdCByZXdyaXRhYmxlcyA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc3BsaXR0ZXJTaWRlRWxlbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgcmVhZHkoc3BsaXR0ZXJTaWRlRWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICB9XG59O1xuXG5jbGFzcyBDb2xsYXBzZURldGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHRhcmdldCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX29uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0YXJnZXQgJiYgdGhpcy5jaGFuZ2VUYXJnZXQodGFyZ2V0KTtcbiAgfVxuXG4gIGNoYW5nZVRhcmdldCh0YXJnZXQpIHtcbiAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBbJ3BvcnRyYWl0JywgJ2xhbmRzY2FwZSddLmluZGV4T2YodGFyZ2V0KSAhPT0gLTE7XG4gICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX21hdGNoKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX29yaWVudGF0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0ID09PSAodmFsdWUuaXNQb3J0cmFpdCA/ICdwb3J0cmFpdCcgOiAnbGFuZHNjYXBlJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5tYXRjaGVzO1xuICB9XG5cbiAgX29uQ2hhbmdlKHZhbHVlKSB7XG4gICAgdGhpcy5fZWxlbWVudC5fdXBkYXRlTW9kZSh0aGlzLl9tYXRjaCh2YWx1ZSkgPyBDT0xMQVBTRV9NT0RFIDogU1BMSVRfTU9ERSk7XG4gIH1cblxuICBhY3RpdmF0ZSgpIHtcbiAgICBpZiAodGhpcy5fb3JpZW50YXRpb24pIHtcbiAgICAgIG9yaWVudGF0aW9uLm9uKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgICB0aGlzLl9vbkNoYW5nZSh7aXNQb3J0cmFpdDogb3JpZW50YXRpb24uaXNQb3J0cmFpdCgpfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0ID0gd2luZG93Lm1hdGNoTWVkaWEodGhpcy5fdGFyZ2V0KTtcbiAgICAgIHRoaXMuX3F1ZXJ5UmVzdWx0LmFkZExpc3RlbmVyKHRoaXMuX29uQ2hhbmdlKTtcbiAgICAgIHRoaXMuX29uQ2hhbmdlKHRoaXMuX3F1ZXJ5UmVzdWx0KTtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgb3JpZW50YXRpb24ub2ZmKCdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9xdWVyeVJlc3VsdCkge1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQucmVtb3ZlTGlzdGVuZXIodGhpcy5fb25DaGFuZ2UpO1xuICAgICAgdGhpcy5fcXVlcnlSZXN1bHQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5jb25zdCB3aWR0aFRvUHggPSAod2lkdGgsIHBhcmVudCkgPT4ge1xuICBjb25zdCBbdmFsdWUsIHB4XSA9IFtwYXJzZUludCh3aWR0aCwgMTApLCAvcHgvLnRlc3Qod2lkdGgpXTtcbiAgcmV0dXJuIHB4ID8gdmFsdWUgOiBNYXRoLnJvdW5kKHBhcmVudC5vZmZzZXRXaWR0aCAqIHZhbHVlIC8gMTAwKTtcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXNwbGl0dGVyLXNpZGVcbiAqIEBjYXRlZ29yeSBtZW51XG4gKiBAZGVzY3JpcHRpb25cbiAqICBbZW5dXG4gKiAgICBUaGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQgaXMgdXNlZCBhcyBhIGNoaWxkIGVsZW1lbnQgb2YgYDxvbnMtc3BsaXR0ZXI+YC5cbiAqXG4gKiAgICBJdCB3aWxsIGJlIGRpc3BsYXllZCBvbiBlaXRoZXIgdGhlIGxlZnQgb3IgcmlnaHQgc2lkZSBvZiB0aGUgYDxvbnMtc3BsaXR0ZXItY29udGVudD5gIGVsZW1lbnQuXG4gKlxuICogICAgSXQgc3VwcG9ydHMgdHdvIG1vZGVzOiBjb2xsYXBzZWQgYW5kIHNwbGl0LiBXaGVuIGl0J3MgaW4gY29sbGFwc2VkIG1vZGUgaXQgd2lsbCBiZSBoaWRkZW4gZnJvbSB2aWV3IGFuZCBjYW4gYmUgZGlzcGxheWVkIHdoZW4gdGhlIHVzZXIgc3dpcGVzIHRoZSBzY3JlZW4gb3IgdGFwcyBhIGJ1dHRvbi4gSW4gc3BsaXQgbW9kZSB0aGUgZWxlbWVudCBpcyBhbHdheXMgc2hvd24uIEl0IGNhbiBiZSBjb25maWd1cmVkIHRvIGF1dG9tYXRpY2FsbHkgc3dpdGNoIGJldHdlZW4gdGhlIHR3byBtb2RlcyBkZXBlbmRpbmcgb24gdGhlIHNjcmVlbiBzaXplLlxuICogIFsvZW5dXG4gKiAgW2phXW9ucy1zcGxpdHRlci1zaWRl6KaB57Sg44Gv44CBb25zLXNwbGl0dGVy6KaB57Sg44Gu5a2Q6KaB57Sg44Go44GX44Gm5Yip55So44GX44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHJPUU9NTFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3NwbGl0dGVyXG4gKiBAZ3VpZGUgZnVuZGFtZW50YWxzLmh0bWwjbWFuYWdpbmctcGFnZXNcbiAqICBbZW5dTWFuYWdpbmcgbXVsdGlwbGUgcGFnZXMuWy9lbl1cbiAqICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1zcGxpdHRlclxuICogIFtlbl1UaGUgYDxvbnMtc3BsaXR0ZXI+YCBpcyB0aGUgcGFyZW50IGNvbXBvbmVudC5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXNwbGl0dGVyLWNvbnRlbnRcbiAqICBbZW5dVGhlIGA8b25zLXNwbGl0dGVyLWNvbnRlbnQ+YCBjb21wb25lbnQgY29udGFpbnMgdGhlIG1haW4gY29udGVudCBvZiB0aGUgcGFnZS5bL2VuXVxuICogIFtqYV1vbnMtc3BsaXR0ZXItY29udGVudOOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zcGxpdHRlcj5cbiAqICAgPG9ucy1zcGxpdHRlci1jb250ZW50PlxuICogICAgIC4uLlxuICogICA8L29ucy1zcGxpdHRlci1jb250ZW50PlxuICpcbiAqICAgPG9ucy1zcGxpdHRlci1zaWRlIHNpZGU9XCJsZWZ0XCIgd2lkdGg9XCI4MCVcIiBjb2xsYXBzZT5cbiAqICAgICAuLi5cbiAqICAgPC9vbnMtc3BsaXR0ZXItc2lkZT5cbiAqIDwvb25zLXNwbGl0dGVyPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGxpdHRlclNpZGVFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgbW9kZWNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZWQganVzdCBhZnRlciB0aGUgY29tcG9uZW50J3MgbW9kZSBjaGFuZ2VzLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBruODouODvOODieOBjOWkieWMluOBl+OBn+mam+OBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQubW9kZVxuICAgKiAgIFtlbl1SZXR1cm5zIHRoZSBjdXJyZW50IG1vZGUuIENhbiBiZSBlaXRoZXIgYFwiY29sbGFwc2VcImAgb3IgYFwic3BsaXRcImAuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Gu44Oi44O844OJ44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwcmVvcGVuXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlZCBqdXN0IGJlZm9yZSB0aGUgc2xpZGluZyBtZW51IGlzIG9wZW5lZC5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgY/liY3jgavnmbrngavjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogICBbZW5dRXZlbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOCquODluOCuOOCp+OCr+ODiOOBp+OBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmNhbmNlbFxuICAgKiAgIFtlbl1DYWxsIHRvIGNhbmNlbCBvcGVuaW5nIHNsaWRpbmcgbWVudS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6njgqTjg4fjgqPjg7PjgrDjg6Hjg4vjg6Xjg7zjgYzplovjgY/jga7jgpLjgq3jg6Pjg7Pjgrvjg6vjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdG9wZW5cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHNsaWRpbmcgbWVudSBpcyBvcGVuZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaL44GE44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlY2xvc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYmVmb3JlIHRoZSBzbGlkaW5nIG1lbnUgaXMgY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOBjOmWieOBmOOCi+WJjeOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44Gn44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnNpZGVcbiAgICogICBbZW5dQ29tcG9uZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgrPjg7Pjg53jg7zjg43jg7Pjg4jjga7jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0byBjYW5jZWwgb3BlbmluZyBzbGlkaW5nLW1lbnUuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44KL44Gu44KS44Kt44Oj44Oz44K744Or44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBldmVudCBwb3N0Y2xvc2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIGp1c3QgYWZ0ZXIgdGhlIHNsaWRpbmcgbWVudSBpcyBjbG9zZWQuWy9lbl1cbiAgICogICBbamFd44K544Op44Kk44OH44Kj44Oz44Kw44Oh44OL44Ol44O844GM6ZaJ44GY44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgafjgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc2lkZVxuICAgKiAgIFtlbl1Db21wb25lbnQgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCs+ODs+ODneODvOODjeODs+ODiOOBruOCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCAgZGVmYXVsdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24uIFVzZSBvbmUgb2YgYG92ZXJsYXlgLCBgcHVzaGAsIGByZXZlYWxgIG9yICBgZGVmYXVsdGAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PjgpLmjIflrprjgZfjgb7jgZnjgIJcIm92ZXJsYXlcIiwgXCJwdXNoXCIsIFwicmV2ZWFsXCIsIFwiZGVmYXVsdFwi44Gu44GE44Ga44KM44GL44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG9wZW4tdGhyZXNob2xkXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqIEBkZWZhdWx0ICAwLjNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dU3BlY2lmeSBob3cgbXVjaCB0aGUgbWVudSBuZWVkcyB0byBiZSBzd2lwZWQgYmVmb3JlIG9wZW5pbmcuIEEgdmFsdWUgYmV0d2VlbiBgMGAgYW5kIGAxYC5bL2VuXVxuICAgKiAgW2phXeOBqeOBruOBj+OCieOBhOOCueODr+OCpOODl+OBmeOCjOOBsOOCueODqeOCpOODh+OCo+ODs+OCsOODoeODi+ODpeODvOOCkumWi+OBj+OBi+OBqeOBhuOBi+OBruWJsuWQiOOCkuaMh+WumuOBl+OBvuOBmeOAgjDjgYvjgokx44Gu6ZaT44Gu5pWw5YCk44KS5oyH5a6a44GX44G+44GZ44CC44K544Ov44Kk44OX44Gu6Led6Zui44GM44GT44GT44Gn5oyH5a6a44GX44Gf5pWw5YCk5o6b44GR44KL44GT44Gu6KaB57Sg44Gu5bmF44KI44KK44KC5aSn44GN44GR44KM44Gw44CB44K544Ov44Kk44OX44GM57WC44KP44Gj44Gf5pmC44Gr44GT44Gu6KaB57Sg44KS6ZaL44GN44G+44GZ44CC44OH44OV44Kp44Or44OI44GvMC4z44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY29sbGFwc2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgU3BlY2lmeSB0aGUgY29sbGFwc2UgYmVoYXZpb3IuIFZhbGlkIHZhbHVlcyBhcmUgYFwicG9ydHJhaXRcImAsIGBcImxhbmRzY2FwZVwiYCBvciBhIG1lZGlhIHF1ZXJ5LlxuICAgKiAgICAgVGhlIHN0cmluZ3MgYFwicG9ydHJhaXRcImAgYW5kIGBcImxhbmRzY2FwZVwiYCBtZWFucyB0aGUgdmlldyB3aWxsIGNvbGxhcHNlIHdoZW4gZGV2aWNlIGlzIGluIGxhbmRzY2FwZSBvciBwb3J0cmFpdCBvcmllbnRhdGlvbi5cbiAgICogICAgIElmIHRoZSB2YWx1ZSBpcyBhIG1lZGlhIHF1ZXJ5LCB0aGUgdmlldyB3aWxsIGNvbGxhcHNlIHdoZW4gdGhlIG1lZGlhIHF1ZXJ5IHJlc29sdmVzIHRvIGB0cnVlYC5cbiAgICogICAgIElmIHRoZSB2YWx1ZSBpcyBub3QgZGVmaW5lZCwgdGhlIHZpZXcgYWx3YXlzIGJlIGluIGBcImNvbGxhcHNlXCJgIG1vZGUuXG4gICAqICAgWy9lbl1cbiAgICogICBbamFdXG4gICAqICAgICDlt6blgbTjga7jg5rjg7zjgrjjgpLpnZ7ooajnpLrjgavjgZnjgovmnaHku7bjgpLmjIflrprjgZfjgb7jgZnjgIJwb3J0cmFpdCwgbGFuZHNjYXBl44CBd2lkdGggI3B444KC44GX44GP44Gv44Oh44OH44Kj44Ki44Kv44Ko44Oq44Gu5oyH5a6a44GM5Y+v6IO944Gn44GZ44CCXG4gICAqICAgICBwb3J0cmFpdOOCguOBl+OBj+OBr2xhbmRzY2FwZeOCkuaMh+WumuOBmeOCi+OBqOOAgeODh+ODkOOCpOOCueOBrueUu+mdouOBjOe4puWQkeOBjeOCguOBl+OBj+OBr+aoquWQkeOBjeOBq+OBquOBo+OBn+aZguOBq+mBqeeUqOOBleOCjOOBvuOBmeOAglxuICAgKiAgICAg44Oh44OH44Kj44Ki44Kv44Ko44Oq44KS5oyH5a6a44GZ44KL44Go44CB5oyH5a6a44GX44Gf44Kv44Ko44Oq44Gr6YGp5ZCI44GX44Gm44GE44KL5aC05ZCI44Gr6YGp55So44GV44KM44G+44GZ44CCXG4gICAqICAgICDlgKTjgavkvZXjgoLmjIflrprjgZfjgarjgYTloLTlkIjjgavjga/jgIHluLjjgatjb2xsYXBzZeODouODvOODieOBq+OBquOCiuOBvuOBmeOAglxuICAgKiAgIFsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHN3aXBlLXRhcmdldC13aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhlIHdpZHRoIG9mIHN3aXBlYWJsZSBhcmVhIGNhbGN1bGF0ZWQgZnJvbSB0aGUgZWRnZSAoaW4gcGl4ZWxzKS4gVXNlIHRoaXMgdG8gZW5hYmxlIHN3aXBlIG9ubHkgd2hlbiB0aGUgZmluZ2VyIHRvdWNoIG9uIHRoZSBzY3JlZW4gZWRnZS5bL2VuXVxuICAgKiAgIFtqYV3jgrnjg6/jgqTjg5fjga7liKTlrprpoJjln5/jgpLjg5Tjgq/jgrvjg6vljZjkvY3jgafmjIflrprjgZfjgb7jgZnjgILnlLvpnaLjga7nq6/jgYvjgonmjIflrprjgZfjgZ/ot53pm6LjgavpgZTjgZnjgovjgajjg5rjg7zjgrjjgYzooajnpLrjgZXjgozjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSB3aWR0aFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ2FuIGJlIHNwZWNpZmllZCBpbiBlaXRoZXIgcGl4ZWxzIG9yIGFzIGEgcGVyY2VudGFnZSwgZS5nLiBgOTAlYCBvciBgMjAwcHhgLlsvZW5dXG4gICAqICAgW2phXeOBk+OBruimgee0oOOBruaoquW5heOCkuaMh+WumuOBl+OBvuOBmeOAgnB444GoJeOBp+OBruaMh+WumuOBjOWPr+iDveOBp+OBmeOAgmVnLiA5MCUsIDIwMHB4Wy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc2lkZVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBsZWZ0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1TcGVjaWZ5IHdoaWNoIHNpZGUgb2YgdGhlIHNjcmVlbiB0aGUgYDxvbnMtc3BsaXR0ZXItc2lkZT5gIGVsZW1lbnQgaXMgbG9jYXRlZC4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJsZWZ0XCJgIGFuZCBgXCJyaWdodFwiYC5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDjgYzlt6bjgYvlj7PjgYvjgpLmjIflrprjgZfjgb7jgZnjgILmjIflrprjgafjgY3jgovlgKTjga9cImxlZnRcIuOBi1wicmlnaHRcIuOBruOBv+OBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIG1vZGVcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUN1cnJlbnQgbW9kZS4gUG9zc2libGUgdmFsdWVzIGFyZSBgXCJjb2xsYXBzZVwiYCBvciBgXCJzcGxpdFwiYC4gVGhpcyBhdHRyaWJ1dGUgaXMgcmVhZCBvbmx5LlsvZW5dXG4gICAqICAgW2phXeePvuWcqOOBruODouODvOODieOBjOioreWumuOBleOCjOOBvuOBmeOAglwiY29sbGFwc2VcIuOCguOBl+OBj+OBr1wic3BsaXRcIuOBjOaMh+WumuOBleOCjOOBvuOBmeOAguOBk+OBruWxnuaAp+OBr+iqreOBv+i+vOOBv+WwgueUqOOBp+OBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHBhZ2VcbiAgICogQGluaXRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgVVJMIG9mIHRoZSBtZW51IHBhZ2UuWy9lbl1cbiAgICogICBbamFdb25zLXNwbGl0dGVyLXNpZGXopoHntKDjgavooajnpLrjgZnjgovjg5rjg7zjgrjjga5VUkzjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBzd2lwZWFibGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRvIGVuYWJsZSBzd2lwZSBpbnRlcmFjdGlvbiBvbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAqICAgW2phXWNvbGxhcHNl44Oi44O844OJ5pmC44Gr44K544Ov44Kk44OX5pON5L2c44KS5pyJ5Yq544Gr44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX3BhZ2UgPSBudWxsO1xuICAgIHRoaXMuX3N0YXRlID0gQ0xPU0VEX1NUQVRFO1xuICAgIHRoaXMuX2xvY2sgPSBuZXcgRG9vckxvY2soKTtcbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gZGVmYXVsdFBhZ2VMb2FkZXI7XG4gICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24gPSBuZXcgQ29sbGFwc2VEZXRlY3Rpb24odGhpcyk7XG5cbiAgICB0aGlzLl9hbmltYXRvckZhY3RvcnkgPSBuZXcgQW5pbWF0b3JGYWN0b3J5KHtcbiAgICAgIGFuaW1hdG9yczogU3BsaXR0ZXJFbGVtZW50LmFuaW1hdG9ycyxcbiAgICAgIGJhc2VDbGFzczogU3BsaXR0ZXJBbmltYXRvcixcbiAgICAgIGJhc2VDbGFzc05hbWU6ICdTcGxpdHRlckFuaW1hdG9yJyxcbiAgICAgIGRlZmF1bHRBbmltYXRpb246IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKVxuICAgIH0pO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIC8vIFRoZXNlIGF0dHJpYnV0ZXMgYXJlIHVzZWQgZWFybHkgYnkgdGhlIHBhcmVudCBlbGVtZW50XG4gICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnd2lkdGgnKTtcbiAgICAgIGlmICghdGhpcy5oYXNBdHRyaWJ1dGUoJ3NpZGUnKSkge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnc2lkZScsICdsZWZ0Jyk7XG4gICAgICB9XG5cbiAgICAgIHJld3JpdGFibGVzLnJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFnZSA9IHRoaXMuX3BhZ2UgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhZ2UnKTtcbiAgICAgICAgcGFnZSAmJiB0aGlzLmxvYWQocGFnZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGlmICghdXRpbC5tYXRjaCh0aGlzLnBhcmVudE5vZGUsICdvbnMtc3BsaXR0ZXInKSkge1xuICAgICAgdXRpbC50aHJvdygnUGFyZW50IG11c3QgYmUgYW4gb25zLXNwbGl0dGVyIGVsZW1lbnQnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zd2lwZSA9IG5ldyBTd2lwZVJldmVhbCh7XG4gICAgICBlbGVtZW50OiB0aGlzLFxuICAgICAgZWxlbWVudEhhbmRsZXI6IHRoaXMucGFyZW50RWxlbWVudCxcbiAgICAgIHN3aXBlTWF4OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZSgxLCB0aGlzLl9hbmltYXRpb25PcHQpO1xuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgIH0sXG4gICAgICBzd2lwZU1pZDogKGRpc3RhbmNlLCB3aWR0aCkgPT4ge1xuICAgICAgICB0aGlzLl9vblN3aXBlICYmIHRoaXMuX29uU3dpcGUoZGlzdGFuY2Uvd2lkdGgpO1xuICAgICAgICB0aGlzLl9hbmltYXRvci50cmFuc2xhdGUoZGlzdGFuY2UpO1xuICAgICAgfSxcbiAgICAgIHN3aXBlTWluOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX29uU3dpcGUgJiYgdGhpcy5fb25Td2lwZSgwLCB0aGlzLl9hbmltYXRpb25PcHQpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9LFxuICAgICAgZ2V0VGhyZXNob2xkOiAoKSA9PiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdvcGVuLXRocmVzaG9sZCcpKSB8fCAwLjMpKSxcbiAgICAgIGdldFNpZGU6ICgpID0+IHRoaXMuc2lkZSxcbiAgICAgIGlzSW5pdGlhbFN0YXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsb3NlZCA9IHRoaXMuX3N0YXRlID09PSBDTE9TRURfU1RBVEU7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gQ0hBTkdJTkdfU1RBVEU7XG4gICAgICAgIHJldHVybiBjbG9zZWQ7XG4gICAgICB9LFxuICAgICAgaWdub3JlU3dpcGU6IChldmVudCwgZGlzdGFuY2UpID0+IHtcbiAgICAgICAgY29uc3QgaXNPcGVuID0gdGhpcy5pc09wZW47XG4gICAgICAgIGNvbnN0IHZhbGlkRHJhZyA9IGQgPT4gdGhpcy5zaWRlID09PSAnbGVmdCdcbiAgICAgICAgICA/ICgoZCA9PT0gJ2xlZnQnICYmIGlzT3BlbikgfHwgKGQgPT09ICdyaWdodCcgJiYgIWlzT3BlbikpXG4gICAgICAgICAgOiAoKGQgPT09ICdsZWZ0JyAmJiAhaXNPcGVuKSB8fCAoZCA9PT0gJ3JpZ2h0JyAmJiBpc09wZW4pKTtcblxuICAgICAgICBjb25zdCBhcmVhID0gTWF0aC5tYXgoMCwgcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3N3aXBlLXRhcmdldC13aWR0aCcpLCAxMCkgfHwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGUgPT09IFNQTElUX01PREUgfHwgdGhpcy5fbG9jay5pc0xvY2tlZCgpIHx8IHRoaXMuX2lzT3RoZXJTaWRlT3BlbigpXG4gICAgICAgICAgfHwgIXZhbGlkRHJhZyhldmVudC5nZXN0dXJlLmRpcmVjdGlvbilcbiAgICAgICAgICB8fCAoIWlzT3BlbiAmJiBhcmVhICE9PSAwICYmIGRpc3RhbmNlID4gYXJlYSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygnc3dpcGVhYmxlJyk7XG5cbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5vYnNlcnZlZEF0dHJpYnV0ZXMuZm9yRWFjaChhdHRyID0+IHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpKSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgc2lkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ3NpZGUnKSA9PT0gJ3JpZ2h0JyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9zd2lwZSAmJiB0aGlzLl9zd2lwZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5fYW5pbWF0b3IgPSB0aGlzLl9hbmltYXRpb25PcHQgPSB0aGlzLl9zd2lwZSA9IG51bGw7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWydhbmltYXRpb24nLCAnd2lkdGgnLCAnY29sbGFwc2UnLCAnc3dpcGVhYmxlJywgJ2FuaW1hdGlvbi1vcHRpb25zJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnc3dpcGVhYmxlJzpcbiAgICAgICAgdGhpcy5fc3dpcGUgJiYgdGhpcy5fc3dpcGUudXBkYXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICBjdXJyZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7IC8vIFNvbWV0aW1lcyB1bmRlZmluZWQuIENFIGJ1Zz9cbiAgICAgICAgdGhpcy5zdHlsZS53aWR0aCA9IC9eXFxkKyhweHwlKSQvLnRlc3QoY3VycmVudCkgPyBjdXJyZW50IDogJzgwJSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpc1t1dGlsLmNhbWVsaXplKGBfdXBkYXRlLSR7bmFtZX1gKV0oY3VycmVudCk7XG4gICAgfVxuICB9XG5cbiAgX2VtaXRFdmVudChuYW1lKSB7XG4gICAgaWYgKG5hbWUuc2xpY2UoMCwgMykgIT09ICdwcmUnKSB7XG4gICAgICByZXR1cm4gdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsIG5hbWUsIHtzaWRlOiB0aGlzfSk7XG4gICAgfVxuICAgIGxldCBpc0NhbmNlbGVkID0gZmFsc2U7XG5cbiAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgbmFtZSwge1xuICAgICAgc2lkZTogdGhpcyxcbiAgICAgIGNhbmNlbDogKCkgPT4gaXNDYW5jZWxlZCA9IHRydWVcbiAgICB9KTtcblxuICAgIHJldHVybiBpc0NhbmNlbGVkO1xuICB9XG5cbiAgX2lzT3RoZXJTaWRlT3BlbigpIHtcbiAgICByZXR1cm4gISF1dGlsLmZpbmRDaGlsZCh0aGlzLnBhcmVudEVsZW1lbnQsXG4gICAgICBlbCA9PiBlbCBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IgJiYgZWwgIT09IHRoaXMgJiYgZWwuX21vZGUgPT09IENPTExBUFNFX01PREUgJiYgZWwuaXNPcGVuXG4gICAgKTtcbiAgfVxuXG4gIF91cGRhdGVDb2xsYXBzZSh2YWx1ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjb2xsYXBzZScpKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnc3BsaXQnKSB7XG4gICAgICB0aGlzLl9jb2xsYXBzZURldGVjdGlvbi5kaXNhYmxlKCk7XG4gICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTW9kZShTUExJVF9NT0RFKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJ2NvbGxhcHNlJykge1xuICAgICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uZGlzYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU1vZGUoQ09MTEFQU0VfTU9ERSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY29sbGFwc2VEZXRlY3Rpb24uY2hhbmdlVGFyZ2V0KHZhbHVlKTtcbiAgfVxuXG4gIF91cGRhdGVNb2RlKG1vZGUpIHtcbiAgICBpZiAobW9kZSAhPT0gdGhpcy5fbW9kZSkge1xuICAgICAgdGhpcy5fbW9kZSA9IG1vZGU7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnbW9kZScsIG1vZGUpOyAvLyByZWFkb25seSBhdHRyaWJ1dGUgZm9yIHRoZSB1c2Vyc1xuXG4gICAgICBpZiAobW9kZSA9PT0gU1BMSVRfTU9ERSkge1xuICAgICAgICB0aGlzLl9hbmltYXRvciAmJiB0aGlzLl9hbmltYXRvci5kZWFjdGl2YXRlKCk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gQ0xPU0VEX1NUQVRFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0b3IgJiYgdGhpcy5fYW5pbWF0b3IuYWN0aXZhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuX3N0YXRlID09PSBPUEVOX1NUQVRFICYmIHRoaXMuX2FuaW1hdG9yLm9wZW4oKTtcbiAgICAgIH1cblxuICAgICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdtb2RlY2hhbmdlJywgeyBzaWRlOiB0aGlzLCBtb2RlIH0pO1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVBbmltYXRpb24oYW5pbWF0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbicpKSB7XG4gICAgaWYodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLl9hbmltYXRvciAmJiB0aGlzLl9hbmltYXRvci5kZWFjdGl2YXRlKCk7XG4gICAgICB0aGlzLl9hbmltYXRvciA9IHRoaXMuX2FuaW1hdG9yRmFjdG9yeS5uZXdBbmltYXRvcih7YW5pbWF0aW9ufSk7XG4gICAgICB0aGlzLl9hbmltYXRvci5hY3RpdmF0ZSh0aGlzKTtcbiAgICAgIHRoaXMuX2FuaW1hdGlvbk9wdCA9IHtcbiAgICAgICAgdGltaW5nOiB0aGlzLl9hbmltYXRvci5kdXJhdGlvbixcbiAgICAgICAgZHVyYXRpb246IHRoaXMuX2FuaW1hdG9yLmR1cmF0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVBbmltYXRpb25PcHRpb25zKHZhbHVlID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FuaW1hdGlvbi1vcHRpb25zJykpIHtcbiAgICB0aGlzLl9hbmltYXRvci51cGRhdGVPcHRpb25zKEFuaW1hdG9yRmFjdG9yeS5wYXJzZUFuaW1hdGlvbk9wdGlvbnNTdHJpbmcodmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgcGFnZVxuICAgKiBAdHlwZSB7Kn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVBhZ2UgbG9jYXRpb24gdG8gbG9hZCBpbiB0aGUgc3BsaXR0ZXIgc2lkZS5bL2VuXVxuICAgKiAgIFtqYV3jgZPjga7opoHntKDlhoXjgavooajnpLrjgZnjgovjg5rjg7zjgrjjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2U7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBwYWdlXG4gICAqL1xuICBzZXQgcGFnZShwYWdlKSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gIH1cblxuICBnZXQgX2NvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF07XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHBhZ2VMb2FkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgcGFnZUxvYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUxvYWRlcjtcbiAgfVxuXG4gIHNldCBwYWdlTG9hZGVyKGxvYWRlcikge1xuICAgIGlmICghKGxvYWRlciBpbnN0YW5jZW9mIFBhZ2VMb2FkZXIpKSB7XG4gICAgICB1dGlsLnRocm93UGFnZUxvYWRlcigpO1xuICAgIH1cbiAgICB0aGlzLl9wYWdlTG9hZGVyID0gbG9hZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBtb2RlXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dQ3VycmVudCBtb2RlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwic3BsaXRcIiwgXCJjb2xsYXBzZVwiLCBcImNsb3NlZFwiLCBcIm9wZW5cIiBvciBcImNoYW5naW5nXCIuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBtb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvblN3aXBlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhvb2sgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIHNsaWRlcyB0aGUgc3BsaXR0ZXIuIEl0IGdldHMgYSBkZWNpbWFsIHJhdGlvICgwLTEpIGFuZCBhbiBhbmltYXRpb25PcHRpb25zIG9iamVjdCBhcyBhcmd1bWVudHMuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGdldCBvblN3aXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9vblN3aXBlO1xuICB9XG5cbiAgc2V0IG9uU3dpcGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkge1xuICAgICAgdXRpbC50aHJvdygnXCJvblN3aXBlXCIgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG4gICAgdGhpcy5fb25Td2lwZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBpc09wZW5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEByZWFkb25seVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dVGhpcyB2YWx1ZSBpcyBgdHJ1ZWAgd2hlbiB0aGUgbWVudSBpcyBvcGVuLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlID09PSBDT0xMQVBTRV9NT0RFICYmIHRoaXMuX3N0YXRlICE9PSBDTE9TRURfU1RBVEU7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBvcGVuXG4gICAqIEBzaWduYXR1cmUgb3Blbihbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5jYWxsYmFja11cbiAgICogICBbZW5dVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgbWVudSBoYXMgYmVlbiBvcGVuZWQuWy9lbl1cbiAgICogICBbamFd44Oh44OL44Ol44O844GM6ZaL44GE44Gf5b6M44Gr5ZG844Gz5Ye644GV44KM44KL6Zai5pWw44Kq44OW44K444Kn44Kv44OI44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXU9wZW4gbWVudSBpbiBjb2xsYXBzZSBtb2RlLlsvZW5dXG4gICAqICAgW2phXWNvbGxhcHNl44Oi44O844OJ44Gr44Gq44Gj44Gm44GE44KLb25zLXNwbGl0dGVyLXNpZGXopoHntKDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIG9wZW4ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZShvcHRpb25zLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNsb3NlXG4gICAqIEBzaWduYXR1cmUgY2xvc2UoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXVRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIG1lbnUgaGFzIGJlZW4gY2xvc2VkLlsvZW5dXG4gICAqICAgW2phXeODoeODi+ODpeODvOOBjOmWieOBmOOBn+W+jOOBq+WRvOOBs+WHuuOBleOCjOOCi+mWouaVsOOCquODluOCuOOCp+OCr+ODiOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1DbG9zZSBtZW51IGluIGNvbGxhcHNlIG1vZGUuWy9lbl1cbiAgICogICBbamFdY29sbGFwc2Xjg6Ljg7zjg4njgavjgarjgaPjgabjgYTjgotvbnMtc3BsaXR0ZXItc2lkZeimgee0oOOCkumWieOBmOOBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBzcGxpdHRlciBzaWRlIGVsZW1lbnQgb3IgZmFsc2UgaWYgbm90IGluIGNvbGxhcHNlIG1vZGVbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cbiAgY2xvc2Uob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZShvcHRpb25zLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1PcGVucyBpZiBpdCdzIGNsb3NlZC4gQ2xvc2VzIGlmIGl0J3Mgb3Blbi5bL2VuXVxuICAgKiAgIFtqYV3plovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplonjgZjjgb7jgZnjgZ3jgZfjgabplovjgZHjgabjgYTjgovloLTlkIjjga/opoHntKDjgpLplovjgY3jgb7jgZnjgIJbL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgc3BsaXR0ZXIgc2lkZSBlbGVtZW50IG9yIGZhbHNlIGlmIG5vdCBpbiBjb2xsYXBzZSBtb2RlWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHRvZ2dsZShvcHRpb25zID0ge30sIGZvcmNlKSB7XG4gICAgY29uc3Qgc2hvdWxkT3BlbiA9IHR5cGVvZiBmb3JjZSA9PT0gJ2Jvb2xlYW4nID8gZm9yY2UgOiAhdGhpcy5pc09wZW47XG4gICAgY29uc3QgYWN0aW9uID0gc2hvdWxkT3BlbiA/ICdvcGVuJyA6ICdjbG9zZScsXG4gICAgICBGSU5BTF9TVEFURSA9IHNob3VsZE9wZW4gPyBPUEVOX1NUQVRFIDogQ0xPU0VEX1NUQVRFO1xuXG4gICAgaWYgKHRoaXMuX21vZGUgPT09IFNQTElUX01PREUpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IEZJTkFMX1NUQVRFKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbG9jay5pc0xvY2tlZCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0Fub3RoZXIgc3BsaXR0ZXItc2lkZSBhY3Rpb24gaXMgYWxyZWFkeSBydW5uaW5nLicpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkT3BlbiAmJiB0aGlzLl9pc090aGVyU2lkZU9wZW4oKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdBbm90aGVyIG1lbnUgaXMgYWxyZWFkeSBvcGVuLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZW1pdEV2ZW50KGBwcmUke2FjdGlvbn1gKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBDYW5jZWxlZCBpbiBwcmUke2FjdGlvbn0gZXZlbnQuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgdW5sb2NrID0gdGhpcy5fbG9jay5sb2NrKCk7XG4gICAgdGhpcy5fc3RhdGUgPSBDSEFOR0lOR19TVEFURTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMuX2FuaW1hdG9yW2FjdGlvbl0oKCkgPT4ge1xuICAgICAgICB1dGlsLmlvc1BhZ2VTY3JvbGxGaXgoc2hvdWxkT3Blbik7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gRklOQUxfU1RBVEU7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgICB0aGlzLl9lbWl0RXZlbnQoYHBvc3Qke2FjdGlvbn1gKTtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9wdGlvbnMuY2FsbGJhY2sodGhpcyk7XG4gICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGxvYWRcbiAgICogQHNpZ25hdHVyZSBsb2FkKHBhZ2UsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhZ2VcbiAgICogICBbZW5dUGFnZSBVUkwuIENhbiBiZSBlaXRoZXIgYW4gSFRNTCBkb2N1bWVudCBvciBhIGA8dGVtcGxhdGU+YC5bL2VuXVxuICAgKiAgIFtqYV1wYWdl44GuVVJM44GL44CBYDx0ZW1wbGF0ZT5g44Gn5a6j6KiA44GX44Gf44OG44Oz44OX44Os44O844OI44GuaWTlsZ7mgKfjga7lgKTjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmNhbGxiYWNrXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgcGFnZSBzcGVjaWZpZWQgaW4gcGFnZVVybCBpbiB0aGUgcmlnaHQgc2VjdGlvblsvZW5dXG4gICAqICAgW2phXeaMh+WumuOBl+OBn1VSTOOCkuODoeOCpOODs+ODmuODvOOCuOOCkuiqreOBv+i+vOOBv+OBvuOBmeOAglsvamFdXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqICAgW2VuXVJlc29sdmVzIHRvIHRoZSBuZXcgcGFnZSBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIGxvYWQocGFnZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fcGFnZSA9IHBhZ2U7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8ICgoKSA9PiB7fSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgb2xkQ29udGVudCA9IHRoaXMuX2NvbnRlbnQgfHwgbnVsbDtcblxuICAgICAgdGhpcy5fcGFnZUxvYWRlci5sb2FkKHtwYWdlLCBwYXJlbnQ6IHRoaXN9LCBwYWdlRWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChvbGRDb250ZW50KSB7XG4gICAgICAgICAgdGhpcy5fcGFnZUxvYWRlci51bmxvYWQob2xkQ29udGVudCk7XG4gICAgICAgICAgb2xkQ29udGVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc2hvdygpKTtcblxuICAgICAgICBjYWxsYmFjayhwYWdlRWxlbWVudCk7XG4gICAgICAgIHJlc29sdmUocGFnZUVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fY29udGVudC5fc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKCkge1xuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9jb250ZW50Ll9oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2Rlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRlbnQpIHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMuX2NvbnRlbnQpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBldmVudHMoKSB7XG4gICAgcmV0dXJuIFsncHJlb3BlbicsICdwb3N0b3BlbicsICdwcmVjbG9zZScsICdwb3N0Y2xvc2UnLCAnbW9kZWNoYW5nZSddO1xuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cbn1cblxub25zRWxlbWVudHMuU3BsaXR0ZXJTaWRlID0gU3BsaXR0ZXJTaWRlRWxlbWVudDtcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnb25zLXNwbGl0dGVyLXNpZGUnLCBTcGxpdHRlclNpZGVFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VDaGVja2JveEVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtY2hlY2tib3gnO1xuaW1wb3J0IGNvbnRlbnRSZWFkeSBmcm9tICcuLi9vbnMvY29udGVudC1yZWFkeSc7XG5pbXBvcnQgR2VzdHVyZURldGVjdG9yIGZyb20gJy4uL29ucy9nZXN0dXJlLWRldGVjdG9yJztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnJzogJ3N3aXRjaC0tKicsXG4gICcuc3dpdGNoX19pbnB1dCc6ICdzd2l0Y2gtLSpfX2lucHV0JyxcbiAgJy5zd2l0Y2hfX2hhbmRsZSc6ICdzd2l0Y2gtLSpfX2hhbmRsZScsXG4gICcuc3dpdGNoX190b2dnbGUnOiAnc3dpdGNoLS0qX190b2dnbGUnXG59O1xuXG5jb25zdCBsb2NhdGlvbnMgPSB7XG4gIGlvczogWzEsIDIxXSxcbiAgbWF0ZXJpYWw6IFswLCAxNl1cbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXN3aXRjaFxuICogQGNhdGVnb3J5IGZvcm1cbiAqIEBkZXNjcmlwdGlvblxuICogICBbZW5dXG4gKiAgICAgU3dpdGNoIGNvbXBvbmVudC4gVGhlIHN3aXRjaCBjYW4gYmUgdG9nZ2xlZCBib3RoIGJ5IGRyYWdnaW5nIGFuZCB0YXBwaW5nLlxuICpcbiAqICAgICBXaWxsIGF1dG9tYXRpY2FsbHkgZGlzcGxheXMgYSBNYXRlcmlhbCBEZXNpZ24gc3dpdGNoIG9uIEFuZHJvaWQgZGV2aWNlcy5cbiAqICAgWy9lbl1cbiAqICAgW2phXeOCueOCpOODg+ODgeOCkuihqOekuuOBmeOCi+OCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAglsvamFdXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiBzd2l0Y2hbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBjb2RlcGVuIExwWFpRUVxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3N3aXRjaFxuICogQGd1aWRlIHRoZW1pbmcuaHRtbCNtb2RpZmllcnMgW2VuXU1vcmUgZGV0YWlscyBhYm91dCB0aGUgYG1vZGlmaWVyYCBhdHRyaWJ1dGVbL2VuXVtqYV1tb2RpZmllcuWxnuaAp+OBruS9v+OBhOaWuVsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy1zd2l0Y2ggY2hlY2tlZD48L29ucy1zd2l0Y2g+XG4gKiA8b25zLXN3aXRjaCBkaXNhYmxlZD48L29ucy1zd2l0Y2g+XG4gKiA8b25zLXN3aXRjaCBtb2RpZmllcj1cIm1hdGVyaWFsXCI+PC9vbnMtc3dpdGNoPlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN3aXRjaEVsZW1lbnQgZXh0ZW5kcyBCYXNlQ2hlY2tib3hFbGVtZW50IHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdtb2RpZmllcicsIG51bGwsIHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RpZmllcicpKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX29uQ2hhbmdlID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vblJlbGVhc2UgPSB0aGlzLl9vblJlbGVhc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9sYXN0VGltZVN0YW1wID0gMDtcbiAgfVxuXG4gIGdldCBfc2NoZW1lKCkge1xuICAgIHJldHVybiBzY2hlbWU7XG4gIH1cblxuICBnZXQgX2RlZmF1bHRDbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuICdzd2l0Y2gnO1xuICB9XG5cbiAgZ2V0IF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGlucHV0IHR5cGU9XCIke3RoaXMudHlwZX1cIiBjbGFzcz1cIiR7dGhpcy5fZGVmYXVsdENsYXNzTmFtZX1fX2lucHV0XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9fdG9nZ2xlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke3RoaXMuX2RlZmF1bHRDbGFzc05hbWV9X19oYW5kbGVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiJHt0aGlzLl9kZWZhdWx0Q2xhc3NOYW1lfV9fdG91Y2hcIj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuICdjaGVja2JveCc7XG4gIH1cblxuICAvKiBPd24gcHJvcHMgKi9cblxuICBfZ2V0UG9zaXRpb24oZSkge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9sb2NhdGlvbnM7XG4gICAgcmV0dXJuIE1hdGgubWluKGxbMV0sIE1hdGgubWF4KGxbMF0sIHRoaXMuX3N0YXJ0WCArIGUuZ2VzdHVyZS5kZWx0YVgpKTtcbiAgfVxuXG4gIF9lbWl0Q2hhbmdlRXZlbnQoKSB7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdjaGFuZ2UnLCB7XG4gICAgICB2YWx1ZTogdGhpcy5jaGVja2VkLFxuICAgICAgc3dpdGNoOiB0aGlzLFxuICAgICAgaXNJbnRlcmFjdGl2ZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgX29uQ2hhbmdlKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZW1pdENoYW5nZUV2ZW50KCk7XG4gIH1cblxuICBfb25DbGljayhldikge1xuICAgIGlmIChldi50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGAke3RoaXMuZGVmYXVsdEVsZW1lbnRDbGFzc31fX3RvdWNoYClcbiAgICAgIHx8IChldi50aW1lU3RhbXAgLSB0aGlzLl9sYXN0VGltZVN0YW1wIDwgNTApIC8vIFByZXZlbnQgc2Vjb25kIGNsaWNrIHRyaWdnZXJlZCBieSA8bGFiZWw+XG4gICAgKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0VGltZVN0YW1wID0gZXYudGltZVN0YW1wO1xuICB9XG5cbiAgX29uSG9sZChlKSB7XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICBNb2RpZmllclV0aWwuYWRkTW9kaWZpZXIodGhpcywgJ2FjdGl2ZScpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVsZWFzZScsIHRoaXMuX29uUmVsZWFzZSk7XG4gICAgfVxuICB9XG5cbiAgX29uRHJhZ1N0YXJ0KGUpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGUuZ2VzdHVyZS5kaXJlY3Rpb24pID09PSAtMSkge1xuICAgICAgTW9kaWZpZXJVdGlsLnJlbW92ZU1vZGlmaWVyKHRoaXMsICdhY3RpdmUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlLmNvbnN1bWVkID0gdHJ1ZTtcblxuICAgIE1vZGlmaWVyVXRpbC5hZGRNb2RpZmllcih0aGlzLCAnYWN0aXZlJyk7XG4gICAgdGhpcy5fc3RhcnRYID0gdGhpcy5fbG9jYXRpb25zW3RoaXMuY2hlY2tlZCA/IDEgOiAwXTsvLyAtIGUuZ2VzdHVyZS5kZWx0YVg7XG5cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9vblJlbGVhc2UpO1xuICB9XG5cbiAgX29uRHJhZyhlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLl9oYW5kbGUuc3R5bGUubGVmdCA9IHRoaXMuX2dldFBvc2l0aW9uKGUpICsgJ3B4JztcbiAgfVxuXG4gIF9vblJlbGVhc2UoZSkge1xuICAgIGNvbnN0IGwgPSB0aGlzLl9sb2NhdGlvbnM7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbihlKTtcbiAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5jaGVja2VkO1xuXG4gICAgdGhpcy5jaGVja2VkID0gcG9zaXRpb24gPj0gKGxbMF0gKyBsWzFdKSAvIDI7XG5cbiAgICBpZiAodGhpcy5jaGVja2VkICE9PSBwcmV2aW91c1ZhbHVlKSB7XG4gICAgICB0aGlzLl9lbWl0Q2hhbmdlRXZlbnQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWcnLCB0aGlzLl9vbkRyYWcpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlbGVhc2UnLCB0aGlzLl9vblJlbGVhc2UpO1xuXG4gICAgdGhpcy5faGFuZGxlLnN0eWxlLmxlZnQgPSAnJztcbiAgICBNb2RpZmllclV0aWwucmVtb3ZlTW9kaWZpZXIodGhpcywgJ2FjdGl2ZScpO1xuICB9XG5cbiAgY2xpY2soZXYgPSB7fSkge1xuICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gIXRoaXMuY2hlY2tlZDtcbiAgICAgIHRoaXMuX2VtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgdGhpcy5fbGFzdFRpbWVTdGFtcCA9IGV2LnRpbWVTdGFtcCB8fCAwO1xuICAgIH1cbiAgfVxuXG4gIGdldCBfaGFuZGxlKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3IoYC4ke3RoaXMuX2RlZmF1bHRDbGFzc05hbWV9X19oYW5kbGVgKTtcbiAgfVxuXG4gIGdldCBjaGVja2JveCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXQ7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5faW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdob2xkJywgdGhpcy5fb25Ib2xkKTtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuY2xpY2spO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICB0aGlzLl9nZXN0dXJlRGV0ZWN0b3IgPSBuZXcgR2VzdHVyZURldGVjdG9yKHRoaXMsIHsgZHJhZ01pbkRpc3RhbmNlOiAxLCBob2xkVGltZW91dDogMjUxLCBwYXNzaXZlOiB0cnVlIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX29uQ2hhbmdlKTtcbiAgICB9KTtcblxuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQpO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignaG9sZCcsIHRoaXMuX29uSG9sZCk7XG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0YXAnLCB0aGlzLmNsaWNrKTtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgaWYgKHRoaXMuX2dlc3R1cmVEZXRlY3Rvcikge1xuICAgICAgdGhpcy5fZ2VzdHVyZURldGVjdG9yLmRpc3Bvc2UoKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWy4uLnN1cGVyLm9ic2VydmVkQXR0cmlidXRlcywgJ21vZGlmaWVyJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICBjb25zdCBtZCA9IChjdXJyZW50IHx8ICcnKS5pbmRleE9mKCdtYXRlcmlhbCcpICE9PSAtMTtcbiAgICAgIHRoaXMuX2xvY2F0aW9ucyA9IGxvY2F0aW9uc1ttZCA/ICdtYXRlcmlhbCcgOiAnaW9zJ107XG4gICAgfVxuXG4gICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBldmVudCBjaGFuZ2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUZpcmVkIHdoZW4gdGhlIHN3aXRjaCBpcyB0b2dnbGVkLlsvZW5dXG4gICAqICAgW2phXU9OL09GRuOBjOWkieOCj+OBo+OBn+aZguOBq+eZuueBq+OBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiAgIFtlbl1FdmVudCBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kk44OZ44Oz44OI44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnN3aXRjaFxuICAgKiAgIFtlbl1Td2l0Y2ggb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCpOODmeODs+ODiOOBjOeZuueBq+OBl+OBn1N3aXRjaOOCquODluOCuOOCp+OCr+ODiOOCkui/lOOBl+OBvuOBmeOAglsvamFdXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXZlbnQudmFsdWVcbiAgICogICBbZW5dQ3VycmVudCB2YWx1ZS5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjga7lgKTjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGV2ZW50LmlzSW50ZXJhY3RpdmVcbiAgICogICBbZW5dVHJ1ZSBpZiB0aGUgY2hhbmdlIHdhcyB0cmlnZ2VyZWQgYnkgdGhlIHVzZXIgY2xpY2tpbmcgb24gdGhlIHN3aXRjaC5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg4Pjg5fjgoTjgq/jg6rjg4Pjgq/jgarjganjga7jg6bjg7zjgrbjga7mk43kvZzjgavjgojjgaPjgablpInjgo/jgaPjgZ/loLTlkIjjgavjga90cnVl44KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICBbZW5dVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHN3aXRjaC5bL2VuXVxuICAgKiAgW2phXeOCueOCpOODg+ODgeOBruihqOePvuOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGRpc2FibGVkXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBzd2l0Y2ggaXMgYmUgZGlzYWJsZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44KS54Sh5Yq544Gu54q25oWL44Gr44GZ44KL5aC05ZCI44Gr5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgY2hlY2tlZFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgc3dpdGNoIGlzIGNoZWNrZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7nirbmhYvjgavjgZnjgovjgajjgY3jgavmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBpbnB1dC1pZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYGlkYCBhdHRyaWJ1dGUgb2YgdGhlIGlubmVyIGA8aW5wdXQ+YCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIGA8bGFiZWwgZm9yPVwiLi4uXCI+YCBlbGVtZW50cy5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGNoZWNrZWRcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIHZhbHVlIGlzIGB0cnVlYCBpZiB0aGUgc3dpdGNoIGlzIGNoZWNrZWQuWy9lbl1cbiAgICogICBbamFd44K544Kk44OD44OB44GMT07jga7loLTlkIjjgatgdHJ1ZWDjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IHZhbHVlXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBkaXNhYmxlZFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZGlzYWJsZWQgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeeEoeWKueWMluOBleOCjOOBpuOBhOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgY2hlY2tib3hcbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSB1bmRlcmx5aW5nIGNoZWNrYm94IGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFd44Kz44Oz44Od44O844ON44Oz44OI5YaF6YOo44GuY2hlY2tib3jopoHntKDjgavjgarjgorjgb7jgZnjgIJbL2phXVxuICAgKi9cblxufVxuXG5vbnNFbGVtZW50cy5Td2l0Y2ggPSBTd2l0Y2hFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtc3dpdGNoJywgU3dpdGNoRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgb25zRWxlbWVudHMgZnJvbSAnLi4vLi4vb25zL2VsZW1lbnRzJztcbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBpbnRlcm5hbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi8uLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBTd2lwZXIgZnJvbSAnLi4vLi4vb25zL2ludGVybmFsL3N3aXBlcic7XG5pbXBvcnQgTW9kaWZpZXJVdGlsIGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9tb2RpZmllci11dGlsJztcbmltcG9ydCBCYXNlRWxlbWVudCBmcm9tICcuLi9iYXNlL2Jhc2UtZWxlbWVudCc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnRhYmJhcl9fY29udGVudCc6ICd0YWJiYXItLSpfX2NvbnRlbnQnLFxuICAnLnRhYmJhcl9fYm9yZGVyJzogJ3RhYmJhci0tKl9fYm9yZGVyJyxcbiAgJy50YWJiYXInOiAndGFiYmFyLS0qJ1xufTtcblxuY29uc3QgcmV3cml0YWJsZXMgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhYmJhckVsZW1lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHJlYWR5KHRhYmJhckVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufTtcblxuY29uc3QgbnVsbFBhZ2UgPSBpbnRlcm5hbC5udWxsRWxlbWVudDtcbmNvbnN0IGxlcnAgPSAoeDAsIHgxLCB0KSA9PiAoMSAtIHQpICogeDAgKyB0ICogeDE7XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRhYmJhclxuICogQGNhdGVnb3J5IHRhYmJhclxuICogQGRlc2NyaXB0aW9uXG4gKiAgIFtlbl1BIGNvbXBvbmVudCB0byBkaXNwbGF5IGEgdGFiIGJhciBvbiB0aGUgYm90dG9tIG9mIGEgcGFnZS4gVXNlZCB3aXRoIGA8b25zLXRhYj5gIHRvIG1hbmFnZSBwYWdlcyB1c2luZyB0YWJzLlsvZW5dXG4gKiAgIFtqYV3jgr/jg5bjg5Djg7zjgpLjg5rjg7zjgrjkuIvpg6jjgavooajnpLrjgZnjgovjgZ/jgoHjga7jgrPjg7Pjg53jg7zjg43jg7Pjg4jjgafjgZnjgIJvbnMtdGFi44Go57WE44G/5ZCI44KP44Gb44Gm5L2/44GG44GT44Go44Gn44CB44Oa44O844K444KS566h55CG44Gn44GN44G+44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIHBHdURMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvdGFiYmFyXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXUEgdGFiYmFyIGluIE1hdGVyaWFsIERlc2lnbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBhdXRvZ3Jvd1xuICogICBbZW5dVGFicyBhdXRvbWF0aWNhbGx5IGdyb3cgZGVwZW5kaW5nIG9uIHRoZWlyIGNvbnRlbnQgaW5zdGVhZCBvZiBoYXZpbmcgYSBmaXhlZCB3aWR0aC5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciB0b3AtYm9yZGVyXG4gKiAgIFtlbl1TaG93cyBhIHN0YXRpYyBib3JkZXItYm90dG9tIGluIHRhYnMgZm9yIGlPUyB0b3AgdGFiYmFycy5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBndWlkZSBmdW5kYW1lbnRhbHMuaHRtbCNtYW5hZ2luZy1wYWdlc1xuICogIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogIFtqYV3opIfmlbDjga7jg5rjg7zjgrjjgpLnrqHnkIbjgZnjgotbL2phXVxuICogQHNlZWFsc28gb25zLXRhYlxuICogICBbZW5dVGhlIGA8b25zLXRhYj5gIGNvbXBvbmVudC5bL2VuXVxuICogICBbamFdb25zLXRhYuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtcGFnZVxuICogICBbZW5dVGhlIGA8b25zLXBhZ2U+YCBjb21wb25lbnQuWy9lbl1cbiAqICAgW2phXW9ucy1wYWdl44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRhYmJhcj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwiaG9tZS5odG1sXCJcbiAqICAgICBsYWJlbD1cIkhvbWVcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJzZXR0aW5ncy5odG1sXCJcbiAqICAgICBsYWJlbD1cIlNldHRpbmdzXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqIDwvb25zLXRhYmJhcj5cbiAqXG4gKiA8dGVtcGxhdGUgaWQ9XCJob21lLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L3RlbXBsYXRlPlxuICpcbiAqIDx0ZW1wbGF0ZSBpZD1cInNldHRpbmdzLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L3RlbXBsYXRlPlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJiYXJFbGVtZW50IGV4dGVuZHMgQmFzZUVsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcHJlY2hhbmdlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBqdXN0IGJlZm9yZSB0aGUgdGFiIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM5aSJ44KP44KL5YmN44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYW5jZWxcbiAgICogICBbZW5dQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGNhbmNlbCB0aGUgY2hhbmdlIGV2ZW50LlsvZW5dXG4gICAqICAgW2phXeOBk+OBrumWouaVsOOCkuWRvOOBs+WHuuOBmeOBqOOAgeOCouOCr+ODhuOCo+ODluOBquOCv+ODluOBruWkieabtOOBjOOCreODo+ODs+OCu+ODq+OBleOCjOOBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZXZlbnQgcG9zdGNoYW5nZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRmlyZXMganVzdCBhZnRlciB0aGUgdGFiIGlzIGNoYW5nZWQuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM5aSJ44KP44Gj44Gf5b6M44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGV2ZW50IHJlYWN0aXZlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1GaXJlcyBpZiB0aGUgYWxyZWFkeSBvcGVuIHRhYiBpcyB0YXBwZWQgYWdhaW4uWy9lbl1cbiAgICogICBbamFd44GZ44Gn44Gr44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44GM44KC44GG5LiA5bqm44K/44OD44OX44KE44Kv44Oq44OD44Kv44GV44KM44Gf5aC05ZCI44Gr55m654Gr44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqICAgW2VuXUV2ZW50IG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqTjg5njg7Pjg4jjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXZlbnQuaW5kZXhcbiAgICogICBbZW5dQ3VycmVudCBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3nj77lnKjjgqLjgq/jg4bjgqPjg5bjgavjgarjgaPjgabjgYTjgotvbnMtdGFi44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnRhYkl0ZW1cbiAgICogICBbZW5dVGFiIGl0ZW0gb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXXRhYkl0ZW3jgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBhbmltYXRpb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgbm9uZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dSWYgdGhpcyBhdHRyaWJ1dGUgaXMgc2V0IHRvIGBcIm5vbmVcImAgdGhlIHRyYW5zaXRpb25zIHdpbGwgbm90IGJlIGFuaW1hdGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvbi1vcHRpb25zXG4gICAqIEB0eXBlIHtFeHByZXNzaW9ufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgdGltaW5nIGFuZCBkZWxheSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgdGltaW5nLCBkZWxheeOCkuOCquODluOCuOOCp+OCr+ODiOODquODhuODqeODq+OBp+aMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAxLCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQGF0dHJpYnV0ZSBwb3NpdGlvblxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgYm90dG9tXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UYWJiYXIncyBwb3NpdGlvbi4gQXZhaWxhYmxlIHZhbHVlcyBhcmUgYFwiYm90dG9tXCJgIGFuZCBgXCJ0b3BcImAuIFVzZSBgXCJhdXRvXCJgIHRvIGNob29zZSBwb3NpdGlvbiBkZXBlbmRpbmcgb24gcGxhdGZvcm0gKGJvdHRvbSBmb3IgaU9TIGZsYXQgZGVzaWduLCB0b3AgZm9yIE1hdGVyaWFsIERlc2lnbikuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844Gu5L2N572u44KS5oyH5a6a44GX44G+44GZ44CCXCJib3R0b21cIuOCguOBl+OBj+OBr1widG9wXCLjgpLpgbjmip7jgafjgY3jgb7jgZnjgILjg4fjg5Xjgqnjg6vjg4jjga9cImJvdHRvbVwi44Gn44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgc3dpcGVhYmxlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1JZiB0aGlzIGF0dHJpYnV0ZSBpcyBzZXQgdGhlIHRhYiBiYXIgY2FuIGJlIHNjcm9sbGVkIGJ5IGRyYWcgb3Igc3dpcGUuWy9lbl1cbiAgICogICBbamFd44GT44Gu5bGe5oCn44GM44GC44KL5pmC44CB44K/44OW44OQ44O844KS44K544Ov44Kk44OX44KE44OJ44Op44OD44Kw44Gn56e75YuV44Gn44GN44KL44KI44GG44Gr44Gq44KK44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWdub3JlLWVkZ2Utd2lkdGhcbiAgICogQHR5cGUge051bWJlcn1cbiAgICogQGRlZmF1bHQgMjBcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3RhbmNlIGluIHBpeGVscyBmcm9tIGJvdGggZWRnZXMuIFN3aXBpbmcgb24gdGhlc2UgYXJlYXMgd2lsbCBwcmlvcml0aXplIHBhcmVudCBjb21wb25lbnRzIHN1Y2ggYXMgYG9ucy1zcGxpdHRlcmAgb3IgYG9ucy1uYXZpZ2F0b3JgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGhpZGUtdGFic1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0byBoaWRlIHRoZSB0YWJzLlsvZW5dXG4gICAqICAgW2phXeOCv+ODluOCkumdnuihqOekuuOBq+OBmeOCi+WgtOWQiOOBq+aMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIHRhYi1ib3JkZXJcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUlmIHRoaXMgYXR0cmlidXRlIGlzIHNldCB0aGUgdGFicyBzaG93IGEgZHluYW1pYyBib3R0b20gYm9yZGVyLiBPbmx5IHdvcmtzIGZvciBpT1MgZmxhdCBkZXNpZ24gc2luY2UgdGhlIGJvcmRlciBpcyBhbHdheXMgdmlzaWJsZSBpbiBNYXRlcmlhbCBEZXNpZ24uWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSB0YWJiYXIuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4gdGhpcy5fY29tcGlsZSgpKTtcbiAgICB0aGlzLl9sb2FkSW5hY3RpdmUgPSB1dGlsLmRlZmVyKCk7IC8vIEltcHJvdmVzICMyMzI0XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAoIXRoaXMuX3N3aXBlcikge1xuICAgICAgdGhpcy5fc3dpcGVyID0gbmV3IFN3aXBlcih7XG4gICAgICAgIGdldEVsZW1lbnQ6ICgpID0+IHRoaXMuX2NvbnRlbnRFbGVtZW50LFxuICAgICAgICBnZXRJbml0aWFsSW5kZXg6ICgpID0+IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmVJbmRleCcpIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmUtaW5kZXgnKSxcbiAgICAgICAgZ2V0QXV0b1Njcm9sbFJhdGlvOiB0aGlzLl9nZXRBdXRvU2Nyb2xsUmF0aW8uYmluZCh0aGlzKSxcbiAgICAgICAgZ2V0QnViYmxlV2lkdGg6ICgpID0+IHBhcnNlSW50KHRoaXMuZ2V0QXR0cmlidXRlKCdpZ25vcmUtZWRnZS13aWR0aCcpIHx8IDI1LCAxMCksXG4gICAgICAgIGlzQXV0b1Njcm9sbGFibGU6ICgpID0+IHRydWUsXG4gICAgICAgIHByZUNoYW5nZUhvb2s6IHRoaXMuX29uUHJlQ2hhbmdlLmJpbmQodGhpcyksXG4gICAgICAgIHBvc3RDaGFuZ2VIb29rOiB0aGlzLl9vblBvc3RDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgICAgcmVmcmVzaEhvb2s6IHRoaXMuX29uUmVmcmVzaC5iaW5kKHRoaXMpLFxuICAgICAgICBzY3JvbGxIb29rOiB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpXG4gICAgICB9KTtcblxuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyID0gdXRpbC5maW5kQ2hpbGQodGhpcy5fdGFiYmFyRWxlbWVudCwgJy50YWJiYXJfX2JvcmRlcicpO1xuICAgICAgICB0aGlzLl9zd2lwZXIuaW5pdCh7IHN3aXBlYWJsZTogdGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cbiAgICAgIGlmICghdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtcGFnZScsIHAgPT4gcCA9PT0gZG9jdW1lbnQuYm9keSkpIHtcbiAgICAgICAgdGhpcy5fc2hvdygpOyAvLyBUaGlzIHRhYmJhciBpcyB0aGUgdG9wIGNvbXBvbmVudFxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuX3N3aXBlciAmJiB0aGlzLl9zd2lwZXIuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuX3N3aXBlci5kaXNwb3NlKCk7XG4gICAgICB0aGlzLl9zd2lwZXIgPSBudWxsO1xuICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX3RhYnNSZWN0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfbm9ybWFsaXplRXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4geyAuLi5ldmVudCwgaW5kZXg6IGV2ZW50LmFjdGl2ZUluZGV4LCB0YWJJdGVtOiB0aGlzLnRhYnNbZXZlbnQuYWN0aXZlSW5kZXhdIH07XG4gIH1cblxuICBfb25Qb3N0Q2hhbmdlKGV2ZW50KSB7XG4gICAgZXZlbnQgPSB0aGlzLl9ub3JtYWxpemVFdmVudChldmVudCk7XG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwb3N0Y2hhbmdlJywgZXZlbnQpO1xuICAgIGNvbnN0IHBhZ2UgPSBldmVudC50YWJJdGVtLnBhZ2VFbGVtZW50O1xuICAgIHBhZ2UgJiYgcGFnZS5fc2hvdygpO1xuICB9XG5cbiAgX29uUHJlQ2hhbmdlKGV2ZW50KSB7XG4gICAgZXZlbnQgPSB0aGlzLl9ub3JtYWxpemVFdmVudChldmVudCk7XG4gICAgZXZlbnQuY2FuY2VsID0gKCkgPT4gZXZlbnQuY2FuY2VsZWQgPSB0cnVlO1xuXG4gICAgdXRpbC50cmlnZ2VyRWxlbWVudEV2ZW50KHRoaXMsICdwcmVjaGFuZ2UnLCBldmVudCk7XG5cbiAgICBpZiAoIWV2ZW50LmNhbmNlbGVkKSB7XG4gICAgICBjb25zdCB7IGFjdGl2ZUluZGV4LCBsYXN0QWN0aXZlSW5kZXggfSA9IGV2ZW50O1xuICAgICAgY29uc3QgdGFicyA9IHRoaXMudGFicztcblxuICAgICAgdGFic1thY3RpdmVJbmRleF0uc2V0QWN0aXZlKHRydWUpO1xuICAgICAgaWYgKGxhc3RBY3RpdmVJbmRleCA+PSAwKSB7XG4gICAgICAgIGNvbnN0IHByZXZUYWIgPSB0YWJzW2xhc3RBY3RpdmVJbmRleF07XG4gICAgICAgIHByZXZUYWIuc2V0QWN0aXZlKGZhbHNlKTtcbiAgICAgICAgcHJldlRhYi5wYWdlRWxlbWVudCAmJiBwcmV2VGFiLnBhZ2VFbGVtZW50Ll9oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50LmNhbmNlbGVkXG4gIH1cblxuICBfb25TY3JvbGwoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLl90YWJiYXJCb3JkZXIpIHtcbiAgICAgIHRoaXMuX3RhYmJhckJvcmRlci5zdHlsZS50cmFuc2l0aW9uID0gYGFsbCAke29wdGlvbnMuZHVyYXRpb24gfHwgMH1zICR7b3B0aW9ucy50aW1pbmcgfHwgJyd9YDtcblxuICAgICAgaWYgKHRoaXMuX2F1dG9ncm93ICYmIHRoaXMuX3RhYnNSZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgYSA9IE1hdGguZmxvb3IoaW5kZXgpLCBiID0gTWF0aC5jZWlsKGluZGV4KSwgciA9IGluZGV4ICUgMTtcbiAgICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyLnN0eWxlLndpZHRoID0gbGVycCh0aGlzLl90YWJzUmVjdFthXS53aWR0aCwgdGhpcy5fdGFic1JlY3RbYl0ud2lkdGgsIHIpICsgJ3B4JztcbiAgICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke2xlcnAodGhpcy5fdGFic1JlY3RbYV0ubGVmdCwgdGhpcy5fdGFic1JlY3RbYl0ubGVmdCwgcil9cHgsIDAsIDApYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3RhYmJhckJvcmRlci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtpbmRleCAqIDEwMH0lLCAwLCAwKWA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fb25Td2lwZSAmJiB0aGlzLl9vblN3aXBlKGluZGV4LCBvcHRpb25zKTtcbiAgfVxuXG4gIF9vblJlZnJlc2goKSB7XG4gICAgdGhpcy5fYXV0b2dyb3cgPSB1dGlsLmhhc01vZGlmaWVyKHRoaXMsICdhdXRvZ3JvdycpO1xuICAgIHRoaXMuX3RhYnNSZWN0ID0gdGhpcy50YWJzLm1hcCh0YWIgPT4gdGFiLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICBpZiAodGhpcy5fdGFiYmFyQm9yZGVyKSB7XG4gICAgICB0aGlzLl90YWJiYXJCb3JkZXIuc3R5bGUuZGlzcGxheSA9IHRoaXMuaGFzQXR0cmlidXRlKCd0YWItYm9yZGVyJykgfHwgdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKSA/ICdibG9jaycgOiAnbm9uZSc7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKTtcbiAgICAgIGlmICh0aGlzLl90YWJzUmVjdC5sZW5ndGggPiAwICYmIGluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy5fdGFiYmFyQm9yZGVyLnN0eWxlLndpZHRoID0gdGhpcy5fdGFic1JlY3RbaW5kZXhdLndpZHRoICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZ2V0QXV0b1Njcm9sbFJhdGlvKG1hdGNoZXMsIHZlbG9jaXR5LCBzaXplKSB7XG4gICAgY29uc3QgcmF0aW8gPSAuNjsgLy8gQmFzZSByYXRpb1xuICAgIGNvbnN0IG1vZGlmaWVyID0gc2l6ZSAvIDMwMCAqIChtYXRjaGVzID8gLTEgOiAxKTsgLy8gQmFzZWQgb24gc2NyZWVuIHNpemVcbiAgICByZXR1cm4gTWF0aC5taW4oMSwgTWF0aC5tYXgoMCwgcmF0aW8gKyB2ZWxvY2l0eSAqIG1vZGlmaWVyKSk7XG4gIH1cblxuICBnZXQgX3RhYmJhckVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiYmFyJyk7XG4gIH1cblxuICBnZXQgX2NvbnRlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB1dGlsLmZpbmRDaGlsZCh0aGlzLCAnLnRhYmJhcl9fY29udGVudCcpO1xuICB9XG5cbiAgZ2V0IF90YXJnZXRFbGVtZW50KCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9jb250ZW50RWxlbWVudDtcbiAgICByZXR1cm4gY29udGVudCAmJiBjb250ZW50LmNoaWxkcmVuWzBdIHx8IG51bGw7XG4gIH1cblxuICBfY29tcGlsZSgpIHtcbiAgICBhdXRvU3R5bGUucHJlcGFyZSh0aGlzKTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9jb250ZW50RWxlbWVudCB8fCB1dGlsLmNyZWF0ZSgnLnRhYmJhcl9fY29udGVudCcpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnb25zLXRhYmJhcl9fY29udGVudCcpO1xuICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX3RhYmJhckVsZW1lbnQgfHwgdXRpbC5jcmVhdGUoJy50YWJiYXInKTtcbiAgICB0YWJiYXIuY2xhc3NMaXN0LmFkZCgnb25zLXRhYmJhcl9fZm9vdGVyJyk7XG5cbiAgICBpZiAoIXRhYmJhci5wYXJlbnROb2RlKSB7XG4gICAgICB3aGlsZSAodGhpcy5maXJzdENoaWxkKSB7XG4gICAgICAgIHRhYmJhci5hcHBlbmRDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gTnVtYmVyKHRoaXMuZ2V0QXR0cmlidXRlKCdhY3RpdmVJbmRleCcpKTsgLy8gMCBieSBkZWZhdWx0XG4gICAgaWYgKHRhYmJhci5jaGlsZHJlbi5sZW5ndGggPiBhY3RpdmVJbmRleCAmJiAhdXRpbC5maW5kQ2hpbGQodGFiYmFyLCAnW2FjdGl2ZV0nKSkge1xuICAgICAgdGFiYmFyLmNoaWxkcmVuW2FjdGl2ZUluZGV4XS5zZXRBdHRyaWJ1dGUoJ2FjdGl2ZScsICcnKTtcbiAgICB9XG5cbiAgICB0aGlzLl90YWJiYXJCb3JkZXIgPSB1dGlsLmZpbmRDaGlsZCh0YWJiYXIsICcudGFiYmFyX19ib3JkZXInKSB8fCB1dGlsLmNyZWF0ZSgnLnRhYmJhcl9fYm9yZGVyJyk7XG4gICAgdGFiYmFyLmFwcGVuZENoaWxkKHRoaXMuX3RhYmJhckJvcmRlcik7XG4gICAgdGFiYmFyLmNsYXNzTGlzdC5hZGQoJ29ucy1zd2lwZXItdGFiYmFyJyk7IC8vIEhpZGVzIG1hdGVyaWFsIGJvcmRlclxuXG4gICAgIWNvbnRlbnQuY2hpbGRyZW5bMF0gJiYgY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgIWNvbnRlbnQuY2hpbGRyZW5bMV0gJiYgY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSk7XG4gICAgY29udGVudC5hcHBlbmRDaGlsZCA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQuYmluZChjb250ZW50LmNoaWxkcmVuWzBdKTtcbiAgICBjb250ZW50Lmluc2VydEJlZm9yZSA9IGNvbnRlbnQuaW5zZXJ0QmVmb3JlLmJpbmQoY29udGVudC5jaGlsZHJlblswXSk7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgIHRoaXMuYXBwZW5kQ2hpbGQodGFiYmFyKTsgLy8gVHJpZ2dlcnMgb25zLXRhYiBjb25uZWN0ZWRDYWxsYmFja1xuXG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICB9XG5cbiAgX3VwZGF0ZVBvc2l0aW9uKHBvc2l0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJykpIHtcbiAgICBjb25zdCB0b3AgPSB0aGlzLl90b3AgPSBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgKHBvc2l0aW9uID09PSAnYXV0bycgJiYgdXRpbC5oYXNNb2RpZmllcih0aGlzLCAnbWF0ZXJpYWwnKSk7XG4gICAgY29uc3QgYWN0aW9uID0gdG9wID8gdXRpbC5hZGRNb2RpZmllciA6IHV0aWwucmVtb3ZlTW9kaWZpZXI7XG5cbiAgICBhY3Rpb24odGhpcywgJ3RvcCcpO1xuXG4gICAgY29uc3QgcGFnZSA9IHV0aWwuZmluZFBhcmVudCh0aGlzLCAnb25zLXBhZ2UnKTtcbiAgICBpZiAocGFnZSkge1xuICAgICAgY29udGVudFJlYWR5KHBhZ2UsICgpID0+IHtcbiAgICAgICAgbGV0IHAgPSAwO1xuICAgICAgICBpZiAocGFnZS5jaGlsZHJlblswXSAmJiB1dGlsLm1hdGNoKHBhZ2UuY2hpbGRyZW5bMF0sICdvbnMtdG9vbGJhcicpKSB7XG4gICAgICAgICAgYWN0aW9uKHBhZ2UuY2hpbGRyZW5bMF0sICdub3NoYWRvdycpO1xuICAgICAgICAgIHAgPSAxOyAvLyBWaXN1YWwgZml4IGZvciBzb21lIGRldmljZXNcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBwYWdlLl9nZXRDb250ZW50RWxlbWVudCgpO1xuICAgICAgICBjb25zdCBjcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhZ2UuX2dldENvbnRlbnRFbGVtZW50KCksIG51bGwpXG5cbiAgICAgICAgdGhpcy5zdHlsZS50b3AgPSB0b3AgPyBwYXJzZUludChjcy5nZXRQcm9wZXJ0eVZhbHVlKCdwYWRkaW5nLXRvcCcpLCAxMCkgLSBwICsgJ3B4JyA6ICcnO1xuXG4gICAgICAgIC8vIFJlZnJlc2ggY29udGVudCB0b3AgLSBGaXggZm9yIGlPUyA4XG4gICAgICAgIGNvbnRlbnQuc3R5bGUudG9wID0gY3MudG9wO1xuICAgICAgICBjb250ZW50LnN0eWxlLnRvcCA9ICcnO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaW50ZXJuYWwuYXV0b1N0YXR1c0JhckZpbGwoKCkgPT4ge1xuICAgICAgY29uc3QgZmlsbGVkID0gdXRpbC5maW5kUGFyZW50KHRoaXMsIGUgPT4gZS5oYXNBdHRyaWJ1dGUoJ3N0YXR1cy1iYXItZmlsbCcpKTtcbiAgICAgIHV0aWwudG9nZ2xlQXR0cmlidXRlKHRoaXMsICdzdGF0dXMtYmFyLWZpbGwnLCB0b3AgJiYgIWZpbGxlZCk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgdG9wUGFnZSgpIHtcbiAgICBjb25zdCB0YWJzID0gdGhpcy50YWJzLFxuICAgICAgaW5kZXggPSB0aGlzLmdldEFjdGl2ZVRhYkluZGV4KCk7XG4gICAgcmV0dXJuIHRhYnNbaW5kZXhdXG4gICAgICA/IHRhYnNbaW5kZXhdLnBhZ2VFbGVtZW50IHx8IHRoaXMucGFnZXNbMF0gfHwgbnVsbFxuICAgICAgOiBudWxsO1xuICB9XG5cbiAgZ2V0IHBhZ2VzKCkge1xuICAgIHJldHVybiB1dGlsLmFycmF5RnJvbSh0aGlzLl90YXJnZXRFbGVtZW50LmNoaWxkcmVuKTtcbiAgfVxuXG4gIGdldCB0YWJzKCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwodGhpcy5fdGFiYmFyRWxlbWVudC5jaGlsZHJlbiwgZSA9PiBlLnRhZ05hbWUgPT09ICdPTlMtVEFCJyk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRBY3RpdmVUYWJcbiAgICogQHNpZ25hdHVyZSBzZXRBY3RpdmVUYWIoaW5kZXgsIFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gICAqICAgW2VuXVRhYiBpbmRleC5bL2VuXVxuICAgKiAgIFtqYV3jgr/jg5bjga7jgqTjg7Pjg4fjg4Pjgq/jgrnjgpLmjIflrprjgZfjgb7jgZnjgIJbL2phXVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuY2FsbGJhY2tdXG4gICAqICAgW2VuXUZ1bmN0aW9uIHRoYXQgcnVucyB3aGVuIHRoZSBuZXcgcGFnZSBoYXMgbG9hZGVkLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUlmIHRoaXMgb3B0aW9uIGlzIFwibm9uZVwiLCB0aGUgdHJhbnNpdGlvbiB3b24ndCBzbGlkZS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNob3cgc3BlY2lmaWVkIHRhYiBwYWdlLiBBbmltYXRpb25zIGFuZCB0aGVpciBvcHRpb25zIGNhbiBiZSBzcGVjaWZpZWQgYnkgdGhlIHNlY29uZCBwYXJhbWV0ZXIuWy9lbl1cbiAgICogICBbamFd5oyH5a6a44GX44Gf44Kk44Oz44OH44OD44Kv44K544Gu44K/44OW44KS6KGo56S644GX44G+44GZ44CC44Ki44OL44Oh44O844K344On44Oz44Gq44Gp44Gu44Kq44OX44K344On44Oz44KS5oyH5a6a44Gn44GN44G+44GZ44CCWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG5ldyBwYWdlIGVsZW1lbnQuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG4gIHNldEFjdGl2ZVRhYihuZXh0SW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHByZXZJbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgoKTtcbiAgICBjb25zdCBwcmV2VGFiID0gdGhpcy50YWJzW3ByZXZJbmRleF0sXG4gICAgICBuZXh0VGFiID0gdGhpcy50YWJzW25leHRJbmRleF07XG5cbiAgICBpZiAoIW5leHRUYWIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnU3BlY2lmaWVkIGluZGV4IGRvZXMgbm90IG1hdGNoIGFueSB0YWIuJyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHRJbmRleCA9PT0gcHJldkluZGV4KSB7XG4gICAgICB1dGlsLnRyaWdnZXJFbGVtZW50RXZlbnQodGhpcywgJ3JlYWN0aXZlJywgeyBpbmRleDogbmV4dEluZGV4LCBhY3RpdmVJbmRleDogbmV4dEluZGV4LCB0YWJJdGVtOiBuZXh0VGFiIH0pO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXh0VGFiLnBhZ2VFbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBGSVhNRTogbmV4dFRhYi5sb2FkZWQgaXMgYnJva2VuIGluIFpvbmUuanMgcHJvbWlzZXMgKEFuZ3VsYXIyKVxuICAgIGNvbnN0IG5leHRQYWdlID0gbmV4dFRhYi5wYWdlRWxlbWVudDtcbiAgICByZXR1cm4gKG5leHRQYWdlID8gUHJvbWlzZS5yZXNvbHZlKG5leHRQYWdlKSA6IG5leHRUYWIubG9hZGVkKVxuICAgICAgLnRoZW4obmV4dFBhZ2UgPT4gdGhpcy5fc3dpcGVyLnNldEFjdGl2ZUluZGV4KG5leHRJbmRleCwge1xuICAgICAgICByZWplY3Q6IHRydWUsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGFuaW1hdGlvbjogcHJldlRhYiAmJiBuZXh0UGFnZSA/IG9wdGlvbnMuYW5pbWF0aW9uIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24nKSA6ICdub25lJyxcbiAgICAgICAgYW5pbWF0aW9uT3B0aW9uczogdXRpbC5leHRlbmQoXG4gICAgICAgICAgeyBkdXJhdGlvbjogLjMsIHRpbWluZzogJ2N1YmljLWJlemllciguNCwgLjcsIC41LCAxKScgfSxcbiAgICAgICAgICB0aGlzLmhhc0F0dHJpYnV0ZSgnYW5pbWF0aW9uLW9wdGlvbnMnKSA/IHV0aWwuYW5pbWF0aW9uT3B0aW9uc1BhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKCdhbmltYXRpb24tb3B0aW9ucycpKSA6IHt9LFxuICAgICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uT3B0aW9ucyB8fCB7fVxuICAgICAgICApXG4gICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5jYWxsYmFjayBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIG9wdGlvbnMuY2FsbGJhY2sobmV4dFBhZ2UpO1xuICAgICAgICByZXR1cm4gbmV4dFBhZ2U7XG4gICAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBzZXRUYWJiYXJWaXNpYmlsaXR5XG4gICAqIEBzaWduYXR1cmUgc2V0VGFiYmFyVmlzaWJpbGl0eSh2aXNpYmxlKVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVVzZWQgdG8gaGlkZSBvciBzaG93IHRoZSB0YWIgYmFyLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBzZXRUYWJiYXJWaXNpYmlsaXR5KHZpc2libGUpIHtcbiAgICBjb250ZW50UmVhZHkodGhpcywgKCkgPT4ge1xuICAgICAgdGhpcy5fY29udGVudEVsZW1lbnQuc3R5bGVbdGhpcy5fdG9wID8gJ3RvcCcgOiAnYm90dG9tJ10gPSB2aXNpYmxlID8gJycgOiAnMHB4JztcbiAgICAgIHRoaXMuX3RhYmJhckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnJyA6ICdub25lJztcbiAgICAgIHZpc2libGUgJiYgdGhpcy5fb25SZWZyZXNoKCk7XG4gICAgfSk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIHRoaXMuc2V0VGFiYmFyVmlzaWJpbGl0eSh0cnVlKTtcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy5zZXRUYWJiYXJWaXNpYmlsaXR5KGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSB0YWJiYXIgaXMgdmlzaWJsZSBvciBub3QuWy9lbl1cbiAgICogICBbamFd44K/44OW44OQ44O844GM6KaL44GI44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl90YWJiYXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgIT09ICdub25lJztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgc3dpcGVhYmxlXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dRW5hYmxlIHN3aXBlIGludGVyYWN0aW9uLlsvZW5dXG4gICAqICAgW2phXXN3aXBlYWJsZeOBp+OBguOCjOOBsHRydWXjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0IHN3aXBlYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ3N3aXBlYWJsZScpO1xuICB9XG5cbiAgc2V0IHN3aXBlYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB1dGlsLnRvZ2dsZUF0dHJpYnV0ZSh0aGlzLCAnc3dpcGVhYmxlJywgdmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm9wZXJ0eSBvblN3aXBlXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhvb2sgY2FsbGVkIHdoZW5ldmVyIHRoZSB1c2VyIHNsaWRlcyB0aGUgdGFiYmFyLiBJdCBnZXRzIGEgZGVjaW1hbCBpbmRleCBhbmQgYW4gYW5pbWF0aW9uT3B0aW9ucyBvYmplY3QgYXMgYXJndW1lbnRzLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqL1xuICBnZXQgb25Td2lwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fb25Td2lwZTtcbiAgfVxuXG4gIHNldCBvblN3aXBlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmICEodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgIHV0aWwudGhyb3coYFwib25Td2lwZVwiIG11c3QgYmUgYSBmdW5jdGlvbmApXG4gICAgfVxuICAgIHRoaXMuX29uU3dpcGUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGdldEFjdGl2ZVRhYkluZGV4XG4gICAqIEBzaWduYXR1cmUgZ2V0QWN0aXZlVGFiSW5kZXgoKVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqICAgW2VuXVRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSB0YWIuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CCWy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVJldHVybnMgdGFiIGluZGV4IG9uIGN1cnJlbnQgYWN0aXZlIHRhYi4gSWYgYWN0aXZlIHRhYiBpcyBub3QgZm91bmQsIHJldHVybnMgLTEuWy9lbl1cbiAgICogICBbamFd54++5Zyo44Ki44Kv44OG44Kj44OW44Gr44Gq44Gj44Gm44GE44KL44K/44OW44Gu44Kk44Oz44OH44OD44Kv44K544KS6L+U44GX44G+44GZ44CC54++5Zyo44Ki44Kv44OG44Kj44OW44Gq44K/44OW44GM44Gq44GE5aC05ZCI44Gr44GvLTHjgpLov5TjgZfjgb7jgZnjgIJbL2phXVxuICAgKi9cbiAgZ2V0QWN0aXZlVGFiSW5kZXgodGFicyA9IHRoaXMudGFicykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRhYnNbaV0gJiYgdGFic1tpXS50YWdOYW1lID09PSAnT05TLVRBQicgJiYgdGFic1tpXS5pc0FjdGl2ZSgpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBfc2hvdygpIHtcbiAgICB0aGlzLl9zd2lwZXIuc2hvdygpO1xuXG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnM7XG4gICAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuZ2V0QWN0aXZlVGFiSW5kZXgodGFicyk7XG4gICAgICB0aGlzLl9sb2FkSW5hY3RpdmUucmVzb2x2ZSgpO1xuICAgICAgaWYgKHRhYnMubGVuZ3RoID4gMCAmJiBhY3RpdmVJbmRleCA+PSAwKSB7XG4gICAgICAgIHRhYnNbYWN0aXZlSW5kZXhdLmxvYWRlZC50aGVuKGVsID0+IGVsICYmIHNldEltbWVkaWF0ZSgoKSA9PiBlbC5fc2hvdygpKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfaGlkZSgpIHtcbiAgICB0aGlzLl9zd2lwZXIuaGlkZSgpO1xuICAgIGNvbnN0IHRvcFBhZ2UgPSB0aGlzLnRvcFBhZ2U7XG4gICAgdG9wUGFnZSAmJiB0b3BQYWdlLl9oaWRlKCk7XG4gIH1cblxuICBfZGVzdHJveSgpIHtcbiAgICB0aGlzLnRhYnMuZm9yRWFjaCh0YWIgPT4gdGFiLnJlbW92ZSgpKTtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncG9zaXRpb24nLCAnc3dpcGVhYmxlJywgJ3RhYi1ib3JkZXInLCAnaGlkZS10YWJzJ107XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgbGFzdCwgY3VycmVudCkge1xuICAgIGlmIChuYW1lID09PSAnbW9kaWZpZXInKSB7XG4gICAgICBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKTtcbiAgICAgIGNvbnN0IGlzVG9wID0gbSA9PiAvKF58XFxzKyl0b3AoJHxcXHMrKS9pLnRlc3QobSk7XG4gICAgICBpc1RvcChsYXN0KSAhPT0gaXNUb3AoY3VycmVudCkgJiYgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwb3NpdGlvbicpIHtcbiAgICAgIHV0aWwuaXNBdHRhY2hlZCh0aGlzKSAmJiB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3N3aXBlYWJsZScpIHtcbiAgICAgIHRoaXMuX3N3aXBlciAmJiB0aGlzLl9zd2lwZXIudXBkYXRlU3dpcGVhYmxlKHRoaXMuaGFzQXR0cmlidXRlKCdzd2lwZWFibGUnKSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAnaGlkZS10YWJzJykge1xuICAgICAgdGhpcy5zZXRUYWJiYXJWaXNpYmlsaXR5KCF0aGlzLmhhc0F0dHJpYnV0ZSgnaGlkZS10YWJzJykgfHwgY3VycmVudCA9PT0gJ2ZhbHNlJyk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCByZXdyaXRhYmxlcygpIHtcbiAgICByZXR1cm4gcmV3cml0YWJsZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGV2ZW50cygpIHtcbiAgICByZXR1cm4gWydwcmVjaGFuZ2UnLCAncG9zdGNoYW5nZScsICdyZWFjdGl2ZSddO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlRhYmJhciA9IFRhYmJhckVsZW1lbnQ7XG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ29ucy10YWJiYXInLCBUYWJiYXJFbGVtZW50KTtcbiIsIi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCBvbnNFbGVtZW50cyBmcm9tICcuLi9vbnMvZWxlbWVudHMnO1xuaW1wb3J0IHV0aWwgZnJvbSAnLi4vb25zL3V0aWwnO1xuaW1wb3J0IGF1dG9TdHlsZSBmcm9tICcuLi9vbnMvYXV0b3N0eWxlJztcbmltcG9ydCBNb2RpZmllclV0aWwgZnJvbSAnLi4vb25zL2ludGVybmFsL21vZGlmaWVyLXV0aWwnO1xuaW1wb3J0IEJhc2VFbGVtZW50IGZyb20gJy4vYmFzZS9iYXNlLWVsZW1lbnQnO1xuaW1wb3J0IFRhYmJhckVsZW1lbnQgZnJvbSAnLi9vbnMtdGFiYmFyJztcbmltcG9ydCBjb250ZW50UmVhZHkgZnJvbSAnLi4vb25zL2NvbnRlbnQtcmVhZHknO1xuaW1wb3J0IHsgUGFnZUxvYWRlciwgZGVmYXVsdFBhZ2VMb2FkZXIgfSBmcm9tICcuLi9vbnMvcGFnZS1sb2FkZXInO1xuXG5jb25zdCBkZWZhdWx0Q2xhc3NOYW1lID0gJ3RhYmJhcl9faXRlbSc7XG5cbmNvbnN0IHNjaGVtZSA9IHtcbiAgJyc6ICd0YWJiYXItLSpfX2l0ZW0nLFxuICAnLnRhYmJhcl9fYnV0dG9uJzogJ3RhYmJhci0tKl9fYnV0dG9uJ1xufTtcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdGFiXG4gKiBAY2F0ZWdvcnkgdGFiYmFyXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVJlcHJlc2VudHMgYSB0YWIgaW5zaWRlIHRhYiBiYXIuIEVhY2ggYDxvbnMtdGFiPmAgcmVwcmVzZW50cyBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXVxuICogICAgIOOCv+ODluODkOODvOOBq+mFjee9ruOBleOCjOOCi+WQhOOCouOCpOODhuODoOOBruOCs+ODs+ODneODvOODjeODs+ODiOOBp+OBmeOAguOBneOCjOOBnuOCjOOBrm9ucy10YWLjga/jg5rjg7zjgrjjgpLooajjgZfjgb7jgZnjgIJcbiAqICAgICBvbnMtdGFi6KaB57Sg44Gu5Lit44Gr44Gv44CB44K/44OW44Gr6KGo56S644GV44KM44KL44Kz44Oz44OG44Oz44OE44KS55u05o6l6KiY6L+w44GZ44KL44GT44Go44GM5Ye65p2l44G+44GZ44CCXG4gKiAgIFsvamFdXG4gKiBAY29kZXBlbiBwR3VETFxuICogQHR1dG9yaWFsIHZhbmlsbGEvUmVmZXJlbmNlL3RhYmJhclxuICogQGd1aWRlIGZ1bmRhbWVudGFscy5odG1sI21hbmFnaW5nLXBhZ2VzXG4gKiAgIFtlbl1NYW5hZ2luZyBtdWx0aXBsZSBwYWdlcy5bL2VuXVxuICogICBbamFd6KSH5pWw44Gu44Oa44O844K444KS566h55CG44GZ44KLWy9qYV1dXG4gKiBAZ3VpZGUgYXBwc2l6ZS5odG1sI3JlbW92aW5nLWljb24tcGFja3MgW2VuXVJlbW92aW5nIGljb24gcGFja3MuWy9lbl1bamFdWy9qYV1cbiAqIEBndWlkZSBmYXEuaHRtbCNob3ctY2FuLWktdXNlLWN1c3RvbS1pY29uLXBhY2tzIFtlbl1BZGRpbmcgY3VzdG9tIGljb24gcGFja3MuWy9lbl1bamFdWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy10YWJiYXJcbiAqICAgW2VuXW9ucy10YWJiYXIgY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy10YWJiYXLjgrPjg7Pjg53jg7zjg43jg7Pjg4hbL2phXVxuICogQHNlZWFsc28gb25zLXBhZ2VcbiAqICAgW2VuXW9ucy1wYWdlIGNvbXBvbmVudFsvZW5dXG4gKiAgIFtqYV1vbnMtcGFnZeOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAc2VlYWxzbyBvbnMtaWNvblxuICogICBbZW5db25zLWljb24gY29tcG9uZW50Wy9lbl1cbiAqICAgW2phXW9ucy1pY29u44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBleGFtcGxlXG4gKiA8b25zLXRhYmJhcj5cbiAqICAgPG9ucy10YWJcbiAqICAgICBwYWdlPVwiaG9tZS5odG1sXCJcbiAqICAgICBsYWJlbD1cIkhvbWVcIlxuICogICAgIGFjdGl2ZT5cbiAqICAgPC9vbnMtdGFiPlxuICogICA8b25zLXRhYlxuICogICAgIHBhZ2U9XCJzZXR0aW5ncy5odG1sXCJcbiAqICAgICBsYWJlbD1cIlNldHRpbmdzXCJcbiAqICAgICBhY3RpdmU+XG4gKiAgIDwvb25zLXRhYj5cbiAqIDwvb25zLXRhYmJhcj5cbiAqXG4gKiA8dGVtcGxhdGUgaWQ9XCJob21lLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L3RlbXBsYXRlPlxuICpcbiAqIDx0ZW1wbGF0ZSBpZD1cInNldHRpbmdzLmh0bWxcIj5cbiAqICAgLi4uXG4gKiA8L3RlbXBsYXRlPlxuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYkVsZW1lbnQgZXh0ZW5kcyBCYXNlRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgcGFnZVxuICAgKiBAaW5pdG9ubHlcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBwYWdlIHRoYXQgaXMgZGlzcGxheWVkIHdoZW4gdGhlIHRhYiBpcyB0YXBwZWQuWy9lbl1cbiAgICogICBbamFdb25zLXRhYuOBjOWPgueFp+OBmeOCi+ODmuODvOOCuOOBuOOBrlVSTOOCkuaMh+WumuOBl+OBvuOBmeOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVxuICAgKiAgICAgVGhlIGljb24gbmFtZSBmb3IgdGhlIHRhYi4gQ2FuIHNwZWNpZnkgdGhlIHNhbWUgaWNvbiBuYW1lIGFzIGA8b25zLWljb24+YC4gQ2hlY2sgW1NlZSBhbHNvXSgjc2VlYWxzbykgc2VjdGlvbiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICogICBbL2VuXVxuICAgKiAgIFtqYV1cbiAgICogICAgIOOCouOCpOOCs+ODs+WQjeOCkuaMh+WumuOBl+OBvuOBmeOAgm9ucy1pY29u44Go5ZCM44GY44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgICDlgIvliKXjgavjgqLjgqTjgrPjg7PjgpLjgqvjgrnjgr/jg57jgqTjgrrjgZnjgovloLTlkIjjga/jgIFiYWNrZ3JvdW5kLWltYWdl44Gq44Gp44GuQ1NT44K544K/44Kk44Or44KS55So44GE44Gm5oyH5a6a44Gn44GN44G+44GZ44CCXG4gICAqICAgWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlLWljb25cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBuYW1lIG9mIHRoZSBpY29uIHdoZW4gdGhlIHRhYiBpcyBhY3RpdmUuWy9lbl1cbiAgICogICBbamFd44Ki44Kv44OG44Kj44OW44Gu6Zqb44Gu44Ki44Kk44Kz44Oz5ZCN44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbGFiZWxcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBsYWJlbCBvZiB0aGUgdGFiIGl0ZW0uWy9lbl1cbiAgICogICBbamFd44Ki44Kk44Kz44Oz5LiL44Gr6KGo56S644GV44KM44KL44Op44OZ44Or44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYmFkZ2VcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXURpc3BsYXkgYSBub3RpZmljYXRpb24gYmFkZ2Ugb24gdG9wIG9mIHRoZSB0YWIuWy9lbl1cbiAgICogICBbamFd44OQ44OD44K444Gr6KGo56S644GZ44KL5YaF5a6544KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYWN0aXZlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1UaGlzIGF0dHJpYnV0ZSBzaG91bGQgYmUgc2V0IHRvIHRoZSB0YWIgdGhhdCBpcyBhY3RpdmUgYnkgZGVmYXVsdC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKFsnbGFiZWwnLCAnaWNvbicsICdiYWRnZSddLnNvbWUodGhpcy5oYXNBdHRyaWJ1dGUuYmluZCh0aGlzKSkpIHtcbiAgICAgIHRoaXMuX2NvbXBpbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX2NvbXBpbGUoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGRlZmF1bHRQYWdlTG9hZGVyO1xuICAgIHRoaXMuX29uQ2xpY2sgPSB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcyk7XG4gIH1cblxuICBzZXQgcGFnZUxvYWRlcihsb2FkZXIpIHtcbiAgICBpZiAoIShsb2FkZXIgaW5zdGFuY2VvZiBQYWdlTG9hZGVyKSkge1xuICAgICAgdXRpbC50aHJvd1BhZ2VMb2FkZXIoKTtcbiAgICB9XG4gICAgdGhpcy5fcGFnZUxvYWRlciA9IGxvYWRlcjtcbiAgfVxuXG4gIGdldCBwYWdlTG9hZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlTG9hZGVyO1xuICB9XG5cbiAgX2NvbXBpbGUoKSB7XG4gICAgYXV0b1N0eWxlLnByZXBhcmUodGhpcyk7XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGRlZmF1bHRDbGFzc05hbWUpO1xuXG4gICAgaWYgKHRoaXMuX2J1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1dHRvbiA9IHV0aWwuY3JlYXRlKCdidXR0b24udGFiYmFyX19idXR0b24nKTtcbiAgICB3aGlsZSh0aGlzLmNoaWxkTm9kZXNbMF0pIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkTm9kZXNbMF0pO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0ID0gdXRpbC5jcmVhdGUoJ2lucHV0JywgeyBkaXNwbGF5OiAnbm9uZScgfSk7XG4gICAgaW5wdXQudHlwZSA9ICdyYWRpbyc7XG5cbiAgICB0aGlzLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICB0aGlzLmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICB0aGlzLl91cGRhdGVCdXR0b25Db250ZW50KCk7XG4gICAgTW9kaWZpZXJVdGlsLmluaXRNb2RpZmllcih0aGlzLCBzY2hlbWUpO1xuICAgIHRoaXMuX3VwZGF0ZVJpcHBsZSgpO1xuICB9XG5cbiAgX3VwZGF0ZVJpcHBsZSgpIHtcbiAgICB0aGlzLl9idXR0b24gJiYgdXRpbC51cGRhdGVSaXBwbGUodGhpcy5fYnV0dG9uLCB0aGlzLmhhc0F0dHJpYnV0ZSgncmlwcGxlJykpO1xuICB9XG5cbiAgX3VwZGF0ZUJ1dHRvbkNvbnRlbnQoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy5fYnV0dG9uO1xuXG4gICAgbGV0IGljb25XcmFwcGVyID0gdGhpcy5faWNvbjtcbiAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2ljb24nKSkge1xuICAgICAgaWNvbldyYXBwZXIgPSBpY29uV3JhcHBlciB8fCB1dGlsLmNyZWF0ZUVsZW1lbnQoJzxkaXYgY2xhc3M9XCJ0YWJiYXJfX2ljb25cIj48b25zLWljb24+PC9vbnMtaWNvbj48L2Rpdj4nKTtcbiAgICAgIGNvbnN0IGljb24gPSBpY29uV3JhcHBlci5jaGlsZHJlblswXTtcbiAgICAgIGNvbnN0IGZpeCA9IChsYXN0ID0+ICgpID0+IGljb24uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCdpY29uJywgbGFzdCwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKSkpKGljb24uZ2V0QXR0cmlidXRlKCdpY29uJykpO1xuICAgICAgaWNvbi5zZXRBdHRyaWJ1dGUoJ2ljb24nLCB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpKTtcbiAgICAgIGljb25XcmFwcGVyLnBhcmVudEVsZW1lbnQgIT09IGJ1dHRvbiAmJiBidXR0b24uaW5zZXJ0QmVmb3JlKGljb25XcmFwcGVyLCBidXR0b24uZmlyc3RDaGlsZCk7XG5cbiAgICAgIC8vIGRpcnR5IGZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL09uc2VuVUkvT25zZW5VSS9pc3N1ZXMvMTY1NFxuICAgICAgaWNvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICA/IGZpeCgpXG4gICAgICAgIDogc2V0SW1tZWRpYXRlKCgpID0+IGljb24uYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIGluc3RhbmNlb2YgRnVuY3Rpb24gJiYgZml4KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpY29uV3JhcHBlciAmJiBpY29uV3JhcHBlci5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBbJ2xhYmVsJywgJ2JhZGdlJ10uZm9yRWFjaCgoYXR0ciwgaW5kZXgpID0+IHtcbiAgICAgIGxldCBwcm9wID0gdGhpcy5xdWVyeVNlbGVjdG9yKGAudGFiYmFyX18ke2F0dHJ9YCk7XG4gICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoYXR0cikpIHtcbiAgICAgICAgcHJvcCA9IHByb3AgfHwgdXRpbC5jcmVhdGUoYC50YWJiYXJfXyR7YXR0cn1gICsgKGF0dHIgPT09ICdiYWRnZScgPyAnIG5vdGlmaWNhdGlvbicgOiAnJykpO1xuICAgICAgICBwcm9wLnRleHRDb250ZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIHByb3AucGFyZW50RWxlbWVudCAhPT0gYnV0dG9uICYmIGJ1dHRvbi5hcHBlbmRDaGlsZChwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AgJiYgcHJvcC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldCBfaW5wdXQoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICdpbnB1dCcpO1xuICB9XG5cbiAgZ2V0IF9idXR0b24oKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsICcudGFiYmFyX19idXR0b24nKTtcbiAgfVxuXG4gIGdldCBfaWNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKCcudGFiYmFyX19pY29uJyk7XG4gIH1cblxuICBnZXQgX3RhYmJhcigpIHtcbiAgICByZXR1cm4gdXRpbC5maW5kUGFyZW50KHRoaXMsICdvbnMtdGFiYmFyJyk7XG4gIH1cblxuICBnZXQgaW5kZXgoKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcy5wYXJlbnRFbGVtZW50LmNoaWxkcmVuLCB0aGlzKTtcbiAgfVxuXG4gIF9vbkNsaWNrKCkge1xuICAgIGlmICh0aGlzLm9uQ2xpY2sgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgdGhpcy5vbkNsaWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3RhYmJhci5zZXRBY3RpdmVUYWIodGhpcy5pbmRleCwgeyByZWplY3Q6IGZhbHNlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNldEFjdGl2ZShhY3RpdmUgPSB0cnVlKSB7XG4gICAgdGhpcy5faW5wdXQuY2hlY2tlZCA9IGFjdGl2ZTtcbiAgICB0aGlzLmNsYXNzTGlzdC50b2dnbGUoJ2FjdGl2ZScsIGFjdGl2ZSk7XG4gICAgdXRpbC50b2dnbGVBdHRyaWJ1dGUodGhpcywgJ2FjdGl2ZScsIGFjdGl2ZSlcblxuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgnaWNvbicpICYmIHRoaXMuaGFzQXR0cmlidXRlKCdhY3RpdmUtaWNvbicpKSB7XG4gICAgICB0aGlzLl9pY29uLmNoaWxkcmVuWzBdLnNldEF0dHJpYnV0ZSgnaWNvbicsIHRoaXMuZ2V0QXR0cmlidXRlKGFjdGl2ZSA/ICdhY3RpdmUtaWNvbicgOiAnaWNvbicpKTtcbiAgICB9XG4gIH1cblxuICBfbG9hZFBhZ2VFbGVtZW50KHBhcmVudCwgcGFnZSkge1xuICAgIHRoaXMuX2hhc0xvYWRlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl9wYWdlTG9hZGVyLmxvYWQoeyBwYXJlbnQsIHBhZ2UgfSwgcGFnZUVsZW1lbnQgPT4ge1xuICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHBhZ2VFbGVtZW50LCBwYXJlbnQuY2hpbGRyZW5bdGhpcy5pbmRleF0pOyAvLyBFbnN1cmUgcG9zaXRpb25cbiAgICAgICAgdGhpcy5fbG9hZGVkUGFnZSA9IHBhZ2VFbGVtZW50O1xuICAgICAgICByZXNvbHZlKHBhZ2VFbGVtZW50KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IHBhZ2VFbGVtZW50KCkge1xuICAgIC8vIEl0IGhhcyBiZWVuIGxvYWRlZCBieSBvbnMtdGFiXG4gICAgaWYgKHRoaXMuX2xvYWRlZFBhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sb2FkZWRQYWdlO1xuICAgIH1cbiAgICAvLyBNYW51YWxseSBhdHRhY2hlZCB0byBET00sIDEgcGVyIHRhYlxuICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX3RhYmJhcjtcbiAgICBpZiAodGFiYmFyLnBhZ2VzLmxlbmd0aCA9PT0gdGFiYmFyLnRhYnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGFiYmFyLnBhZ2VzW3RoaXMuaW5kZXhdO1xuICAgIH1cbiAgICAvLyBMb2FkZWQgaW4gYW5vdGhlciB3YXlcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrLCBmYWxzZSk7XG4gICAgaWYgKHRoaXMuX2xvYWRlZFBhZ2UpIHtcbiAgICAgIHRoaXMuX3BhZ2VMb2FkZXIudW5sb2FkKHRoaXMuX2xvYWRlZFBhZ2UpO1xuICAgICAgdGhpcy5fbG9hZGVkUGFnZSA9IG51bGw7XG4gICAgICB0aGlzLl9oYXNMb2FkZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9hZGVkID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljaywgZmFsc2UpO1xuXG4gICAgaWYgKCF1dGlsLmlzQXR0YWNoZWQodGhpcykgfHwgdGhpcy5sb2FkZWQpIHtcbiAgICAgIHJldHVybjsgLy8gb25zLXRhYmJhciBjb21waWxhdGlvbiBtYXkgdHJpZ2dlciB0aGlzXG4gICAgfVxuXG4gICAgY29uc3QgZGVmZXJyZWQgPSB1dGlsLmRlZmVyKCk7XG4gICAgdGhpcy5sb2FkZWQgPSBkZWZlcnJlZC5wcm9taXNlO1xuXG4gICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGNvbnN0IHRhYmJhciA9IHRoaXMuX3RhYmJhcjtcbiAgICAgIGlmICghdGFiYmFyKSB7XG4gICAgICAgIHV0aWwudGhyb3coJ1RhYiBlbGVtZW50cyBtdXN0IGJlIGNoaWxkcmVuIG9mIFRhYmJhcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFiYmFyLmhhc0F0dHJpYnV0ZSgnbW9kaWZpZXInKSkge1xuICAgICAgICB1dGlsLmFkZE1vZGlmaWVyKHRoaXMsIHRhYmJhci5nZXRBdHRyaWJ1dGUoJ21vZGlmaWVyJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2hhc0xvYWRlZCkge1xuICAgICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgdGhpcy5zZXRBY3RpdmUodHJ1ZSk7XG4gICAgICAgICAgdGFiYmFyLnNldEF0dHJpYnV0ZSgnYWN0aXZlSW5kZXgnLCBpbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXggPT09IHRhYmJhci50YWJzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB0YWJiYXIuX29uUmVmcmVzaCgpO1xuICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0YWJiYXIuX29uUmVmcmVzaCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFRhYmJhckVsZW1lbnQucmV3cml0YWJsZXMucmVhZHkodGFiYmFyLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFnZVRhcmdldCA9IHRoaXMucGFnZSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncGFnZScpO1xuICAgICAgICAgIGlmICghdGhpcy5wYWdlRWxlbWVudCAmJiBwYWdlVGFyZ2V0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRUYXJnZXQgPSB0YWJiYXIuX3RhcmdldEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBkdW1teVBhZ2UgPSB1dGlsLmNyZWF0ZSgnZGl2JywgeyBoZWlnaHQ6ICcxMDAlJywgd2lkdGg6ICcxMDAlJywgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSk7XG4gICAgICAgICAgICBwYXJlbnRUYXJnZXQuaW5zZXJ0QmVmb3JlKGR1bW15UGFnZSwgcGFyZW50VGFyZ2V0LmNoaWxkcmVuW2luZGV4XSk7IC8vIEVuc3VyZSBwb3NpdGlvblxuXG4gICAgICAgICAgICBjb25zdCBsb2FkID0gKCkgPT4gdGhpcy5fbG9hZFBhZ2VFbGVtZW50KHBhcmVudFRhcmdldCwgcGFnZVRhcmdldCkudGhlbihkZWZlcnJlZC5yZXNvbHZlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQWN0aXZlKCkgPyBsb2FkKCkgOiB0YWJiYXIuX2xvYWRJbmFjdGl2ZS5wcm9taXNlLnRoZW4obG9hZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnJlc29sdmUodGhpcy5wYWdlRWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFsnbW9kaWZpZXInLCAncmlwcGxlJywgJ2ljb24nLCAnbGFiZWwnLCAncGFnZScsICdiYWRnZScsICdjbGFzcyddO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIGxhc3QsIGN1cnJlbnQpIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgICAgdXRpbC5yZXN0b3JlQ2xhc3ModGhpcywgZGVmYXVsdENsYXNzTmFtZSwgc2NoZW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb2RpZmllcic6XG4gICAgICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiBNb2RpZmllclV0aWwub25Nb2RpZmllckNoYW5nZWQobGFzdCwgY3VycmVudCwgdGhpcywgc2NoZW1lKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlwcGxlJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZVJpcHBsZSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpY29uJzpcbiAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgIGNhc2UgJ2JhZGdlJzpcbiAgICAgICAgY29udGVudFJlYWR5KHRoaXMsICgpID0+IHRoaXMuX3VwZGF0ZUJ1dHRvbkNvbnRlbnQoKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncGFnZSc6XG4gICAgICAgIHRoaXMucGFnZSA9IGN1cnJlbnQgfHwgJyc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5vbnNFbGVtZW50cy5UYWIgPSBUYWJFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdGFiJywgVGFiRWxlbWVudCk7XG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgQmFzZUFuaW1hdG9yIGZyb20gJy4uLy4uL29ucy9iYXNlLWFuaW1hdG9yJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9hc3RBbmltYXRvciBleHRlbmRzIEJhc2VBbmltYXRvciB7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnRpbWluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kdXJhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5kZWxheVxuICAgKi9cbiAgY29uc3RydWN0b3Ioe3RpbWluZyA9ICdsaW5lYXInLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yfSA9IHt9KSB7XG4gICAgc3VwZXIoeyB0aW1pbmcsIGRlbGF5LCBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyhtb2RhbCwgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG1vZGFsXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKG1vZGFsLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cbiIsIlxuLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IGFuaW1pdCBmcm9tICcuLi8uLi9vbnMvYW5pbWl0JztcbmltcG9ydCBUb2FzdEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIGlPUyBzdHlsZSBhbmltYXRvciBmb3IgZGlhbG9nLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWRlVG9hc3RBbmltYXRvciBleHRlbmRzIFRvYXN0QW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHt0aW1pbmcgPSAnbGluZWFyJywgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDAuM30gPSB7fSkge1xuICAgIHN1cGVyKHsgdGltaW5nLCBkZWxheSwgZHVyYXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3codG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNhbGxiYWNrIDogZnVuY3Rpb24oKSB7fTtcblxuICAgIGFuaW1pdCh0b2FzdCwgdGhpcy5kZWYpXG4gICAgICAuZGVmYXVsdCh7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH0pXG4gICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH0pXG4gICAgICAucGxheSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRvYXN0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqL1xuICBoaWRlKHRvYXN0LCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPyBjYWxsYmFjayA6IGZ1bmN0aW9uKCkge307XG5cbiAgICBhbmltaXQodG9hc3QsIHRoaXMuZGVmKVxuICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAxIH0sIHsgb3BhY2l0eTogMCB9KVxuICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9KVxuICAgICAgLnBsYXkoKTtcbiAgfVxufVxuIiwiXG4vKlxuQ29weXJpZ2h0IDIwMTMtMjAxNSBBU0lBTCBDT1JQT1JBVElPTlxuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbmxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4qL1xuXG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYW5pbWl0IGZyb20gJy4uLy4uL29ucy9hbmltaXQnO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgaVBob25lWFBhdGNoIGZyb20gJy4uLy4uL29ucy9pcGhvbmV4LXBhdGNoJztcbmltcG9ydCBUb2FzdEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIEFzY2VuZCBUb2FzdCBBbmltYXRvci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXNjZW5kVG9hc3RBbmltYXRvciBleHRlbmRzIFRvYXN0QW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgdGltaW5nID0gJ2Vhc2UnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4yNSB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuXG4gICAgdGhpcy5tZXNzYWdlRGVsYXkgPSB0aGlzLmR1cmF0aW9uICogMC40ICsgdGhpcy5kZWxheTsgLy8gRGVsYXkgbWVzc2FnZSBvcGFjaXR5IGNoYW5nZVxuICAgIGlmIChwbGF0Zm9ybS5pc0FuZHJvaWQoKSkge1xuICAgICAgdGhpcy5hc2NlbnNpb24gPSA0ODsgLy8gVG9hc3RzIGFyZSBhbHdheXMgMSBsaW5lXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICAgIHRoaXMuYXNjZW5zaW9uID0gOTg7IC8vIDY0ICsgMzRcbiAgICAgIH0gZWxzZSBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWExhbmRzY2FwZVBhdGNoQWN0aXZlKCkpIHtcbiAgICAgICAgdGhpcy5hc2NlbnNpb24gPSA4NTsgLy8gNjQgKyAyMVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hc2NlbnNpb24gPSA2NDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3codG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG4gICAgdXRpbC5nbG9iYWxzLmZhYk9mZnNldCA9IHRoaXMuYXNjZW5zaW9uO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0b2FzdCwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLmFzY2Vuc2lvbn1weCwgMClgIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSksXG5cbiAgICAgIGFuaW1pdCh0aGlzLl9nZXRGYWJzKCkpXG4gICAgICAgIC53YWl0KHRoaXMuZGVsYXkpXG4gICAgICAgIC5xdWV1ZSh7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsIC0ke3RoaXMuYXNjZW5zaW9ufXB4LCAwKSBzY2FsZSgxKWAgfSwgdGhpcy5kZWYpLFxuXG4gICAgICBhbmltaXQodXRpbC5hcnJheUZyb20odG9hc3QuY2hpbGRyZW4pLCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoeyBvcGFjaXR5OiAwIH0sIHsgb3BhY2l0eTogMSB9KVxuICAgICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZSh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICB0b2FzdCA9IHRvYXN0Ll90b2FzdDtcbiAgICB1dGlsLmdsb2JhbHMuZmFiT2Zmc2V0ID0gMDtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodG9hc3QsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJyB9LFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLmFzY2Vuc2lvbn1weCwgMClgIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pLFxuXG4gICAgICBhbmltaXQodGhpcy5fZ2V0RmFicygpLCB0aGlzLmRlZilcbiAgICAgICAgLndhaXQodGhpcy5kZWxheSlcbiAgICAgICAgLnF1ZXVlKHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgMCwgMCkgc2NhbGUoMSlgIH0sIHRoaXMuZGVmKSxcblxuICAgICAgYW5pbWl0KHV0aWwuYXJyYXlGcm9tKHRvYXN0LmNoaWxkcmVuKSwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSlcbiAgICApO1xuICB9XG5cbiAgX2dldEZhYnMoKSB7XG4gICAgcmV0dXJuIHV0aWwuYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ29ucy1mYWJbcG9zaXRpb25+PWJvdHRvbV0sIG9ucy1zcGVlZC1kaWFsW3Bvc2l0aW9ufj1ib3R0b21dJykpLmZpbHRlcihmYWIgPT4gZmFiLnZpc2libGUpO1xuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgaVBob25lWFBhdGNoIGZyb20gJy4uLy4uL29ucy9pcGhvbmV4LXBhdGNoJztcbmltcG9ydCBUb2FzdEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIExpZnQtZmFkZSBUb2FzdCBBbmltYXRvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaWZ0VG9hc3RBbmltYXRvciBleHRlbmRzIFRvYXN0QW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgdGltaW5nID0gJ2Vhc2UnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zNSB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICAgIHRoaXMuYm9keUhlaWdodCA9IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0OyAvLyBhdm9pZCBGb3JjZWQgU3luY2hyb25vdXMgTGF5b3V0XG4gICAgaWYgKGlQaG9uZVhQYXRjaC5pc0lQaG9uZVhQb3J0cmFpdFBhdGNoQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMubGlmdEFtb3VudCA9ICdjYWxjKDEwMCUgKyAzNHB4KSc7XG4gICAgfSBlbHNlIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYTGFuZHNjYXBlUGF0Y2hBY3RpdmUoKSkge1xuICAgICAgdGhpcy5saWZ0QW1vdW50ID0gJ2NhbGMoMTAwJSArIDIxcHgpJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5saWZ0QW1vdW50ID0gJzEwMCUnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgc2hvdyh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICB0b2FzdCA9IHRvYXN0Ll90b2FzdDtcblxuICAgIGFuaW1pdC5ydW5BbGwoXG4gICAgICBhbmltaXQodG9hc3QsIHRoaXMuZGVmKVxuICAgICAgICAuZGVmYXVsdChcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5saWZ0QW1vdW50fSwgMClgLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IDEgfVxuICAgICAgICApXG4gICAgICAgIC5xdWV1ZShkb25lID0+IHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGhpZGUodG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRvYXN0LCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5saWZ0QW1vdW50fSwgMClgLCBvcGFjaXR5OiAwIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIF91cGRhdGVQb3NpdGlvbih0b2FzdCkge1xuICAgIGlmIChwYXJzZUludCh0b2FzdC5zdHlsZS50b3AsIDEwKSA9PT0gMCkge1xuICAgICAgdG9hc3Quc3R5bGUudG9wID0gdG9hc3Quc3R5bGUuYm90dG9tID0gJyc7XG4gICAgfVxuICB9XG59XG4iLCJcbi8qXG5Db3B5cmlnaHQgMjAxMy0yMDE1IEFTSUFMIENPUlBPUkFUSU9OXG5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiovXG5cbmltcG9ydCB1dGlsIGZyb20gJy4uLy4uL29ucy91dGlsJztcbmltcG9ydCBhbmltaXQgZnJvbSAnLi4vLi4vb25zL2FuaW1pdCc7XG5pbXBvcnQgaVBob25lWFBhdGNoIGZyb20gJy4uLy4uL29ucy9pcGhvbmV4LXBhdGNoJztcbmltcG9ydCBUb2FzdEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuXG4vKipcbiAqIEZhbGwtZmFkZSBUb2FzdCBBbmltYXRvclxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWxsVG9hc3RBbmltYXRvciBleHRlbmRzIFRvYXN0QW5pbWF0b3Ige1xuXG4gIGNvbnN0cnVjdG9yKHsgdGltaW5nID0gJ2Vhc2UnLCBkZWxheSA9IDAsIGR1cmF0aW9uID0gMC4zNSB9ID0ge30pIHtcbiAgICBzdXBlcih7IHRpbWluZywgZGVsYXksIGR1cmF0aW9uIH0pO1xuICAgIGlmIChpUGhvbmVYUGF0Y2guaXNJUGhvbmVYUG9ydHJhaXRQYXRjaEFjdGl2ZSgpKSB7XG4gICAgICB0aGlzLmZhbGxBbW91bnQgPSAnY2FsYygtMTAwJSAtIDQ0cHgpJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWxsQW1vdW50ID0gJy0xMDAlJztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9hc3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIHNob3codG9hc3QsIGNhbGxiYWNrKSB7XG4gICAgdG9hc3QgPSB0b2FzdC5fdG9hc3Q7XG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24odG9hc3QpO1xuXG4gICAgYW5pbWl0LnJ1bkFsbChcbiAgICAgIGFuaW1pdCh0b2FzdCwgdGhpcy5kZWYpXG4gICAgICAgIC5kZWZhdWx0KFxuICAgICAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoMCwgJHt0aGlzLmZhbGxBbW91bnR9LCAwKWAsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApJywgb3BhY2l0eTogMSB9XG4gICAgICAgIClcbiAgICAgICAgLnF1ZXVlKGRvbmUgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0b2FzdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgaGlkZSh0b2FzdCwgY2FsbGJhY2spIHtcbiAgICB0b2FzdCA9IHRvYXN0Ll90b2FzdDtcbiAgICB0aGlzLl91cGRhdGVQb3NpdGlvbih0b2FzdCk7XG5cbiAgICBhbmltaXQucnVuQWxsKFxuICAgICAgYW5pbWl0KHRvYXN0LCB0aGlzLmRlZilcbiAgICAgICAgLmRlZmF1bHQoXG4gICAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKScsIG9wYWNpdHk6IDEgfSxcbiAgICAgICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKDAsICR7dGhpcy5mYWxsQW1vdW50fSwgMClgLCBvcGFjaXR5OiAwIH1cbiAgICAgICAgKVxuICAgICAgICAucXVldWUoZG9uZSA9PiB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24odG9hc3QsIHRydWUpO1xuICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9KVxuICAgICk7XG4gIH1cblxuICBfdXBkYXRlUG9zaXRpb24odG9hc3QsIGNsZWFuVXApIHtcbiAgICBsZXQgY29ycmVjdFRvcDtcbiAgICBpZiAoaVBob25lWFBhdGNoLmlzSVBob25lWFBvcnRyYWl0UGF0Y2hBY3RpdmUoKSkge1xuICAgICAgY29ycmVjdFRvcCA9ICc0NHB4JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29ycmVjdFRvcCA9ICcwJztcbiAgICB9XG5cbiAgICBpZiAodG9hc3Quc3R5bGUudG9wICE9PSBjb3JyZWN0VG9wKSB7XG4gICAgICB0b2FzdC5zdHlsZS50b3AgPSBjb3JyZWN0VG9wO1xuICAgICAgdG9hc3Quc3R5bGUuYm90dG9tID0gJ2luaXRpYWwnO1xuICAgIH1cbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uLy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgdXRpbCBmcm9tICcuLi8uLi9vbnMvdXRpbCc7XG5pbXBvcnQgYXV0b1N0eWxlIGZyb20gJy4uLy4uL29ucy9hdXRvc3R5bGUnO1xuaW1wb3J0IE1vZGlmaWVyVXRpbCBmcm9tICcuLi8uLi9vbnMvaW50ZXJuYWwvbW9kaWZpZXItdXRpbCc7XG5pbXBvcnQgQW5pbWF0b3JGYWN0b3J5IGZyb20gJy4uLy4uL29ucy9pbnRlcm5hbC9hbmltYXRvci1mYWN0b3J5JztcbmltcG9ydCBUb2FzdEFuaW1hdG9yIGZyb20gJy4vYW5pbWF0b3InO1xuaW1wb3J0IEZhZGVUb2FzdEFuaW1hdG9yIGZyb20gJy4vZmFkZS1hbmltYXRvcic7XG5pbXBvcnQgQXNjZW5kVG9hc3RBbmltYXRvciBmcm9tICcuL2FzY2VuZC1hbmltYXRvcic7XG5pbXBvcnQgTGlmdFRvYXN0QW5pbWF0b3IgZnJvbSAnLi9saWZ0LWFuaW1hdG9yJztcbmltcG9ydCBGYWxsVG9hc3RBbmltYXRvciBmcm9tICcuL2ZhbGwtYW5pbWF0b3InO1xuaW1wb3J0IHBsYXRmb3JtIGZyb20gJy4uLy4uL29ucy9wbGF0Zm9ybSc7XG5pbXBvcnQgQmFzZURpYWxvZ0VsZW1lbnQgZnJvbSAnLi4vYmFzZS9iYXNlLWRpYWxvZyc7XG5pbXBvcnQgY29udGVudFJlYWR5IGZyb20gJy4uLy4uL29ucy9jb250ZW50LXJlYWR5JztcblxuY29uc3Qgc2NoZW1lID0ge1xuICAnLnRvYXN0JzogJ3RvYXN0LS0qJyxcbiAgJy50b2FzdF9fbWVzc2FnZSc6ICd0b2FzdC0tKl9fbWVzc2FnZScsXG4gICcudG9hc3RfX2J1dHRvbic6ICd0b2FzdC0tKl9fYnV0dG9uJ1xufTtcblxuY29uc3QgZGVmYXVsdENsYXNzTmFtZSA9ICd0b2FzdCc7XG5cbmNvbnN0IF9hbmltYXRvckRpY3QgPSB7XG4gICdkZWZhdWx0JzogcGxhdGZvcm0uaXNBbmRyb2lkKCkgPyBBc2NlbmRUb2FzdEFuaW1hdG9yIDogTGlmdFRvYXN0QW5pbWF0b3IsXG4gICdmYWRlJzogRmFkZVRvYXN0QW5pbWF0b3IsXG4gICdhc2NlbmQnOiBBc2NlbmRUb2FzdEFuaW1hdG9yLFxuICAnbGlmdCc6IExpZnRUb2FzdEFuaW1hdG9yLFxuICAnZmFsbCc6IEZhbGxUb2FzdEFuaW1hdG9yLFxuICAnbm9uZSc6IFRvYXN0QW5pbWF0b3Jcbn07XG5cbi8qKlxuICogQGVsZW1lbnQgb25zLXRvYXN0XG4gKiBAY2F0ZWdvcnkgZGlhbG9nXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXVxuICogICAgIFRoZSBUb2FzdCBvciBTbmFja2JhciBjb21wb25lbnQgaXMgdXNlZnVsIGZvciBkaXNwbGF5aW5nIGRpc21pc3NhYmxlIGluZm9ybWF0aW9uIG9yIHNpbXBsZSBhY3Rpb25zIGF0IChub3JtYWxseSkgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5cbiAqXG4gKiAgICAgVGhpcyBjb21wb25lbnQgZG9lcyBub3QgYmxvY2sgdXNlciBpbnB1dCwgYWxsb3dpbmcgdGhlIGFwcCB0byBjb250aW51ZSBpdHMgZmxvdy4gRm9yIHNpbXBsZSB0b2FzdHMsIGNvbnNpZGVyIGBvbnMubm90aWZpY2F0aW9uLnRvYXN0YCBpbnN0ZWFkLlxuICogICBbL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEB0dXRvcmlhbCB2YW5pbGxhL1JlZmVyZW5jZS90b2FzdFxuICogQHNlZWFsc28gb25zLWFsZXJ0LWRpYWxvZ1xuICogICBbZW5dVGhlIGA8b25zLWFsZXJ0LWRpYWxvZz5gIGNvbXBvbmVudCBpcyBwcmVmZXJyZWQgZm9yIGRpc3BsYXlpbmcgdW5kaXNtaXNzYWJsZSBpbmZvcm1hdGlvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9hc3RFbGVtZW50IGV4dGVuZHMgQmFzZURpYWxvZ0VsZW1lbnQge1xuXG4gIC8qKlxuICAgKiBAYXR0cmlidXRlIGFuaW1hdGlvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVmYXVsdCBkZWZhdWx0XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVRoZSBhbmltYXRpb24gdXNlZCB3aGVuIHNob3dpbmcgYW5kIGhpZGluZyB0aGUgdG9hc3QuIENhbiBiZSBlaXRoZXIgYFwiZGVmYXVsdFwiYCwgYFwiYXNjZW5kXCJgIChBbmRyb2lkKSwgYFwibGlmdFwiYCAoaU9TKSwgYFwiZmFsbFwiYCwgYFwiZmFkZVwiYCBvciBgXCJub25lXCJgLlsvZW5dXG4gICAqICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgYW5pbWF0aW9uLW9wdGlvbnNcbiAgICogQHR5cGUge0V4cHJlc3Npb259XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCB0aW1pbmcgYW5kIGRlbGF5IHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMSwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCB0aW1pbmcsIGRlbGF544KS44Kq44OW44K444Kn44Kv44OI44Oq44OG44Op44Or44Gn5oyH5a6a44GX44G+44GZ44CCZS5nLiA8Y29kZT57ZHVyYXRpb246IDAuMiwgZGVsYXk6IDEsIHRpbWluZzogJ2Vhc2UtaW4nfTwvY29kZT5bL2phXVxuICAgKi9cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fZGVmYXVsdERCQiA9IGUgPT4gZS5jYWxsUGFyZW50SGFuZGxlcigpO1xuICAgIGNvbnRlbnRSZWFkeSh0aGlzLCAoKSA9PiB0aGlzLl9jb21waWxlKCkpO1xuICB9XG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHNjaGVtZTtcbiAgfVxuXG4gIGdldCBfdG9hc3QoKSB7XG4gICAgcmV0dXJuIHV0aWwuZmluZENoaWxkKHRoaXMsIGAuJHtkZWZhdWx0Q2xhc3NOYW1lfWApO1xuICB9XG5cbiAgX3VwZGF0ZUFuaW1hdG9yRmFjdG9yeSgpIHtcbiAgICAvLyBSZXNldCBwb3NpdGlvbiBzdHlsZVxuICAgIHRoaXMuX3RvYXN0ICYmICh0aGlzLl90b2FzdC5zdHlsZS50b3AgPSB0aGlzLl90b2FzdC5zdHlsZS5ib3R0b20gPSAnJyk7XG5cbiAgICByZXR1cm4gbmV3IEFuaW1hdG9yRmFjdG9yeSh7XG4gICAgICBhbmltYXRvcnM6IF9hbmltYXRvckRpY3QsXG4gICAgICBiYXNlQ2xhc3M6IFRvYXN0QW5pbWF0b3IsXG4gICAgICBiYXNlQ2xhc3NOYW1lOiAnVG9hc3RBbmltYXRvcicsXG4gICAgICBkZWZhdWx0QW5pbWF0aW9uOiB0aGlzLmdldEF0dHJpYnV0ZSgnYW5pbWF0aW9uJylcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgb25EZXZpY2VCYWNrQnV0dG9uXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1CYWNrLWJ1dHRvbiBoYW5kbGVyLlsvZW5dXG4gICAqICAgW2phXeODkOODg+OCr+ODnOOCv+ODs+ODj+ODs+ODieODqeOAglsvamFdXG4gICAqL1xuXG4gIF9jb21waWxlKCkge1xuICAgIGF1dG9TdHlsZS5wcmVwYXJlKHRoaXMpO1xuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gMTAwMDA7IC8vIExvd2VyIHRoYW4gZGlhbG9nc1xuXG4gICAgY29uc3QgbWVzc2FnZUNsYXNzTmFtZSA9ICd0b2FzdF9fbWVzc2FnZSc7XG4gICAgY29uc3QgYnV0dG9uQ2xhc3NOYW1lID0gJ3RvYXN0X19idXR0b24nO1xuXG4gICAgbGV0IHRvYXN0ID0gdXRpbC5maW5kQ2hpbGQodGhpcywgYC4ke2RlZmF1bHRDbGFzc05hbWV9YCk7XG4gICAgaWYgKCF0b2FzdCkge1xuICAgICAgdG9hc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRvYXN0LmNsYXNzTGlzdC5hZGQoZGVmYXVsdENsYXNzTmFtZSk7XG4gICAgICB3aGlsZSAodGhpcy5jaGlsZE5vZGVzWzBdKSB7XG4gICAgICAgIHRvYXN0LmFwcGVuZENoaWxkKHRoaXMuY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGJ1dHRvbiA9IHV0aWwuZmluZENoaWxkKHRvYXN0LCBgLiR7YnV0dG9uQ2xhc3NOYW1lfWApO1xuICAgIGlmICghYnV0dG9uKSB7XG4gICAgICBidXR0b24gPSB1dGlsLmZpbmRDaGlsZCh0b2FzdCwgZSA9PiB1dGlsLm1hdGNoKGUsICcuYnV0dG9uJykgfHwgdXRpbC5tYXRjaChlLCAnYnV0dG9uJykpO1xuICAgICAgaWYgKGJ1dHRvbikge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnYnV0dG9uJyk7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKGJ1dHRvbkNsYXNzTmFtZSk7XG4gICAgICAgIHRvYXN0LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF1dGlsLmZpbmRDaGlsZCh0b2FzdCwgYC4ke21lc3NhZ2VDbGFzc05hbWV9YCkpIHtcbiAgICAgIGxldCBtZXNzYWdlID0gdXRpbC5maW5kQ2hpbGQodG9hc3QsICcubWVzc2FnZScpO1xuICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRvYXN0LmNoaWxkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAodG9hc3QuY2hpbGROb2Rlc1tpXSAhPT0gYnV0dG9uKSB7XG4gICAgICAgICAgICBtZXNzYWdlLmluc2VydEJlZm9yZSh0b2FzdC5jaGlsZE5vZGVzW2ldLCBtZXNzYWdlLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWVzc2FnZS5jbGFzc0xpc3QuYWRkKG1lc3NhZ2VDbGFzc05hbWUpO1xuXG4gICAgICB0b2FzdC5pbnNlcnRCZWZvcmUobWVzc2FnZSwgdG9hc3QuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHRvYXN0LnBhcmVudE5vZGUgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodG9hc3QpO1xuICAgIH1cblxuICAgIE1vZGlmaWVyVXRpbC5pbml0TW9kaWZpZXIodGhpcywgdGhpcy5fc2NoZW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvcGVydHkgdmlzaWJsZVxuICAgKiBAcmVhZG9ubHlcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1XaGV0aGVyIHRoZSBlbGVtZW50IGlzIHZpc2libGUgb3Igbm90LlsvZW5dXG4gICAqICAgW2phXeimgee0oOOBjOimi+OBiOOCi+WgtOWQiOOBq2B0cnVlYOOAglsvamFdXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHNob3dcbiAgICogQHNpZ25hdHVyZSBzaG93KFtvcHRpb25zXSlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiAgIFtlbl1QYXJhbWV0ZXIgb2JqZWN0LlsvZW5dXG4gICAqICAgW2phXeOCquODl+OCt+ODp+ODs+OCkuaMh+WumuOBmeOCi+OCquODluOCuOOCp+OCr+ODiOOAglsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25dXG4gICAqICAgW2VuXUFuaW1hdGlvbiBuYW1lLiBBdmFpbGFibGUgYW5pbWF0aW9ucyBhcmUgYFwiZGVmYXVsdFwiYCwgYFwiYXNjZW5kXCJgIChBbmRyb2lkKSwgYFwibGlmdFwiYCAoaU9TKSwgYFwiZmFsbFwiYCwgYFwiZmFkZVwiYCBvciBgXCJub25lXCJgLlsvZW5dXG4gICAqICAgW2phXVsvamFdXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb25PcHRpb25zXVxuICAgKiAgIFtlbl1TcGVjaWZ5IHRoZSBhbmltYXRpb24ncyBkdXJhdGlvbiwgZGVsYXkgYW5kIHRpbWluZy4gRS5nLiBge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfWAuWy9lbl1cbiAgICogICBbamFd44Ki44OL44Oh44O844K344On44Oz5pmC44GuZHVyYXRpb24sIGRlbGF5LCB0aW1pbmfjgpLmjIflrprjgZfjgb7jgZnjgIJlLmcuIHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31bL2phXVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dU2hvdyB0aGUgZWxlbWVudC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiAgIFtlbl1SZXNvbHZlcyB0byB0aGUgZGlzcGxheWVkIGVsZW1lbnRbL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHNpZ25hdHVyZSB0b2dnbGUoW29wdGlvbnNdKVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqICAgW2VuXVBhcmFtZXRlciBvYmplY3QuWy9lbl1cbiAgICogICBbamFd44Kq44OX44K344On44Oz44KS5oyH5a6a44GZ44KL44Kq44OW44K444Kn44Kv44OI44CCWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbl1cbiAgICogICBbZW5dQW5pbWF0aW9uIG5hbWUuIEF2YWlsYWJsZSBhbmltYXRpb25zIGFyZSBgXCJkZWZhdWx0XCJgLCBgXCJhc2NlbmRcImAgKEFuZHJvaWQpLCBgXCJsaWZ0XCJgIChpT1MpLCBgXCJmYWxsXCJgLCBgXCJmYWRlXCJgIG9yIGBcIm5vbmVcImAuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbk9wdGlvbnNdXG4gICAqICAgW2VuXVNwZWNpZnkgdGhlIGFuaW1hdGlvbidzIGR1cmF0aW9uLCBkZWxheSBhbmQgdGltaW5nLiBFLmcuIGB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9YC5bL2VuXVxuICAgKiAgIFtqYV3jgqLjg4vjg6Hjg7zjgrfjg6fjg7PmmYLjga5kdXJhdGlvbiwgZGVsYXksIHRpbWluZ+OCkuaMh+WumuOBl+OBvuOBmeOAgmUuZy4ge2R1cmF0aW9uOiAwLjIsIGRlbGF5OiAwLjQsIHRpbWluZzogJ2Vhc2UtaW4nfVsvamFdXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAgIFtlbl1Ub2dnbGUgdG9hc3QgdmlzaWJpbGl0eS5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQG1ldGhvZCBoaWRlXG4gICAqIEBzaWduYXR1cmUgaGlkZShbb3B0aW9uc10pXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogICBbZW5dUGFyYW1ldGVyIG9iamVjdC5bL2VuXVxuICAgKiAgIFtqYV3jgqrjg5fjgrfjg6fjg7PjgpLmjIflrprjgZnjgovjgqrjg5bjgrjjgqfjgq/jg4jjgIJbL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uXVxuICAgKiAgIFtlbl1BbmltYXRpb24gbmFtZS4gQXZhaWxhYmxlIGFuaW1hdGlvbnMgYXJlIGBcImRlZmF1bHRcImAsIGBcImFzY2VuZFwiYCAoQW5kcm9pZCksIGBcImxpZnRcImAgKGlPUyksIGBcImZhbGxcImAsIGBcImZhZGVcImAgb3IgYFwibm9uZVwiYC5bL2VuXVxuICAgKiAgIFtqYV1bL2phXVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uT3B0aW9uc11cbiAgICogICBbZW5dU3BlY2lmeSB0aGUgYW5pbWF0aW9uJ3MgZHVyYXRpb24sIGRlbGF5IGFuZCB0aW1pbmcuIEUuZy4gYHtkdXJhdGlvbjogMC4yLCBkZWxheTogMC40LCB0aW1pbmc6ICdlYXNlLWluJ31gLlsvZW5dXG4gICAqICAgW2phXeOCouODi+ODoeODvOOCt+ODp+ODs+aZguOBrmR1cmF0aW9uLCBkZWxheSwgdGltaW5n44KS5oyH5a6a44GX44G+44GZ44CCZS5nLiB7ZHVyYXRpb246IDAuMiwgZGVsYXk6IDAuNCwgdGltaW5nOiAnZWFzZS1pbid9Wy9qYV1cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXUhpZGUgdG9hc3QuWy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogICBbZW5dUmVzb2x2ZXMgdG8gdGhlIGhpZGRlbiBlbGVtZW50Wy9lbl1cbiAgICogICBbamFdWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IEFuaW1hdG9yXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJBbmltYXRvcihuYW1lLCBBbmltYXRvcikge1xuICAgIGlmICghKEFuaW1hdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFRvYXN0QW5pbWF0b3IpKSB7XG4gICAgICB1dGlsLnRocm93KCdcIkFuaW1hdG9yXCIgcGFyYW0gbXVzdCBpbmhlcml0IE9uc1RvYXN0RWxlbWVudC5Ub2FzdEFuaW1hdG9yJyk7XG4gICAgfVxuICAgIF9hbmltYXRvckRpY3RbbmFtZV0gPSBBbmltYXRvcjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgYW5pbWF0b3JzKCkge1xuICAgIHJldHVybiBfYW5pbWF0b3JEaWN0O1xuICB9XG5cbiAgc3RhdGljIGdldCBUb2FzdEFuaW1hdG9yKCkge1xuICAgIHJldHVybiBUb2FzdEFuaW1hdG9yO1xuICB9XG59XG5cbm9uc0VsZW1lbnRzLlRvYXN0ID0gVG9hc3RFbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdG9hc3QnLCBUb2FzdEVsZW1lbnQpO1xuIiwiLypcbkNvcHlyaWdodCAyMDEzLTIwMTUgQVNJQUwgQ09SUE9SQVRJT05cblxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuKi9cblxuaW1wb3J0IG9uc0VsZW1lbnRzIGZyb20gJy4uL29ucy9lbGVtZW50cyc7XG5pbXBvcnQgQmFzZUJ1dHRvbkVsZW1lbnQgZnJvbSAnLi9iYXNlL2Jhc2UtYnV0dG9uJztcblxuLyoqXG4gKiBAZWxlbWVudCBvbnMtdG9vbGJhci1idXR0b25cbiAqIEBjYXRlZ29yeSBwYWdlXG4gKiBAbW9kaWZpZXIgbWF0ZXJpYWxcbiAqICAgW2VuXU1hdGVyaWFsIERlc2lnbiB0b29sYmFyIGJ1dHRvbi5bL2VuXVxuICogICBbamFdWy9qYV1cbiAqIEBtb2RpZmllciBvdXRsaW5lXG4gKiAgIFtlbl1BIGJ1dHRvbiB3aXRoIGFuIG91dGxpbmUuWy9lbl1cbiAqICAgW2phXeOCouOCpuODiOODqeOCpOODs+OCkuOCguOBo+OBn+ODnOOCv+ODs+OCkuihqOekuuOBl+OBvuOBmeOAglsvamFdXG4gKiBAZGVzY3JpcHRpb25cbiAqICAgW2VuXUJ1dHRvbiBjb21wb25lbnQgZm9yIG9ucy10b29sYmFyIGFuZCBvbnMtYm90dG9tLXRvb2xiYXIuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44GC44KL44GE44Gvb25zLWJvdHRvbS10b29sYmFy44Gr6Kit572u44Gn44GN44KL44Oc44K/44Oz55So44Kz44Oz44Od44O844ON44Oz44OI44Gn44GZ44CCWy9qYV1cbiAqIEBjb2RlcGVuIGFIbUdMXG4gKiBAdHV0b3JpYWwgdmFuaWxsYS9SZWZlcmVuY2UvcGFnZVxuICogQGd1aWRlIGNvbXBpbGF0aW9uLmh0bWwjdG9vbGJhci1jb21waWxhdGlvblxuICogICBbZW5dQWRkaW5nIGEgdG9vbGJhclsvZW5dXG4gKiAgIFtqYV3jg4Tjg7zjg6vjg5Djg7zjga7ov73liqBbL2phXVxuICogQHNlZWFsc28gb25zLXRvb2xiYXJcbiAqICAgW2VuXVRoZSBgPG9ucy10b29sYmFyPmAgY29tcG9uZW50IGRpc3BsYXlzIGEgbmF2aWdhdGlvbiBiYXIgYXQgdGhlIHRvcCBvZiBhIHBhZ2UuWy9lbl1cbiAqICAgW2phXW9ucy10b29sYmFy44Kz44Oz44Od44O844ON44Oz44OIWy9qYV1cbiAqIEBzZWVhbHNvIG9ucy1iYWNrLWJ1dHRvblxuICogICBbZW5dVGhlIGA8b25zLWJhY2stYnV0dG9uPmAgZGlzcGxheXMgYSBiYWNrIGJ1dHRvbiBpbiB0aGUgbmF2aWdhdGlvbiBiYXIuWy9lbl1cbiAqICAgW2phXW9ucy1iYWNrLWJ1dHRvbuOCs+ODs+ODneODvOODjeODs+ODiFsvamFdXG4gKiBAZXhhbXBsZVxuICogPG9ucy10b29sYmFyPlxuICogICA8ZGl2IGNsYXNzPVwibGVmdFwiPlxuICogICAgIDxvbnMtdG9vbGJhci1idXR0b24+XG4gKiAgICAgICBCdXR0b25cbiAqICAgICA8L29ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgPC9kaXY+XG4gKiAgIDxkaXYgY2xhc3M9XCJjZW50ZXJcIj5cbiAqICAgICBUaXRsZVxuICogICA8L2Rpdj5cbiAqICAgPGRpdiBjbGFzcz1cInJpZ2h0XCI+XG4gKiAgICAgPG9ucy10b29sYmFyLWJ1dHRvbj5cbiAqICAgICAgIDxvbnMtaWNvbiBpY29uPVwiaW9uLW5hdmljb25cIiBzaXplPVwiMjhweFwiPjwvb25zLWljb24+XG4gKiAgICAgPC9vbnMtdG9vbGJhci1idXR0b24+XG4gKiAgIDwvZGl2PlxuICogPC9vbnMtdG9vbGJhcj5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9vbGJhckJ1dHRvbkVsZW1lbnQgZXh0ZW5kcyBCYXNlQnV0dG9uRWxlbWVudCB7XG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgbW9kaWZpZXJcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVRoZSBhcHBlYXJhbmNlIG9mIHRoZSBidXR0b24uWy9lbl1cbiAgICogICBbamFd44Oc44K/44Oz44Gu6KGo54++44KS5oyH5a6a44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgaWNvblxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogIFtlbl1DcmVhdGVzIGFuIGBvbnMtaWNvbmAgY29tcG9uZW50IHdpdGggdGhpcyBzdHJpbmcuWy9lbl1cbiAgICogIFtqYV1gb25zLWljb25g44Kz44Oz44Od44O844ON44Oz44OI44KS5oKq5oCn44GX44G+44GZ44CCWy9qYV1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBhdHRyaWJ1dGUgZGlzYWJsZWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqICAgW2VuXVNwZWNpZnkgaWYgYnV0dG9uIHNob3VsZCBiZSBkaXNhYmxlZC5bL2VuXVxuICAgKiAgIFtqYV3jg5zjgr/jg7PjgpLnhKHlirnljJbjgZnjgovloLTlkIjjga/mjIflrprjgZfjgabjgY/jgaDjgZXjgYTjgIJbL2phXVxuICAgKi9cblxuICAvKipcbiAgICogQHByb3BlcnR5IGRpc2FibGVkXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogICBbZW5dV2hldGhlciB0aGUgZWxlbWVudCBpcyBkaXNhYmxlZCBvciBub3QuWy9lbl1cbiAgICogICBbamFd54Sh5Yq55YyW44GV44KM44Gm44GE44KL5aC05ZCI44GrYHRydWVg44CCWy9qYV1cbiAgICovXG5cbiAgZ2V0IF9zY2hlbWUoKSB7XG4gICAgcmV0dXJuIHsgJyc6ICd0b29sYmFyLWJ1dHRvbi0tKicgfTtcbiAgfVxuXG4gIGdldCBfZGVmYXVsdENsYXNzTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Rvb2xiYXItYnV0dG9uJztcbiAgfVxuXG4gIGdldCBfcmlwcGxlT3B0KCkge1xuICAgIHJldHVybiBbdGhpcywgdW5kZWZpbmVkLCB7IGNlbnRlcjogJycsICdzaXplJzogJ2NvbnRhaW4nLCAnYmFja2dyb3VuZCc6ICd0cmFuc3BhcmVudCcgfV07XG4gIH1cbn1cblxub25zRWxlbWVudHMuVG9vbGJhckJ1dHRvbiA9IFRvb2xiYXJCdXR0b25FbGVtZW50O1xuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdvbnMtdG9vbGJhci1idXR0b24nLCBUb29sYmFyQnV0dG9uRWxlbWVudCk7XG4iLCJpbXBvcnQgb25zIGZyb20gJy4vb25zJzsgLy8gQWRkIG9ucyBpbnRlcm5hbHNcbmltcG9ydCBzZXR1cCBmcm9tICcuL3NldHVwJzsgLy8gQWRkIHBvbHlmaWxsc1xuXG4vLyBBZGQgYW5kIHJlZ2lzdGVyIEN1c3RvbSBFbGVtZW50c1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10ZW1wbGF0ZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWlmJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYWN0aW9uLXNoZWV0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYWN0aW9uLXNoZWV0LWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZyc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWFsZXJ0LWRpYWxvZy1idXR0b24nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1iYWNrLWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWJvdHRvbS10b29sYmFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtYnV0dG9uJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtY2FyZCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNhcm91c2VsLWl0ZW0nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jYXJvdXNlbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWNvbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWRpYWxvZyc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWZhYic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWdlc3R1cmUtZGV0ZWN0b3InO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1pY29uJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbGF6eS1yZXBlYXQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0LWhlYWRlcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLWxpc3QtdGl0bGUnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0LWl0ZW0nO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1saXN0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtaW5wdXQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1jaGVja2JveCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXJhZGlvJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc2VhcmNoLWlucHV0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtbW9kYWwnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1uYXZpZ2F0b3InO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1wYWdlJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcG9wb3Zlcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWJhcic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXByb2dyZXNzLWNpcmN1bGFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcHVsbC1ob29rJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtcmFuZ2UnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1yaXBwbGUnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1yb3cnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zZWdtZW50JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc2VsZWN0JztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbC1pdGVtJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BlZWQtZGlhbCc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyLWNvbnRlbnQnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy1zcGxpdHRlci1tYXNrJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3BsaXR0ZXItc2lkZSc7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXNwbGl0dGVyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtc3dpdGNoJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdGFiJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdGFiYmFyJztcbmltcG9ydCAnLi9lbGVtZW50cy9vbnMtdG9hc3QnO1xuaW1wb3J0ICcuL2VsZW1lbnRzL29ucy10b29sYmFyLWJ1dHRvbic7XG5pbXBvcnQgJy4vZWxlbWVudHMvb25zLXRvb2xiYXInO1xuXG5zZXR1cChvbnMpOyAvLyBTZXR1cCBpbml0aWFsIGxpc3RlbmVyc1xud2luZG93Ll9zdXBlclNlY3JldE9ucyA9IG9ucztcblxuZXhwb3J0IGRlZmF1bHQgb25zO1xuIl0sIm5hbWVzIjpbInByZWZpeCIsInN0eWxlcyIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsIkFycmF5IiwicHJvdG90eXBlIiwic2xpY2UiLCJjYWxsIiwiam9pbiIsIm1hdGNoIiwiT0xpbmsiLCJuYW1lIiwidXRpbCIsImh5cGhlbmF0ZSIsInN0eWxlciIsImVsZW1lbnQiLCJzdHlsZSIsImtleXMiLCJmb3JFYWNoIiwia2V5Iiwid2FybiIsImNsZWFyIiwiY2xlYXJsaXN0Iiwic3BsaXQiLCJyZWR1Y2UiLCJyIiwicyIsImNvbmNhdCIsImkiLCJsZW5ndGgiLCJzb21lIiwiaW5kZXhPZiIsInB1c2giLCJnZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJOYXRpdmVIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiUGxhdGZvcm0iLCJfc2VsZWN0ZWRQbGF0Zm9ybSIsIl9pZ25vcmVQbGF0Zm9ybVNlbGVjdCIsInBsYXRmb3JtIiwidHJpbSIsInRvTG93ZXJDYXNlIiwiZm4iLCJyZXN1bHQiLCJyZWFkeVN0YXRlIiwiRXJyb3IiLCJjb3Jkb3ZhIiwicGhvbmVnYXAiLCJQaG9uZUdhcCIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpc0lQaG9uZSIsInNjcmVlbiIsIndpZHRoIiwiaGVpZ2h0IiwiX2dldFNlbGVjdGVkUGxhdGZvcm0iLCJkZXZpY2UiLCJwYXJzZUludCIsInZlcnNpb24iLCJ2ZXIiLCJyZXBsYWNlIiwidWEiLCJpc0lPUyIsInN0YW5kYWxvbmUiLCJsdGU5Iiwid2Via2l0IiwibWVzc2FnZUhhbmRsZXJzIiwiaW5kZXhlZERCIiwiaXNJT1NTYWZhcmkiLCJpc1dLV2ViVmlldyIsIm9wZXJhIiwiSW5zdGFsbFRyaWdnZXIiLCJPYmplY3QiLCJ0b1N0cmluZyIsInAiLCJzYWZhcmkiLCJwdXNoTm90aWZpY2F0aW9uIiwiY2hyb21lIiwiZG9jdW1lbnRNb2RlIiwiaXNBbmRyb2lkIiwiaXNXUCIsImlzSVBhZCIsImlzSVBvZCIsImVycm9yIiwidGhyb3ciLCJtZXNzYWdlIiwicGFnZUF0dHJpYnV0ZUV4cHJlc3Npb24iLCJ2YWx1ZSIsIm92ZXJ3cml0ZSIsIl92YXJpYWJsZXMiLCJoYXNPd25Qcm9wZXJ0eSIsInBhcnQiLCJjIiwiaW5JbnRlcnBvbGF0aW9uIiwiY3VycmVudEluZGV4IiwidG9rZW5zIiwiY2hhckF0IiwidG9rZW4iLCJzdWJzdHJpbmciLCJyZSIsInZhcmlhYmxlIiwiZ2V0VmFyaWFibGUiLCJydiIsIm1hcCIsIl9yZXBsYWNlVG9rZW4iLCJiaW5kIiwiZXhwcmVzc2lvbiIsIl9wYXJzZVBhcnQiLCJfcmVwbGFjZVRva2VucyIsIl9wYXJzZUV4cHJlc3Npb24iLCJkZWZpbmVWYXJpYWJsZSIsImdldE1vYmlsZU9TIiwiZ2V0SU9TRGV2aWNlIiwiaXNXZWJWaWV3IiwiaW50ZXJuYWwiLCJjb25maWciLCJudWxsRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpc0VuYWJsZWRBdXRvU3RhdHVzQmFyRmlsbCIsImF1dG9TdGF0dXNCYXJGaWxsIiwibm9ybWFsaXplUGFnZUhUTUwiLCJodG1sIiwid2FpdERPTUNvbnRlbnRMb2FkZWQiLCJ3cmFwcGVkQ2FsbGJhY2siLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhbGxiYWNrIiwib25SZWFkeSIsInNob3VsZEZpbGxTdGF0dXNCYXIiLCJpc0lPUzdhYm92ZSIsImlzSVBob25lWCIsImJvZHkiLCJxdWVyeVNlbGVjdG9yIiwidGVtcGxhdGVTdG9yZSIsIl9zdG9yYWdlIiwidGVtcGxhdGUiLCJlIiwidGFyZ2V0Iiwibm9kZU5hbWUiLCJzZXQiLCJ0ZW1wbGF0ZUlkIiwicmVnaXN0ZXIiLCJxdWVyeSIsInRlbXBsYXRlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0ZXh0Q29udGVudCIsImNvbnRlbnQiLCJnZXRUZW1wbGF0ZUhUTUxBc3luYyIsInBhZ2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImNhY2hlIiwiZ2V0IiwiRG9jdW1lbnRGcmFnbWVudCIsImxvY2FsIiwiZ2V0RWxlbWVudEJ5SWQiLCJ4aHIiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJvbmxvYWQiLCJyZXNwb25zZVRleHQiLCJzdGF0dXMiLCJmcmFnbWVudCIsImNyZWF0ZUZyYWdtZW50IiwiYXJyYXlGcm9tIiwic2NyaXB0IiwidHlwZSIsImVsIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsInRleHQiLCJpbm5lckhUTUwiLCJwYXJlbnROb2RlIiwicmVwbGFjZUNoaWxkIiwib25lcnJvciIsInNlbmQiLCJnZXRQYWdlSFRNTEFzeW5jIiwicGFnZXMiLCJldmFsdWF0ZSIsImdldFBhZ2UiLCJjYXRjaCIsInNoaWZ0IiwiQW5pbWF0b3JGYWN0b3J5Iiwib3B0cyIsIl9hbmltYXRvcnMiLCJhbmltYXRvcnMiLCJfYmFzZUNsYXNzIiwiYmFzZUNsYXNzIiwiX2Jhc2VDbGFzc05hbWUiLCJiYXNlQ2xhc3NOYW1lIiwiX2FuaW1hdGlvbiIsImRlZmF1bHRBbmltYXRpb24iLCJfYW5pbWF0aW9uT3B0aW9ucyIsImRlZmF1bHRBbmltYXRpb25PcHRpb25zIiwib3B0aW9ucyIsImRlZmF1bHRBbmltYXRvciIsImFuaW1hdG9yIiwiYW5pbWF0aW9uIiwiQW5pbWF0b3IiLCJhbmltYXRpb25PcHRzIiwiZXh0ZW5kIiwiYW5pbWF0aW9uT3B0aW9ucyIsImFuaW1hdGlvbnNEaXNhYmxlZCIsImR1cmF0aW9uIiwiZGVsYXkiLCJqc29uU3RyaW5nIiwiYW5pbWF0aW9uT3B0aW9uc1BhcnNlIiwiYXV0b1N0eWxlRW5hYmxlZCIsIm1vZGlmaWVyc01hcCIsInBsYXRmb3JtcyIsImFuZHJvaWQiLCJlbGVtZW50TmFtZSIsInRhZ05hbWUiLCJoYXNNb2RpZmllciIsIm9sZE1vZGlmaWVyIiwibmV3TW9kaWZpZXIiLCJ1bnNoaWZ0Iiwic2V0QXR0cmlidXRlIiwiZWxlbWVudHMiLCJoYXNBdHRyaWJ1dGUiLCJpb3MiLCJyZW1vdmVNb2RpZmllciIsImFkZE1vZGlmaWVyIiwidW5sb2NrZWQiLCJnZXRQbGF0Zm9ybSIsImZvcmNlIiwibW9iaWxlT1MiLCJvbnNQbGF0Zm9ybSIsInByZXBhcmUiLCJtYXBNb2RpZmllciIsIm1vZGlmaWVyIiwibSIsInJlc3RvcmVNb2RpZmllciIsIk1vZGlmaWVyVXRpbCIsImxhc3QiLCJjdXJyZW50IiwibWFrZURpY3QiLCJyZW1vdmVkIiwiYWRkZWQiLCJkaWN0IiwiZGlmZiIsImNsYXNzTGlzdCIsImtsYXNzIiwiYWRkIiwiayIsInJlbW92ZSIsInNjaGVtZSIsInRhcmdldEVsZW1lbnRzIiwic2VsZWN0b3IiLCJmaWx0ZXIiLCJmaW5kUGFyZW50IiwidGFyZ2V0RWxlbWVudCIsInBhcmVudCIsImFwcGx5RGlmZlRvQ2xhc3NMaXN0IiwiYXBwbHlEaWZmVG9FbGVtZW50IiwibW9kaWZpZXJUb2tlbiIsImluZGV4Iiwic3BsaWNlIiwiX2RvbUNvbnRlbnRMb2FkZWQiLCJfcmVhZHkiLCJfb25ET01Db250ZW50TG9hZGVkIiwiSGFuZGxlclJlcG9zaXRvcnkiLCJoYW5kbGVyIiwiZGF0YXNldCIsImRldmljZUJhY2tCdXR0b25IYW5kbGVySWQiLCJpZCIsIl9nZW5JZCIsIl9zdG9yZSIsInVuZGVmaW5lZCIsIkRldmljZUJhY2tCdXR0b25EaXNwYXRjaGVyIiwiX2lzRW5hYmxlZCIsIl9ib3VuZENhbGxiYWNrIiwiX2NhbGxiYWNrIiwiYWRkQmFja0J1dHRvbkxpc3RlbmVyIiwicmVtb3ZlQmFja0J1dHRvbkxpc3RlbmVyIiwiZXZlbnQiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJfZGlzcGF0Y2hEZXZpY2VCYWNrQnV0dG9uRXZlbnQiLCJGdW5jdGlvbiIsIl9lbGVtZW50IiwiZW5hYmxlIiwidHJlZSIsIl9jYXB0dXJlVHJlZSIsIl9maW5kSGFuZGxlckxlYWZFbGVtZW50IiwiY3JlYXRlVHJlZSIsImFwcGx5IiwiYXJyYXlPZiIsImNoaWxkcmVuIiwiY2hpbGRFbGVtZW50IiwiZGlzcGxheSIsIl9pc1Nob3duIiwiaGFzIiwic3ViVHJlZSIsImZpbmQiLCJub2RlIiwiY2hpbGROb2RlIiwibGVmdCIsInJpZ2h0IiwibGVmdFoiLCJ6SW5kZXgiLCJyaWdodFoiLCJpc05hTiIsImRiYkRpc3BhdGNoZXIiLCJkZXZpY2VCYWNrQnV0dG9uRGlzcGF0Y2hlciIsInN0YXJ0c1dpdGgiLCJzdWJzdHIiLCJlbmRzV2l0aCIsInVud3JhcCIsImlzT2JqZWN0U3RyaW5nIiwiaXNBcnJheVN0cmluZyIsImlzUXVvdGVkU3RyaW5nIiwic3RyaW5nIiwib3JpZ2luYWxTdHJpbmciLCJwcm9jZXNzVG9rZW4iLCJwYXJzZU9iamVjdCIsInBhcnNlQXJyYXkiLCJuZXh0VG9rZW4iLCJsaW1pdCIsImNoYXJDb2RlQXQiLCJuZXN0ZWRPYmplY3QiLCJpc1ZhbGlkS2V5Iiwib2JqZWN0IiwicmVhZGluZ0tleSIsInByZXZpb3VzVG9rZW4iLCJhcnJheSIsInBhcnNlIiwiZXJyb3JQcmVmaXgiLCJnbG9iYWxzIiwiX3J1bk9uQWN0dWFsUGxhdGZvcm0iLCJhY3R1YWxNb2JpbGVPUyIsImlzVUlXZWJWaWV3IiwiZGVmaW5lUHJvcGVydHkiLCJzdXBwb3J0c1Bhc3NpdmUiLCJvcHQiLCJpc0dEIiwiY2FwdHVyZSIsInByZXBhcmVRdWVyeSIsIm1hdGNoZXMiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImZpbmRDaGlsZCIsImNoaWxkTm9kZXMiLCJub2RlVHlwZSIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJ1bnRpbCIsImlzQXR0YWNoZWQiLCJjb250YWlucyIsImhhc0FueUNvbXBvbmVudEFzUGFyZW50IiwiaXNQYWdlQ29udHJvbCIsInByb3BhZ2F0ZUFjdGlvbiIsImFjdGlvbiIsImNoaWxkIiwiY2FtZWxpemUiLCJsIiwidG9VcHBlckNhc2UiLCJjcmVhdGUiLCJjbGFzc05hbWUiLCJ3cmFwcGVyIiwiaW1wb3J0Tm9kZSIsImRzdCIsImFyZ3MiLCJqIiwiYXJyYXlMaWtlIiwicGFyc2VKU09OT2JqZWN0U2FmZWx5IiwiZmFpbFNhZmUiLCJKU09OIiwiZmluZEZyb21QYXRoIiwicGF0aCIsImdldFRvcFBhZ2UiLCJjb250YWluZXIiLCJ0b3BQYWdlIiwiZmluZFRvb2xiYXJQYWdlIiwiX2NhbkFuaW1hdGVUb29sYmFyIiwiX2NvbnRlbnRFbGVtZW50IiwibmV4dFBhZ2UiLCJ0cmlnZ2VyRWxlbWVudEV2ZW50IiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiQ3VzdG9tRXZlbnQiLCJtb2RpZmllck5hbWUiLCJSZWdFeHAiLCJhdXRvU3R5bGUiLCJmb3JjZUF1dG9TdHlsZSIsIm5ld01vZGlmaWVycyIsInRvZ2dsZU1vZGlmaWVyIiwidG9nZ2xlIiwicmVzdG9yZUNsYXNzIiwiZGVmYXVsdENsYXNzIiwicmVmcmVzaCIsInVwZGF0ZVBhcmVudFBvc2l0aW9uIiwiX3BhcmVudFVwZGF0ZWQiLCJwYXJlbnRFbGVtZW50IiwiZ2V0UHJvcGVydHlWYWx1ZSIsInBvc2l0aW9uIiwidG9nZ2xlQXR0cmlidXRlIiwiYmluZExpc3RlbmVycyIsImxpc3RlbmVyTmFtZXMiLCJib3VuZE5hbWUiLCJlYWNoIiwib2JqIiwiZiIsInVwZGF0ZVJpcHBsZSIsImhhc1JpcHBsZSIsImF0dHJzIiwicmlwcGxlRWxlbWVudCIsImluc2VydEJlZm9yZSIsImZpcnN0Q2hpbGQiLCJpc0ludGVnZXIiLCJpc0Zpbml0ZSIsIk1hdGgiLCJmbG9vciIsImRlZmVyIiwiZGVmZXJyZWQiLCJwcm9taXNlIiwid2FybmluZ3NEaXNhYmxlZCIsInRocm93QWJzdHJhY3QiLCJ0aHJvd01lbWJlciIsInRocm93UGFnZUxvYWRlciIsInRocm93QW5pbWF0b3IiLCJwcmV2ZW50IiwiY2FuY2VsYWJsZSIsInByZXZlbnREZWZhdWx0IiwiaW9zUHJldmVudFNjcm9sbCIsImNsZWFuIiwib2ZmIiwib24iLCJpb3NQYWdlU2Nyb2xsRml4IiwiZm9yY2VVSVdlYlZpZXdTY3JvbGxGaXgiLCJpb3NNYXNrU2Nyb2xsRml4IiwiaXNWYWxpZEdlc3R1cmUiLCJnZXN0dXJlIiwiZGlzdGFuY2UiLCJkZWx0YVRpbWUiLCJjaGVja01pc3NpbmdJbXBvcnQiLCJlbGVtZW50TmFtZXMiLCJvbnNFbGVtZW50cyIsIlRJTUVPVVRfUkFUSU8iLCJjYXBpdGFsaXplIiwic3RyIiwiYnVpbGRUcmFuc2l0aW9uVmFsdWUiLCJwYXJhbXMiLCJwcm9wZXJ0eSIsInRpbWluZyIsInByb3BzIiwicHJvcCIsIm9uY2VPblRyYW5zaXRpb25FbmQiLCJzdG9wUHJvcGFnYXRpb24iLCJyZW1vdmVMaXN0ZW5lcnMiLCJfdHJhbnNpdGlvbkVuZEV2ZW50cyIsInZlbmRvclByZWZpeCIsIl9jc3NQcm9wZXJ0eURpY3QiLCJhIiwieiIsInVwcGVyIiwiaGFzQ3NzUHJvcGVydHkiLCJwcmUiLCJmb3JjZUxheW91dEF0T25jZSIsImJhdGNoSW1tZWRpYXRlIiwib2Zmc2V0SGVpZ2h0IiwiY2FsbGJhY2tzIiwiY29uY3JlYXRlQ2FsbGJhY2tzIiwiYmF0Y2hBbmltYXRpb25GcmFtZSIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm1velJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJtc1JlcXVlc3RBbmltYXRpb25GcmFtZSIsInRyYW5zaXRpb25Qcm9wZXJ0eU5hbWUiLCJBbmltaXQiLCJkZWZhdWx0cyIsInRyYW5zaXRpb25RdWV1ZSIsImxhc3RTdHlsZUF0dHJpYnV0ZURpY3QiLCJkb25lIiwic3RhcnRBbmltYXRpb24iLCJmcm9tIiwidG8iLCJzdGVwIiwiY3NzIiwic2F2ZVN0eWxlIiwicXVldWUiLCJ3YWl0IiwicmVzdG9yZVN0eWxlIiwidHJhbnNpdGlvbiIsIlRyYW5zaXRpb24iLCJidWlsZCIsInNlY29uZHMiLCJzZWxmIiwidHJhbnNpdGlvbk5hbWUiLCJ0cmFuc2l0aW9uVmFsdWUiLCJ0aW1lb3V0SWQiLCJjbGVhclRyYW5zaXRpb24iLCJzZXRUaW1lb3V0IiwibGVuIiwicmVzZXQiLCJfZGVxdWV1ZVRyYW5zaXRpb24iLCJfY3VycmVudFRyYW5zaXRpb24iLCJjYWxsZWQiLCJydW5BbGwiLCJhcmd1bWVudHMiLCJwbGF5IiwiY3JlYXRlQWN0dWFsQ3NzUHJvcHMiLCJ0aW1lb3V0IiwicHJlZml4ZWQiLCJFdmVudCIsIlV0aWxzIiwiRGV0ZWN0aW9uIiwiUG9pbnRlckV2ZW50IiwiR2VzdHVyZURldGVjdG9yIiwiSW5zdGFuY2UiLCJET0NVTUVOVCIsIkhBU19QT0lOVEVSRVZFTlRTIiwicG9pbnRlckVuYWJsZWQiLCJtc1BvaW50ZXJFbmFibGVkIiwiSEFTX1RPVUNIRVZFTlRTIiwiSVNfTU9CSUxFIiwiTk9fTU9VU0VFVkVOVFMiLCJDQUxDVUxBVEVfSU5URVJWQUwiLCJFVkVOVF9UWVBFUyIsIkRJUkVDVElPTl9ET1dOIiwiRElSRUNUSU9OX0xFRlQiLCJESVJFQ1RJT05fVVAiLCJESVJFQ1RJT05fUklHSFQiLCJQT0lOVEVSX01PVVNFIiwiUE9JTlRFUl9UT1VDSCIsIlBPSU5URVJfUEVOIiwiRVZFTlRfU1RBUlQiLCJFVkVOVF9NT1ZFIiwiRVZFTlRfRU5EIiwiRVZFTlRfUkVMRUFTRSIsIkVWRU5UX1RPVUNIIiwiUkVBRFkiLCJwbHVnaW5zIiwiZ2VzdHVyZXMiLCJzZXR1cCIsImRldGVybWluZUV2ZW50VHlwZXMiLCJvblRvdWNoIiwiZGV0ZWN0IiwidXRpbHMiLCJkZXN0Iiwic3JjIiwibWVyZ2UiLCJpdGVyYXRvciIsImNvbnRleHQiLCJpblN0ciIsImluQXJyYXkiLCJkZWVwIiwiZXZlcnkiLCJ0b0FycmF5IiwiaGFzUGFyZW50IiwiZ2V0Q2VudGVyIiwidG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJjbGllbnRYIiwiY2xpZW50WSIsIm1pbiIsIm1heCIsInRvdWNoIiwiZ2V0VmVsb2NpdHkiLCJkZWx0YVgiLCJkZWx0YVkiLCJhYnMiLCJnZXRBbmdsZSIsInRvdWNoMSIsInRvdWNoMiIsIngiLCJ5IiwiYXRhbjIiLCJQSSIsImdldERpcmVjdGlvbiIsImdldERpc3RhbmNlIiwic3FydCIsImdldFNjYWxlIiwic3RhcnQiLCJlbmQiLCJnZXRSb3RhdGlvbiIsImlzVmVydGljYWwiLCJkaXJlY3Rpb24iLCJzZXRQcmVmaXhlZENzcyIsInByZWZpeGVzIiwidG9DYW1lbENhc2UiLCJ0b2dnbGVCZWhhdmlvciIsImZhbHNlRm4iLCJ1c2VyU2VsZWN0Iiwib25zZWxlY3RzdGFydCIsInVzZXJEcmFnIiwib25kcmFnc3RhcnQiLCJob29rIiwidHlwZXMiLCJldmVudFR5cGUiLCJvblRvdWNoSGFuZGxlciIsImV2Iiwic3JjVHlwZSIsImlzUG9pbnRlciIsImlzTW91c2UiLCJ0cmlnZ2VyVHlwZSIsInByZXZlbnRNb3VzZUV2ZW50cyIsImJ1dHRvbiIsInNob3VsZERldGVjdCIsImJ1dHRvbnMiLCJtYXRjaFR5cGUiLCJ1cGRhdGVQb2ludGVyIiwiZG9EZXRlY3QiLCJ0b3VjaExpc3QiLCJnZXRUb3VjaExpc3QiLCJ0b3VjaExpc3RMZW5ndGgiLCJ0cmlnZ2VyQ2hhbmdlIiwidHJpZ2dlciIsImNoYW5nZWRMZW5ndGgiLCJjaGFuZ2VkVG91Y2hlcyIsInN0YXJ0ZWQiLCJldkRhdGEiLCJjb2xsZWN0RXZlbnREYXRhIiwiaWRlbnRpZmllcnMiLCJpZGVudGlmaWVyIiwicG9pbnRlclR5cGUiLCJEYXRlIiwibm93Iiwic3JjRXZlbnQiLCJwcmV2ZW50TWFuaXB1bGF0aW9uIiwic3RvcERldGVjdCIsInRvdWNobGlzdCIsInBvaW50ZXJzIiwicG9pbnRlciIsInBvaW50ZXJFdmVudCIsInBvaW50ZXJJZCIsInB0IiwiTVNQT0lOVEVSX1RZUEVfTU9VU0UiLCJNU1BPSU5URVJfVFlQRV9UT1VDSCIsIk1TUE9JTlRFUl9UWVBFX1BFTiIsInJlc2V0TGlzdCIsImRldGVjdGlvbiIsInN0YXJ0RGV0ZWN0IiwiaW5zdCIsImV2ZW50RGF0YSIsInN0b3BwZWQiLCJleHRlbmRFdmVudERhdGEiLCJpbnN0T3B0aW9ucyIsInRyaWdnZXJHZXN0dXJlIiwiZW5hYmxlZCIsImxhc3RFdmVudCIsInByZXZpb3VzIiwiZ2V0Q2FsY3VsYXRlZERhdGEiLCJjZW50ZXIiLCJjdXIiLCJyZWNhbGMiLCJjYWxjRXYiLCJsYXN0Q2FsY0V2ZW50IiwiY2FsY0RhdGEiLCJsYXN0Q2FsY0RhdGEiLCJ0aW1lU3RhbXAiLCJmdXR1cmVDYWxjRXZlbnQiLCJ2ZWxvY2l0eSIsImFuZ2xlIiwidmVsb2NpdHlYIiwidmVsb2NpdHlZIiwiaW50ZXJpbUFuZ2xlIiwiaW50ZXJpbURpcmVjdGlvbiIsInN0YXJ0RXYiLCJzdGFydEV2ZW50IiwibGFzdEV2Iiwic29ydCIsImIiLCJsaXN0ZW5lck9wdGlvbnMiLCJwYXNzaXZlIiwiYmVoYXZpb3IiLCJldmVudFN0YXJ0SGFuZGxlciIsImV2ZW50SGFuZGxlcnMiLCJvbkV2ZW50Iiwib2ZmRXZlbnQiLCJ0cmlnZ2VyRXZlbnQiLCJzdGF0ZSIsImRpc3Bvc2UiLCJlaCIsInRyaWdnZXJlZCIsImRyYWdHZXN0dXJlIiwiZHJhZ01heFRvdWNoZXMiLCJkcmFnTWluRGlzdGFuY2UiLCJzdGFydENlbnRlciIsImRyYWdEaXN0YW5jZUNvcnJlY3Rpb24iLCJmYWN0b3IiLCJkcmFnTG9ja1RvQXhpcyIsImRyYWdMb2NrTWluRGlzdGFuY2UiLCJsYXN0RGlyZWN0aW9uIiwiZHJhZ0Jsb2NrVmVydGljYWwiLCJkcmFnQmxvY2tIb3Jpem9udGFsIiwiRHJhZyIsIkdlc3R1cmUiLCJyZWxlYXNlR2VzdHVyZSIsInRpbWVyIiwiaG9sZEdlc3R1cmUiLCJob2xkVGltZW91dCIsImhvbGRUaHJlc2hvbGQiLCJIb2xkIiwiUmVsZWFzZSIsIkluZmluaXR5IiwiU3dpcGUiLCJzd2lwZUdlc3R1cmUiLCJzd2lwZU1pblRvdWNoZXMiLCJzd2lwZU1heFRvdWNoZXMiLCJzd2lwZVZlbG9jaXR5WCIsInN3aXBlVmVsb2NpdHlZIiwiaGFzTW92ZWQiLCJ0YXBHZXN0dXJlIiwicHJldiIsInNpbmNlUHJldiIsImRpZERvdWJsZVRhcCIsInRhcE1heERpc3RhbmNlIiwidGFwTWF4VGltZSIsImRvdWJsZVRhcEludGVydmFsIiwiZG91YmxlVGFwRGlzdGFuY2UiLCJ0YXBBbHdheXMiLCJUYXAiLCJUb3VjaCIsInRvdWNoR2VzdHVyZSIsInByZXZlbnRNb3VzZSIsInRyYW5zZm9ybUdlc3R1cmUiLCJzY2FsZVRocmVzaG9sZCIsInNjYWxlIiwicm90YXRpb25UaHJlc2hvbGQiLCJyb3RhdGlvbiIsInRyYW5zZm9ybU1pblNjYWxlIiwidHJhbnNmb3JtTWluUm90YXRpb24iLCJUcmFuc2Zvcm0iLCJyZWFkeU1hcCIsInF1ZXVlTWFwIiwiaXNDb250ZW50UmVhZHkiLCJzZXRDb250ZW50UmVhZHkiLCJhZGRDYWxsYmFjayIsImNvbnN1bWVRdWV1ZSIsImRlbGV0ZSIsImNvbnRlbnRSZWFkeSIsIldlYWtNYXAiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hpbGRMaXN0IiwiY2hhcmFjdGVyRGF0YSIsIlRvYXN0UXVldWUiLCJ0aGVuIiwiX3NldEF0dHJpYnV0ZXMiLCJfbm9ybWFsaXplQXJndW1lbnRzIiwibWVzc2FnZUhUTUwiLCJidXR0b25MYWJlbHMiLCJidXR0b25MYWJlbCIsImlzQXJyYXkiLCJwYXJhbSIsIm5vdGlmaWNhdGlvbiIsIl9jcmVhdGVBbGVydERpYWxvZyIsImlucHV0U3RyaW5nIiwiaXNQcm9tcHQiLCJpbnB1dFR5cGUiLCJwbGFjZWhvbGRlciIsImRlZmF1bHRWYWx1ZSIsImxhYmVsIiwicHJpbWFyeUJ1dHRvbkluZGV4IiwiX2Rlc3Ryb3lEaWFsb2ciLCJkaWFsb2ciLCJvbkRpYWxvZ0NhbmNlbCIsImRlc3Ryb3kiLCJtYXNrQ29sb3IiLCJ0aXRsZSIsInN1Ym1pdE9uRW50ZXIiLCJpbnB1dCIsIm9ua2V5cHJlc3MiLCJrZXlDb2RlIiwiaGlkZSIsInJlc29sdmVWYWx1ZSIsImZvb3RlciIsImJ1dHRvbkVsZW1lbnQiLCJvbmNsaWNrIiwiY29tcGlsZSIsInNob3ciLCJhdXRvZm9jdXMiLCJzdHJMZW5ndGgiLCJmb2N1cyIsInNldFNlbGVjdGlvblJhbmdlIiwiYWxlcnQiLCJjb25maXJtIiwicHJvbXB0IiwidG9hc3QiLCJmaW5pc2giLCJfdG9hc3QiLCJjaGVja09wdGlvbnMiLCJlcnIiLCJpbnN0YW5jZU9mIiwiY2IiLCJkIiwiYWN0aW9uU2hlZXQiLCJjbGFzcyIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJpdGVtIiwiYnV0dG9uT3B0aW9ucyIsImRlc3RydWN0aXZlIiwiaWNvbiIsIk1pY3JvRXZlbnQiLCJmY3QiLCJfZXZlbnRzIiwiX2ZjdCIsIm1peGluIiwiZGVzdE9iamVjdCIsIl9pc1BvcnRyYWl0IiwiaXNQb3J0cmFpdCIsIl9vbk9yaWVudGF0aW9uQ2hhbmdlIiwiX29uUmVzaXplIiwiaW5uZXJIZWlnaHQiLCJpbm5lcldpZHRoIiwiX2luc3RhbGxJc1BvcnRyYWl0SW1wbGVtZW50YXRpb24iLCJlbWl0Iiwib3JpZW50YXRpb24iLCJuSXRlciIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ3IiwiaCIsIl9pbml0IiwibW9kaWZpZXJzIiwic29mdHdhcmVLZXlib2FyZCIsIl92aXNpYmxlIiwib25TaG93Iiwib25IaWRlIiwiYmluZEV2ZW50cyIsIktleWJvYXJkIiwib25zaG93Iiwib25oaWRlIiwidmlzaWJsZSIsImlzVmlzaWJsZSIsIm5vUGx1Z2luRXJyb3IiLCJnZW5lcmF0ZUlkIiwiRG9vckxvY2siLCJfbG9ja0xpc3QiLCJfd2FpdExpc3QiLCJfbG9nIiwibG9nIiwidW5sb2NrIiwiX3VubG9jayIsIl90cnlUb0ZyZWVXYWl0TGlzdCIsImlzTG9ja2VkIiwibG9hZFBhZ2UiLCJwYWdlRWxlbWVudCIsInVubG9hZFBhZ2UiLCJfZGVzdHJveSIsIlBhZ2VMb2FkZXIiLCJsb2FkZXIiLCJ1bmxvYWRlciIsIl9sb2FkZXIiLCJfdW5sb2FkZXIiLCJFbGVtZW50IiwiZGVmYXVsdFBhZ2VMb2FkZXIiLCJpbnN0YW50UGFnZUxvYWRlciIsIm9ucyIsInNlbGVjdCIsImxvY2F0aW9uIiwic2VhcmNoIiwid2FpdERldmljZVJlYWR5IiwicmVhZHlFcnJvciIsImFmdGVyIiwiaXNSZWFkeSIsIl9yZWFkeUxvY2siLCJyZWFkeSIsIndhaXRVbmxvY2siLCJzZXREZWZhdWx0RGV2aWNlQmFja0J1dHRvbkxpc3RlbmVyIiwibGlzdGVuZXIiLCJfZGVmYXVsdERldmljZUJhY2tCdXR0b25IYW5kbGVyIiwic2V0TGlzdGVuZXIiLCJkaXNhYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJkaXNhYmxlIiwiZW5hYmxlRGV2aWNlQmFja0J1dHRvbkhhbmRsZXIiLCJmaXJlRGV2aWNlQmFja0J1dHRvbkV2ZW50IiwiZW5hYmxlQXV0b1N0YXR1c0JhckZpbGwiLCJkaXNhYmxlQXV0b1N0YXR1c0JhckZpbGwiLCJtb2NrU3RhdHVzQmFyIiwibW9jayIsImRpc2FibGVBbmltYXRpb25zIiwiZW5hYmxlQW5pbWF0aW9ucyIsIl9kaXNhYmxlV2FybmluZ3MiLCJfZW5hYmxlV2FybmluZ3MiLCJkaXNhYmxlQXV0b1N0eWxpbmciLCJlbmFibGVBdXRvU3R5bGluZyIsImRpc2FibGVJY29uQXV0b1ByZWZpeCIsIkljb24iLCJzZXRBdXRvUHJlZml4IiwiZm9yY2VQbGF0Zm9ybVN0eWxpbmciLCJuZXdQbGF0Zm9ybSIsIl91dGlsIiwiX3BsYXRmb3JtVXBkYXRlIiwiX3VwZGF0ZVBvc2l0aW9uIiwicHJlbG9hZCIsImFsbCIsImFwcGVuZCIsImxpbmsiLCJjcmVhdGVQb3BvdmVyIiwiY3JlYXRlRGlhbG9nIiwiY3JlYXRlQWxlcnREaWFsb2ciLCJvcGVuQWN0aW9uU2hlZXQiLCJyZXNvbHZlTG9hZGluZ1BsYWNlaG9sZGVyIiwiX3Jlc29sdmVMb2FkaW5nUGxhY2Vob2xkZXIiLCJfc2V0dXBMb2FkaW5nUGxhY2VIb2xkZXJzIiwicmVtb3ZlQ2hpbGQiLCJ1bmxvY2tEZXZpY2VSZWFkeSIsImxvY2siLCJleGVjVW5sb2NrIiwiZ2V0Q1MiLCJjdXJyZW50U2NyaXB0Iiwic2NyaXB0cyIsImdldFNjcmlwdFBhZ2UiLCJGYXN0Q2xpY2siLCJsYXllciIsIm9sZE9uQ2xpY2siLCJ0cmFja2luZ0NsaWNrIiwidHJhY2tpbmdDbGlja1N0YXJ0IiwidG91Y2hTdGFydFgiLCJ0b3VjaFN0YXJ0WSIsImxhc3RUb3VjaElkZW50aWZpZXIiLCJ0b3VjaEJvdW5kYXJ5IiwidGFwRGVsYXkiLCJ0YXBUaW1lb3V0Iiwibm90TmVlZGVkIiwibWV0aG9kIiwibWV0aG9kcyIsImRldmljZUlzQW5kcm9pZCIsIm9uTW91c2UiLCJvbkNsaWNrIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaE1vdmUiLCJvblRvdWNoRW5kIiwib25Ub3VjaENhbmNlbCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInJtdiIsImhpamFja2VkIiwiYWR2IiwicHJvcGFnYXRpb25TdG9wcGVkIiwiZGV2aWNlSXNXaW5kb3dzUGhvbmUiLCJkZXZpY2VJc0lPUyIsImRldmljZUlzSU9TNCIsImRldmljZUlzSU9TV2l0aEJhZFRhcmdldCIsImRldmljZUlzQmxhY2tCZXJyeTEwIiwidGV4dEZpZWxkcyIsIm5lZWRzQ2xpY2siLCJkaXNhYmxlZCIsIm5lZWRzRm9jdXMiLCJyZWFkT25seSIsInNlbmRDbGljayIsImNsaWNrRXZlbnQiLCJhY3RpdmVFbGVtZW50IiwiYmx1ciIsImluaXRNb3VzZUV2ZW50IiwiZGV0ZXJtaW5lRXZlbnRUeXBlIiwic2NyZWVuWCIsInNjcmVlblkiLCJmb3J3YXJkZWRUb3VjaEV2ZW50IiwidXBkYXRlU2Nyb2xsUGFyZW50Iiwic2Nyb2xsUGFyZW50IiwiZmFzdENsaWNrU2Nyb2xsUGFyZW50Iiwic2Nyb2xsSGVpZ2h0IiwiZmFzdENsaWNrTGFzdFNjcm9sbFRvcCIsInNjcm9sbFRvcCIsImdldFRhcmdldEVsZW1lbnRGcm9tRXZlbnRUYXJnZXQiLCJldmVudFRhcmdldCIsIlRFWFRfTk9ERSIsImlzVGV4dEZpZWxkIiwidGFyZ2V0VG91Y2hlcyIsImlzQ29udGVudEVkaXRhYmxlIiwibGFzdENsaWNrVGltZSIsInRvdWNoSGFzTW92ZWQiLCJib3VuZGFyeSIsImZpbmRDb250cm9sIiwibGFiZWxFbGVtZW50IiwiY29udHJvbCIsImh0bWxGb3IiLCJmb3JFbGVtZW50IiwidGFyZ2V0VGFnTmFtZSIsImNhbmNlbE5leHRDbGljayIsImVsZW1lbnRGcm9tUG9pbnQiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwidG9wIiwicGVybWl0dGVkIiwibWV0YVZpZXdwb3J0IiwiY2hyb21lVmVyc2lvbiIsImJsYWNrYmVycnlWZXJzaW9uIiwiZmlyZWZveFZlcnNpb24iLCJvbnRvdWNoc3RhcnQiLCJleGVjIiwic2Nyb2xsV2lkdGgiLCJvdXRlcldpZHRoIiwibXNUb3VjaEFjdGlvbiIsInRvdWNoQWN0aW9uIiwiYXR0YWNoIiwiZGVmaW5lIiwiYmFiZWxIZWxwZXJzLnR5cGVvZiIsImFtZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJjdXN0b21FbGVtZW50cyIsImZvcmNlUG9seWZpbGwiLCJnbG9iYWwiLCJfX2ciLCJjb3JlIiwiX19lIiwiaXQiLCJpc09iamVjdCIsIlR5cGVFcnJvciIsInJlcXVpcmUkJDAiLCJpcyIsInJlcXVpcmUkJDEiLCJyZXF1aXJlJCQyIiwiUyIsInZhbCIsInZhbHVlT2YiLCJkUCIsIk8iLCJQIiwiQXR0cmlidXRlcyIsInRvUHJpbWl0aXZlIiwiSUU4X0RPTV9ERUZJTkUiLCJiaXRtYXAiLCJjcmVhdGVEZXNjIiwicHgiLCJyYW5kb20iLCJTUkMiLCJUT19TVFJJTkciLCIkdG9TdHJpbmciLCJUUEwiLCJpbnNwZWN0U291cmNlIiwic2FmZSIsImlzRnVuY3Rpb24iLCJTdHJpbmciLCJ0aGF0IiwiUFJPVE9UWVBFIiwiJGV4cG9ydCIsInNvdXJjZSIsIklTX0ZPUkNFRCIsIkYiLCJJU19HTE9CQUwiLCJHIiwiSVNfU1RBVElDIiwiSVNfUFJPVE8iLCJJU19CSU5EIiwiQiIsImV4cFByb3RvIiwib3duIiwib3V0IiwiZXhwIiwiY3R4IiwicmVkZWZpbmUiLCJVIiwiVyIsIlIiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImNvZiIsIklPYmplY3QiLCJkZWZpbmVkIiwiZ09QRCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInRvSU9iamVjdCIsInBJRSIsImNoZWNrIiwicHJvdG8iLCJzZXRQcm90b3R5cGVPZiIsImJ1Z2d5IiwiX19wcm90b19fIiwiU0hBUkVEIiwic3RvcmUiLCJTeW1ib2wiLCJVU0VfU1lNQk9MIiwiJGV4cG9ydHMiLCJ1aWQiLCJUQUciLCJBUkciLCJ0cnlHZXQiLCJUIiwiY2FsbGVlIiwiY2xhc3NvZiIsImNlaWwiLCJwb3MiLCJ0b0ludGVnZXIiLCJJU19JTkNMVURFUyIsIiR0aGlzIiwiZnJvbUluZGV4IiwidG9MZW5ndGgiLCJ0b0Fic29sdXRlSW5kZXgiLCJzaGFyZWQiLCJhcnJheUluZGV4T2YiLCJJRV9QUk9UTyIsIm5hbWVzIiwiJGtleXMiLCJlbnVtQnVnS2V5cyIsImRlZmluZVByb3BlcnRpZXMiLCJQcm9wZXJ0aWVzIiwiZ2V0S2V5cyIsIkVtcHR5IiwiY3JlYXRlRGljdCIsImlmcmFtZSIsImx0IiwiZ3QiLCJpZnJhbWVEb2N1bWVudCIsImNvbnRlbnRXaW5kb3ciLCJ3cml0ZSIsImNsb3NlIiwiYW5PYmplY3QiLCJkUHMiLCJkZWYiLCJ0YWciLCJzdGF0IiwiY29uZmlndXJhYmxlIiwiSXRlcmF0b3JQcm90b3R5cGUiLCJDb25zdHJ1Y3RvciIsIk5BTUUiLCJuZXh0IiwiZGVzY3JpcHRvciIsIk9iamVjdFByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJ0b09iamVjdCIsImNvbnN0cnVjdG9yIiwiSVRFUkFUT1IiLCJCVUdHWSIsIkZGX0lURVJBVE9SIiwiS0VZUyIsIlZBTFVFUyIsInJldHVyblRoaXMiLCJCYXNlIiwiREVGQVVMVCIsIklTX1NFVCIsIkZPUkNFRCIsImdldE1ldGhvZCIsImtpbmQiLCJ2YWx1ZXMiLCJlbnRyaWVzIiwiREVGX1ZBTFVFUyIsIlZBTFVFU19CVUciLCIkbmF0aXZlIiwiJGRlZmF1bHQiLCIkZW50cmllcyIsIiRhbnlOYXRpdmUiLCJMSUJSQVJZIiwiJGF0IiwiaXRlcmF0ZWQiLCJfdCIsIl9pIiwicG9pbnQiLCJVTlNDT1BBQkxFUyIsIkFycmF5UHJvdG8iLCJfayIsIkl0ZXJhdG9ycyIsIkFyZ3VtZW50cyIsImFkZFRvVW5zY29wYWJsZXMiLCJ3a3MiLCJUT19TVFJJTkdfVEFHIiwiQXJyYXlWYWx1ZXMiLCJET01JdGVyYWJsZXMiLCJjb2xsZWN0aW9ucyIsImV4cGxpY2l0IiwiQ29sbGVjdGlvbiIsIiRpdGVyYXRvcnMiLCJmb3JiaWRkZW5GaWVsZCIsInJldCIsImdldEl0ZXJhdG9yTWV0aG9kIiwiQlJFQUsiLCJSRVRVUk4iLCJpdGVyYWJsZSIsIml0ZXJGbiIsImdldEl0ZXJGbiIsImlzQXJyYXlJdGVyIiwiU1BFQ0lFUyIsIktFWSIsIkMiLCJERVNDUklQVE9SUyIsIk1FVEEiLCJzZXREZXNjIiwiaXNFeHRlbnNpYmxlIiwiRlJFRVpFIiwicHJldmVudEV4dGVuc2lvbnMiLCJzZXRNZXRhIiwiZmFzdEtleSIsImdldFdlYWsiLCJvbkZyZWV6ZSIsIm1ldGEiLCJORUVEIiwiVFlQRSIsIlNJWkUiLCJnZXRFbnRyeSIsImVudHJ5IiwiX2YiLCJuIiwiSVNfTUFQIiwiQURERVIiLCJfbCIsImZvck9mIiwidmFsaWRhdGUiLCJkYXRhIiwiY2FsbGJhY2tmbiIsInYiLCJTQUZFX0NMT1NJTkciLCJyaXRlciIsInNraXBDbG9zaW5nIiwiYXJyIiwiaXRlciIsImNvbW1vbiIsIklTX1dFQUsiLCJmaXhNZXRob2QiLCJmYWlscyIsImdldENvbnN0cnVjdG9yIiwiaW5zdGFuY2UiLCJIQVNOVF9DSEFJTklORyIsIlRIUk9XU19PTl9QUklNSVRJVkVTIiwiQUNDRVBUX0lURVJBQkxFUyIsIiRpdGVyRGV0ZWN0IiwiQlVHR1lfWkVSTyIsIiRpbnN0YW5jZSIsImluaGVyaXRJZlJlcXVpcmVkIiwic2V0U3Ryb25nIiwiU0VUIiwiU2V0Iiwic3Ryb25nIiwidG9KU09OIiwiQ09MTEVDVElPTiIsIm9mIiwiQSIsIm1hcEZuIiwibWFwcGluZyIsImFGdW5jdGlvbiIsIm5leHRJdGVtIiwicmVxdWlyZSQkNyIsIk1BUCIsIk1hcCIsImFyZyIsIm9yaWdpbmFsIiwic3BlY2llc0NvbnN0cnVjdG9yIiwiJGNyZWF0ZSIsIklTX0ZJTFRFUiIsIklTX1NPTUUiLCJJU19FVkVSWSIsIklTX0ZJTkRfSU5ERVgiLCJOT19IT0xFUyIsImFzYyIsInJlcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIiRhc3NpZ24iLCJhc3NpZ24iLCJLIiwiYUxlbiIsImdldFN5bWJvbHMiLCJnT1BTIiwiaXNFbnVtIiwiYXJyYXlGaW5kIiwiY3JlYXRlQXJyYXlNZXRob2QiLCJhcnJheUZpbmRJbmRleCIsInVuY2F1Z2h0RnJvemVuU3RvcmUiLCJVbmNhdWdodEZyb3plblN0b3JlIiwiZmluZFVuY2F1Z2h0RnJvemVuIiwiJGhhcyIsIldFQUtfTUFQIiwid2VhayIsInVmc3RvcmUiLCJ0bXAiLCJJbnRlcm5hbE1hcCIsIiRXZWFrTWFwIiwiZnJlZXplIiwicmVxdWlyZSQkNSIsIiRkZWZpbmVQcm9wZXJ0eSIsIm1hcGZuIiwicmVzZXJ2ZWRUYWdMaXN0IiwiaXNWYWxpZEN1c3RvbUVsZW1lbnROYW1lIiwibG9jYWxOYW1lIiwicmVzZXJ2ZWQiLCJ2YWxpZEZvcm0iLCJpc0Nvbm5lY3RlZCIsIm5hdGl2ZVZhbHVlIiwiX19DRV9pc0ltcG9ydERvY3VtZW50IiwiRG9jdW1lbnQiLCJTaGFkb3dSb290IiwiaG9zdCIsIm5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmciLCJyb290IiwibmV4dFNpYmxpbmciLCJuZXh0Tm9kZSIsIndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzIiwidmlzaXRlZEltcG9ydHMiLCJpbXBvcnQiLCJzaGFkb3dSb290IiwiX19DRV9zaGFkb3dSb290Iiwic2V0UHJvcGVydHlVbmNoZWNrZWQiLCJkZXN0aW5hdGlvbiIsIkN1c3RvbUVsZW1lbnRTdGF0ZSIsIkN1c3RvbUVsZW1lbnRJbnRlcm5hbHMiLCJfbG9jYWxOYW1lVG9EZWZpbml0aW9uIiwiX2NvbnN0cnVjdG9yVG9EZWZpbml0aW9uIiwiX3BhdGNoZXMiLCJfaGFzUGF0Y2hlcyIsImRlZmluaXRpb24iLCJwYXRjaCIsIl9fQ0VfcGF0Y2hlZCIsIl9fQ0Vfc3RhdGUiLCJDRVN0YXRlIiwiY3VzdG9tIiwiVXRpbGl0aWVzIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJ1cGdyYWRlRWxlbWVudCIsImRpc2Nvbm5lY3RlZENhbGxiYWNrIiwiZ2F0aGVyRWxlbWVudHMiLCJfX0NFX2hhc1JlZ2lzdHJ5IiwiX19DRV9kb2N1bWVudExvYWRIYW5kbGVkIiwicGF0Y2hBbmRVcGdyYWRlVHJlZSIsImN1cnJlbnRTdGF0ZSIsImxvY2FsTmFtZVRvRGVmaW5pdGlvbiIsImNvbnN0cnVjdGlvblN0YWNrIiwicG9wIiwiZmFpbGVkIiwiX19DRV9kZWZpbml0aW9uIiwiYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIiwib2JzZXJ2ZWRBdHRyaWJ1dGVzIiwiX19DRV9pc0Nvbm5lY3RlZENhbGxiYWNrQ2FsbGVkIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsIm5hbWVzcGFjZSIsIkRvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIiLCJpbnRlcm5hbHMiLCJkb2MiLCJfaW50ZXJuYWxzIiwiX2RvY3VtZW50IiwiX29ic2VydmVyIiwiX2hhbmRsZU11dGF0aW9ucyIsImRpc2Nvbm5lY3QiLCJtdXRhdGlvbnMiLCJhZGRlZE5vZGVzIiwiRGVmZXJyZWQiLCJfdmFsdWUiLCJfcmVzb2x2ZSIsIl9wcm9taXNlIiwiQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IiwiX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nIiwiX3doZW5EZWZpbmVkRGVmZXJyZWQiLCJfZmx1c2hDYWxsYmFjayIsIl9mbHVzaFBlbmRpbmciLCJfdW5mbHVzaGVkTG9jYWxOYW1lcyIsIl9kb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyIiwiU3ludGF4RXJyb3IiLCJhZG9wdGVkQ2FsbGJhY2siLCJnZXRDYWxsYmFjayIsImNhbGxiYWNrVmFsdWUiLCJzZXREZWZpbml0aW9uIiwiX2ZsdXNoIiwicHJpb3IiLCJ0b1Byb21pc2UiLCJvdXRlciIsImlubmVyIiwiZmx1c2giLCJ3aGVuRGVmaW5lZCIsInBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2siLCJjcmVhdGVFbGVtZW50TlMiLCJjbG9uZU5vZGUiLCJnZXRBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIiLCJjb25zdHJ1Y3RvclRvRGVmaW5pdGlvbiIsIk5hdGl2ZSIsIkRvY3VtZW50X2NyZWF0ZUVsZW1lbnQiLCJsYXN0SW5kZXgiLCJidWlsdEluIiwibm9kZXMiLCJjb25uZWN0ZWRCZWZvcmUiLCJwcmVwZW5kIiwiZGlzY29ubmVjdFRyZWUiLCJjb25uZWN0VHJlZSIsImNsb25lIiwiRG9jdW1lbnRfaW1wb3J0Tm9kZSIsInBhdGNoVHJlZSIsIk5TX0hUTUwiLCJEb2N1bWVudF9jcmVhdGVFbGVtZW50TlMiLCJEb2N1bWVudF9wcmVwZW5kIiwiRG9jdW1lbnRfYXBwZW5kIiwicmVmTm9kZSIsImluc2VydGVkTm9kZXMiLCJuYXRpdmVSZXN1bHQiLCJOb2RlX2luc2VydEJlZm9yZSIsIm5vZGVXYXNDb25uZWN0ZWQiLCJOb2RlX2FwcGVuZENoaWxkIiwiTm9kZV9jbG9uZU5vZGUiLCJvd25lckRvY3VtZW50IiwiTm9kZV9yZW1vdmVDaGlsZCIsIm5vZGVUb0luc2VydCIsIm5vZGVUb1JlbW92ZSIsIk5vZGVfcmVwbGFjZUNoaWxkIiwibm9kZVRvSW5zZXJ0V2FzQ29ubmVjdGVkIiwidGhpc0lzQ29ubmVjdGVkIiwicGF0Y2hfdGV4dENvbnRlbnQiLCJiYXNlRGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJhc3NpZ25lZFZhbHVlIiwicmVtb3ZlZE5vZGVzIiwiY2hpbGROb2Rlc0xlbmd0aCIsIk5vZGVfdGV4dENvbnRlbnQiLCJhZGRQYXRjaCIsInBhcnRzIiwiYmVmb3JlIiwid2FzQ29ubmVjdGVkIiwicmVwbGFjZVdpdGgiLCJFbGVtZW50X2F0dGFjaFNoYWRvdyIsImluaXQiLCJwYXRjaF9pbm5lckhUTUwiLCJodG1sU3RyaW5nIiwicmVtb3ZlZEVsZW1lbnRzIiwiRWxlbWVudF9pbm5lckhUTUwiLCJIVE1MRWxlbWVudF9pbm5lckhUTUwiLCJyYXdEaXYiLCJFbGVtZW50X3NldEF0dHJpYnV0ZSIsIkVsZW1lbnRfZ2V0QXR0cmlidXRlIiwiRWxlbWVudF9zZXRBdHRyaWJ1dGVOUyIsIkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMiLCJFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZSIsIkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlMiLCJwYXRjaF9pbnNlcnRBZGphY2VudEVsZW1lbnQiLCJiYXNlTWV0aG9kIiwid2hlcmUiLCJpbnNlcnRlZEVsZW1lbnQiLCJIVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQiLCJFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCIsIkVsZW1lbnRfcHJlcGVuZCIsIkVsZW1lbnRfYXBwZW5kIiwiRWxlbWVudF9iZWZvcmUiLCJFbGVtZW50X2FmdGVyIiwiRWxlbWVudF9yZXBsYWNlV2l0aCIsIkVsZW1lbnRfcmVtb3ZlIiwicHJpb3JDdXN0b21FbGVtZW50cyIsIkpzTXV0YXRpb25PYnNlcnZlciIsInJlZ2lzdHJhdGlvbnNUYWJsZSIsInNldEltbWVkaWF0ZSIsInNldEltbWVkaWF0ZVF1ZXVlIiwic2VudGluZWwiLCJmdW5jIiwicG9zdE1lc3NhZ2UiLCJpc1NjaGVkdWxlZCIsInNjaGVkdWxlZE9ic2VydmVycyIsInNjaGVkdWxlQ2FsbGJhY2siLCJkaXNwYXRjaENhbGxiYWNrcyIsIndyYXBJZk5lZWRlZCIsIlNoYWRvd0RPTVBvbHlmaWxsIiwib2JzZXJ2ZXJzIiwibzEiLCJvMiIsInVpZF8iLCJhbnlOb25FbXB0eSIsInRha2VSZWNvcmRzIiwiY2FsbGJhY2tfIiwicmVtb3ZlVHJhbnNpZW50T2JzZXJ2ZXJzRm9yIiwibm9kZXNfIiwicmVnaXN0cmF0aW9ucyIsInJlZ2lzdHJhdGlvbiIsInJlbW92ZVRyYW5zaWVudE9ic2VydmVycyIsImZvckVhY2hBbmNlc3RvckFuZE9ic2VydmVyRW5xdWV1ZVJlY29yZCIsInN1YnRyZWUiLCJyZWNvcmQiLCJlbnF1ZXVlIiwidWlkQ291bnRlciIsInJlY29yZHNfIiwiYXR0cmlidXRlcyIsImF0dHJpYnV0ZU9sZFZhbHVlIiwiYXR0cmlidXRlRmlsdGVyIiwiY2hhcmFjdGVyRGF0YU9sZFZhbHVlIiwiUmVnaXN0cmF0aW9uIiwiYWRkTGlzdGVuZXJzIiwiY29weU9mUmVjb3JkcyIsIk11dGF0aW9uUmVjb3JkIiwicHJldmlvdXNTaWJsaW5nIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZU5hbWVzcGFjZSIsImNvcHlNdXRhdGlvblJlY29yZCIsImN1cnJlbnRSZWNvcmQiLCJyZWNvcmRXaXRoT2xkVmFsdWUiLCJnZXRSZWNvcmQiLCJnZXRSZWNvcmRXaXRoT2xkVmFsdWUiLCJjbGVhclJlY29yZHMiLCJyZWNvcmRSZXByZXNlbnRzQ3VycmVudE11dGF0aW9uIiwic2VsZWN0UmVjb3JkIiwibGFzdFJlY29yZCIsIm5ld1JlY29yZCIsInRyYW5zaWVudE9ic2VydmVkTm9kZXMiLCJyZWNvcmRzIiwicmVjb3JkVG9SZXBsYWNlTGFzdCIsImFkZExpc3RlbmVyc18iLCJyZW1vdmVMaXN0ZW5lcnNfIiwiYXR0ck5hbWUiLCJyZWxhdGVkTm9kZSIsIm5hbWVzcGFjZVVSSSIsImF0dHJDaGFuZ2UiLCJNdXRhdGlvbkV2ZW50IiwiQURESVRJT04iLCJwcmV2VmFsdWUiLCJhZGRUcmFuc2llbnRPYnNlcnZlciIsImNoYW5nZWROb2RlIiwiX2lzUG9seWZpbGxlZCIsIm5leHRIYW5kbGUiLCJ0YXNrc0J5SGFuZGxlIiwiY3VycmVudGx5UnVubmluZ0FUYXNrIiwiYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyIsInBhcnRpYWxseUFwcGxpZWQiLCJydW5JZlByZXNlbnQiLCJoYW5kbGUiLCJ0YXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsIm5leHRUaWNrIiwiY2FuVXNlUG9zdE1lc3NhZ2UiLCJpbXBvcnRTY3JpcHRzIiwicG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyIsIm9sZE9uTWVzc2FnZSIsIm9ubWVzc2FnZSIsImluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uIiwibWVzc2FnZVByZWZpeCIsIm9uR2xvYmFsTWVzc2FnZSIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24iLCJhdHRhY2hUbyIsInByb2Nlc3MiLCJERUZBVUxUX1ZJRVdQT1JUIiwiVmlld3BvcnQiLCJ2aWV3cG9ydEVsZW1lbnQiLCJoZWFkIiwiZW5zdXJlVmlld3BvcnRFbGVtZW50IiwiX29uc0xvYWRlZCIsImZhc3RDbGljayIsInN1cHBvcnRUb3VjaEFjdGlvbiIsIl9pbnRlcm5hbCIsImNyZWF0ZUhhbmRsZXIiLCJhcHAiLCJleGl0QXBwIiwiX2dlc3R1cmVEZXRlY3RvciIsImdldEVsZW1lbnRDbGFzcyIsIkJhc2VFbGVtZW50IiwiVGVtcGxhdGVFbGVtZW50Iiwib3V0ZXJIVE1MIiwiYnViYmxlcyIsIlRlbXBsYXRlIiwiSWZFbGVtZW50IiwiX2lzQWxsb3dlZFBsYXRmb3JtIiwiY29uZGl0aW9uYWxPcmllbnRhdGlvbiIsImN1cnJlbnRPcmllbnRhdGlvbiIsIklmIiwiQmFzZUFuaW1hdG9yIiwicHJvcGVydGllcyIsImV4dGVuZGVkQW5pbWF0b3IiLCJuZXdBbmltYXRvciIsImlQaG9uZVhQYXRjaCIsImlzSVBob25lWFBvcnRyYWl0UGF0Y2hBY3RpdmUiLCJpc0lQaG9uZVhMYW5kc2NhcGVQYXRjaEFjdGl2ZSIsImdldFNhZmVBcmVhTGVuZ3RocyIsInNhZmVBcmVhTGVuZ3RocyIsImdldFNhZmVBcmVhRE9NUmVjdCIsInNhZmVBcmVhUmVjdCIsIkFjdGlvblNoZWV0QW5pbWF0b3IiLCJNREFjdGlvblNoZWV0QW5pbWF0b3IiLCJtYXNrVGltaW5nIiwibWFza0R1cmF0aW9uIiwiYW5pbWl0IiwiX21hc2siLCJvcGFjaXR5IiwiX3NoZWV0IiwiZGVmYXVsdCIsInRyYW5zZm9ybSIsIklPU0FjdGlvblNoZWV0QW5pbWF0b3IiLCJsaWZ0QW1vdW50IiwiY2xpZW50SGVpZ2h0IiwiQmFzZURpYWxvZ0VsZW1lbnQiLCJzaG91bGRTaG93IiwiX2Rvb3JMb2NrIiwiX2NhbmNlbCIsIl9zZWxmQ2FtZWxOYW1lIiwiX2RlZmF1bHREQkIiLCJjYWxsUGFyZW50SGFuZGxlciIsIl9hbmltYXRvckZhY3RvcnkiLCJfdXBkYXRlQW5pbWF0b3JGYWN0b3J5IiwiX3J1bm5pbmciLCJfc2V0VmlzaWJsZSIsInBhcnNlQW5pbWF0aW9uT3B0aW9uc1N0cmluZyIsImNhbmNlbGVkIiwiX3RvZ2dsZVN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwib25EZXZpY2VCYWNrQnV0dG9uIiwiX2JhY2tCdXR0b25IYW5kbGVyIiwib25Nb2RpZmllckNoYW5nZWQiLCJfc2NoZW1lIiwiX3VwZGF0ZU1hc2siLCJfYW5pbWF0b3JEaWN0IiwiQWN0aW9uU2hlZXRFbGVtZW50IiwiX2NvbXBpbGUiLCJzaGVldCIsIl90aXRsZSIsIm1hc2siLCJpbml0TW9kaWZpZXIiLCJfdXBkYXRlVGl0bGUiLCJBY3Rpb25TaGVldCIsIkJhc2VCdXR0b25FbGVtZW50IiwiX2RlZmF1bHRDbGFzc05hbWUiLCJfaWNvbiIsIl91cGRhdGVSaXBwbGUiLCJfcmlwcGxlT3B0IiwiX3VwZGF0ZUljb24iLCJBY3Rpb25TaGVldEJ1dHRvbkVsZW1lbnQiLCJBY3Rpb25TaGVldEJ1dHRvbiIsIkFsZXJ0RGlhbG9nQW5pbWF0b3IiLCJBbmRyb2lkQWxlcnREaWFsb2dBbmltYXRvciIsIl9kaWFsb2ciLCJJT1NBbGVydERpYWxvZ0FuaW1hdG9yIiwiQWxlcnREaWFsb2dFbGVtZW50IiwiQWxlcnREaWFsb2ciLCJBbGVydERpYWxvZ0J1dHRvbkVsZW1lbnQiLCJBbGVydERpYWxvZ0J1dHRvbiIsImRlZmF1bHRDbGFzc05hbWUiLCJCYWNrQnV0dG9uRWxlbWVudCIsIl9vcHRpb25zIiwiX2JvdW5kT25DbGljayIsIl9vbkNsaWNrIiwibWRCYWNrQnV0dG9uSWNvbiIsImlvc0JhY2tCdXR0b25JY29uIiwicG9wUGFnZSIsIkJhY2tCdXR0b24iLCJCb3R0b21Ub29sYmFyRWxlbWVudCIsIkJvdHRvbVRvb2xiYXIiLCJCdXR0b25FbGVtZW50IiwiQnV0dG9uIiwiQ2FyZEVsZW1lbnQiLCJDYXJkIiwiQ2Fyb3VzZWxJdGVtRWxlbWVudCIsIkNhcm91c2VsSXRlbSIsImRpcmVjdGlvbk1hcCIsIlN3aXBlciIsIkZBTFNFIiwiZ2V0RWxlbWVudCIsInNjcm9sbEhvb2siLCJpdGVtU2l6ZSIsImdldEF1dG9TY3JvbGxSYXRpbyIsInJhdGlvIiwic2hvdWxkQmxvY2siLCJvbkRyYWdTdGFydCIsIm9uRHJhZyIsIm9uRHJhZ0VuZCIsIm9uUmVzaXplIiwiX3Nob3VsZEZpeFNjcm9sbCIsInN3aXBlYWJsZSIsImF1dG9SZWZyZXNoIiwiaW5pdGlhbGl6ZWQiLCJibG9ja2VyIiwiX211dGF0aW9uT2JzZXJ2ZXIiLCJ1cGRhdGVTd2lwZWFibGUiLCJ1cGRhdGVBdXRvUmVmcmVzaCIsIl9zY3JvbGwiLCJfb2Zmc2V0IiwiX2xhc3RBY3RpdmVJbmRleCIsIl91cGRhdGVMYXlvdXQiLCJfc2V0dXBJbml0aWFsSW5kZXgiLCJzZXR1cFJlc2l6ZSIsInRhcmdldFNpemUiLCJfcmVzZXQiLCJzZXRBY3RpdmVJbmRleCIsInJvdW5kIiwiTnVtYmVyIiwiZ2V0SW5pdGlhbEluZGV4IiwiaXRlbUNvdW50IiwiaXRlbU51bVNpemUiLCJfc2Nyb2xsVG8iLCJfc2V0U3dpcGluZyIsInNjcm9sbCIsIm1heFNjcm9sbCIsImFycmF5T2ZBcnJheSIsImNvbnRlbnRzIiwiX2NoYW5nZVRvIiwiY291bnQiLCJzaXplIiwic2hvdWxkVXBkYXRlIiwic2hvdWxkV2F0Y2giLCJuZXdTaXplIiwiYmxvY2siLCJwb2ludGVyRXZlbnRzIiwiaXNGaXJzdCIsImlzT3ZlclNjcm9sbGFibGUiLCJpc0xhc3QiLCJfaWdub3JlRHJhZyIsImNvbnN1bWVkIiwiY29uc3VtZSIsIl9jYW5Db25zdW1lR2VzdHVyZSIsInN0YXJ0WCIsImRpc3RGcm9tRWRnZSIsImdldEJ1YmJsZVdpZHRoIiwiX3N0YXJ0ZWQiLCJ0b2dnbGVCbG9ja2VyIiwiX2NvbnRpbnVlZCIsIl9nZXREZWx0YSIsInRocm90dGxlIiwibm9ybWFsaXplZFNjcm9sbCIsIl9ub3JtYWxpemVTY3JvbGwiLCJfc3RhcnRNb21lbnR1bVNjcm9sbCIsIl9raWxsT3ZlclNjcm9sbCIsIl9nZXRWZWxvY2l0eSIsIm1hdGNoZXNEaXJlY3Rpb24iLCJkTSIsImRpciIsIm5leHRTY3JvbGwiLCJfZ2V0QXV0b1Njcm9sbCIsInN3aXBlIiwia2lsbE92ZXJTY3JvbGwiLCJvdmVyU2Nyb2xsSG9vayIsImFjdGl2ZUluZGV4IiwiZ2V0QWN0aXZlSW5kZXgiLCJsYXN0QWN0aXZlSW5kZXgiLCJjaGFuZ2UiLCJwcmVDaGFuZ2VIb29rIiwicG9zdENoYW5nZUhvb2siLCJ0b0ZpeGVkIiwiX2dldFRyYW5zZm9ybSIsIm9mZnNldCIsImlzQXV0b1Njcm9sbGFibGUiLCJsYXN0U2Nyb2xsIiwic2Nyb2xsUmF0aW8iLCJfdGFyZ2V0U2l6ZSIsIl9pdGVtTnVtU2l6ZSIsInJlZnJlc2hIb29rIiwiYXhpcyIsInQzZCIsIm5leHRFbGVtZW50U2libGluZyIsImlzQ2VudGVyZWQiLCJfY2FsY3VsYXRlSXRlbVNpemUiLCJDYXJvdXNlbEVsZW1lbnQiLCJfc3dpcGVyIiwiYXV0b1Njcm9sbFJhdGlvIiwidmVydGljYWwiLCJvdmVyc2Nyb2xsYWJsZSIsImNlbnRlcmVkIiwiYXV0b1Njcm9sbCIsIl9vbk92ZXJTY3JvbGwiLCJfb25DaGFuZ2UiLCJfb25SZWZyZXNoIiwiX29uU3dpcGUiLCJ1cGRhdGVJdGVtU2l6ZSIsIndhaXRGb3JBY3Rpb24iLCJjYXJvdXNlbCIsIml0ZW1TaXplQXR0ciIsInBhcnNlRmxvYXQiLCJDYXJvdXNlbCIsIkNvbEVsZW1lbnQiLCJfdXBkYXRlV2lkdGgiLCJDb2wiLCJEaWFsb2dBbmltYXRvciIsIkFuZHJvaWREaWFsb2dBbmltYXRvciIsIklPU0RpYWxvZ0FuaW1hdG9yIiwiYm9keUhlaWdodCIsIlNsaWRlRGlhbG9nQW5pbWF0b3IiLCJEaWFsb2dFbGVtZW50IiwiRGlhbG9nIiwiRmFiRWxlbWVudCIsImlzQm90dG9tIiwidHJhbnNsYXRlIiwiZmFiT2Zmc2V0IiwiRmFiIiwiR2VzdHVyZURldGVjdG9yRWxlbWVudCIsImF1dG9QcmVmaXgiLCJJY29uRWxlbWVudCIsIl9jbGVhbkNsYXNzQXR0cmlidXRlIiwiX3VwZGF0ZSIsIl9idWlsZENsYXNzQW5kU3R5bGUiLCJfcGFyc2VBdHRyIiwiYXR0ciIsIm1kIiwibGFzdEljb24iLCJsYXN0TW9kaWZpZXIiLCJfcHJlZml4SWNvbiIsImN1c3RvbVByZWZpeFJFIiwiaWNvbk5hbWUiLCJyZW1vdmVQcm9wZXJ0eSIsImZvbnRTaXplIiwiTGF6eVJlcGVhdERlbGVnYXRlIiwidXNlckRlbGVnYXRlIiwidGVtcGxhdGVFbGVtZW50IiwiX3VzZXJEZWxlZ2F0ZSIsIl90ZW1wbGF0ZUVsZW1lbnQiLCJfcmVuZGVyIiwibG9hZEl0ZW1FbGVtZW50IiwiY3JlYXRlSXRlbUNvbnRlbnQiLCJjb3VudEl0ZW1zIiwidXBkYXRlSXRlbUNvbnRlbnQiLCJjYWxjdWxhdGVJdGVtSGVpZ2h0IiwiZGVzdHJveUl0ZW0iLCJpdGVtSGVpZ2h0IiwiTGF6eVJlcGVhdFByb3ZpZGVyIiwid3JhcHBlckVsZW1lbnQiLCJkZWxlZ2F0ZSIsIl93cmFwcGVyRWxlbWVudCIsIl9kZWxlZ2F0ZSIsIl9pbnNlcnRJbmRleCIsIl9wYWdlQ29udGVudCIsIl9maW5kUGFnZUNvbnRlbnRFbGVtZW50IiwibGFzdFNjcm9sbFRvcCIsInBhZGRpbmciLCJfdG9wUG9zaXRpb25zIiwiX3JlbmRlcmVkSXRlbXMiLCJfdW5rbm93bkl0ZW1IZWlnaHQiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJwYWdlQ29udGVudCIsIl9pdGVtSGVpZ2h0IiwidmlzaWJpbGl0eSIsInN0YXRpY0l0ZW1IZWlnaHQiLCJfZ2V0SXRlbUhlaWdodCIsImZvcmNlUmVuZGVyIiwiZm9yY2VTY3JvbGxEb3duIiwibGFzdEl0ZW1JbmRleCIsIl9sYXN0SXRlbVJlbmRlcmVkIiwiX2NvdW50SXRlbXMiLCJmaXJzdEl0ZW1JbmRleCIsIl9maXJzdEl0ZW1SZW5kZXJlZCIsImZvcmNlTGFzdEluZGV4IiwiX2NhbGN1bGF0ZVJlbmRlcmVkSGVpZ2h0IiwiZm9yY2VGaXJzdEluZGV4IiwiX3JlbW92ZUFsbEVsZW1lbnRzIiwiX2NoZWNrSXRlbUhlaWdodCIsImlzU2Nyb2xsVXAiLCJrZWVwIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiX2NhbGN1bGF0ZVN0YXJ0SW5kZXgiLCJoYXNSZW5kZXJGdW5jdGlvbiIsIl9yZW5kZXJFbGVtZW50IiwiX3JlbW92ZUVsZW1lbnQiLCJ1cGRhdGVJdGVtIiwiX3JlY2FsY3VsYXRlVG9wUG9zaXRpb25zIiwibWlkZGxlIiwiaW1tZWRpYXRlIiwiY2FsbE5vdyIsIl9kZWJvdW5jZSIsIl9ib3VuZE9uQ2hhbmdlIiwiX2JvdW5kRG91YmxlRmlyZU9uVG91Y2hlbmQiLCJfcGFyZW50RWxlbWVudCIsIl9yZW1vdmVFdmVudExpc3RlbmVycyIsInBhZGRpbmdUb3AiLCJMYXp5UmVwZWF0RWxlbWVudCIsIl9sYXp5UmVwZWF0UHJvdmlkZXIiLCJMYXp5UmVwZWF0IiwiTGlzdEhlYWRlckVsZW1lbnQiLCJMaXN0SGVhZGVyIiwiTGlzdFRpdGxlRWxlbWVudCIsIkxpc3RUaXRsZSIsIkxpc3RJdGVtQW5pbWF0b3IiLCJsaXN0SXRlbSIsIlNsaWRlTGlzdEl0ZW1BbmltYXRvciIsIl9hbmltYXRlRXhwYW5zaW9uIiwic2hvdWxkT3BlbiIsIm9sZEhlaWdodCIsImV4cGFuZGFibGVDb250ZW50Iiwib2xkRGlzcGxheSIsImNvbXB1dGVkU3R5bGUiLCJleHBhbnNpb25PcGVuVHJhbnNpdGlvbiIsInBhZGRpbmdCb3R0b20iLCJpY29uT3BlblRyYW5zaXRpb24iLCJyZXZlcnNlIiwiZXhwYW5kQ2hldnJvbiIsIkxpc3RJdGVtRWxlbWVudCIsInRvZ2dsZUV4cGFuc2lvbiIsIl9zaG91bGRJZ25vcmVUYXAiLCJzaG93RXhwYW5zaW9uIiwiaGlkZUV4cGFuc2lvbiIsImNoZXZyb24iLCJfdG9wIiwiX2V4cGFuZGluZyIsImV4cGFuZGVkIiwiX3NldHVwTGlzdGVuZXJzIiwiX29yaWdpbmFsQmFja2dyb3VuZENvbG9yIiwidGFwcGVkIiwiX29uVG91Y2giLCJfb25SZWxlYXNlIiwiX29uRHJhZyIsInRvdWNoU3R5bGUiLCJib3hTaGFkb3ciLCJMaXN0SXRlbSIsIkxpc3RFbGVtZW50IiwiTGlzdCIsIklOUFVUX0FUVFJJQlVURVMiLCJCYXNlSW5wdXRFbGVtZW50IiwiX2JvdW5kRGVsZWdhdGVFdmVudCIsIl9kZWxlZ2F0ZUV2ZW50IiwiX3RlbXBsYXRlIiwiX3NldElucHV0SWQiLCJfdXBkYXRlQm91bmRBdHRyaWJ1dGVzIiwiX2lucHV0IiwidG9JU09TdHJpbmciLCJJbnB1dEVsZW1lbnQiLCJfYm91bmRPbklucHV0IiwiX2JvdW5kT25Gb2N1c2luIiwiX3VwZGF0ZUxhYmVsIiwiX3VwZGF0ZUxhYmVsQ2xhc3MiLCJfaGVscGVyIiwiaW5uZXJUZXh0IiwiSW5wdXQiLCJCYXNlQ2hlY2tib3hFbGVtZW50IiwiY2hlY2tlZCIsIkNoZWNrYm94RWxlbWVudCIsIkNoZWNrYm94IiwiUmFkaW9FbGVtZW50IiwiUmFkaW8iLCJTZWFyY2hJbnB1dEVsZW1lbnQiLCJTZWFyY2hJbnB1dCIsIk1vZGFsQW5pbWF0b3IiLCJtb2RhbCIsIkZhZGVNb2RhbEFuaW1hdG9yIiwiTGlmdE1vZGFsQW5pbWF0b3IiLCJNb2RhbEVsZW1lbnQiLCJNb2RhbCIsIndpZHRoVG9QeCIsIm9mZnNldFdpZHRoIiwiU3dpcGVSZXZlYWwiLCJlbGVtZW50SGFuZGxlciIsImdldFRocmVzaG9sZCIsImdldFNpZGUiLCJoYW5kbGVHZXN0dXJlIiwiZ2VzdHVyZURldGVjdG9yIiwiaWdub3JlU3dpcGUiLCJfd2lkdGgiLCJfc3RhcnREaXN0YW5jZSIsIl9kaXN0YW5jZSIsImlzSW5pdGlhbFN0YXRlIiwiZGVsdGEiLCJzd2lwZU1pZCIsImlzU3dpcGVNYXgiLCJzd2lwZU1heCIsInN3aXBlTWluIiwiTmF2aWdhdG9yQW5pbWF0b3IiLCJlbnRlclBhZ2UiLCJsZWF2ZVBhZ2UiLCJJT1NTd2lwZU5hdmlnYXRvckFuaW1hdG9yIiwiZHVyYXRpb25SZXN0b3JlIiwiZHVyYXRpb25Td2lwZSIsInRpbWluZ1N3aXBlIiwicmVzdCIsIm9wdFN3aXBlIiwib3B0UmVzdG9yZSIsInN3aXBlU2hhZG93IiwiaXNEcmFnU3RhcnQiLCJ1bmJsb2NrIiwiYmFja2dyb3VuZE1hc2siLCJkZWNvbXAiLCJfZGVjb21wb3NlIiwiZW50ZXIiLCJsZWF2ZSIsIl9jYWxjdWxhdGVEZWx0YSIsInNob3VsZEFuaW1hdGVUb29sYmFyIiwiX3Nob3VsZEFuaW1hdGVUb29sYmFyIiwidG9vbGJhciIsIl9zYXZlU3R5bGUiLCJvdmVyZmxvd0VsZW1lbnQiLCJtYXhXaWR0aCIsImlzU3dpcGluZyIsIl9kcmFnU3RhcnRTZXR1cCIsInN3aXBlUmF0aW8iLCJib3R0b21Ub29sYmFyIiwiYmFja2dyb3VuZCIsInRvb2xiYXJDZW50ZXIiLCJiYWNrQnV0dG9uTGFiZWwiLCJvdGhlciIsIl9zYXZlZFN0eWxlIiwic2F2ZSIsInJlc3RvcmUiLCJfcmVzdG9yZVN0eWxlIiwidHJhbnNsYXRlM2QiLCJJT1NTbGlkZU5hdmlnYXRvckFuaW1hdG9yIiwiX2dldFRvb2xiYXJFbGVtZW50IiwiX2dldFRvb2xiYXJMZWZ0SXRlbXNFbGVtZW50IiwiX2dldFRvb2xiYXJSaWdodEl0ZW1zRWxlbWVudCIsImV4Y2x1ZGVCYWNrQnV0dG9uIiwiX2dldFRvb2xiYXJDZW50ZXJJdGVtc0VsZW1lbnQiLCJfZ2V0VG9vbGJhckJhY2tCdXR0b25JY29uRWxlbWVudCIsIl9nZXRUb29sYmFyQmFja0J1dHRvbkxhYmVsRWxlbWVudCIsIl9nZXRDb250ZW50RWxlbWVudCIsIl9nZXRCYWNrZ3JvdW5kRWxlbWVudCIsIl9nZXRCb3R0b21Ub29sYmFyRWxlbWVudCIsInRvb2xiYXJzIiwiZW50ZXJUb29sYmFyIiwibGVhdmVUb29sYmFyIiwiaXNTdGF0aWMiLCJpc01hdGVyaWFsIiwiaXNUcmFuc3BhcmVudCIsImRlY29tcG9zaXRpb24iLCJwYWdlUmVjdCIsImxhYmVsUmVjdCIsImJhY2tCdXR0b25JY29uIiwiZW50ZXJQYWdlVGFyZ2V0IiwibGVhdmVQYWdlVGFyZ2V0IiwiZW50ZXJQYWdlRGVjb21wb3NpdGlvbiIsImxlYXZlUGFnZURlY29tcG9zaXRpb24iLCJwb3BTd2lwZSIsIklPU0xpZnROYXZpZ2F0b3JBbmltYXRvciIsIklPU0ZhZGVOYXZpZ2F0b3JBbmltYXRvciIsIk1EU2xpZGVOYXZpZ2F0b3JBbmltYXRvciIsImJsYWNrTWFza09wYWNpdHkiLCJNRExpZnROYXZpZ2F0b3JBbmltYXRvciIsIm1hc2tDbGVhciIsIk1ERmFkZU5hdmlnYXRvckFuaW1hdG9yIiwidGltaW5nUG9wIiwiTm9uZU5hdmlnYXRvckFuaW1hdG9yIiwicmV3cml0YWJsZXMiLCJuYXZpZ2F0b3JFbGVtZW50IiwidmVyaWZ5UGFnZUVsZW1lbnQiLCJOYXZpZ2F0b3JFbGVtZW50IiwiX2lzUnVubmluZyIsIl9pbml0aWFsaXplZCIsIl9wYWdlTG9hZGVyIiwiX3BhZ2VNYXAiLCJfcGFnZSIsIl9vbkRldmljZUJhY2tCdXR0b24iLCJzd2lwZUFuaW1hdG9yIiwiX3N3aXBlIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsImFyZWEiLCJpc0JCIiwicHVzaGVkT3B0aW9ucyIsImFuaW1hdG9yRmFjdG9yeSIsImxvYWRlZCIsIl9nZXRQYWdlVGFyZ2V0IiwicHVzaFBhZ2UiLCJfc2hvdyIsIl91cGRhdGVMYXN0UGFnZUJhY2tCdXR0b24iLCJ1cGRhdGUiLCJfcHJlcGFyZVBhZ2VBbmRPcHRpb25zIiwidGltZXMiLCJfcmVtb3ZlUGFnZXMiLCJwb3BVcGRhdGUiLCJ1bmxvYWQiLCJfcG9wUGFnZSIsIl9lbWl0UHJlUG9wRXZlbnQiLCJ1cGRhdGVCYWNrQnV0dG9uIiwiX2hpZGUiLCJwYWdlSFRNTCIsIl9wdXNoUGFnZSIsImxvYWQiLCJfZW1pdFByZVB1c2hFdmVudCIsInBhZ2VMZW5ndGgiLCJfcmVwbGFjZVBhZ2UiLCJyZXNvbHZlZFZhbHVlIiwiX25vcm1hbGl6ZUluZGV4IiwiaW5zZXJ0UGFnZSIsIm5ld1BhZ2UiLCJfbGFzdEluZGV4T2ZQYWdlIiwicGFnZU5hbWUiLCJpc0NhbmNlbGVkIiwiX2VtaXRQcmVFdmVudCIsInRlbXBsYXRlSFRNTCIsInBhZ2VMb2FkZXIiLCJsYXN0RWxlbWVudENoaWxkIiwiTmF2aWdhdG9yIiwiVG9vbGJhckVsZW1lbnQiLCJfZW5zdXJlVG9vbGJhckl0ZW1FbGVtZW50cyIsIl9lbnN1cmVUb29sYmFyRWxlbWVudCIsIlRvb2xiYXIiLCJQYWdlRWxlbWVudCIsIl9kZXJpdmVIb29rcyIsIl9iYWNrZ3JvdW5kRWxlbWVudCIsIl9lbGVtZW50U2hvdWxkQmVNb3ZlZCIsIl90cnlUb0ZpbGxTdGF0dXNCYXIiLCJmaXhlZEVsZW1lbnRzIiwib25Jbml0IiwiYmFja0J1dHRvbiIsIm92ZXJMaW1pdCIsIl9pbmZpbml0ZVNjcm9sbExpbWl0IiwiX29uSW5maW5pdGVTY3JvbGwiLCJfbG9hZGluZ0NvbnRlbnQiLCJvbkluZmluaXRlU2Nyb2xsIiwib25EZXN0cm95IiwiZXZlbnRzIiwiX2JvdW5kT25TY3JvbGwiLCJfb25TY3JvbGwiLCJQYWdlIiwiUG9wb3ZlckFuaW1hdG9yIiwicG9wb3ZlciIsImFuaW1hdGlvbnMiLCJfYW5pbWF0ZSIsImZhZGUiLCJNREZhZGVQb3BvdmVyQW5pbWF0b3IiLCJfYW5pbWF0ZUFsbCIsImluIiwiSU9TRmFkZVBvcG92ZXJBbmltYXRvciIsInBvc2l0aW9ucyIsIlBvcG92ZXJFbGVtZW50IiwiX2N1cnJlbnRUYXJnZXQiLCJfcG9zaXRpb25Qb3BvdmVyIiwiX2NsZWFyU3R5bGVzIiwicmFkaXVzIiwiX3JhZGl1cyIsImNvbnRlbnRFbGVtZW50IiwiX2NvbnRlbnQiLCJtYXJnaW4iLCJfbWFyZ2luIiwidGFyZ2V0UmVjdCIsImlzTUQiLCJjb3ZlciIsInBhcmVudERpbWVuc2lvbnMiLCJtYXhQb3NpdGlvbnMiLCJib3R0b20iLCJ0YXJnZXREaXN0YW5jZSIsInRhcmdldENlbnRlckRpc3RhbmNlRnJvbSIsIl9jYWxjdWxhdGVEaXJlY3Rpb25zIiwicHJpbWFyeURpcmVjdGlvbiIsInByaW1hcnkiLCJzZWNvbmRhcnlEaXJlY3Rpb24iLCJzZWNvbmRhcnkiLCJfY3VycmVudERpcmVjdGlvbiIsInNpemVOYW1lIiwiY29udGVudFNpemUiLCJ0YXJnZXRBbmRBcnJvd0xlbmd0aCIsInByaW1hcnlPZmZzZXQiLCJzZWNvbmRhcnlPZmZzZXQiLCJfcG9wb3ZlciIsIl9hcnJvdyIsImhhc0RlZmF1bHRDb250YWluZXIiLCJhcnJvdyIsIlBvcG92ZXIiLCJJTkRFVCIsIlByb2dyZXNzQmFyRWxlbWVudCIsIl9pc0NvbXBpbGVkIiwiX3ByaW1hcnkiLCJfc2Vjb25kYXJ5IiwiX3VwZGF0ZURldGVybWluYXRlIiwiX3VwZGF0ZVZhbHVlIiwiYmFyRWxlbWVudCIsIlByb2dyZXNzQmFyIiwiUHJvZ3Jlc3NDaXJjdWxhckVsZW1lbnQiLCJwZXIiLCJzdmciLCJQcm9ncmVzc0NpcmN1bGFyIiwiU1RBVEVfSU5JVElBTCIsIlNUQVRFX1BSRUFDVElPTiIsIlNUQVRFX0FDVElPTiIsInRocm93VHlwZSIsIlB1bGxIb29rRWxlbWVudCIsIl9vbkRyYWdTdGFydCIsIl9vbkRyYWdFbmQiLCJfc2V0U3RhdGUiLCJsaW5lSGVpZ2h0IiwiX3BhZ2VFbGVtZW50IiwidGFwWSIsIm1heFkiLCJkcmFnZ2FibGVBcmVhUmF0aW8iLCJfc3RhcnRTY3JvbGwiLCJfY3VycmVudFRyYW5zbGF0aW9uIiwidGgiLCJ0aHJlc2hvbGRIZWlnaHQiLCJfZmluaXNoIiwiX3RyYW5zbGF0ZVRvIiwiYW5pbWF0ZSIsIm9uQWN0aW9uIiwibm9FdmVudCIsImxhc3RTdGF0ZSIsIm1hcmdpblRvcCIsIl9vblB1bGwiLCJzY3JvbGxFbGVtZW50IiwiX2RyYWdMb2NrRGlzYWJsZWQiLCJzY3JvbGxUb2dnbGUiLCJnZFRvZ2dsZSIsIl9zZXRTdHlsZSIsIl9vbkFjdGlvbiIsIlB1bGxIb29rIiwiYWN0aXZlQ2xhc3NUb2tlbiIsIlJhbmdlRWxlbWVudCIsIl9vbk1vdXNlRG93biIsIl9vbk1vdXNlVXAiLCJfb25Ub3VjaFN0YXJ0IiwiX29uVG91Y2hFbmQiLCJfb25JbnB1dCIsIl9vbkRyYWdzdGFydCIsIl9vbkRyYWdlbmQiLCJfdXBkYXRlRGlzYWJsZWQiLCJmb2N1c1JpbmciLCJfZm9jdXNSaW5nIiwiYmFja2dyb3VuZFNpemUiLCJfcmF0aW8iLCJSYW5nZSIsIkFuaW1hdG9yQ1NTIiwiZmluYWwiLCJnZXRUaW1lIiwiaW5pdGlhbCIsInVwZGF0ZVN0eWxlcyIsImNsZWFyVGltZW91dCIsInRyYW5zaXRpb25EdXJhdGlvbiIsInN0b3BOZXh0IiwibmV3RHVyYXRpb24iLCJwYXNzZWQiLCJyZW1haW5pbmciLCJzcGVlZFVwVGltZSIsInN0b3AiLCJtaWxsaXNlY29uZHMiLCJzcGVlZCIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsIl9vblN0b3BBbmltYXRpb25zIiwiX3F1ZXVlIiwiX2luZGV4Iiwic3RvcEFuaW1hdGlvbnMiLCJSaXBwbGVFbGVtZW50IiwiX29uVGFwIiwiX29uSG9sZCIsIl9hbmltYXRvciIsIl93YXZlIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsIl9iYWNrZ3JvdW5kIiwic2l6ZXMiLCJfZ2V0RWZmZWN0U2l6ZSIsIl9jZW50ZXIiLCJfbWluUiIsIl9jYWxjdWxhdGVDb29yZHMiLCJzdG9wQWxsIiwicmlwcGxlIiwiX3VwZGF0ZVBhcmVudCIsIl9yaXBwbGVBbmltYXRpb24iLCJfaG9sZGluZyIsIl9wYXJlbnROb2RlIiwicG4iLCJSaXBwbGUiLCJSb3dFbGVtZW50IiwiUm93IiwiU2VnbWVudEVsZW1lbnQiLCJfc2VnbWVudElkIiwiX3RhYmJhciIsIl9vblRhYmJhclByZUNoYW5nZSIsImdldEFjdGl2ZVRhYkluZGV4IiwiZ2V0QWN0aXZlQnV0dG9uSW5kZXgiLCJfc2V0Q2hlY2tlZCIsImZpcnN0RWxlbWVudENoaWxkIiwic2V0QWN0aXZlVGFiIiwiX3Bvc3RDaGFuZ2UiLCJTZWdtZW50IiwiU2VsZWN0RWxlbWVudCIsIl9kZXJpdmVHZXR0ZXJzIiwiX3NlbGVjdCIsInNlbCIsIm9wdGlvbiIsIlNlbGVjdCIsIlNwZWVkRGlhbEl0ZW1FbGVtZW50IiwiU3BlZWREaWFsSXRlbSIsIlNwZWVkRGlhbEVsZW1lbnQiLCJfaXRlbVNob3duIiwiX3VwZGF0ZURpcmVjdGlvbiIsInRvZ2dsZUl0ZW1zIiwiaW5saW5lIiwiX2ZhYiIsIml0ZW1zIiwiX2dldFRyYW5zbGF0ZSIsImhpZGVJdGVtcyIsInRvdGFsRGVsYXkiLCJpc09wZW4iLCJzaG93SXRlbXMiLCJTcGVlZERpYWwiLCJTcGxpdHRlckNvbnRlbnRFbGVtZW50Iiwib2xkQ29udGVudCIsIlNwbGl0dGVyQ29udGVudCIsIlNwbGl0dGVyTWFza0VsZW1lbnQiLCJfc2lkZXMiLCJzaWRlIiwibW9kZSIsIlNwbGl0dGVyTWFzayIsIlNwbGl0dGVyQW5pbWF0b3IiLCJzaWRlRWxlbWVudCIsInNwbGl0dGVyIiwiX3NpZGUiLCJfb3Bwb3NpdGVTaWRlIiwiY2xlYXJNYXNrIiwiT3ZlcmxheVNwbGl0dGVyQW5pbWF0b3IiLCJtaW51cyIsIlB1c2hTcGxpdHRlckFuaW1hdG9yIiwic2xpZGluZ0VsZW1lbnRzIiwiX3NsaWRpbmdFbGVtZW50cyIsIl9nZXRTbGlkaW5nRWxlbWVudHMiLCJSZXZlYWxTcGxpdHRlckFuaW1hdG9yIiwiX3NldFN0eWxlcyIsIl91bnNldFN0eWxlcyIsIl9nZW5lcmF0ZUJlaGluZFBhZ2VTdHlsZSIsImJlaGluZERpc3RhbmNlIiwiYmVoaW5kVHJhbnNmb3JtIiwiX2dldE1heFdpZHRoIiwibWVudVN0eWxlIiwiU3BsaXR0ZXJFbGVtZW50IiwiX2xheW91dCIsIl9nZXRTaWRlIiwiX29uTW9kZUNoYW5nZSIsIlNwbGl0dGVyIiwiU1BMSVRfTU9ERSIsIkNPTExBUFNFX01PREUiLCJDTE9TRURfU1RBVEUiLCJPUEVOX1NUQVRFIiwiQ0hBTkdJTkdfU1RBVEUiLCJzcGxpdHRlclNpZGVFbGVtZW50IiwiQ29sbGFwc2VEZXRlY3Rpb24iLCJjaGFuZ2VUYXJnZXQiLCJfdGFyZ2V0IiwiX29yaWVudGF0aW9uIiwiYWN0aXZhdGUiLCJfdXBkYXRlTW9kZSIsIl9tYXRjaCIsIl9xdWVyeVJlc3VsdCIsIm1hdGNoTWVkaWEiLCJhZGRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwiU3BsaXR0ZXJTaWRlRWxlbWVudCIsIl9zdGF0ZSIsIl9sb2NrIiwiX2NvbGxhcHNlRGV0ZWN0aW9uIiwiX2FuaW1hdGlvbk9wdCIsImNsb3NlZCIsInZhbGlkRHJhZyIsIl9tb2RlIiwiX2lzT3RoZXJTaWRlT3BlbiIsImRlYWN0aXZhdGUiLCJ1cGRhdGVPcHRpb25zIiwiRklOQUxfU1RBVEUiLCJfZW1pdEV2ZW50IiwiU3BsaXR0ZXJTaWRlIiwibG9jYXRpb25zIiwiU3dpdGNoRWxlbWVudCIsIl9sYXN0VGltZVN0YW1wIiwiX2xvY2F0aW9ucyIsIl9zdGFydFgiLCJfZW1pdENoYW5nZUV2ZW50IiwiZGVmYXVsdEVsZW1lbnRDbGFzcyIsIl9oYW5kbGUiLCJfZ2V0UG9zaXRpb24iLCJwcmV2aW91c1ZhbHVlIiwiY2xpY2siLCJTd2l0Y2giLCJ0YWJiYXJFbGVtZW50IiwibGVycCIsIngwIiwieDEiLCJ0IiwiVGFiYmFyRWxlbWVudCIsIl9sb2FkSW5hY3RpdmUiLCJfZ2V0QXV0b1Njcm9sbFJhdGlvIiwiX29uUHJlQ2hhbmdlIiwiX29uUG9zdENoYW5nZSIsIl90YWJiYXJCb3JkZXIiLCJfdGFiYmFyRWxlbWVudCIsIl90YWJzUmVjdCIsInRhYkl0ZW0iLCJ0YWJzIiwiX25vcm1hbGl6ZUV2ZW50IiwiY2FuY2VsIiwic2V0QWN0aXZlIiwicHJldlRhYiIsIl9hdXRvZ3JvdyIsInRhYiIsInRhYmJhciIsImNzIiwiZmlsbGVkIiwibmV4dEluZGV4IiwicHJldkluZGV4IiwibmV4dFRhYiIsInNldFRhYmJhclZpc2liaWxpdHkiLCJpc0FjdGl2ZSIsImlzVG9wIiwiX3RhcmdldEVsZW1lbnQiLCJUYWJiYXIiLCJUYWJFbGVtZW50IiwiX2J1dHRvbiIsIl91cGRhdGVCdXR0b25Db250ZW50IiwiaWNvbldyYXBwZXIiLCJmaXgiLCJhY3RpdmUiLCJfaGFzTG9hZGVkIiwiX2xvYWRlZFBhZ2UiLCJwYWdlVGFyZ2V0IiwicGFyZW50VGFyZ2V0IiwiZHVtbXlQYWdlIiwiX2xvYWRQYWdlRWxlbWVudCIsIlRhYiIsIlRvYXN0QW5pbWF0b3IiLCJGYWRlVG9hc3RBbmltYXRvciIsIkFzY2VuZFRvYXN0QW5pbWF0b3IiLCJtZXNzYWdlRGVsYXkiLCJhc2NlbnNpb24iLCJfZ2V0RmFicyIsImZhYiIsIkxpZnRUb2FzdEFuaW1hdG9yIiwiRmFsbFRvYXN0QW5pbWF0b3IiLCJmYWxsQW1vdW50IiwiY2xlYW5VcCIsImNvcnJlY3RUb3AiLCJUb2FzdEVsZW1lbnQiLCJtZXNzYWdlQ2xhc3NOYW1lIiwiYnV0dG9uQ2xhc3NOYW1lIiwiVG9hc3QiLCJUb29sYmFyQnV0dG9uRWxlbWVudCIsIlRvb2xiYXJCdXR0b24iLCJfc3VwZXJTZWNyZXRPbnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsa0JBQWUsRUFBZjs7QUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsQUFFQTs7Ozs7O0FBTUEsSUFBTUEsU0FBVSxZQUFXO01BQ25CQyxTQUFTQyxPQUFPQyxnQkFBUCxDQUF3QkMsU0FBU0MsZUFBakMsRUFBa0QsRUFBbEQsQ0FBZjtNQUNNTCxTQUFTLENBQUNNLE1BQU1DLFNBQU4sQ0FBZ0JDLEtBQWhCLENBQ2JDLElBRGEsQ0FDUlIsTUFEUSxFQUViUyxJQUZhLENBRVIsRUFGUSxFQUdiQyxLQUhhLENBR1AsbUJBSE8sS0FHa0JWLE9BQU9XLEtBQVAsS0FBaUIsRUFBakIsSUFBdUIsQ0FBQyxFQUFELEVBQUssR0FBTCxDQUgxQyxFQUliLENBSmEsQ0FBZjs7U0FNTyxVQUFTQyxJ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
